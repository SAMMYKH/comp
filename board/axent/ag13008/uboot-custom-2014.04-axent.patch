diff --git a/arch/arm/cpu/arm926ejs/at91/at91sam9m10g45_devices.c b/arch/arm/cpu/arm926ejs/at91/at91sam9m10g45_devices.c
index 7d7725c..27ffb02 100644
--- a/arch/arm/cpu/arm926ejs/at91/at91sam9m10g45_devices.c
+++ b/arch/arm/cpu/arm926ejs/at91/at91sam9m10g45_devices.c
@@ -165,3 +165,15 @@ void at91_macb_hw_init(void)
 #endif
 }
 #endif
+
+#if defined(CONFIG_ATMEL_MCI) || defined(CONFIG_GENERIC_ATMEL_MCI)
+void at91_mci_hw_init(void)
+{
+    at91_set_A_periph(AT91_PIN_PA0, 0);
+    at91_set_A_periph(AT91_PIN_PA1, 1);
+    at91_set_A_periph(AT91_PIN_PA2, 1);
+    at91_set_A_periph(AT91_PIN_PA3, 1);
+    at91_set_A_periph(AT91_PIN_PA4, 1);
+    at91_set_A_periph(AT91_PIN_PA5, 1);
+}
+#endif
diff --git a/arch/arm/cpu/arm926ejs/mxs/clock.c b/arch/arm/cpu/arm926ejs/mxs/clock.c
index e9d8800..ca020ca 100644
--- a/arch/arm/cpu/arm926ejs/mxs/clock.c
+++ b/arch/arm/cpu/arm926ejs/mxs/clock.c
@@ -5,7 +5,7 @@
  * on behalf of DENX Software Engineering GmbH
  *
  * Based on code from LTIB:
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -309,7 +309,7 @@ void mxs_set_ssp_busclock(unsigned int bus, uint32_t freq)
 		bus, tgtclk, freq);
 }
 
-void mxs_set_lcdclk(uint32_t freq)
+void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq)
 {
 	struct mxs_clkctrl_regs *clkctrl_regs =
 		(struct mxs_clkctrl_regs *)MXS_CLKCTRL_BASE;
diff --git a/arch/arm/cpu/armv7/mx6/clock.c b/arch/arm/cpu/armv7/mx6/clock.c
index bd65a08..9c6838f 100644
--- a/arch/arm/cpu/armv7/mx6/clock.c
+++ b/arch/arm/cpu/armv7/mx6/clock.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -80,7 +80,7 @@ static u32 decode_pll(enum pll_clocks pll, u32 infreq)
 		div = __raw_readl(&imx_ccm->analog_pll_sys);
 		div &= BM_ANADIG_PLL_SYS_DIV_SELECT;
 
-		return infreq * (div >> 1);
+		return (infreq * div) >> 1;
 	case PLL_BUS:
 		div = __raw_readl(&imx_ccm->analog_pll_528);
 		div &= BM_ANADIG_PLL_528_DIV_SELECT;
@@ -204,6 +204,10 @@ static u32 get_ipg_per_clk(void)
 	u32 reg, perclk_podf;
 
 	reg = __raw_readl(&imx_ccm->cscmr1);
+#if (defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX))
+	if (reg & MXC_CCM_CSCMR1_PER_CLK_SEL_MASK)
+		return MXC_HCLK; /* OSC 24Mhz */
+#endif
 	perclk_podf = reg & MXC_CCM_CSCMR1_PERCLK_PODF_MASK;
 
 	return get_ipg_clk() / (perclk_podf + 1);
@@ -214,7 +218,7 @@ static u32 get_uart_clk(void)
 	u32 reg, uart_podf;
 	u32 freq = decode_pll(PLL_USBOTG, MXC_HCLK) / 6; /* static divider */
 	reg = __raw_readl(&imx_ccm->cscdr1);
-#ifdef CONFIG_MX6SL
+#if (defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX))
 	if (reg & MXC_CCM_CSCDR1_UART_CLK_SEL)
 		freq = MXC_HCLK;
 #endif
@@ -282,7 +286,7 @@ static u32 get_emi_slow_clk(void)
 	return root_freq / (emi_slow_podf + 1);
 }
 
-#ifdef CONFIG_MX6SL
+#if (defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX))
 static u32 get_mmdc_ch0_clk(void)
 {
 	u32 cbcmr = __raw_readl(&imx_ccm->cbcmr);
@@ -322,28 +326,312 @@ static u32 get_mmdc_ch0_clk(void)
 }
 #endif
 
+#ifdef CONFIG_MX6SX
+void enable_lvds(uint32_t lcdif_base)
+{
+	u32 reg = 0;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_GPR_BASE_ADDR;
+
+	/* Turn on LDB DI0 clocks */
+	reg = readl(&imx_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK;
+	writel(reg, &imx_ccm->CCGR3);
+
+	/* set LDB DI0 clk select to 011 PLL2 PFD3 200M*/
+	reg = readl(&imx_ccm->cs2cdr);
+	reg &= ~MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK;
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET);
+	writel(reg, &imx_ccm->cs2cdr);
+
+	reg = readl(&imx_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV;
+	writel(reg, &imx_ccm->cscmr2);
+
+	/* set LDB DI0 clock for LCDIF PIX clock */
+	reg = readl(&imx_ccm->cscdr2);
+	if (lcdif_base == LCDIF1_BASE_ADDR) {
+		reg &= ~MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK;
+		reg |= (0x3 << MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_OFFSET);
+	} else {
+		reg &= ~MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK;
+		reg |= (0x3 << MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_OFFSET);
+	}
+	writel(reg, &imx_ccm->cscdr2);
+
+	reg = IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+		| IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+		| IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+		| IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[6]);
+
+	reg = readl(&iomux->gpr[5]);
+	if (lcdif_base == LCDIF1_BASE_ADDR)
+		reg &= ~0x8;  /* MUX LVDS to LCDIF1 */
+	else
+		reg |= 0x8; /* MUX LVDS to LCDIF2 */
+	writel(reg, &iomux->gpr[5]);
+}
+
+void enable_lcdif_clock(uint32_t base_addr)
+{
+	u32 reg = 0;
+
+	/* Set to pre-mux clock at default */
+	reg = readl(&imx_ccm->cscdr2);
+	if (base_addr == LCDIF1_BASE_ADDR)
+		reg &= ~MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK;
+	else
+		reg &= ~MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK;
+	writel(reg, &imx_ccm->cscdr2);
+
+	/* Enable the LCDIF pix clock, axi clock, disp axi clock */
+	reg = readl(&imx_ccm->CCGR3);
+	if (base_addr == LCDIF1_BASE_ADDR)
+		reg |= (MXC_CCM_CCGR3_LCDIF1_PIX_MASK | MXC_CCM_CCGR3_DISP_AXI_MASK);
+	else
+		reg |= (MXC_CCM_CCGR3_LCDIF2_PIX_MASK | MXC_CCM_CCGR3_DISP_AXI_MASK);
+	writel(reg, &imx_ccm->CCGR3);
+
+	reg = readl(&imx_ccm->CCGR2);
+	reg |= (MXC_CCM_CCGR2_LCD_MASK);
+	writel(reg, &imx_ccm->CCGR2);
+}
+
+static int enable_pll_video(u32 pll_div, u32 pll_num, u32 pll_denom)
+{
+	u32 reg = 0;
+	ulong start;
+
+	debug("pll5 div = %d, num = %d, denom = %d\n",
+		pll_div, pll_num, pll_denom);
+
+	/* Power up PLL5 video */
+	writel(BM_ANADIG_PLL_VIDEO_POWERDOWN | BM_ANADIG_PLL_VIDEO_BYPASS |
+		BM_ANADIG_PLL_VIDEO_DIV_SELECT | BM_ANADIG_PLL_VIDEO_TEST_DIV_SELECT,
+		&imx_ccm->analog_pll_video_clr);
+
+	/* Set div, num and denom */
+	writel(BF_ANADIG_PLL_VIDEO_DIV_SELECT(pll_div) |
+		BF_ANADIG_PLL_VIDEO_TEST_DIV_SELECT(0x2),
+		&imx_ccm->analog_pll_video_set);
+
+	writel(BF_ANADIG_PLL_VIDEO_NUM_A(pll_num),
+		&imx_ccm->analog_pll_video_num);
+
+	writel(BF_ANADIG_PLL_VIDEO_DENOM_B(pll_denom),
+		&imx_ccm->analog_pll_video_denon);
+
+	/* Wait PLL5 lock */
+	start = get_timer(0);	/* Get current timestamp */
+
+	do {
+		reg = readl(&imx_ccm->analog_pll_video);
+		if (reg & BM_ANADIG_PLL_VIDEO_LOCK) {
+			/* Enable PLL out */
+			writel(BM_ANADIG_PLL_VIDEO_ENABLE,
+					&imx_ccm->analog_pll_video_set);
+			return 0;
+		}
+	} while (get_timer(0) < (start + 10)); /* Wait 10ms */
+
+	printf("Lock PLL5 timeout\n");
+	return 1;
+
+}
+
+void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq)
+{
+	u32 reg = 0;
+	u32 hck = MXC_HCLK/1000;
+	u32 min = hck * 27;
+	u32 max = hck * 54;
+	u32 temp, best = 0;
+	u32 i, j, pred = 1, postd = 1;
+	u32 pll_div, pll_num, pll_denom;
+
+	debug("mxs_set_lcdclk, freq = %d\n", freq);
+
+	if (base_addr == LCDIF1_BASE_ADDR) {
+		reg = readl(&imx_ccm->cscdr2);
+		if ((reg & MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK) != 0)
+			return; /*Can't change clocks when clock not from pre-mux */
+	} else {
+		reg = readl(&imx_ccm->cscdr2);
+		if ((reg & MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK) != 0)
+			return; /*Can't change clocks when clock not from pre-mux */
+	}
+
+	for (i = 1; i <= 8; i++) {
+		for (j = 1; j <= 8; j++) {
+			temp = freq * i * j;
+			if (temp > max || temp < min)
+				continue;
+
+			if (best == 0 || temp < best) {
+				best = temp;
+				pred = i;
+				postd = j;
+			}
+		}
+	}
+
+	if (best == 0) {
+		printf("Fail to set rate to %dkhz", freq);
+		return;
+	}
+
+	debug("best %d, pred = %d, postd = %d\n", best, pred, postd);
+
+	pll_div = best / hck;
+	pll_denom = 1000000;
+	pll_num = (best - hck * pll_div) * pll_denom / hck;
+
+	if (base_addr == LCDIF1_BASE_ADDR) {
+		if (enable_pll_video(pll_div, pll_num, pll_denom))
+			return;
+
+		/* Select pre-lcd clock to PLL5 */
+		reg = readl(&imx_ccm->cscdr2);
+		reg &= ~MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_MASK;
+		reg |= (0x2 << MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_OFFSET);
+		/* Set the pre divider */
+		reg &= ~MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_MASK;
+		reg |= ((pred - 1) << MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_OFFSET);
+		writel(reg, &imx_ccm->cscdr2);
+
+		/* Set the post divider */
+		reg = readl(&imx_ccm->cbcmr);
+		reg &= ~MXC_CCM_CBCMR_LCDIF1_PODF_MASK;
+		reg |= ((postd - 1) << MXC_CCM_CBCMR_LCDIF1_PODF_OFFSET);
+		writel(reg, &imx_ccm->cbcmr);
+
+	} else {
+		if (enable_pll_video(pll_div, pll_num, pll_denom))
+			return;
+
+		/* Select pre-lcd clock to PLL5 */
+		reg = readl(&imx_ccm->cscdr2);
+		reg &= ~MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_MASK;
+		reg |= (0x2 << MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_OFFSET);
+		/* Set the pre divider */
+		reg &= ~MXC_CCM_CSCDR2_LCDIF2_PRE_DIV_MASK;
+		reg |= ((pred - 1) << MXC_CCM_CSCDR2_LCDIF2_PRE_DIV_OFFSET);
+		writel(reg, &imx_ccm->cscdr2);
+
+		/* Set the post divider */
+		reg = readl(&imx_ccm->cscmr1);
+		reg &= ~MXC_CCM_CSCMR1_LCDIF2_PODF_MASK;
+		reg |= ((postd - 1) << MXC_CCM_CSCMR1_LCDIF2_PODF_OFFSET);
+		writel(reg, &imx_ccm->cscmr1);
+	}
+}
+
+/* qspi_num can be from 0 - 1 */
+void enable_qspi_clk(int qspi_num)
+{
+    u32 reg = 0;
+
+    /* Enable QuadSPI clock */
+	switch (qspi_num) {
+	case 0:
+		/*disable the clock gate*/
+		clrbits_le32(&imx_ccm->CCGR3, MXC_CCM_CCGR3_QSPI1_MASK);
+
+		/* set 50M  : (50 = 396 / 2 / 4) */
+		reg = readl(&imx_ccm->cscmr1);
+		reg &= ~(MXC_CCM_CSCMR1_QSPI1_PODF_MASK |
+			MXC_CCM_CSCMR1_QSPI1_CLK_SEL_MASK);
+		reg |= ((1 << MXC_CCM_CSCMR1_QSPI1_PODF_OFFSET) |
+				(2 << MXC_CCM_CSCMR1_QSPI1_CLK_SEL_OFFSET));
+		writel(reg, &imx_ccm->cscmr1);
+
+		/*enable the clock gate*/
+		setbits_le32(&imx_ccm->CCGR3, MXC_CCM_CCGR3_QSPI1_MASK);
+		break;
+	case 1:
+		/*disable the clock gatei*/
+		/*QSPI2 and GPMI_BCH_INPUT_GPMI_IO share the same clock gate, disable both of them*/
+		clrbits_le32(&imx_ccm->CCGR4, MXC_CCM_CCGR4_QSPI2_ENFC_MASK
+				| MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK);
+
+		/* set 50M  : (50 = 396 / 2 / 4) */
+		reg = readl(&imx_ccm->cs2cdr);
+		reg &= ~(MXC_CCM_CS2CDR_QSPI2_CLK_PODF_MASK |
+				MXC_CCM_CS2CDR_QSPI2_CLK_PRED_MASK |
+				MXC_CCM_CS2CDR_QSPI2_CLK_SEL_MASK);
+		reg |= (MXC_CCM_CS2CDR_QSPI2_CLK_PRED(0x1) |
+				MXC_CCM_CS2CDR_QSPI2_CLK_SEL(0x3));
+		writel(reg, &imx_ccm->cs2cdr);
+
+		/*enable the clock gate*/
+		setbits_le32(&imx_ccm->CCGR4, MXC_CCM_CCGR4_QSPI2_ENFC_MASK
+				| MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK);
+		break;
+	default:
+		break;
+	}
+}
+
+void enable_enet_clock(void)
+{
+	u32 reg = 0;
+
+	/* set enet ahb clock 200Mhz
+	 * pll2_pfd2_396m-> ENET_PODF-> ENET_AHB
+	 */
+	reg = __raw_readl(&imx_ccm->chsccdr);
+	reg &= ~(MXC_CCM_CHSCCDR_ENET_PRE_CLK_SEL_MASK
+		| MXC_CCM_CHSCCDR_ENET_PODF_MASK | MXC_CCM_CHSCCDR_ENET_CLK_SEL_MASK);
+	/* PLL2 PFD2 */
+	reg |= (4 << MXC_CCM_CHSCCDR_ENET_PRE_CLK_SEL_OFFSET);
+	/* Div = 2*/
+	reg |= (1 << MXC_CCM_CHSCCDR_ENET_PODF_OFFSET);
+	reg |= (0 << MXC_CCM_CHSCCDR_ENET_CLK_SEL_OFFSET);
+	writel(reg, &imx_ccm->chsccdr);
+
+	/* Enable enet system clock */
+	reg = readl(&imx_ccm->CCGR3);
+	reg |= MXC_CCM_CCGR3_ENET_MASK;
+	writel(reg, &imx_ccm->CCGR3);
+}
+
+void mxs_set_vadcclk()
+{
+	u32 reg = 0;
+
+	reg = readl(&imx_ccm->cscmr2);
+	reg &= ~MXC_CCM_CSCMR2_VID_CLK_SEL_MASK;
+	reg |= 0x19 << MXC_CCM_CSCMR2_VID_CLK_SEL_OFFSET;
+	writel(reg, &imx_ccm->cscmr2);
+}
+#endif
+
 #ifdef CONFIG_FEC_MXC
-int enable_fec_anatop_clock(enum enet_freq freq)
+int enable_fec_anatop_clock(int fec_id, enum enet_freq freq)
 {
 	u32 reg = 0;
 	s32 timeout = 100000;
 
-	struct anatop_regs __iomem *anatop =
-		(struct anatop_regs __iomem *)ANATOP_BASE_ADDR;
-
 	if (freq < ENET_25MHz || freq > ENET_125MHz)
 		return -EINVAL;
 
-	reg = readl(&anatop->pll_enet);
+	reg = readl(&imx_ccm->analog_pll_enet);
 	reg &= ~BM_ANADIG_PLL_ENET_DIV_SELECT;
-	reg |= freq;
+
+	if (0 == fec_id) {
+		reg &= ~BM_ANADIG_PLL_ENET_DIV_SELECT;
+		reg |= BF_ANADIG_PLL_ENET_DIV_SELECT(freq);
+	} else {
+		reg &= ~BM_ANADIG_PLL_ENET2_DIV_SELECT;
+		reg |= BF_ANADIG_PLL_ENET2_DIV_SELECT(freq);
+	}
 
 	if ((reg & BM_ANADIG_PLL_ENET_POWERDOWN) ||
 	    (!(reg & BM_ANADIG_PLL_ENET_LOCK))) {
 		reg &= ~BM_ANADIG_PLL_ENET_POWERDOWN;
-		writel(reg, &anatop->pll_enet);
+		writel(reg, &imx_ccm->analog_pll_enet);
 		while (timeout--) {
-			if (readl(&anatop->pll_enet) & BM_ANADIG_PLL_ENET_LOCK)
+			if (readl(&imx_ccm->analog_pll_enet) & BM_ANADIG_PLL_ENET_LOCK)
 				break;
 		}
 		if (timeout < 0)
@@ -351,9 +639,15 @@ int enable_fec_anatop_clock(enum enet_freq freq)
 	}
 
 	/* Enable FEC clock */
-	reg |= BM_ANADIG_PLL_ENET_ENABLE;
+	if (0 == fec_id)
+		reg |= BM_ANADIG_PLL_ENET_ENABLE;
+	else
+		reg |= BM_ANADIG_PLL_ENET2_ENABLE;
 	reg &= ~BM_ANADIG_PLL_ENET_BYPASS;
-	writel(reg, &anatop->pll_enet);
+#ifdef CONFIG_FEC_MXC_25M_REF_CLK
+	reg |= BM_ANADIG_PLL_ENET_REF_25M_ENABLE;
+#endif
+	writel(reg, &imx_ccm->analog_pll_enet);
 
 	return 0;
 }
@@ -437,6 +731,7 @@ static int enable_enet_pll(uint32_t en)
 	return 0;
 }
 
+#ifndef CONFIG_MX6SX
 static void ungate_sata_clock(void)
 {
 	struct mxc_ccm_reg *const imx_ccm =
@@ -445,6 +740,16 @@ static void ungate_sata_clock(void)
 	/* Enable SATA clock. */
 	setbits_le32(&imx_ccm->CCGR5, MXC_CCM_CCGR5_SATA_MASK);
 }
+#else
+static void ungate_disp_axi_clock(void)
+{
+	struct mxc_ccm_reg *const imx_ccm =
+		(struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* Enable display axi clock. */
+	setbits_le32(&imx_ccm->CCGR3, MXC_CCM_CCGR3_DISP_AXI_MASK);
+}
+#endif
 
 static void ungate_pcie_clock(void)
 {
@@ -455,17 +760,18 @@ static void ungate_pcie_clock(void)
 	setbits_le32(&imx_ccm->CCGR4, MXC_CCM_CCGR4_PCIE_MASK);
 }
 
+#ifndef CONFIG_MX6SX
 int enable_sata_clock(void)
 {
 	ungate_sata_clock();
 	return enable_enet_pll(BM_ANADIG_PLL_ENET_ENABLE_SATA);
 }
+#endif
 
 int enable_pcie_clock(void)
 {
-	struct anatop_regs *anatop_regs =
-		(struct anatop_regs *)ANATOP_BASE_ADDR;
-	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	/* PCIe reference clock sourced from AXI. */
+	clrbits_le32(&imx_ccm->cbcmr, MXC_CCM_CBCMR_PCIE_AXI_CLK_SEL);
 
 	/*
 	 * Here be dragons!
@@ -482,22 +788,70 @@ int enable_pcie_clock(void)
 #define ANADIG_ANA_MISC1_LVDSCLK1_IBEN		(1 << 12)
 #define ANADIG_ANA_MISC1_LVDSCLK1_OBEN		(1 << 10)
 #define ANADIG_ANA_MISC1_LVDS1_CLK_SEL_MASK	0x0000001F
-	clrsetbits_le32(&anatop_regs->ana_misc1,
+#ifndef CONFIG_MX6SX
+	/* lvds_clk1 is sourced from sata ref on imx6q/dl/solo */
+	clrsetbits_le32(&imx_ccm->ana_misc1,
 			ANADIG_ANA_MISC1_LVDSCLK1_IBEN |
 			ANADIG_ANA_MISC1_LVDS1_CLK_SEL_MASK,
 			ANADIG_ANA_MISC1_LVDSCLK1_OBEN | 0xb);
 
-	/* PCIe reference clock sourced from AXI. */
-	clrbits_le32(&ccm_regs->cbcmr, MXC_CCM_CBCMR_PCIE_AXI_CLK_SEL);
-
 	/* Party time! Ungate the clock to the PCIe. */
 	ungate_sata_clock();
 	ungate_pcie_clock();
 
 	return enable_enet_pll(BM_ANADIG_PLL_ENET_ENABLE_SATA |
-			       BM_ANADIG_PLL_ENET_ENABLE_PCIE);
+			BM_ANADIG_PLL_ENET_ENABLE_PCIE);
+#else
+	/* lvds_clk1 is sourced from pcie ref on imx6sx */
+	clrsetbits_le32(&imx_ccm->ana_misc1,
+			ANADIG_ANA_MISC1_LVDSCLK1_IBEN |
+			ANADIG_ANA_MISC1_LVDS1_CLK_SEL_MASK,
+			ANADIG_ANA_MISC1_LVDSCLK1_OBEN | 0xa);
+
+	ungate_disp_axi_clock();
+	ungate_pcie_clock();
+	return enable_enet_pll(BM_ANADIG_PLL_ENET_ENABLE_PCIE);
+#endif
 }
 
+#ifdef CONFIG_SECURE_BOOT
+void hab_caam_clock_enable(void)
+{
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 reg = 0;
+
+	/*CG4 ~ CG6, enable CAAM clocks*/
+	reg = readl(&ccm_regs->CCGR0);
+	reg |= (MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK |
+			MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK |
+			MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK);
+	writel(reg, &ccm_regs->CCGR0);
+
+	/* Enable EMI slow clk */
+	reg = readl(&ccm_regs->CCGR6);
+	reg |= MXC_CCM_CCGR6_EMI_SLOW_MASK;
+	writel(reg, &ccm_regs->CCGR6);
+}
+
+void hab_caam_clock_disable(void)
+{
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 reg = 0;
+
+	/*CG4 ~ CG6, disable CAAM clocks*/
+	reg = readl(&ccm_regs->CCGR0);
+	reg &= ~(MXC_CCM_CCGR0_CAAM_WRAPPER_IPG_MASK |
+			MXC_CCM_CCGR0_CAAM_WRAPPER_ACLK_MASK |
+			MXC_CCM_CCGR0_CAAM_SECURE_MEM_MASK);
+	writel(reg, &ccm_regs->CCGR0);
+
+	/* Disable EMI slow clk */
+	reg = readl(&ccm_regs->CCGR6);
+	reg &= ~MXC_CCM_CCGR6_EMI_SLOW_MASK;
+	writel(reg, &ccm_regs->CCGR6);
+}
+#endif
+
 unsigned int mxc_get_clock(enum mxc_clock clk)
 {
 	switch (clk) {
@@ -573,6 +927,7 @@ int do_mx6_showclocks(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return 0;
 }
 
+#ifndef CONFIG_MX6SX
 void enable_ipu_clock(void)
 {
 	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
@@ -581,6 +936,7 @@ void enable_ipu_clock(void)
 	reg |= MXC_CCM_CCGR3_IPU1_IPU_MASK;
 	writel(reg, &mxc_ccm->CCGR3);
 }
+#endif
 /***************************************************/
 
 U_BOOT_CMD(
diff --git a/arch/arm/cpu/armv7/mx6/hab.c b/arch/arm/cpu/armv7/mx6/hab.c
index 5187775..e1d10b9 100644
--- a/arch/arm/cpu/armv7/mx6/hab.c
+++ b/arch/arm/cpu/armv7/mx6/hab.c
@@ -7,15 +7,98 @@
 #include <common.h>
 #include <asm/io.h>
 #include <asm/arch/hab.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/sys_proto.h>
 
 /* -------- start of HAB API updates ------------*/
-#define hab_rvt_report_event ((hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT)
-#define hab_rvt_report_status ((hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS)
-#define hab_rvt_authenticate_image \
-	((hab_rvt_authenticate_image_t *)HAB_RVT_AUTHENTICATE_IMAGE)
-#define hab_rvt_entry ((hab_rvt_entry_t *)HAB_RVT_ENTRY)
-#define hab_rvt_exit ((hab_rvt_exit_t *)HAB_RVT_EXIT)
-#define hab_rvt_clock_init HAB_RVT_CLOCK_INIT
+#define hab_rvt_report_event_p						\
+(									\
+	((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) \
+		&& (is_soc_rev(CHIP_REV_1_5) >= 0)) ?		\
+	((hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT_NEW) :		\
+	(is_cpu_type(MXC_CPU_MX6DL) && (is_soc_rev(CHIP_REV_1_2) >= 0)) ?		\
+	((hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT_NEW) :		\
+	((hab_rvt_report_event_t *)HAB_RVT_REPORT_EVENT)		\
+)
+
+#define hab_rvt_report_status_p						\
+(									\
+	((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D)) \
+		&& (is_soc_rev(CHIP_REV_1_5) >= 0)) ?		\
+	((hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS_NEW) :	\
+	((is_cpu_type(MXC_CPU_MX6DL) || is_cpu_type(MXC_CPU_MX6SOLO))	\
+		&& (is_soc_rev(CHIP_REV_1_2) >= 0)) ?		\
+	((hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS_NEW) :	\
+	((hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS)		\
+)
+
+#define hab_rvt_authenticate_image_p					\
+(									\
+	((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D))	\
+		&& (is_soc_rev(CHIP_REV_1_5) >= 0)) ?		\
+	((hab_rvt_authenticate_image_t *)HAB_RVT_AUTHENTICATE_IMAGE_NEW) : \
+	((is_cpu_type(MXC_CPU_MX6DL) || is_cpu_type(MXC_CPU_MX6SOLO))	\
+		&& (is_soc_rev(CHIP_REV_1_2) >= 0)) ?		\
+	((hab_rvt_authenticate_image_t *)HAB_RVT_AUTHENTICATE_IMAGE_NEW) :\
+	((hab_rvt_authenticate_image_t *)HAB_RVT_AUTHENTICATE_IMAGE)	\
+)
+
+#define hab_rvt_entry_p							\
+(									\
+	((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D))	\
+		&& (is_soc_rev(CHIP_REV_1_5) >= 0)) ?		\
+	((hab_rvt_entry_t *)HAB_RVT_ENTRY_NEW) :			\
+	((is_cpu_type(MXC_CPU_MX6DL) || is_cpu_type(MXC_CPU_MX6SOLO))	\
+		&& (is_soc_rev(CHIP_REV_1_2) >= 0)) ?		\
+	((hab_rvt_entry_t *)HAB_RVT_ENTRY_NEW) :			\
+	((hab_rvt_entry_t *)HAB_RVT_ENTRY)				\
+)
+
+#define hab_rvt_exit_p							\
+(									\
+	((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D))	\
+		&& (is_soc_rev(CHIP_REV_1_5) >= 0)) ?		\
+	((hab_rvt_exit_t *)HAB_RVT_EXIT_NEW) :				\
+	((is_cpu_type(MXC_CPU_MX6DL) || is_cpu_type(MXC_CPU_MX6SOLO))	\
+		&& (is_soc_rev(CHIP_REV_1_2) >= 0)) ?		\
+	((hab_rvt_exit_t *)HAB_RVT_EXIT_NEW) :				\
+	((hab_rvt_exit_t *)HAB_RVT_EXIT)				\
+)
+
+#define IVT_SIZE		0x20
+#define ALIGN_SIZE		0x1000
+#define CSF_PAD_SIZE		0x2000
+
+/*
+ * +------------+  0x0 (DDR_UIMAGE_START) -
+ * |   Header   |                          |
+ * +------------+  0x40                    |
+ * |            |                          |
+ * |            |                          |
+ * |            |                          |
+ * |            |                          |
+ * | Image Data |                          |
+ * .            |                          |
+ * .            |                           > Stuff to be authenticated ----+
+ * .            |                          |                                |
+ * |            |                          |                                |
+ * |            |                          |                                |
+ * +------------+                          |                                |
+ * |            |                          |                                |
+ * | Fill Data  |                          |                                |
+ * |            |                          |                                |
+ * +------------+ Align to ALIGN_SIZE      |                                |
+ * |    IVT     |                          |                                |
+ * +------------+ + IVT_SIZE              -                                 |
+ * |            |                                                           |
+ * |  CSF DATA  | <---------------------------------------------------------+
+ * |            |
+ * +------------+
+ * |            |
+ * | Fill Data  |
+ * |            |
+ * +------------+ + CSF_PAD_SIZE
+ */
 
 bool is_hab_enabled(void)
 {
@@ -52,12 +135,17 @@ int get_hab_status(void)
 	size_t bytes = sizeof(event_data); /* Event size in bytes */
 	enum hab_config config = 0;
 	enum hab_state state = 0;
+	hab_rvt_report_event_t *hab_rvt_report_event;
+	hab_rvt_report_status_t *hab_rvt_report_status;
 
 	if (is_hab_enabled())
 		puts("\nSecure boot enabled\n");
 	else
 		puts("\nSecure boot disabled\n");
 
+	hab_rvt_report_event = hab_rvt_report_event_p;
+	hab_rvt_report_status = hab_rvt_report_status_p;
+
 	/* Check HAB status */
 	if (hab_rvt_report_status(&config, &state) != HAB_SUCCESS) {
 		printf("\nHAB Configuration: 0x%02x, HAB State: 0x%02x\n",
@@ -85,6 +173,120 @@ int get_hab_status(void)
 	return 0;
 }
 
+#ifdef DEBUG_AUTHENTICATE_IMAGE
+void dump_mem(uint32_t addr, int size)
+{
+	int i;
+
+	for (i = 0; i < size; i += 4) {
+		if (i != 0) {
+			if (i % 16 == 0)
+				printf("\n");
+			else
+				printf(" ");
+		}
+
+		printf("0x%08x", *(uint32_t *)addr);
+		addr += 4;
+	}
+
+	printf("\n");
+
+	return;
+}
+#endif
+
+uint32_t authenticate_image(uint32_t ddr_start, uint32_t image_size)
+{
+	uint32_t load_addr = 0;
+	size_t bytes;
+	ptrdiff_t ivt_offset = 0;
+	int result = 0;
+	ulong start;
+	hab_rvt_authenticate_image_t *hab_rvt_authenticate_image;
+	hab_rvt_entry_t *hab_rvt_entry;
+	hab_rvt_exit_t *hab_rvt_exit;
+
+	hab_rvt_authenticate_image = hab_rvt_authenticate_image_p;
+	hab_rvt_entry = hab_rvt_entry_p;
+	hab_rvt_exit = hab_rvt_exit_p;
+
+	if (is_hab_enabled()) {
+		printf("\nAuthenticate uImage from DDR location 0x%x...\n",
+			ddr_start);
+
+		hab_caam_clock_enable();
+
+		if (hab_rvt_entry() == HAB_SUCCESS) {
+			/* If not already aligned, Align to ALIGN_SIZE */
+			ivt_offset = (image_size + ALIGN_SIZE - 1) &
+					~(ALIGN_SIZE - 1);
+
+			start = ddr_start;
+			bytes = ivt_offset + IVT_SIZE + CSF_PAD_SIZE;
+
+#ifdef DEBUG_AUTHENTICATE_IMAGE
+			printf("\nivt_offset = 0x%x, ivt addr = 0x%x\n",
+			       ivt_offset, ddr_start + ivt_offset);
+			printf("Dumping IVT\n");
+			dump_mem(ddr_start + ivt_offset, 0x20);
+
+			printf("Dumping CSF Header\n");
+			dump_mem(ddr_start + ivt_offset + 0x20, 0x40);
+
+			get_hab_status();
+
+			printf("\nCalling authenticate_image in ROM\n");
+			printf("\tivt_offset = 0x%x\n\tstart = 0x%08x"
+			       "\n\tbytes = 0x%x\n", ivt_offset, start, bytes);
+#endif
+			/*
+			 * If the MMU is enabled, we have to notify the ROM
+			 * code, or it won't flush the caches when needed.
+			 * This is done, by setting the "pu_irom_mmu_enabled"
+			 * word to 1. You can find its address by looking in
+			 * the ROM map. This is critical for
+			 * authenticate_image(). If MMU is enabled, without
+			 * setting this but, authentication will fail and may
+			 * crash.
+			 */
+			if (is_cpu_type(MXC_CPU_MX6Q) ||
+			    is_cpu_type(MXC_CPU_MX6D)) {
+				/*
+				 * This won't work on Rev 1.0.0 of i.MX6Q/D,
+				 * since their ROM doesn't do cache flushes.
+				 * I don't think any exist, so we ignore them.
+				 */
+				writel(1, 0x009024a8);
+			} else if (is_cpu_type(MXC_CPU_MX6DL) ||
+				   is_cpu_type(MXC_CPU_MX6SOLO)) {
+				writel(1, 0x00901dd0);
+			} else if (is_cpu_type(MXC_CPU_MX6SL)) {
+				writel(1, 0x00900a18);
+			}
+
+			load_addr = (uint32_t)hab_rvt_authenticate_image(
+					HAB_CID_UBOOT,
+					ivt_offset, (void **)&start,
+					(size_t *)&bytes, NULL);
+			if (hab_rvt_exit() != HAB_SUCCESS) {
+				printf("hab exit function fail\n");
+				load_addr = 0;
+			}
+		} else
+			printf("hab entry function fail\n");
+
+		hab_caam_clock_disable();
+
+		get_hab_status();
+	}
+
+	if ((!is_hab_enabled()) || (load_addr != 0))
+		result = 1;
+
+	return result;
+}
+
 int do_hab_status(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 {
 	if ((argc != 1)) {
@@ -97,8 +299,33 @@ int do_hab_status(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 	return 0;
 }
 
+static int do_authenticate_image(cmd_tbl_t *cmdtp, int flag, int argc,
+				char * const argv[])
+{
+	ulong	addr, ivt_offset;
+	int	rcode = 0;
+
+	if (argc < 3)
+		return CMD_RET_USAGE;
+
+	addr = simple_strtoul(argv[1], NULL, 16);
+	ivt_offset = simple_strtoul(argv[2], NULL, 16);
+
+	rcode = authenticate_image(addr, ivt_offset);
+
+	return rcode;
+}
+
 U_BOOT_CMD(
 		hab_status, CONFIG_SYS_MAXARGS, 1, do_hab_status,
 		"display HAB status",
 		""
 	  );
+
+U_BOOT_CMD(
+		hab_auth_img, 3, 1, do_authenticate_image,
+		"authenticate image via HAB",
+		"addr ivt_offset\n"
+		"addr - image hex address\n"
+		"ivt_offset - hex offset of IVT in the image"
+	  );
diff --git a/arch/arm/cpu/armv7/mx6/soc.c b/arch/arm/cpu/armv7/mx6/soc.c
index 1725279..3c3d2fd 100644
--- a/arch/arm/cpu/armv7/mx6/soc.c
+++ b/arch/arm/cpu/armv7/mx6/soc.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -17,9 +17,19 @@
 #include <asm/arch/sys_proto.h>
 #include <asm/imx-common/boot_mode.h>
 #include <asm/imx-common/dma.h>
+#include <libfdt.h>
 #include <stdbool.h>
 #include <asm/arch/mxc_hdmi.h>
 #include <asm/arch/crm_regs.h>
+#ifdef CONFIG_FASTBOOT
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif
+#ifdef CONFIG_IMX_UDC
+#include <asm/arch/mx6_usbphy.h>
+#include <usb/imx_udc.h>
+#endif
 
 enum ldo_reg {
 	LDO_ARM,
@@ -35,14 +45,26 @@ struct scu_regs {
 	u32	fpga_rev;
 };
 
+#define TEMPERATURE_MIN		-40
+#define TEMPERATURE_HOT		80
+#define TEMPERATURE_MAX		125
+#define FACTOR1			15976
+#define FACTOR2			4297157
+#define MEASURE_FREQ		327
+
+#define REG_VALUE_TO_CEL(ratio, raw) \
+	((raw_n40c - raw) * 100 / ratio - 40)
+
+static unsigned int fuse = ~0;
+
 u32 get_cpu_rev(void)
 {
-	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
-	u32 reg = readl(&anatop->digprog_sololite);
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 reg = readl(&ccm_regs->digprog_sololite);
 	u32 type = ((reg >> 16) & 0xff);
 
 	if (type != MXC_CPU_MX6SL) {
-		reg = readl(&anatop->digprog);
+		reg = readl(&ccm_regs->digprog);
 		struct scu_regs *scu = (struct scu_regs *)SCU_BASE_ADDR;
 		u32 cfg = readl(&scu->config) & 3;
 		type = ((reg >> 16) & 0xff);
@@ -79,9 +101,15 @@ u32 __weak get_board_rev(void)
 void init_aips(void)
 {
 	struct aipstz_regs *aips1, *aips2;
+#ifdef CONFIG_MX6SX
+	struct aipstz_regs *aips3;
+#endif
 
 	aips1 = (struct aipstz_regs *)AIPS1_BASE_ADDR;
 	aips2 = (struct aipstz_regs *)AIPS2_BASE_ADDR;
+#ifdef CONFIG_MX6SX
+	aips3 = (struct aipstz_regs *)AIPS3_CONFIG_BASE_ADDR;
+#endif
 
 	/*
 	 * Set all MPROTx to be non-bufferable, trusted for R/W,
@@ -107,34 +135,53 @@ void init_aips(void)
 	writel(0x00000000, &aips2->opacr2);
 	writel(0x00000000, &aips2->opacr3);
 	writel(0x00000000, &aips2->opacr4);
+
+#ifdef CONFIG_MX6SX
+	/*
+	 * Set all MPROTx to be non-bufferable, trusted for R/W,
+	 * not forced to user-mode.
+	 */
+	writel(0x77777777, &aips3->mprot0);
+	writel(0x77777777, &aips3->mprot1);
+
+	/*
+	 * Set all OPACRx to be non-bufferable, not require
+	 * supervisor privilege level for access,allow for
+	 * write access and untrusted master access.
+	 */
+	writel(0x00000000, &aips3->opacr0);
+	writel(0x00000000, &aips3->opacr1);
+	writel(0x00000000, &aips3->opacr2);
+	writel(0x00000000, &aips3->opacr3);
+	writel(0x00000000, &aips3->opacr4);
+#endif
 }
 
 static void clear_ldo_ramp(void)
 {
-	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
 	int reg;
 
 	/* ROM may modify LDO ramp up time according to fuse setting, so in
 	 * order to be in the safe side we neeed to reset these settings to
 	 * match the reset value: 0'b00
 	 */
-	reg = readl(&anatop->ana_misc2);
+	reg = readl(&ccm_regs->ana_misc2);
 	reg &= ~(0x3f << 24);
-	writel(reg, &anatop->ana_misc2);
+	writel(reg, &ccm_regs->ana_misc2);
 }
 
 /*
- * Set the VDDSOC
+ * Set the PMU_REG_CORE register
  *
- * Mask out the REG_CORE[22:18] bits (REG2_TRIG) and set
- * them to the specified millivolt level.
+ * Set LDO_SOC/PU/ARM regulators to the specified millivolt level.
  * Possible values are from 0.725V to 1.450V in steps of
  * 0.025V (25mV).
  */
 static int set_ldo_voltage(enum ldo_reg ldo, u32 mv)
 {
-	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
-	u32 val, step, old, reg = readl(&anatop->reg_core);
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 val, step, old, reg = readl(&ccm_regs->reg_core);
 	u8 shift;
 
 	if (mv < 725)
@@ -166,7 +213,7 @@ static int set_ldo_voltage(enum ldo_reg ldo, u32 mv)
 		return 0;
 
 	reg = (reg & ~(0x1F << shift)) | (val << shift);
-	writel(reg, &anatop->reg_core);
+	writel(reg, &ccm_regs->reg_core);
 
 	/*
 	 * The LDO ramp-up is based on 64 clock cycles of 24 MHz = 2.6 us per
@@ -181,12 +228,138 @@ static void imx_set_wdog_powerdown(bool enable)
 {
 	struct wdog_regs *wdog1 = (struct wdog_regs *)WDOG1_BASE_ADDR;
 	struct wdog_regs *wdog2 = (struct wdog_regs *)WDOG2_BASE_ADDR;
+#ifdef CONFIG_MX6SX
+	struct wdog_regs *wdog3 = (struct wdog_regs *)WDOG3_BASE_ADDR;
+	writew(enable, &wdog3->wmcr);
+#endif
 
 	/* Write to the PDE (Power Down Enable) bit */
 	writew(enable, &wdog1->wmcr);
 	writew(enable, &wdog2->wmcr);
 }
 
+static int read_cpu_temperature(void)
+{
+	int temperature;
+	unsigned int ccm_ccgr2;
+	unsigned int reg, tmp;
+	unsigned int raw_25c, raw_n40c, ratio;
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[1];
+	struct fuse_bank1_regs *fuse_bank1 =
+			(struct fuse_bank1_regs *)bank->fuse_regs;
+
+	/* need to make sure pll3 is enabled for thermal sensor */
+	if ((readl(&mxc_ccm->analog_usb1_pll_480_ctrl) &
+			BM_ANADIG_USB1_PLL_480_CTRL_LOCK) == 0) {
+		/* enable pll's power */
+		writel(BM_ANADIG_USB1_PLL_480_CTRL_POWER,
+				&mxc_ccm->analog_usb1_pll_480_ctrl_set);
+		writel(0x80, &mxc_ccm->ana_misc2_clr);
+		/* wait for pll lock */
+		while ((readl(&mxc_ccm->analog_usb1_pll_480_ctrl) &
+			BM_ANADIG_USB1_PLL_480_CTRL_LOCK) == 0)
+			;
+		/* disable bypass */
+		writel(BM_ANADIG_USB1_PLL_480_CTRL_BYPASS,
+				&mxc_ccm->analog_usb1_pll_480_ctrl_clr);
+		/* enable pll output */
+		writel(BM_ANADIG_USB1_PLL_480_CTRL_ENABLE,
+				&mxc_ccm->analog_usb1_pll_480_ctrl_set);
+	}
+
+	ccm_ccgr2 = readl(&mxc_ccm->CCGR2);
+	/* enable OCOTP_CTRL clock in CCGR2 */
+	writel(ccm_ccgr2 | MXC_CCM_CCGR2_OCOTP_CTRL_MASK, &mxc_ccm->CCGR2);
+	fuse = readl(&fuse_bank1->ana1);
+
+	/* restore CCGR2 */
+	writel(ccm_ccgr2, &mxc_ccm->CCGR2);
+
+	if (fuse == 0 || fuse == 0xffffffff || (fuse & 0xfff00000) == 0)
+		return TEMPERATURE_MIN;
+
+	/*
+	 * fuse data layout:
+	 * [31:20] sensor value @ 25C
+	 * [19:8] sensor value of hot
+	 * [7:0] hot temperature value
+	 */
+	raw_25c = fuse >> 20;
+
+	/*
+	 * The universal equation for thermal sensor
+	 * is slope = 0.4297157 - (0.0015976 * 25C fuse),
+	 * here we convert them to integer to make them
+	 * easy for counting, FACTOR1 is 15976,
+	 * FACTOR2 is 4297157. Our ratio = -100 * slope
+	 */
+	ratio = ((FACTOR1 * raw_25c - FACTOR2) + 50000) / 100000;
+
+	debug("Thermal sensor with ratio = %d\n", ratio);
+
+	raw_n40c = raw_25c + (13 * ratio) / 20;
+
+	/*
+	 * now we only use single measure, every time we read
+	 * the temperature, we will power on/down anadig thermal
+	 * module
+	 */
+	writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN, &mxc_ccm->tempsense0_clr);
+	writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF, &mxc_ccm->ana_misc0_set);
+
+	/* write measure freq */
+	reg = readl(&mxc_ccm->tempsense1);
+	reg &= ~BM_ANADIG_TEMPSENSE1_MEASURE_FREQ;
+	reg |= MEASURE_FREQ;
+	writel(reg, &mxc_ccm->tempsense1);
+
+	writel(BM_ANADIG_TEMPSENSE0_MEASURE_TEMP, &mxc_ccm->tempsense0_clr);
+	writel(BM_ANADIG_TEMPSENSE0_FINISHED, &mxc_ccm->tempsense0_clr);
+	writel(BM_ANADIG_TEMPSENSE0_MEASURE_TEMP, &mxc_ccm->tempsense0_set);
+
+	while ((readl(&mxc_ccm->tempsense0) &
+			BM_ANADIG_TEMPSENSE0_FINISHED) == 0)
+		udelay(10000);
+
+	reg = readl(&mxc_ccm->tempsense0);
+	tmp = (reg & BM_ANADIG_TEMPSENSE0_TEMP_VALUE)
+		>> BP_ANADIG_TEMPSENSE0_TEMP_VALUE;
+	writel(BM_ANADIG_TEMPSENSE0_FINISHED, &mxc_ccm->tempsense0_clr);
+
+	if (tmp <= raw_n40c)
+		temperature = REG_VALUE_TO_CEL(ratio, tmp);
+	else
+		temperature = TEMPERATURE_MIN;
+	/* power down anatop thermal sensor */
+	writel(BM_ANADIG_TEMPSENSE0_POWER_DOWN, &mxc_ccm->tempsense0_set);
+	writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF, &mxc_ccm->ana_misc0_clr);
+
+	return temperature;
+}
+
+void check_cpu_temperature(void)
+{
+	int cpu_tmp = 0;
+
+	cpu_tmp = read_cpu_temperature();
+	while (cpu_tmp > TEMPERATURE_MIN && cpu_tmp < TEMPERATURE_MAX) {
+		if (cpu_tmp >= TEMPERATURE_HOT) {
+			printf("CPU is %d C, too hot to boot, waiting...\n",
+				cpu_tmp);
+			udelay(5000000);
+			cpu_tmp = read_cpu_temperature();
+		} else
+			break;
+	}
+	if (cpu_tmp > TEMPERATURE_MIN && cpu_tmp < TEMPERATURE_MAX)
+		printf("CPU:   Temperature %d C, calibration data: 0x%x\n",
+			cpu_tmp, fuse);
+	else
+		printf("CPU:   Temperature: can't get valid data!\n");
+}
+
 static void set_ahb_rate(u32 val)
 {
 	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
@@ -207,14 +380,171 @@ static void clear_mmdc_ch_mask(void)
 	writel(0, &mxc_ccm->ccdr);
 }
 
+static void init_bandgap(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/*
+	 * Ensure the bandgap has stabilized.
+	 */
+	while (!(readl(&mxc_ccm->ana_misc0) & 0x80))
+		;
+	/*
+	 * For best noise performance of the analog blocks using the
+	 * outputs of the bandgap, the reftop_selfbiasoff bit should
+	 * be set.
+	 */
+	writel(BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF, &mxc_ccm->ana_misc0_set);
+}
+
+#ifdef CONFIG_MX6SL
+static void set_preclk_from_osc(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 reg;
+
+	reg = readl(&mxc_ccm->cscmr1);
+	reg |= MXC_CCM_CSCMR1_PER_CLK_SEL_MASK;
+	writel(reg, &mxc_ccm->cscmr1);
+}
+#endif
+
+#ifdef CONFIG_MX6SX
+void vadc_power_up(void)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_GPR_BASE_ADDR;
+	u32 val;
+
+	/* csi0 */
+	val = readl(&iomux->gpr[5]);
+	val &= ~IMX6SX_GPR5_CSI1_MUX_CTRL_MASK,
+	val |= IMX6SX_GPR5_CSI1_MUX_CTRL_CVD;
+	writel(val, &iomux->gpr[5]);
+
+	/* Power on vadc analog
+	 * Power down vadc ext power */
+	val = readl(GPC_BASE_ADDR + 0);
+	val &= ~0x60000;
+	writel(val, GPC_BASE_ADDR + 0);
+
+	/* software reset afe  */
+	val = readl(&iomux->gpr[1]);
+	writel(val | 0x80000, &iomux->gpr[1]);
+
+	udelay(10*1000);
+
+	/* Release reset bit  */
+	writel(val & ~0x80000, &iomux->gpr[1]);
+
+	/* Power on vadc ext power */
+	val = readl(GPC_BASE_ADDR + 0);
+	val |= 0x40000;
+	writel(val, GPC_BASE_ADDR + 0);
+}
+
+void vadc_power_down(void)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_GPR_BASE_ADDR;
+	u32 val;
+
+	/* Power down vadc ext power
+	 * Power off vadc analog */
+	val = readl(GPC_BASE_ADDR + 0);
+	val &= ~0x40000;
+	val |= 0x20000;
+	writel(val, GPC_BASE_ADDR + 0);
+
+	/* clean csi0 connect to vadc  */
+	val = readl(&iomux->gpr[5]);
+	val &= ~IMX6SX_GPR5_CSI1_MUX_CTRL_MASK,
+	writel(val, &iomux->gpr[5]);
+}
+
+void pcie_power_up(void)
+{
+	set_ldo_voltage(LDO_PU, 1100);	/* Set VDDPU to 1.1V */
+}
+
+void pcie_power_off(void)
+{
+	set_ldo_voltage(LDO_PU, 0);	/* Set VDDPU to 1.1V */
+}
+#endif
+
+static void imx_set_vddpu_power_down(void)
+{
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	u32 val;
+
+	/* need to power down xPU in GPC before turn off PU LDO */
+	val = readl(GPC_BASE_ADDR + 0x260);
+	writel(val | 0x1, GPC_BASE_ADDR + 0x260);
+
+	val = readl(GPC_BASE_ADDR + 0x0);
+	writel(val | 0x1, GPC_BASE_ADDR + 0x0);
+	while (readl(GPC_BASE_ADDR + 0x0) & 0x1)
+		;
+
+	/* disable VDDPU */
+	val = 0x3e00;
+	writel(val, &ccm_regs->reg_core_clr);
+}
+
+#ifndef CONFIG_MX6SL
+static void imx_set_pcie_phy_power_down(void)
+{
+	u32 val;
+
+#ifndef CONFIG_MX6SX
+	val = readl(IOMUXC_BASE_ADDR + 0x4);
+	val |= 0x1 << 18;
+	writel(val, IOMUXC_BASE_ADDR + 0x4);
+#else
+	val = readl(IOMUXC_GPR_BASE_ADDR + 0x30);
+	val |= 0x1 << 30;
+	writel(val, IOMUXC_GPR_BASE_ADDR + 0x30);
+#endif
+}
+#endif
+
 int arch_cpu_init(void)
 {
+	/* Clear the Align bit in SCTLR */
+	set_cr(get_cr() & ~CR_A);
+
+#if !defined(CONFIG_MX6SX) && !defined(CONFIG_MX6SL)
+	/*
+	 * imx6sl doesn't have pcie at all.
+	 * this bit is not used by imx6sx anymore
+	 */
+	u32 val;
+
+	/*
+	 * There are about 0.02% percentage, random pcie link down
+	 * when warm-reset is used.
+	 * clear the ref_ssp_en bit16 of gpr1 to workaround it.
+	 * then warm-reset imx6q/dl/solo again.
+	 */
+	val = readl(IOMUXC_BASE_ADDR + 0x4);
+	if (val & (0x1 << 16)) {
+		val &= ~(0x1 << 16);
+		writel(val, IOMUXC_BASE_ADDR + 0x4);
+		reset_cpu(0);
+	}
+#endif
+
 	init_aips();
 
 	/* Need to clear MMDC_CHx_MASK to make warm reset work. */
 	clear_mmdc_ch_mask();
 
 	/*
+	 * Disable self-bias circuit in the analog bandap.
+	 * The self-bias circuit is used by the bandgap during startup.
+	 * This bit should be set after the bandgap has initialized.
+	 */
+	init_bandgap();
+	/*
 	 * When low freq boot is enabled, ROM will not set AHB
 	 * freq, so we need to ensure AHB freq is 132MHz in such
 	 * scenario.
@@ -222,8 +552,27 @@ int arch_cpu_init(void)
 	if (mxc_get_clock(MXC_ARM_CLK) == 396000000)
 		set_ahb_rate(132000000);
 
+	/* Set perclk to source from OSC 24MHz */
+#if defined(CONFIG_MX6SL)
+	set_preclk_from_osc();
+#endif
+
+#ifdef CONFIG_MX6SX
+	u32 reg;
+
+	/* set uart clk to OSC */
+	reg = readl(CCM_BASE_ADDR + 0x24);
+	reg |= 0x40;
+	writel(reg, CCM_BASE_ADDR + 0x24);
+#endif
+
 	imx_set_wdog_powerdown(false); /* Disable PDE bit of WMCR register */
 
+#ifndef CONFIG_MX6SL
+	imx_set_pcie_phy_power_down();
+#endif
+	imx_set_vddpu_power_down();
+
 #ifdef CONFIG_APBH_DMA
 	/* Start APBH DMA */
 	mxs_dma_init();
@@ -239,13 +588,41 @@ int board_postclk_init(void)
 	return 0;
 }
 
+#ifdef CONFIG_SERIAL_TAG
+void get_board_serial(struct tag_serialnr *serialnr)
+{
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[0];
+	struct fuse_bank0_regs *fuse =
+		(struct fuse_bank0_regs *)bank->fuse_regs;
+
+	serialnr->low = fuse->uid_low;
+	serialnr->high = fuse->uid_high;
+}
+#endif
+
 #ifndef CONFIG_SYS_DCACHE_OFF
 void enable_caches(void)
 {
+#if defined(CONFIG_SYS_ARM_CACHE_WRITETHROUGH)
+	enum dcache_option option = DCACHE_WRITETHROUGH;
+#else
+	enum dcache_option option = DCACHE_WRITEBACK;
+#endif
+
 	/* Avoid random hang when download by usb */
 	invalidate_dcache_all();
+
 	/* Enable D-cache. I-cache is already enabled in start.S */
 	dcache_enable();
+
+	/* Enable caching on OCRAM and ROM */
+	mmu_set_region_dcache_behaviour(ROMCP_ARB_BASE_ADDR,
+					ROMCP_ARB_END_ADDR,
+					option);
+	mmu_set_region_dcache_behaviour(IRAM_BASE_ADDR,
+					IRAM_SIZE,
+					option);
 }
 #endif
 
@@ -257,6 +634,29 @@ void imx_get_mac_from_fuse(int dev_id, unsigned char *mac)
 	struct fuse_bank4_regs *fuse =
 			(struct fuse_bank4_regs *)bank->fuse_regs;
 
+#ifdef CONFIG_MX6SX
+	if (0 == dev_id) {
+		u32 value = readl(&fuse->mac_addr1);
+		mac[0] = (value >> 8);
+		mac[1] = value ;
+
+		value = readl(&fuse->mac_addr0);
+		mac[2] = value >> 24 ;
+		mac[3] = value >> 16 ;
+		mac[4] = value >> 8 ;
+		mac[5] = value ;
+	} else {
+		u32 value = readl(&fuse->mac_addr2);
+		mac[0] = value >> 24 ;
+		mac[1] = value >> 16 ;
+		mac[2] = value >> 8 ;
+		mac[3] = value ;
+
+		value = readl(&fuse->mac_addr1);
+		mac[4] = value >> 24 ;
+		mac[5] = value >> 16 ;
+	}
+#else
 	u32 value = readl(&fuse->mac_addr_high);
 	mac[0] = (value >> 8);
 	mac[1] = value ;
@@ -266,7 +666,45 @@ void imx_get_mac_from_fuse(int dev_id, unsigned char *mac)
 	mac[3] = value >> 16 ;
 	mac[4] = value >> 8 ;
 	mac[5] = value ;
+#endif
+}
+#endif
+
+#ifdef CONFIG_MX6SX
+int arch_auxiliary_core_up(u32 core_id, u32 boot_private_data)
+{
+	struct src *src_reg;
+	u32 stack, pc;
+
+	if (!boot_private_data)
+		return 1;
+
+	stack = *(u32 *)boot_private_data;
+	pc = *(u32 *)(boot_private_data + 4);
+
+	/* Set the stack and pc to M4 bootROM */
+	writel(stack, M4_BOOTROM_BASE_ADDR);
+	writel(pc, M4_BOOTROM_BASE_ADDR + 4);
+
+	/* Enable M4 */
+	src_reg = (struct src *)SRC_BASE_ADDR;
+	setbits_le32(&src_reg->scr, 0x00400000);
+	clrbits_le32(&src_reg->scr, 0x00000010);
+
+	return 0;
+}
+
+int arch_auxiliary_core_check_up(u32 core_id)
+{
+	struct src *src_reg = (struct src *)SRC_BASE_ADDR;
+	unsigned val;
 
+	val = readl(&src_reg->scr);
+
+	if (val & 0x00000010)
+		return 0;  /* assert in reset */
+
+	return 1;
 }
 #endif
 
@@ -305,12 +743,60 @@ const struct boot_mode soc_boot_modes[] = {
 	{NULL,		0},
 };
 
+enum boot_device get_boot_device(void)
+{
+    enum boot_device boot_dev = UNKNOWN_BOOT;
+	uint soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	uint bt_mem_ctl = (soc_sbmr & 0x000000FF) >> 4 ;
+	uint bt_mem_type = (soc_sbmr & 0x00000008) >> 3;
+	uint bt_dev_port = (soc_sbmr & 0x00001800) >> 11;
+
+	switch (bt_mem_ctl) {
+	case 0x0:
+		if (bt_mem_type)
+			boot_dev = ONE_NAND_BOOT;
+		else
+			boot_dev = WEIM_NOR_BOOT;
+		break;
+	case 0x2:
+			boot_dev = SATA_BOOT;
+		break;
+	case 0x3:
+		if (bt_mem_type)
+			boot_dev = I2C_BOOT;
+		else
+			boot_dev = SPI_NOR_BOOT;
+		break;
+	case 0x4:
+	case 0x5:
+		boot_dev = bt_dev_port + SD1_BOOT;
+		break;
+	case 0x6:
+	case 0x7:
+		boot_dev = bt_dev_port + MMC1_BOOT;
+		break;
+	case 0x8 ... 0xf:
+		boot_dev = NAND_BOOT;
+		break;
+	default:
+		boot_dev = UNKNOWN_BOOT;
+		break;
+	}
+
+    return boot_dev;
+}
+
 void s_init(void)
 {
-	struct anatop_regs *anatop = (struct anatop_regs *)ANATOP_BASE_ADDR;
-	int is_6q = is_cpu_type(MXC_CPU_MX6Q);
+	struct mxc_ccm_reg *ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	int is_6sx = is_cpu_type(MXC_CPU_MX6SX);
 	u32 mask480;
 	u32 mask528;
+	u32 reg, periph1, periph2;
+
+	/* Don't reset PFD for MX6SX */
+	if (is_6sx)
+		return;
 
 	/* Due to hardware limitation, on MX6Q we need to gate/ungate all PFDs
 	 * to make sure PFD is working right, otherwise, PFDs may
@@ -322,21 +808,171 @@ void s_init(void)
 		ANATOP_PFD_CLKGATE_MASK(1) |
 		ANATOP_PFD_CLKGATE_MASK(2) |
 		ANATOP_PFD_CLKGATE_MASK(3);
-	mask528 = ANATOP_PFD_CLKGATE_MASK(0) |
-		ANATOP_PFD_CLKGATE_MASK(1) |
+	mask528 = ANATOP_PFD_CLKGATE_MASK(1) |
 		ANATOP_PFD_CLKGATE_MASK(3);
 
+	reg = readl(&ccm->cbcmr);
+	periph2 = ((reg & MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_MASK)
+		>> MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_OFFSET);
+	periph1 = ((reg & MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_MASK)
+		>> MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_OFFSET);
+
+	/* Checking if PLL2 PFD0 or PLL2 PFD2 is using for periph clock */
+	if ((periph2 != 0x2) && (periph1 != 0x2))
+		mask528 |= ANATOP_PFD_CLKGATE_MASK(0);
+
+	if ((periph2 != 0x1) && (periph1 != 0x1) &&
+		(periph2 != 0x3) && (periph1 != 0x3))
+		mask528 |= ANATOP_PFD_CLKGATE_MASK(2);
+
+	writel(mask480, &ccm->analog_pfd_480_set);
+	writel(mask528, &ccm->analog_pfd_528_set);
+	writel(mask480, &ccm->analog_pfd_480_clr);
+	writel(mask528, &ccm->analog_pfd_528_clr);
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+DECLARE_GLOBAL_DATA_PTR;
+static int ldo_bypass;
+
+int check_ldo_bypass(void)
+{
+	const int *ldo_mode;
+	int node;
+
+	/* get the right fdt_blob from the global working_fdt */
+	gd->fdt_blob = working_fdt;
+	/* Get the node from FDT for anatop ldo-bypass */
+	node = fdt_node_offset_by_compatible(gd->fdt_blob, -1,
+		"fsl,imx6q-gpc");
+	if (node < 0) {
+		printf("No gpc device node %d, force to ldo-enable.\n", node);
+		return 0;
+	}
+	ldo_mode = fdt_getprop(gd->fdt_blob, node, "fsl,ldo-bypass", NULL);
 	/*
-	 * Don't reset PFD2 on DL/S
+	 * return 1 if "fsl,ldo-bypass = <1>", else return 0 if
+	 * "fsl,ldo-bypass = <0>" or no "fsl,ldo-bypass" property
 	 */
-	if (is_6q)
-		mask528 |= ANATOP_PFD_CLKGATE_MASK(2);
-	writel(mask480, &anatop->pfd_480_set);
-	writel(mask528, &anatop->pfd_528_set);
-	writel(mask480, &anatop->pfd_480_clr);
-	writel(mask528, &anatop->pfd_528_clr);
+	ldo_bypass = fdt32_to_cpu(*ldo_mode) == 1 ? 1 : 0;
+
+	return ldo_bypass;
+}
+
+int check_1_2G(void)
+{
+	u32 reg;
+	int result = 0;
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[0];
+	struct fuse_bank0_regs *fuse_bank0 =
+			(struct fuse_bank0_regs *)bank->fuse_regs;
+
+	reg = readl(&fuse_bank0->cfg3);
+	if (((reg >> 16) & 0x3) == 0x3) {
+		if (ldo_bypass) {
+			printf("Wrong dtb file used! i.MX6Q@1.2Ghz only "
+				"works with ldo-enable mode!\n");
+			/*
+			 * Currently, only imx6q-sabresd board might be here,
+			 * since only i.MX6Q support 1.2G and only Sabresd board
+			 * support ldo-bypass mode. So hardcode here.
+			 * You can also modify your board(i.MX6Q) dtb name if it
+			 * supports both ldo-bypass and ldo-enable mode.
+			 */
+			printf("Please use imx6q-sabresd-ldo.dtb!\n");
+			hang();
+		}
+		result = 1;
+	}
+
+	return result;
+}
+
+static int arm_orig_podf;
+void set_arm_freq_400M(bool is_400M)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	if (is_400M)
+		writel(0x1, &mxc_ccm->cacrr);
+	else
+		writel(arm_orig_podf, &mxc_ccm->cacrr);
+}
+
+void prep_anatop_bypass(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	arm_orig_podf = readl(&mxc_ccm->cacrr);
+	/*
+	 * Downgrade ARM speed to 400Mhz as half of boot 800Mhz before ldo
+	 * bypassed, also downgrade internal vddarm ldo to 0.975V.
+	 * VDDARM_IN 0.975V + 125mV = 1.1V < Max(1.3V)
+	 * otherwise at 800Mhz(i.mx6dl):
+	 * VDDARM_IN 1.175V + 125mV = 1.3V = Max(1.3V)
+	 * We need provide enough gap in this case.
+	 * skip if boot from 400M.
+	 */
+	if (!arm_orig_podf)
+		set_arm_freq_400M(true);
+#if !defined(CONFIG_MX6DL) && !defined(CONFIG_MX6SX)
+	set_ldo_voltage(LDO_ARM, 975);
+#else
+	set_ldo_voltage(LDO_ARM, 1150);
+#endif
+}
+
+void set_wdog_reset(struct wdog_regs *wdog)
+{
+	u32 reg = readw(&wdog->wcr);
+	/*
+	 * use WDOG_B mode to reset external pmic because it's risky for the
+	 * following watchdog reboot in case of cpu freq at lowest 400Mhz with
+	 * ldo-bypass mode. Because boot frequency maybe higher 800Mhz i.e. So
+	 * in ldo-bypass mode watchdog reset will only triger POR reset, not
+	 * WDOG reset. But below code depends on hardware design, if HW didn't
+	 * connect WDOG_B pin to external pmic such as i.mx6slevk, we can skip
+	 * these code since it assumed boot from 400Mhz always.
+	 */
+	reg = readw(&wdog->wcr);
+	reg |= 1 << 3;
+	/*
+	 * WDZST bit is write-once only bit. Align this bit in kernel,
+	 * otherwise kernel code will have no chance to set this bit.
+	 */
+	reg |= 1 << 0;
+	writew(reg, &wdog->wcr);
 }
 
+int set_anatop_bypass(int wdog_reset_pin)
+{
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct wdog_regs *wdog;
+	u32 reg = readl(&ccm_regs->reg_core);
+
+	/* bypass VDDARM/VDDSOC */
+	reg = reg | (0x1F << 18) | 0x1F;
+	writel(reg, &ccm_regs->reg_core);
+
+	if (wdog_reset_pin == 2)
+		wdog = (struct wdog_regs *) WDOG2_BASE_ADDR;
+	else if (wdog_reset_pin == 1)
+		wdog = (struct wdog_regs *) WDOG1_BASE_ADDR;
+	else
+		return arm_orig_podf;
+	set_wdog_reset(wdog);
+	return arm_orig_podf;
+}
+
+void finish_anatop_bypass(void)
+{
+	if (!arm_orig_podf)
+		set_arm_freq_400M(false);
+}
+
+#endif
+
 #ifdef CONFIG_IMX_HDMI
 void imx_enable_hdmi_phy(void)
 {
@@ -358,7 +994,8 @@ void imx_setup_hdmi(void)
 {
 	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
 	struct hdmi_regs *hdmi  = (struct hdmi_regs *)HDMI_ARB_BASE_ADDR;
-	int reg;
+	int reg, count;
+	u8 val;
 
 	/* Turn on HDMI PHY clock */
 	reg = readl(&mxc_ccm->CCGR2);
@@ -375,6 +1012,15 @@ void imx_setup_hdmi(void)
 		 |(CHSCCDR_IPU_PRE_CLK_540M_PFD
 		 << MXC_CCM_CHSCCDR_IPU1_DI0_PRE_CLK_SEL_OFFSET);
 	writel(reg, &mxc_ccm->chsccdr);
+
+	/* Workaround to clear the overflow condition */
+	if (readb(&hdmi->ih_fc_stat2) & HDMI_IH_FC_STAT2_OVERFLOW_MASK) {
+		/* TMDS software reset */
+		writeb((u8)~HDMI_MC_SWRSTZ_TMDSSWRST_REQ, &hdmi->mc_swrstz);
+		val = readb(&hdmi->fc_invidconf);
+		for (count = 0 ; count < 5 ; count++)
+			writeb(val, &hdmi->fc_invidconf);
+	}
 }
 #endif
 
@@ -395,6 +1041,9 @@ void v7_outer_cache_enable(void)
 	}
 #endif
 
+	/* Must disable the L2 before changing the latency parameters */
+	clrbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
+
 	writel(0x132, &pl310->pl310_tag_latency_ctrl);
 	writel(0x132, &pl310->pl310_data_latency_ctrl);
 
@@ -433,3 +1082,97 @@ void v7_outer_cache_disable(void)
 	clrbits_le32(&pl310->pl310_ctrl, L2X0_CTRL_EN);
 }
 #endif /* !CONFIG_SYS_L2CACHE_OFF */
+
+#ifdef CONFIG_FASTBOOT
+
+#ifdef CONFIG_ANDROID_RECOVERY
+#define ANDROID_RECOVERY_BOOT  (1 << 7)
+/* check if the recovery bit is set by kernel, it can be set by kernel
+ * issue a command '# reboot recovery' */
+int recovery_check_and_clean_flag(void)
+{
+	int flag_set = 0;
+	u32 reg;
+	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
+
+	flag_set = !!(reg & ANDROID_RECOVERY_BOOT);
+    printf("check_and_clean: reg %x, flag_set %d\n", reg, flag_set);
+	/* clean it in case looping infinite here.... */
+	if (flag_set) {
+		reg &= ~ANDROID_RECOVERY_BOOT;
+		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
+	}
+
+	return flag_set;
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#define ANDROID_FASTBOOT_BOOT  (1 << 8)
+/* check if the recovery bit is set by kernel, it can be set by kernel
+ * issue a command '# reboot fastboot' */
+int fastboot_check_and_clean_flag(void)
+{
+	int flag_set = 0;
+	u32 reg;
+
+	reg = readl(SNVS_BASE_ADDR + SNVS_LPGPR);
+
+	flag_set = !!(reg & ANDROID_FASTBOOT_BOOT);
+
+	/* clean it in case looping infinite here.... */
+	if (flag_set) {
+		reg &= ~ANDROID_FASTBOOT_BOOT;
+		writel(reg, SNVS_BASE_ADDR + SNVS_LPGPR);
+	}
+
+	return flag_set;
+}
+#endif /*CONFIG_FASTBOOT*/
+
+#ifdef CONFIG_IMX_UDC
+void set_usboh3_clk(void)
+{
+	udc_pins_setting();
+}
+
+void set_usb_phy1_clk(void)
+{
+	/* make sure pll3 is enable here */
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	writel((BM_ANADIG_USB1_CHRG_DETECT_EN_B |
+		BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B),
+		&ccm_regs->usb1_chrg_detect_set);
+
+	writel(BM_ANADIG_USB1_PLL_480_CTRL_EN_USB_CLKS,
+		&ccm_regs->analog_usb1_pll_480_ctrl_set);
+}
+void enable_usb_phy1_clk(unsigned char enable)
+{
+	if (enable)
+		writel(BM_USBPHY_CTRL_CLKGATE,
+			USB_PHY0_BASE_ADDR + HW_USBPHY_CTRL_CLR);
+	else
+		writel(BM_USBPHY_CTRL_CLKGATE,
+			USB_PHY0_BASE_ADDR + HW_USBPHY_CTRL_SET);
+}
+
+void reset_usb_phy1(void)
+{
+	/* Reset USBPHY module */
+	u32 temp;
+	temp = readl(USB_PHY0_BASE_ADDR + HW_USBPHY_CTRL);
+	temp |= BM_USBPHY_CTRL_SFTRST;
+	writel(temp, USB_PHY0_BASE_ADDR + HW_USBPHY_CTRL);
+	udelay(10);
+
+	/* Remove CLKGATE and SFTRST */
+	temp = readl(USB_PHY0_BASE_ADDR + HW_USBPHY_CTRL);
+	temp &= ~(BM_USBPHY_CTRL_CLKGATE | BM_USBPHY_CTRL_SFTRST);
+	writel(temp, USB_PHY0_BASE_ADDR + HW_USBPHY_CTRL);
+	udelay(10);
+
+	/* Power up the PHY */
+	writel(0, USB_PHY0_BASE_ADDR + HW_USBPHY_PWD);
+}
+#endif
diff --git a/arch/arm/imx-common/Makefile b/arch/arm/imx-common/Makefile
index b04dfbb..5f2e620 100644
--- a/arch/arm/imx-common/Makefile
+++ b/arch/arm/imx-common/Makefile
@@ -19,6 +19,7 @@ obj-y	+= misc.o
 endif
 ifeq ($(SOC),$(filter $(SOC),mx6))
 obj-$(CONFIG_CMD_SATA) += sata.o
+obj-$(CONFIG_MXC_RDC) += rdc-sema.o
 endif
 obj-$(CONFIG_CMD_BMODE) += cmd_bmode.o
 obj-$(CONFIG_CMD_HDMIDETECT) += cmd_hdmidet.o
diff --git a/arch/arm/imx-common/cpu.c b/arch/arm/imx-common/cpu.c
index a77c4de..8427eb7 100644
--- a/arch/arm/imx-common/cpu.c
+++ b/arch/arm/imx-common/cpu.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -15,6 +15,11 @@
 #include <asm/arch/sys_proto.h>
 #include <asm/arch/crm_regs.h>
 #include <ipu_pixfmt.h>
+#include <mxsfb.h>
+
+#ifdef CONFIG_VIDEO_GIS
+#include <gis.h>
+#endif
 
 #ifdef CONFIG_FSL_ESDHC
 #include <fsl_esdhc.h>
@@ -114,6 +119,8 @@ const char *get_imx_type(u32 imxtype)
 		return "6SOLO";	/* Solo version of the mx6 */
 	case MXC_CPU_MX6SL:
 		return "6SL";	/* Solo-Lite version of the mx6 */
+	case MXC_CPU_MX6SX:
+		return "6SX";	/* SoloX version of the mx6 */
 	case MXC_CPU_MX51:
 		return "51";
 	case MXC_CPU_MX53:
@@ -126,6 +133,10 @@ const char *get_imx_type(u32 imxtype)
 int print_cpuinfo(void)
 {
 	u32 cpurev;
+#if defined(CONFIG_DBG_MONITOR)
+	struct dbg_monitor_regs *dbg =
+		(struct dbg_monitor_regs *)DEBUG_MONITOR_BASE_ADDR;
+#endif
 
 	cpurev = get_cpu_rev();
 
@@ -134,6 +145,19 @@ int print_cpuinfo(void)
 		(cpurev & 0x000F0) >> 4,
 		(cpurev & 0x0000F) >> 0,
 		mxc_get_clock(MXC_ARM_CLK) / 1000000);
+
+#if defined(CONFIG_MX6)
+	check_cpu_temperature();
+#endif
+
+#if defined(CONFIG_DBG_MONITOR)
+	if (readl(&dbg->snvs_addr))
+		printf("DBG snvs regs addr 0x%x, data 0x%x, info 0x%x\n",
+		       readl(&dbg->snvs_addr),
+		       readl(&dbg->snvs_data),
+		       readl(&dbg->snvs_info));
+#endif
+
 	printf("Reset cause: %s\n", get_reset_cause());
 	return 0;
 }
@@ -173,10 +197,20 @@ u32 get_ahb_clk(void)
 	return get_periph_clk() / (ahb_podf + 1);
 }
 
-#if defined(CONFIG_VIDEO_IPUV3)
 void arch_preboot_os(void)
 {
+#if defined(CONFIG_LDO_BYPASS_CHECK)
+	ldo_mode_set(check_ldo_bypass());
+#endif
+#if defined(CONFIG_VIDEO_IPUV3)
 	/* disable video before launching O/S */
 	ipuv3_fb_shutdown();
-}
 #endif
+#ifdef CONFIG_VIDEO_GIS
+	/* Entry for GIS */
+	mxc_disable_gis();
+#endif
+#ifdef CONFIG_VIDEO_MXS
+	lcdif_power_down();
+#endif
+}
diff --git a/arch/arm/imx-common/i2c-mxv7.c b/arch/arm/imx-common/i2c-mxv7.c
index a580873..5ef1530 100644
--- a/arch/arm/imx-common/i2c-mxv7.c
+++ b/arch/arm/imx-common/i2c-mxv7.c
@@ -32,13 +32,36 @@ static int force_idle_bus(void *priv)
 
 	printf("%s: sda=%d scl=%d sda.gp=0x%x scl.gp=0x%x\n", __func__,
 		sda, scl, p->sda.gp, p->scl.gp);
+	gpio_direction_output(p->scl.gp, 1);
+	udelay(1000);
 	/* Send high and low on the SCL line */
 	for (i = 0; i < 9; i++) {
-		gpio_direction_output(p->scl.gp, 0);
+		gpio_direction_output(p->scl.gp, 1);
 		udelay(50);
-		gpio_direction_input(p->scl.gp);
+		gpio_direction_output(p->scl.gp, 0);
 		udelay(50);
 	}
+
+	/* Simulate the NACK */
+	gpio_direction_output(p->sda.gp, 1);
+	udelay(50);
+	gpio_direction_output(p->scl.gp, 1);
+	udelay(50);
+	gpio_direction_output(p->scl.gp, 0);
+	udelay(50);
+
+	/* Simulate the STOP signal */
+	gpio_direction_output(p->sda.gp, 0);
+	udelay(50);
+	gpio_direction_output(p->scl.gp, 1);
+	udelay(50);
+	gpio_direction_output(p->sda.gp, 1);
+	udelay(50);
+
+	/* Get the bus status */
+	gpio_direction_input(p->sda.gp);
+	gpio_direction_input(p->scl.gp);
+
 	start_time = get_timer(0);
 	for (;;) {
 		sda = gpio_get_value(p->sda.gp);
diff --git a/arch/arm/imx-common/iomux-v3.c b/arch/arm/imx-common/iomux-v3.c
index b59b802..11cfc33 100644
--- a/arch/arm/imx-common/iomux-v3.c
+++ b/arch/arm/imx-common/iomux-v3.c
@@ -55,3 +55,18 @@ void imx_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t const *pad_list,
 	for (i = 0; i < count; i++)
 		imx_iomux_v3_setup_pad(*p++);
 }
+
+void mxc_iomux_set_gpr_register(int group, int start_bit,
+					int num_bits, int value)
+{
+	int i = 0;
+	u32 reg;
+	reg = readl(base + group * 4);
+	while (num_bits) {
+		reg &= ~(1<<(start_bit + i));
+		i++;
+		num_bits--;
+	}
+	reg |= (value << start_bit);
+	writel(reg, base + group * 4);
+}
diff --git a/arch/arm/imx-common/rdc-sema.c b/arch/arm/imx-common/rdc-sema.c
new file mode 100644
index 0000000..3d6f9c9
--- /dev/null
+++ b/arch/arm/imx-common/rdc-sema.c
@@ -0,0 +1,247 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:  GPL-2.0+
+ */
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+
+#define SEMA_GATES_NUM 64
+
+#define RDC_MDA_DID_SHIFT 0
+#define RDC_MDA_DID_MASK (0x3 << RDC_MDA_DID_SHIFT)
+#define RDC_MDA_LCK_SHIFT 31
+#define RDC_MDA_LCK_MASK (0x1 << RDC_MDA_LCK_SHIFT)
+
+#define RDC_PDAP_D0W_SHIFT 0
+#define RDC_PDAP_D0W_MASK (0x1 << RDC_PDAP_D0W_SHIFT)
+#define RDC_PDAP_D0R_SHIFT 1
+#define RDC_PDAP_D0R_MASK (0x1 << RDC_PDAP_D0R_SHIFT)
+#define RDC_PDAP_D1W_SHIFT 2
+#define RDC_PDAP_D1W_MASK (0x1 << RDC_PDAP_D1W_SHIFT)
+#define RDC_PDAP_D1R_SHIFT 3
+#define RDC_PDAP_D1R_MASK (0x1 << RDC_PDAP_D1R_SHIFT)
+#define RDC_PDAP_D2W_SHIFT 4
+#define RDC_PDAP_D2W_MASK (0x1 << RDC_PDAP_D2W_SHIFT)
+#define RDC_PDAP_D2R_SHIFT 5
+#define RDC_PDAP_D2R_MASK (0x1 << RDC_PDAP_D2R_SHIFT)
+#define RDC_PDAP_D3W_SHIFT 6
+#define RDC_PDAP_D3W_MASK (0x1 << RDC_PDAP_D3W_SHIFT)
+#define RDC_PDAP_D3R_SHIFT 7
+#define RDC_PDAP_D3R_MASK (0x1 << RDC_PDAP_D3R_SHIFT)
+#define RDC_PDAP_SREQ_SHIFT 30
+#define RDC_PDAP_SREQ_MASK (0x1 << RDC_PDAP_SREQ_SHIFT)
+#define RDC_PDAP_LCK_SHIFT 31
+#define RDC_PDAP_LCK_MASK (0x1 << RDC_PDAP_LCK_SHIFT)
+
+#define RDC_MRSA_SADR_SHIFT 7
+#define RDC_MRSA_SADR_MASK (0x1ffffff << RDC_MRSA_SADR_SHIFT)
+
+#define RDC_MREA_EADR_SHIFT 7
+#define RDC_MREA_EADR_MASK (0x1ffffff << RDC_MREA_EADR_SHIFT)
+
+#define RDC_MRC_D0W_SHIFT 0
+#define RDC_MRC_D0W_MASK (0x1 << RDC_MRC_D0W_SHIFT)
+#define RDC_MRC_D0R_SHIFT 1
+#define RDC_MRC_D0R_MASK (0x1 << RDC_MRC_D0R_SHIFT)
+#define RDC_MRC_D1W_SHIFT 2
+#define RDC_MRC_D1W_MASK (0x1 << RDC_MRC_D1W_SHIFT)
+#define RDC_MRC_D1R_SHIFT 3
+#define RDC_MRC_D1R_MASK (0x1 << RDC_MRC_D1R_SHIFT)
+#define RDC_MRC_D2W_SHIFT 4
+#define RDC_MRC_D2W_MASK (0x1 << RDC_MRC_D2W_SHIFT)
+#define RDC_MRC_D2R_SHIFT 5
+#define RDC_MRC_D2R_MASK (0x1 << RDC_MRC_D2R_SHIFT)
+#define RDC_MRC_D3W_SHIFT 6
+#define RDC_MRC_D3W_MASK (0x1 << RDC_MRC_D3W_SHIFT)
+#define RDC_MRC_D3R_SHIFT 7
+#define RDC_MRC_D3R_MASK (0x1 << RDC_MRC_D3R_SHIFT)
+#define RDC_MRC_ENA_SHIFT 30
+#define RDC_MRC_ENA_MASK (0x1 << RDC_MRC_ENA_SHIFT)
+#define RDC_MRC_LCK_SHIFT 31
+#define RDC_MRC_LCK_MASK (0x1 << RDC_MRC_LCK_SHIFT)
+
+#define RDC_MRVS_VDID_SHIFT 0
+#define RDC_MRVS_VDID_MASK (0x3 << RDC_MRVS_VDID_SHIFT)
+#define RDC_MRVS_AD_SHIFT 4
+#define RDC_MRVS_AD_MASK (0x1 << RDC_MRVS_AD_SHIFT)
+#define RDC_MRVS_VADDR_SHIFT 5
+#define RDC_MRVS_VADDR_MASK (0x7ffffff << RDC_MRVS_VADDR_SHIFT)
+
+#define RDC_SEMA_GATE_GTFSM_SHIFT 0
+#define RDC_SEMA_GATE_GTFSM_MASK (0xf << RDC_SEMA_GATE_GTFSM_SHIFT)
+#define RDC_SEMA_GATE_LDOM_SHIFT 5
+#define RDC_SEMA_GATE_LDOM_MASK (0x3 << RDC_SEMA_GATE_LDOM_SHIFT)
+
+#define RDC_SEMA_RSTGT_RSTGDP_SHIFT 0
+#define RDC_SEMA_RSTGT_RSTGDP_MASK (0xff << RDC_SEMA_RSTGT_RSTGDP_SHIFT)
+#define RDC_SEMA_RSTGT_RSTGSM_SHIFT 2
+#define RDC_SEMA_RSTGT_RSTGSM_MASK (0x3 << RDC_SEMA_RSTGT_RSTGSM_SHIFT)
+#define RDC_SEMA_RSTGT_RSTGMS_SHIFT 4
+#define RDC_SEMA_RSTGT_RSTGMS_MASK (0xf << RDC_SEMA_RSTGT_RSTGMS_SHIFT)
+#define RDC_SEMA_RSTGT_RSTGTN_SHIFT 8
+#define RDC_SEMA_RSTGT_RSTGTN_MASK (0xff << RDC_SEMA_RSTGT_RSTGTN_SHIFT)
+
+/*
+ * Check the peripheral read / write access permission on Domain 0.
+ * (Always assume the main CPU is in Domain 0)
+ */
+int imx_rdc_check_permission(int per_id)
+{
+	struct rdc_regs *imx_rdc = (struct rdc_regs *)RDC_BASE_ADDR;
+	u32 reg;
+
+	reg = readl(&imx_rdc->pdap[per_id]);
+	if (!(reg & (RDC_PDAP_D0W_MASK | RDC_PDAP_D0R_MASK)))
+		return 1;  /*No access*/
+	return 0;
+}
+
+/*
+ * Check if the RDC Semaphore is required for this peripheral.
+ */
+static inline int imx_rdc_check_sema_required(int per_id)
+{
+	struct rdc_regs *imx_rdc = (struct rdc_regs *)RDC_BASE_ADDR;
+	u32 reg;
+
+	reg = readl(&imx_rdc->pdap[per_id]);
+	if (!(reg & RDC_PDAP_SREQ_MASK))
+		return 1;  /*No semaphore*/
+	return 0;
+}
+
+/*
+ * Lock up the RDC semaphore for this peripheral if semaphore is required.
+ */
+int imx_rdc_sema_lock(int per_id)
+{
+	struct rdc_sema_regs *imx_rdc_sema;
+	u8 reg;
+
+	if (imx_rdc_check_sema_required(per_id))
+		return 1;
+
+	if (per_id < SEMA_GATES_NUM)
+		imx_rdc_sema  = (struct rdc_sema_regs *)SEMAPHORE1_BASE_ADDR;
+	else
+		imx_rdc_sema  = (struct rdc_sema_regs *)SEMAPHORE2_BASE_ADDR;
+
+	do {
+		writeb(RDC_SEMA_PROC_ID, &imx_rdc_sema->gate[per_id % SEMA_GATES_NUM]);
+		reg = readb(&imx_rdc_sema->gate[per_id % SEMA_GATES_NUM]);
+		if ((reg & RDC_SEMA_GATE_GTFSM_MASK) == RDC_SEMA_PROC_ID)
+			break;  /* Get the Semaphore*/
+	} while (1);
+
+	return 0;
+}
+
+/*
+ * Unlock the RDC semaphore for this peripheral if main CPU is the semaphore owner.
+ */
+int imx_rdc_sema_unlock(int per_id)
+{
+	struct rdc_sema_regs *imx_rdc_sema;
+	u8 reg;
+
+	if (imx_rdc_check_sema_required(per_id))
+		return 1;
+
+	if (per_id < SEMA_GATES_NUM)
+		imx_rdc_sema  = (struct rdc_sema_regs *)SEMAPHORE1_BASE_ADDR;
+	else
+		imx_rdc_sema  = (struct rdc_sema_regs *)SEMAPHORE2_BASE_ADDR;
+
+	reg = readb(&imx_rdc_sema->gate[per_id % SEMA_GATES_NUM]);
+	if ((reg & RDC_SEMA_GATE_GTFSM_MASK) != RDC_SEMA_PROC_ID)
+		return 1;	/*Not the semaphore owner */
+
+	writeb(0x0, &imx_rdc_sema->gate[per_id % SEMA_GATES_NUM]);
+
+	return 0;
+}
+
+/*
+ * Setup RDC setting for one peripheral
+ */
+int imx_rdc_setup_peri(rdc_peri_cfg_t p)
+{
+	struct rdc_regs *imx_rdc = (struct rdc_regs *)RDC_BASE_ADDR;
+	u32 reg = 0;
+	u32 share_count = 0;
+	u32 peri_id = p & RDC_PERI_MASK;
+	u32 domain = (p & RDC_DOMAIN_MASK) >> RDC_DOMAIN_SHIFT_BASE;
+
+	if (domain == 0)
+		return 1;
+
+	reg |= domain;
+
+	share_count = (domain & 0x3)
+		+ ((domain >> 2) & 0x3)
+		+ ((domain >> 4) & 0x3)
+		+ ((domain >> 6) & 0x3);
+
+	if (share_count > 0x3)
+		reg |= RDC_PDAP_SREQ_MASK;
+
+	writel(reg, &imx_rdc->pdap[peri_id]);
+
+	return 0;
+}
+
+/*
+ * Setup RDC settings for multiple peripherals
+ */
+int imx_rdc_setup_peripherals(rdc_peri_cfg_t const *peripherals_list,
+				     unsigned count)
+{
+	rdc_peri_cfg_t const *p = peripherals_list;
+	int i;
+	int ret;
+
+	for (i = 0; i < count; i++) {
+		ret = imx_rdc_setup_peri(*p);
+		if (ret)
+			return ret;
+		p++;
+	}
+	return 0;
+}
+
+/*
+ * Setup RDC setting for one master
+ */
+int imx_rdc_setup_ma(rdc_ma_cfg_t p)
+{
+	struct rdc_regs *imx_rdc = (struct rdc_regs *)RDC_BASE_ADDR;
+	u32 master_id = (p & RDC_MASTER_MASK) >> RDC_MASTER_SHIFT;
+	u32 domain = (p & RDC_DOMAIN_MASK) >> RDC_DOMAIN_SHIFT_BASE;
+
+	writel((domain & RDC_MDA_DID_MASK), &imx_rdc->mda[master_id]);
+
+	return 0;
+}
+
+/*
+ * Setup RDC settings for multiple masters
+ */
+int imx_rdc_setup_masters(rdc_ma_cfg_t const *masters_list,
+				     unsigned count)
+{
+	rdc_ma_cfg_t const *p = masters_list;
+	int i;
+	int ret;
+
+	for (i = 0; i < count; i++) {
+		ret = imx_rdc_setup_ma(*p);
+		if (ret)
+			return ret;
+		p++;
+	}
+	return 0;
+}
diff --git a/arch/arm/imx-common/timer.c b/arch/arm/imx-common/timer.c
index c63f78f..f7e49bd 100644
--- a/arch/arm/imx-common/timer.c
+++ b/arch/arm/imx-common/timer.c
@@ -2,7 +2,7 @@
  * (C) Copyright 2007
  * Sascha Hauer, Pengutronix
  *
- * (C) Copyright 2009 Freescale Semiconductor, Inc.
+ * (C) Copyright 2009-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -12,6 +12,7 @@
 #include <div64.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/clock.h>
+#include <asm/arch/sys_proto.h>
 
 /* General purpose timers registers */
 struct mxc_gpt {
@@ -26,23 +27,60 @@ static struct mxc_gpt *cur_gpt = (struct mxc_gpt *)GPT1_BASE_ADDR;
 
 /* General purpose timers bitfields */
 #define GPTCR_SWR		(1 << 15)	/* Software reset */
+#define GPTCR_24MEN	    (1 << 10)	/* Enable 24MHz clock input from crystal */
 #define GPTCR_FRR		(1 << 9)	/* Freerun / restart */
-#define GPTCR_CLKSOURCE_32	(4 << 6)	/* Clock source */
+#define GPTCR_CLKSOURCE_32	(4 << 6)	/* Clock source 32khz */
+#define GPTCR_CLKSOURCE_OSC	(5 << 6)	/* Clock source OSC */
+#define GPTCR_CLKSOURCE_PRE	(1 << 6)	/* Clock source PRECLK */
+#define GPTCR_CLKSOURCE_MASK (0x7 << 6)
 #define GPTCR_TEN		1		/* Timer enable */
 
+#define GPTPR_PRESCALER24M_SHIFT 12
+#define GPTPR_PRESCALER24M_MASK (0xF << GPTPR_PRESCALER24M_SHIFT)
+
 DECLARE_GLOBAL_DATA_PTR;
 
+static inline int gpt_has_clk_source_osc(void)
+{
+#if defined(CONFIG_MX6)
+	if (((is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6D))
+		&& (is_soc_rev(CHIP_REV_1_0) > 0))
+		|| is_cpu_type(MXC_CPU_MX6DL) || is_cpu_type(MXC_CPU_MX6SOLO)
+		|| is_cpu_type(MXC_CPU_MX6SX))
+		return 1;
+
+	return 0;
+#else
+	return 0;
+#endif
+}
+
+static inline ulong gpt_get_clk(void)
+{
+#ifdef CONFIG_MXC_GPT_HCLK
+	if (gpt_has_clk_source_osc())
+		return MXC_HCLK >> 3;
+	else
+		return mxc_get_clock(MXC_IPG_PERCLK);
+#else
+	return MXC_CLK32;
+#endif
+}
 static inline unsigned long long tick_to_time(unsigned long long tick)
 {
+	ulong gpt_clk = gpt_get_clk();
+
 	tick *= CONFIG_SYS_HZ;
-	do_div(tick, MXC_CLK32);
+	do_div(tick, gpt_clk);
 
 	return tick;
 }
 
 static inline unsigned long long us_to_tick(unsigned long long usec)
 {
-	usec = usec * MXC_CLK32 + 999999;
+	ulong gpt_clk = gpt_get_clk();
+
+	usec = usec * gpt_clk + 999999;
 	do_div(usec, 1000000);
 
 	return usec;
@@ -59,11 +97,29 @@ int timer_init(void)
 	for (i = 0; i < 100; i++)
 		__raw_writel(0, &cur_gpt->control);
 
-	__raw_writel(0, &cur_gpt->prescaler); /* 32Khz */
-
-	/* Freerun Mode, PERCLK1 input */
 	i = __raw_readl(&cur_gpt->control);
-	__raw_writel(i | GPTCR_CLKSOURCE_32 | GPTCR_TEN, &cur_gpt->control);
+	i &= ~GPTCR_CLKSOURCE_MASK;
+
+#ifdef CONFIG_MXC_GPT_HCLK
+	if (gpt_has_clk_source_osc()) {
+		i |= GPTCR_CLKSOURCE_OSC | GPTCR_TEN;
+
+		/* For DL/S, SX, they has 24M OSC Enable bit and need to set prescaler */
+		if (is_cpu_type(MXC_CPU_MX6DL) || is_cpu_type(MXC_CPU_MX6SOLO)
+			|| is_cpu_type(MXC_CPU_MX6SX)) {
+			i |= GPTCR_24MEN;
+
+			/* Produce 3Mhz clock */
+			__raw_writel((7 << GPTPR_PRESCALER24M_SHIFT), &cur_gpt->prescaler);
+		}
+	} else {
+		i |= GPTCR_CLKSOURCE_PRE | GPTCR_TEN;
+	}
+#else
+	__raw_writel(0, &cur_gpt->prescaler); /* 32Khz */
+	i |= GPTCR_CLKSOURCE_32 | GPTCR_TEN;
+#endif
+	__raw_writel(i, &cur_gpt->control);
 
 	gd->arch.tbl = __raw_readl(&cur_gpt->counter);
 	gd->arch.tbu = 0;
@@ -86,7 +142,7 @@ ulong get_timer_masked(void)
 {
 	/*
 	 * get_ticks() returns a long long (64 bit), it wraps in
-	 * 2^64 / MXC_CLK32 = 2^64 / 2^15 = 2^49 ~ 5 * 10^14 (s) ~
+	 * 2^64 / GPT_CLK = 2^64 / 2^15 = 2^49 ~ 5 * 10^14 (s) ~
 	 * 5 * 10^9 days... and get_ticks() * CONFIG_SYS_HZ wraps in
 	 * 5 * 10^6 days - long enough.
 	 */
@@ -117,5 +173,5 @@ void __udelay(unsigned long usec)
  */
 ulong get_tbclk(void)
 {
-	return MXC_CLK32;
+	return gpt_get_clk();
 }
diff --git a/arch/arm/include/asm/arch-imx/cpu.h b/arch/arm/include/asm/arch-imx/cpu.h
index a35940e..d275930 100644
--- a/arch/arm/include/asm/arch-imx/cpu.h
+++ b/arch/arm/include/asm/arch-imx/cpu.h
@@ -8,6 +8,7 @@
 #define MXC_CPU_MX53		0x53
 #define MXC_CPU_MX6SL		0x60
 #define MXC_CPU_MX6DL		0x61
-#define MXC_CPU_MX6SOLO		0x62
+#define MXC_CPU_MX6SX		0x62
 #define MXC_CPU_MX6Q		0x63
 #define MXC_CPU_MX6D		0x64
+#define MXC_CPU_MX6SOLO		0x66 /* dummy */
diff --git a/arch/arm/include/asm/arch-mx6/clock.h b/arch/arm/include/asm/arch-mx6/clock.h
index 1b4ded7..740d5c3 100644
--- a/arch/arm/include/asm/arch-mx6/clock.h
+++ b/arch/arm/include/asm/arch-mx6/clock.h
@@ -58,5 +58,19 @@ int enable_sata_clock(void);
 int enable_pcie_clock(void);
 int enable_i2c_clk(unsigned char enable, unsigned i2c_num);
 void enable_ipu_clock(void);
-int enable_fec_anatop_clock(enum enet_freq freq);
+#ifdef CONFIG_FEC_MXC
+int enable_fec_anatop_clock(int fec_id, enum enet_freq freq);
+#endif
+#ifdef CONFIG_SECURE_BOOT
+void hab_caam_clock_enable(void);
+void hab_caam_clock_disable(void);
+#endif
+#if (defined(CONFIG_MX6SX))
+void enable_qspi_clk(int qspi_num);
+void enable_enet_clock(void);
+void enable_lcdif_clock(uint32_t base_addr);
+void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq);
+void enable_lvds(uint32_t lcdif_base);
+void mxs_set_vadcclk(void);
+#endif
 #endif /* __ASM_ARCH_CLOCK_H */
diff --git a/arch/arm/include/asm/arch-mx6/crm_regs.h b/arch/arm/include/asm/arch-mx6/crm_regs.h
index 7202073..576c8fd 100644
--- a/arch/arm/include/asm/arch-mx6/crm_regs.h
+++ b/arch/arm/include/asm/arch-mx6/crm_regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2011-2014 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -64,8 +64,11 @@ struct mxc_ccm_reg {
 	u32 analog_usb1_pll_480_ctrl_set;
 	u32 analog_usb1_pll_480_ctrl_clr;
 	u32 analog_usb1_pll_480_ctrl_tog;
-	u32 analog_reserved0[4];
-	u32 analog_pll_528;			/* 0x4030 */
+	u32 analog_usb2_pll_480_ctrl;	/* 0x4020 */
+	u32 analog_usb2_pll_480_ctrl_set;
+	u32 analog_usb2_pll_480_ctrl_clr;
+	u32 analog_usb2_pll_480_ctrl_tog;
+	u32 analog_pll_528;			    /* 0x4030 */
 	u32 analog_pll_528_set;
 	u32 analog_pll_528_clr;
 	u32 analog_pll_528_tog;
@@ -89,8 +92,12 @@ struct mxc_ccm_reg {
 	u32 analog_pll_video_tog;
 	u32 analog_pll_video_num;		/* 0x40b0 */
 	u32 analog_reserved6[3];
-	u32 analog_pll_vedio_denon;		/* 0x40c0 */
-	u32 analog_reserved7[7];
+	u32 analog_pll_video_denon;		/* 0x40c0 */
+	u32 analog_reserved7[3];
+	u32 analog_pll_mlb;		        /* 0x40d0 */
+	u32 analog_pll_mlb_set;
+	u32 analog_pll_mlb_clr;
+	u32 analog_pll_mlb_tog;
 	u32 analog_pll_enet;			/* 0x40e0 */
 	u32 analog_pll_enet_set;
 	u32 analog_pll_enet_clr;
@@ -103,6 +110,93 @@ struct mxc_ccm_reg {
 	u32 analog_pfd_528_set;
 	u32 analog_pfd_528_clr;
 	u32 analog_pfd_528_tog;
+	u32 reg_1p1;		/* 0x4110 */
+	u32 reg_1p1_set;		/* 0x4114 */
+	u32 reg_1p1_clr;		/* 0x4118 */
+	u32 reg_1p1_tog;		/* 0x411c */
+	u32 reg_3p0;		/* 0x4120 */
+	u32 reg_3p0_set;		/* 0x4124 */
+	u32 reg_3p0_clr;		/* 0x4128 */
+	u32 reg_3p0_tog;		/* 0x412c */
+	u32 reg_2p5;		/* 0x4130 */
+	u32 reg_2p5_set;		/* 0x4134 */
+	u32 reg_2p5_clr;		/* 0x4138 */
+	u32 reg_2p5_tog;		/* 0x413c */
+	u32 reg_core;		/* 0x4140 */
+	u32 reg_core_set;		/* 0x4144 */
+	u32 reg_core_clr;		/* 0x4148 */
+	u32 reg_core_tog;		/* 0x414c */
+	u32 ana_misc0;		/* 0x4150 */
+	u32 ana_misc0_set;		/* 0x4154 */
+	u32 ana_misc0_clr;		/* 0x4158 */
+	u32 ana_misc0_tog;		/* 0x415c */
+	u32 ana_misc1;		/* 0x4160 */
+	u32 ana_misc1_set;		/* 0x4164 */
+	u32 ana_misc1_clr;		/* 0x4168 */
+	u32 ana_misc1_tog;		/* 0x416c */
+	u32 ana_misc2;		/* 0x4170 */
+	u32 ana_misc2_set;		/* 0x4174 */
+	u32 ana_misc2_clr;		/* 0x4178 */
+	u32 ana_misc2_tog;		/* 0x417c */
+	u32 tempsense0;		/* 0x4180 */
+	u32 tempsense0_set;		/* 0x4184 */
+	u32 tempsense0_clr;		/* 0x4188 */
+	u32 tempsense0_tog;		/* 0x418c */
+	u32 tempsense1;		/* 0x4190 */
+	u32 tempsense1_set;		/* 0x4194 */
+	u32 tempsense1_clr;		/* 0x4198 */
+	u32 tempsense1_tog;		/* 0x419c */
+	u32 usb1_vbus_detect;	/* 0x41a0 */
+	u32 usb1_vbus_detect_set;	/* 0x41a4 */
+	u32 usb1_vbus_detect_clr;	/* 0x41a8 */
+	u32 usb1_vbus_detect_tog;	/* 0x41ac */
+	u32 usb1_chrg_detect;	/* 0x41b0 */
+	u32 usb1_chrg_detect_set;	/* 0x41b4 */
+	u32 usb1_chrg_detect_clr;	/* 0x41b8 */
+	u32 usb1_chrg_detect_tog;	/* 0x41bc */
+	u32 usb1_vbus_det_stat;	/* 0x41c0 */
+	u32 usb1_vbus_det_stat_set;	/* 0x41c4 */
+	u32 usb1_vbus_det_stat_clr;	/* 0x41c8 */
+	u32 usb1_vbus_det_stat_tog;	/* 0x41cc */
+	u32 usb1_chrg_det_stat;	/* 0x41d0 */
+	u32 usb1_chrg_det_stat_set;	/* 0x41d4 */
+	u32 usb1_chrg_det_stat_clr;	/* 0x41d8 */
+	u32 usb1_chrg_det_stat_tog;	/* 0x41dc */
+	u32 usb1_loopback;		/* 0x41e0 */
+	u32 usb1_loopback_set;	/* 0x41e4 */
+	u32 usb1_loopback_clr;	/* 0x41e8 */
+	u32 usb1_loopback_tog;	/* 0x41ec */
+	u32 usb1_misc;		/* 0x41f0 */
+	u32 usb1_misc_set;		/* 0x41f4 */
+	u32 usb1_misc_clr;		/* 0x41f8 */
+	u32 usb1_misc_tog;		/* 0x41fc */
+	u32 usb2_vbus_detect;	/* 0x4200 */
+	u32 usb2_vbus_detect_set;	/* 0x4204 */
+	u32 usb2_vbus_detect_clr;	/* 0x4208 */
+	u32 usb2_vbus_detect_tog;	/* 0x420c */
+	u32 usb2_chrg_detect;	/* 0x4210 */
+	u32 usb2_chrg_detect_set;	/* 0x4214 */
+	u32 usb2_chrg_detect_clr;	/* 0x4218 */
+	u32 usb2_chrg_detect_tog;	/* 0x421c */
+	u32 usb2_vbus_det_stat;	/* 0x4220 */
+	u32 usb2_vbus_det_stat_set;	/* 0x4224 */
+	u32 usb2_vbus_det_stat_clr;	/* 0x4228 */
+	u32 usb2_vbus_det_stat_tog;	/* 0x422c */
+	u32 usb2_chrg_det_stat;	/* 0x4230 */
+	u32 usb2_chrg_det_stat_set;	/* 0x4234 */
+	u32 usb2_chrg_det_stat_clr;	/* 0x4238 */
+	u32 usb2_chrg_det_stat_tog;	/* 0x423c */
+	u32 usb2_loopback;		/* 0x4240 */
+	u32 usb2_loopback_set;	/* 0x4244 */
+	u32 usb2_loopback_clr;	/* 0x4248 */
+	u32 usb2_loopback_tog;	/* 0x424c */
+	u32 usb2_misc;		/* 0x4250 */
+	u32 usb2_misc_set;		/* 0x4254 */
+	u32 usb2_misc_clr;		/* 0x4258 */
+	u32 usb2_misc_tog;		/* 0x425c */
+	u32 digprog;		/* 0x4260 */
+	u32 reserved1[7];
+	u32 digprog_sololite;	/* 0x4280 */
 };
 #endif
 
@@ -113,7 +207,11 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCR_WB_COUNT_MASK			0x7
 #define MXC_CCM_CCR_WB_COUNT_OFFSET			(1 << 16)
 #define MXC_CCM_CCR_COSC_EN				(1 << 12)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCR_OSCNT_MASK				0x7F
+#else
 #define MXC_CCM_CCR_OSCNT_MASK				0xFF
+#endif
 #define MXC_CCM_CCR_OSCNT_OFFSET			0
 
 /* Define the bits in register CCDR */
@@ -146,8 +244,10 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CBCDR_PERIPH_CLK2_PODF_OFFSET		27
 #define MXC_CCM_CBCDR_PERIPH2_CLK2_SEL			(1 << 26)
 #define MXC_CCM_CBCDR_PERIPH_CLK_SEL			(1 << 25)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CBCDR_MMDC_CH0_PODF_MASK		(0x7 << 19)
 #define MXC_CCM_CBCDR_MMDC_CH0_PODF_OFFSET		19
+#endif
 #define MXC_CCM_CBCDR_AXI_PODF_MASK			(0x7 << 16)
 #define MXC_CCM_CBCDR_AXI_PODF_OFFSET			16
 #define MXC_CCM_CBCDR_AHB_PODF_MASK			(0x7 << 10)
@@ -162,6 +262,26 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CBCDR_PERIPH2_CLK2_PODF_OFFSET		0
 
 /* Define the bits in register CBCMR */
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CBCMR_GPU_CORE_PODF_MASK		(0x7 << 29)
+#define MXC_CCM_CBCMR_GPU_CORE_PODF_OFFSET		29
+#define MXC_CCM_CBCMR_GPU_AXI_PODF_MASK		(0x7 << 26)
+#define MXC_CCM_CBCMR_GPU_AXI_PODF_OFFSET		26
+#define MXC_CCM_CBCMR_LCDIF1_PODF_MASK		(0x7 << 23)
+#define MXC_CCM_CBCMR_LCDIF1_PODF_OFFSET		23
+#define MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_MASK		(0x3 << 21)
+#define MXC_CCM_CBCMR_PRE_PERIPH2_CLK_SEL_OFFSET	21
+#define MXC_CCM_CBCMR_PRE_PERIPH2_CLK2_SEL		(1 << 20)
+#define MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_MASK		(0x3 << 18)
+#define MXC_CCM_CBCMR_PRE_PERIPH_CLK_SEL_OFFSET		18
+#define MXC_CCM_CBCMR_PERIPH_CLK2_SEL_MASK		(0x3 << 12)
+#define MXC_CCM_CBCMR_PERIPH_CLK2_SEL_OFFSET		12
+#define MXC_CCM_CBCMR_PCIE_AXI_CLK_SEL			(1 << 10)
+#define MXC_CCM_CBCMR_GPU_AXI_CLK_SEL_MASK		(0x3 << 8)
+#define MXC_CCM_CBCMR_GPU_AXI_CLK_SEL_OFFSET	8
+#define MXC_CCM_CBCMR_GPU_CORE_CLK_SEL_MASK		(0x3 << 4)
+#define MXC_CCM_CBCMR_GPU_CORE_CLK_SEL_OFFSET		4
+#else
 #define MXC_CCM_CBCMR_GPU3D_SHADER_PODF_MASK		(0x7 << 29)
 #define MXC_CCM_CBCMR_GPU3D_SHADER_PODF_OFFSET		29
 #define MXC_CCM_CBCMR_GPU3D_CORE_PODF_MASK		(0x7 << 26)
@@ -187,16 +307,28 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CBCMR_GPU3D_CORE_CLK_SEL_OFFSET		4
 #define MXC_CCM_CBCMR_GPU3D_AXI_CLK_SEL			(1 << 1)
 #define MXC_CCM_CBCMR_GPU2D_AXI_CLK_SEL			(1 << 0)
+#endif
 
 /* Define the bits in register CSCMR1 */
 #define MXC_CCM_CSCMR1_ACLK_EMI_SLOW_MASK		(0x3 << 29)
 #define MXC_CCM_CSCMR1_ACLK_EMI_SLOW_OFFSET		29
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CSCMR1_QSPI1_PODF_MASK			(0x7 << 26)
+#define MXC_CCM_CSCMR1_QSPI1_PODF_OFFSET		26
+#else
 #define MXC_CCM_CSCMR1_ACLK_EMI_MASK			(0x3 << 27)
 #define MXC_CCM_CSCMR1_ACLK_EMI_OFFSET			27
+#endif
 #define MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_MASK		(0x7 << 23)
 #define MXC_CCM_CSCMR1_ACLK_EMI_SLOW_PODF_OFFSET	23
+/* ACLK_EMI_PODF is LCFIF2_PODF on MX6SX */
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CSCMR1_LCDIF2_PODF_MASK		(0x7 << 20)
+#define MXC_CCM_CSCMR1_LCDIF2_PODF_OFFSET		20
+#endif
 #define MXC_CCM_CSCMR1_ACLK_EMI_PODF_MASK		(0x7 << 20)
 #define MXC_CCM_CSCMR1_ACLK_EMI_PODF_OFFSET		20
+
 #define MXC_CCM_CSCMR1_USDHC4_CLK_SEL			(1 << 19)
 #define MXC_CCM_CSCMR1_USDHC3_CLK_SEL			(1 << 18)
 #define MXC_CCM_CSCMR1_USDHC2_CLK_SEL			(1 << 17)
@@ -207,19 +339,40 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CSCMR1_SSI2_CLK_SEL_OFFSET		12
 #define MXC_CCM_CSCMR1_SSI1_CLK_SEL_MASK		(0x3 << 10)
 #define MXC_CCM_CSCMR1_SSI1_CLK_SEL_OFFSET		10
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CSCMR1_QSPI1_CLK_SEL_MASK		(0x7 << 7)
+#define MXC_CCM_CSCMR1_QSPI1_CLK_SEL_OFFSET		7
+#endif
+#if (defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX))
+#define MXC_CCM_CSCMR1_PER_CLK_SEL_MASK			(1 << 6)
+#define MXC_CCM_CSCMR1_PER_CLK_SEL_OFFSET		6
+#endif
 #define MXC_CCM_CSCMR1_PERCLK_PODF_MASK			0x3F
 
 /* Define the bits in register CSCMR2 */
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CSCMR2_VID_CLK_SEL_MASK			(0x7 << 21)
+#define MXC_CCM_CSCMR2_VID_CLK_SEL_OFFSET		21
+#endif
 #define MXC_CCM_CSCMR2_ESAI_PRE_SEL_MASK		(0x3 << 19)
 #define MXC_CCM_CSCMR2_ESAI_PRE_SEL_OFFSET		19
 #define MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV			(1 << 11)
 #define MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV			(1 << 10)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_MASK			(0x3 << 8)
+#define MXC_CCM_CSCMR2_CAN_CLK_SEL_OFFSET		8
+#define MXC_CCM_CSCMR2_CAN_CLK_PODF_MASK		(0x3F << 2)
+#define MXC_CCM_CSCMR2_CAN_CLK_PODF_OFFSET		2
+#else
 #define MXC_CCM_CSCMR2_CAN_CLK_SEL_MASK			(0x3F << 2)
 #define MXC_CCM_CSCMR2_CAN_CLK_SEL_OFFSET		2
+#endif
 
 /* Define the bits in register CSCDR1 */
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CSCDR1_VPU_AXI_PODF_MASK		(0x7 << 25)
 #define MXC_CCM_CSCDR1_VPU_AXI_PODF_OFFSET		25
+#endif
 #define MXC_CCM_CSCDR1_USDHC4_PODF_MASK			(0x7 << 22)
 #define MXC_CCM_CSCDR1_USDHC4_PODF_OFFSET		22
 #define MXC_CCM_CSCDR1_USDHC3_PODF_MASK			(0x7 << 19)
@@ -228,21 +381,28 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CSCDR1_USDHC2_PODF_OFFSET		16
 #define MXC_CCM_CSCDR1_USDHC1_PODF_MASK			(0x7 << 11)
 #define MXC_CCM_CSCDR1_USDHC1_PODF_OFFSET		11
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_OFFSET		8
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PRED_MASK		(0x7 << 8)
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_OFFSET		6
 #define MXC_CCM_CSCDR1_USBOH3_CLK_PODF_MASK		(0x3 << 6)
+#endif
 #ifdef CONFIG_MX6SL
 #define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK		0x1F
 #define MXC_CCM_CSCDR1_UART_CLK_SEL			(1 << 6)
 #else
 #define MXC_CCM_CSCDR1_UART_CLK_PODF_MASK		0x3F
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CSCDR1_UART_CLK_SEL			(1 << 6)
+#endif
 #endif
 #define MXC_CCM_CSCDR1_UART_CLK_PODF_OFFSET		0
 
 /* Define the bits in register CS1CDR */
 #define MXC_CCM_CS1CDR_ESAI_CLK_PODF_MASK		(0x3F << 25)
 #define MXC_CCM_CS1CDR_ESAI_CLK_PODF_OFFSET		25
+#define MXC_CCM_CS1CDR_SSI3_CLK_PRED_MASK		(0x7 << 22)
+#define MXC_CCM_CS1CDR_SSI3_CLK_PRED_OFFSET		22
 #define MXC_CCM_CS1CDR_SSI3_CLK_PODF_MASK		(0x3F << 16)
 #define MXC_CCM_CS1CDR_SSI3_CLK_PODF_OFFSET		16
 #define MXC_CCM_CS1CDR_ESAI_CLK_PRED_MASK		(0x3 << 9)
@@ -253,6 +413,17 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CS1CDR_SSI1_CLK_PODF_OFFSET		0
 
 /* Define the bits in register CS2CDR */
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PODF_MASK             (0x3F << 21)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PODF_OFFSET           21
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PODF(v)                       (((v) & 0x3f) << 21)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PRED_MASK             (0x7 << 18)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PRED_OFFSET           18
+#define MXC_CCM_CS2CDR_QSPI2_CLK_PRED(v)                       (((v) & 0x7) << 18)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_SEL_MASK              (0x7 << 15)
+#define MXC_CCM_CS2CDR_QSPI2_CLK_SEL_OFFSET            15
+#define MXC_CCM_CS2CDR_QSPI2_CLK_SEL(v)                        (((v) & 0x7) << 15)
+#else
 #define MXC_CCM_CS2CDR_ENFC_CLK_PODF_MASK		(0x3F << 21)
 #define MXC_CCM_CS2CDR_ENFC_CLK_PODF_OFFSET		21
 #define MXC_CCM_CS2CDR_ENFC_CLK_PODF(v)			(((v) & 0x3f) << 21)
@@ -262,6 +433,7 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK		(0x3 << 16)
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL_OFFSET		16
 #define MXC_CCM_CS2CDR_ENFC_CLK_SEL(v)			(((v) & 0x3) << 16)
+#endif
 #define MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK		(0x7 << 12)
 #define MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET		12
 #define MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK		(0x7 << 9)
@@ -272,13 +444,15 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CS2CDR_SSI2_CLK_PODF_OFFSET		0
 
 /* Define the bits in register CDCDR */
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CDCDR_HSI_TX_PODF_MASK			(0x7 << 29)
 #define MXC_CCM_CDCDR_HSI_TX_PODF_OFFSET		29
 #define MXC_CCM_CDCDR_HSI_TX_CLK_SEL			(1 << 28)
+#endif
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_MASK		(0x7 << 25)
 #define MXC_CCM_CDCDR_SPDIF0_CLK_PRED_OFFSET		25
-#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK		(0x7 << 19)
-#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET		19
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_MASK		(0x7 << 22)
+#define MXC_CCM_CDCDR_SPDIF0_CLK_PODF_OFFSET		22
 #define MXC_CCM_CDCDR_SPDIF0_CLK_SEL_MASK		(0x3 << 20)
 #define MXC_CCM_CDCDR_SPDIF0_CLK_SEL_OFFSET		20
 #define MXC_CCM_CDCDR_SPDIF1_CLK_PRED_MASK		(0x7 << 12)
@@ -289,6 +463,20 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CDCDR_SPDIF1_CLK_SEL_OFFSET		7
 
 /* Define the bits in register CHSCCDR */
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CHSCCDR_ENET_PRE_CLK_SEL_MASK		(0x7 << 15)
+#define MXC_CCM_CHSCCDR_ENET_PRE_CLK_SEL_OFFSET		15
+#define MXC_CCM_CHSCCDR_ENET_PODF_MASK			(0x7 << 12)
+#define MXC_CCM_CHSCCDR_ENET_PODF_OFFSET		12
+#define MXC_CCM_CHSCCDR_ENET_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CHSCCDR_ENET_CLK_SEL_OFFSET		9
+#define MXC_CCM_CHSCCDR_M4_PRE_CLK_SEL_MASK		(0x7 << 6)
+#define MXC_CCM_CHSCCDR_M4_PRE_CLK_SEL_OFFSET		6
+#define MXC_CCM_CHSCCDR_M4_PODF_MASK			(0x7 << 3)
+#define MXC_CCM_CHSCCDR_M4_PODF_OFFSET			3
+#define MXC_CCM_CHSCCDR_M4_CLK_SEL_MASK			(0x7)
+#define MXC_CCM_CHSCCDR_M4_CLK_SEL_OFFSET		0
+#else
 #define MXC_CCM_CHSCCDR_IPU1_DI1_PRE_CLK_SEL_MASK	(0x7 << 15)
 #define MXC_CCM_CHSCCDR_IPU1_DI1_PRE_CLK_SEL_OFFSET	15
 #define MXC_CCM_CHSCCDR_IPU1_DI1_PODF_MASK		(0x7 << 12)
@@ -301,6 +489,7 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CHSCCDR_IPU1_DI0_PODF_OFFSET		3
 #define MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_MASK		(0x7)
 #define MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET		0
+#endif
 
 #define CHSCCDR_CLK_SEL_LDB_DI0				3
 #define CHSCCDR_PODF_DIVIDE_BY_3			2
@@ -308,13 +497,31 @@ struct mxc_ccm_reg {
 
 /* Define the bits in register CSCDR2 */
 #define MXC_CCM_CSCDR2_ECSPI_CLK_PODF_MASK		(0x3F << 19)
-#define MXC_CCM_CSCDR2_ECSPI_CLK_PODF_OFFSET		19
+#define MXC_CCM_CSCDR2_ECSPI_CLK_PODF_OFFSET	19
+
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_MASK		(0x7 << 15)
+#define MXC_CCM_CSCDR2_LCDIF1_PRED_SEL_OFFSET	15
+#define MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_MASK		(0x7 << 12)
+#define MXC_CCM_CSCDR2_LCDIF1_PRE_DIV_OFFSET	12
+#define MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_MASK		(0x7 << 9)
+#define MXC_CCM_CSCDR2_LCDIF1_CLK_SEL_OFFSET	9
+#define MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_MASK		(0x7 << 6)
+#define MXC_CCM_CSCDR2_LCDIF2_PRED_SEL_OFFSET	6
+#define MXC_CCM_CSCDR2_LCDIF2_PRE_DIV_MASK		(0x7 << 3)
+#define MXC_CCM_CSCDR2_LCDIF2_PRE_DIV_OFFSET	3
+#define MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_MASK		(0x7 << 0)
+#define MXC_CCM_CSCDR2_LCDIF2_CLK_SEL_OFFSET	0
+#endif
+
+/* All IPU2_DI1 are LCDIF1 on MX6SX */
 #define MXC_CCM_CHSCCDR_IPU2_DI1_PRE_CLK_SEL_MASK	(0x7 << 15)
 #define MXC_CCM_CHSCCDR_IPU2_DI1_PRE_CLK_SEL_OFFSET	15
 #define MXC_CCM_CHSCCDR_IPU2_DI1_PODF_MASK		(0x7 << 12)
 #define MXC_CCM_CHSCCDR_IPU2_DI1_PODF_OFFSET		12
 #define MXC_CCM_CHSCCDR_IPU2_DI1_CLK_SEL_MASK		(0x7 << 9)
 #define MXC_CCM_CHSCCDR_IPU2_DI1_CLK_SEL_OFFSET		9
+/* All IPU2_DI0 are LCDIF2 on MX6SX */
 #define MXC_CCM_CHSCCDR_IPU2_DI0_PRE_CLK_SEL_MASK	(0x7 << 6)
 #define MXC_CCM_CHSCCDR_IPU2_DI0_PRE_CLK_SEL_OFFSET	6
 #define MXC_CCM_CHSCCDR_IPU2_DI0_PODF_MASK		(0x7 << 3)
@@ -335,7 +542,9 @@ struct mxc_ccm_reg {
 /* Define the bits in register CDHIPR */
 #define MXC_CCM_CDHIPR_ARM_PODF_BUSY			(1 << 16)
 #define MXC_CCM_CDHIPR_PERIPH_CLK_SEL_BUSY		(1 << 5)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CDHIPR_MMDC_CH0_PODF_BUSY		(1 << 4)
+#endif
 #define MXC_CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY		(1 << 3)
 #define MXC_CCM_CDHIPR_MMDC_CH1_PODF_BUSY		(1 << 2)
 #define MXC_CCM_CDHIPR_AHB_PODF_BUSY			(1 << 1)
@@ -344,14 +553,18 @@ struct mxc_ccm_reg {
 /* Define the bits in register CLPCR */
 #define MXC_CCM_CLPCR_MASK_L2CC_IDLE			(1 << 27)
 #define MXC_CCM_CLPCR_MASK_SCU_IDLE			(1 << 26)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CLPCR_MASK_CORE3_WFI			(1 << 25)
 #define MXC_CCM_CLPCR_MASK_CORE2_WFI			(1 << 24)
 #define MXC_CCM_CLPCR_MASK_CORE1_WFI			(1 << 23)
+#endif
 #define MXC_CCM_CLPCR_MASK_CORE0_WFI			(1 << 22)
 #define MXC_CCM_CLPCR_BYP_MMDC_CH1_LPM_HS		(1 << 21)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CLPCR_BYP_MMDC_CH0_LPM_HS		(1 << 19)
 #define MXC_CCM_CLPCR_WB_CORE_AT_LPM			(1 << 17)
-#define MXC_CCM_CLPCR_WB_PER_AT_LPM			(1 << 17)
+#endif
+#define MXC_CCM_CLPCR_WB_PER_AT_LPM			(1 << 16)
 #define MXC_CCM_CLPCR_COSC_PWRDOWN			(1 << 11)
 #define MXC_CCM_CLPCR_STBY_COUNT_MASK			(0x3 << 9)
 #define MXC_CCM_CLPCR_STBY_COUNT_OFFSET			9
@@ -359,15 +572,19 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CLPCR_DIS_REF_OSC			(1 << 7)
 #define MXC_CCM_CLPCR_SBYOS				(1 << 6)
 #define MXC_CCM_CLPCR_ARM_CLK_DIS_ON_LPM		(1 << 5)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CLPCR_LPSR_CLK_SEL_MASK			(0x3 << 3)
 #define MXC_CCM_CLPCR_LPSR_CLK_SEL_OFFSET		3
 #define MXC_CCM_CLPCR_BYPASS_PMIC_VFUNC_READY		(1 << 2)
+#endif
 #define MXC_CCM_CLPCR_LPM_MASK				0x3
 #define MXC_CCM_CLPCR_LPM_OFFSET			0
 
 /* Define the bits in register CISR */
 #define MXC_CCM_CISR_ARM_PODF_LOADED			(1 << 26)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CISR_MMDC_CH0_PODF_LOADED		(1 << 23)
+#endif
 #define MXC_CCM_CISR_PERIPH_CLK_SEL_LOADED		(1 << 22)
 #define MXC_CCM_CISR_MMDC_CH1_PODF_LOADED		(1 << 21)
 #define MXC_CCM_CISR_AHB_PODF_LOADED			(1 << 20)
@@ -378,11 +595,13 @@ struct mxc_ccm_reg {
 
 /* Define the bits in register CIMR */
 #define MXC_CCM_CIMR_MASK_ARM_PODF_LOADED		(1 << 26)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CIMR_MASK_MMDC_CH0_PODF_LOADED		(1 << 23)
+#endif
 #define MXC_CCM_CIMR_MASK_PERIPH_CLK_SEL_LOADED		(1 << 22)
 #define MXC_CCM_CIMR_MASK_MMDC_CH1_PODF_LOADED		(1 << 21)
 #define MXC_CCM_CIMR_MASK_AHB_PODF_LOADED		(1 << 20)
-#define MXC_CCM_CIMR_MASK_PERIPH2_CLK_SEL_LOADED	(1 << 22)
+#define MXC_CCM_CIMR_MASK_PERIPH2_CLK_SEL_LOADED	(1 << 19)
 #define MXC_CCM_CIMR_MASK_AXI_PODF_LOADED		(1 << 17)
 #define MXC_CCM_CIMR_MASK_COSC_READY			(1 << 6)
 #define MXC_CCM_CIMR_MASK_LRF_PLL			1
@@ -393,6 +612,7 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCOSR_CKO2_DIV_OFFSET			21
 #define MXC_CCM_CCOSR_CKO2_SEL_OFFSET			16
 #define MXC_CCM_CCOSR_CKO2_SEL_MASK			(0x1F << 16)
+#define MXC_CCM_CCOSR_CLK_OUT_SEL			(0x1 << 8)
 #define MXC_CCM_CCOSR_CKOL_EN				(0x1 << 7)
 #define MXC_CCM_CCOSR_CKOL_DIV_MASK			(0x7 << 4)
 #define MXC_CCM_CCOSR_CKOL_DIV_OFFSET			4
@@ -400,6 +620,7 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCOSR_CKOL_SEL_OFFSET			0
 
 /* Define the bits in registers CGPR */
+#define MXC_CCM_CGPR_FAST_PLL_EN			(1 << 16)
 #define MXC_CCM_CGPR_EFUSE_PROG_SUPPLY_GATE		(1 << 4)
 #define MXC_CCM_CGPR_MMDC_EXT_CLK_DIS			(1 << 2)
 #define MXC_CCM_CGPR_PMIC_DELAY_SCALER			1
@@ -435,8 +656,13 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR0_DCIC1_MASK			(3 << MXC_CCM_CCGR0_DCIC1_OFFSET)
 #define MXC_CCM_CCGR0_DCIC2_OFFSET			26
 #define MXC_CCM_CCGR0_DCIC2_MASK			(3 << MXC_CCM_CCGR0_DCIC2_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR0_AIPS_TZ3_OFFSET			30
+#define MXC_CCM_CCGR0_AIPS_TZ3_MASK			(3 << MXC_CCM_CCGR0_AIPS_TZ3_OFFSET)
+#else
 #define MXC_CCM_CCGR0_DTCP_OFFSET			28
 #define MXC_CCM_CCGR0_DTCP_MASK				(3 << MXC_CCM_CCGR0_DTCP_OFFSET)
+#endif
 
 #define MXC_CCM_CCGR1_ECSPI1S_OFFSET			0
 #define MXC_CCM_CCGR1_ECSPI1S_MASK			(3 << MXC_CCM_CCGR1_ECSPI1S_OFFSET)
@@ -448,27 +674,48 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR1_ECSPI4S_MASK			(3 << MXC_CCM_CCGR1_ECSPI4S_OFFSET)
 #define MXC_CCM_CCGR1_ECSPI5S_OFFSET			8
 #define MXC_CCM_CCGR1_ECSPI5S_MASK			(3 << MXC_CCM_CCGR1_ECSPI5S_OFFSET)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR1_ENET_CLK_ENABLE_OFFSET		10
 #define MXC_CCM_CCGR1_ENET_CLK_ENABLE_MASK		(3 << MXC_CCM_CCGR1_ENET_CLK_ENABLE_OFFSET)
+#endif
 #define MXC_CCM_CCGR1_EPIT1S_OFFSET			12
 #define MXC_CCM_CCGR1_EPIT1S_MASK			(3 << MXC_CCM_CCGR1_EPIT1S_OFFSET)
 #define MXC_CCM_CCGR1_EPIT2S_OFFSET			14
 #define MXC_CCM_CCGR1_EPIT2S_MASK			(3 << MXC_CCM_CCGR1_EPIT2S_OFFSET)
 #define MXC_CCM_CCGR1_ESAIS_OFFSET			16
 #define MXC_CCM_CCGR1_ESAIS_MASK			(3 << MXC_CCM_CCGR1_ESAIS_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR1_WAKEUP_OFFSET			18
+#define MXC_CCM_CCGR1_WAKEUP_MASK			(3 << MXC_CCM_CCGR1_WAKEUP_OFFSET)
+#endif
 #define MXC_CCM_CCGR1_GPT_BUS_OFFSET			20
 #define MXC_CCM_CCGR1_GPT_BUS_MASK			(3 << MXC_CCM_CCGR1_GPT_BUS_OFFSET)
 #define MXC_CCM_CCGR1_GPT_SERIAL_OFFSET			22
 #define MXC_CCM_CCGR1_GPT_SERIAL_MASK			(3 << MXC_CCM_CCGR1_GPT_SERIAL_OFFSET)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR1_GPU2D_OFFSET			24
 #define MXC_CCM_CCGR1_GPU2D_MASK			(3 << MXC_CCM_CCGR1_GPU2D_OFFSET)
+#endif
 #define MXC_CCM_CCGR1_GPU3D_OFFSET			26
 #define MXC_CCM_CCGR1_GPU3D_MASK			(3 << MXC_CCM_CCGR1_GPU3D_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR1_OCRAM_S_OFFSET			28
+#define MXC_CCM_CCGR1_OCRAM_S_MASK			(3 << MXC_CCM_CCGR1_OCRAM_S_OFFSET)
+#define MXC_CCM_CCGR1_CANFD_OFFSET			30
+#define MXC_CCM_CCGR1_CANFD_MASK			(3 << MXC_CCM_CCGR1_CANFD_OFFSET)
+#endif
 
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET		0
 #define MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_IAHBCLK_OFFSET)
+#else
+#define MXC_CCM_CCGR2_CSI_OFFSET			2
+#define MXC_CCM_CCGR2_CSI_MASK				(3 << MXC_CCM_CCGR2_CSI_OFFSET)
+#endif
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET		4
 #define MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_MASK		(3 << MXC_CCM_CCGR2_HDMI_TX_ISFRCLK_OFFSET)
+#endif
 #define MXC_CCM_CCGR2_I2C1_SERIAL_OFFSET		6
 #define MXC_CCM_CCGR2_I2C1_SERIAL_MASK			(3 << MXC_CCM_CCGR2_I2C1_SERIAL_OFFSET)
 #define MXC_CCM_CCGR2_I2C2_SERIAL_OFFSET		8
@@ -487,11 +734,30 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR2_IPMUX3_MASK			(3 << MXC_CCM_CCGR2_IPMUX3_OFFSET)
 #define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_OFFSET	22
 #define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_MASK	(3 << MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC1_IPGS_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR2_LCD_OFFSET			28
+#define MXC_CCM_CCGR2_LCD_MASK				(3 << MXC_CCM_CCGR2_LCD_OFFSET)
+#define MXC_CCM_CCGR2_PXP_OFFSET			30
+#define MXC_CCM_CCGR2_PXP_MASK				(3 << MXC_CCM_CCGR2_PXP_OFFSET)
+#else
 #define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC2_IPG_OFFSET	24
 #define MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC2_IPG_MASK	(3 << MXC_CCM_CCGR2_IPSYNC_IP2APB_TZASC2_IPG_OFFSET)
 #define MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_OFFSET	26
 #define MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_MASK	(3 << MXC_CCM_CCGR2_IPSYNC_VDOA_IPG_MASTER_CLK_OFFSET)
+#endif
 
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR3_M4_OFFSET					2
+#define MXC_CCM_CCGR3_M4_MASK					(3<<MXC_CCM_CCGR3_M4_OFFSET)
+#define MXC_CCM_CCGR3_ENET_OFFSET				4
+#define MXC_CCM_CCGR3_ENET_MASK					(3<<MXC_CCM_CCGR3_ENET_OFFSET)
+#define MXC_CCM_CCGR3_DISP_AXI_OFFSET			6
+#define MXC_CCM_CCGR3_DISP_AXI_MASK				(3 << MXC_CCM_CCGR3_DISP_AXI_OFFSET)
+#define MXC_CCM_CCGR3_LCDIF2_PIX_OFFSET				8
+#define MXC_CCM_CCGR3_LCDIF2_PIX_MASK				(3 << MXC_CCM_CCGR3_LCDIF2_PIX_OFFSET)
+#define MXC_CCM_CCGR3_LCDIF1_PIX_OFFSET				10
+#define MXC_CCM_CCGR3_LCDIF1_PIX_MASK				(3 << MXC_CCM_CCGR3_LCDIF1_PIX_OFFSET)
+#else
 #define MXC_CCM_CCGR3_IPU1_IPU_OFFSET				0
 #define MXC_CCM_CCGR3_IPU1_IPU_MASK				(3 << MXC_CCM_CCGR3_IPU1_IPU_OFFSET)
 #define MXC_CCM_CCGR3_IPU1_IPU_DI0_OFFSET			2
@@ -504,31 +770,46 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR3_IPU2_IPU_DI0_MASK				(3 << MXC_CCM_CCGR3_IPU2_IPU_DI0_OFFSET)
 #define MXC_CCM_CCGR3_IPU2_IPU_DI1_OFFSET			10
 #define MXC_CCM_CCGR3_IPU2_IPU_DI1_MASK				(3 << MXC_CCM_CCGR3_IPU2_IPU_DI1_OFFSET)
+#endif
 #define MXC_CCM_CCGR3_LDB_DI0_OFFSET				12
 #define MXC_CCM_CCGR3_LDB_DI0_MASK				(3 << MXC_CCM_CCGR3_LDB_DI0_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR3_QSPI1_OFFSET				14
+#define MXC_CCM_CCGR3_QSPI1_MASK				(3 << MXC_CCM_CCGR3_QSPI1_OFFSET)
+#else
 #define MXC_CCM_CCGR3_LDB_DI1_OFFSET				14
 #define MXC_CCM_CCGR3_LDB_DI1_MASK				(3 << MXC_CCM_CCGR3_LDB_DI1_OFFSET)
 #define MXC_CCM_CCGR3_MIPI_CORE_CFG_OFFSET			16
 #define MXC_CCM_CCGR3_MIPI_CORE_CFG_MASK			(3 << MXC_CCM_CCGR3_MIPI_CORE_CFG_OFFSET)
+#endif
 #define MXC_CCM_CCGR3_MLB_OFFSET				18
 #define MXC_CCM_CCGR3_MLB_MASK					(3 << MXC_CCM_CCGR3_MLB_OFFSET)
 #define MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P0_OFFSET	20
 #define MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P0_MASK		(3 << MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P0_OFFSET)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P1_OFFSET	22
 #define MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P1_MASK		(3 << MXC_CCM_CCGR3_MMDC_CORE_ACLK_FAST_CORE_P1_OFFSET)
+#endif
 #define MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P0_OFFSET		24
 #define MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P0_MASK			(3 << MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P0_OFFSET)
 #define MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P1_OFFSET		26
 #define MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P1_MASK			(3 << MXC_CCM_CCGR3_MMDC_CORE_IPG_CLK_P1_OFFSET)
 #define MXC_CCM_CCGR3_OCRAM_OFFSET				28
 #define MXC_CCM_CCGR3_OCRAM_MASK				(3 << MXC_CCM_CCGR3_OCRAM_OFFSET)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET			30
 #define MXC_CCM_CCGR3_OPENVGAXICLK_MASK				(3 << MXC_CCM_CCGR3_OPENVGAXICLK_OFFSET)
+#endif
 
 #define MXC_CCM_CCGR4_PCIE_OFFSET				0
 #define MXC_CCM_CCGR4_PCIE_MASK					(3 << MXC_CCM_CCGR4_PCIE_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR4_QSPI2_ENFC_OFFSET				10
+#define MXC_CCM_CCGR4_QSPI2_ENFC_MASK				(3 << MXC_CCM_CCGR4_QSPI2_ENFC_OFFSET)
+#else
 #define MXC_CCM_CCGR4_PL301_MX6QFAST1_S133_OFFSET		8
 #define MXC_CCM_CCGR4_PL301_MX6QFAST1_S133_MASK			(3 << MXC_CCM_CCGR4_PL301_MX6QFAST1_S133_OFFSET)
+#endif
 #define MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_OFFSET			12
 #define MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK			(3 << MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_OFFSET)
 #define MXC_CCM_CCGR4_PL301_MX6QPER2_MAINCLK_ENABLE_OFFSET	14
@@ -552,8 +833,10 @@ struct mxc_ccm_reg {
 
 #define MXC_CCM_CCGR5_ROM_OFFSET			0
 #define MXC_CCM_CCGR5_ROM_MASK				(3 << MXC_CCM_CCGR5_ROM_OFFSET)
+#ifndef CONFIG_MX6SX
 #define MXC_CCM_CCGR5_SATA_OFFSET			4
 #define MXC_CCM_CCGR5_SATA_MASK				(3 << MXC_CCM_CCGR5_SATA_OFFSET)
+#endif
 #define MXC_CCM_CCGR5_SDMA_OFFSET			6
 #define MXC_CCM_CCGR5_SDMA_MASK				(3 << MXC_CCM_CCGR5_SDMA_OFFSET)
 #define MXC_CCM_CCGR5_SPBA_OFFSET			12
@@ -570,6 +853,12 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR5_UART_MASK				(3 << MXC_CCM_CCGR5_UART_OFFSET)
 #define MXC_CCM_CCGR5_UART_SERIAL_OFFSET		26
 #define MXC_CCM_CCGR5_UART_SERIAL_MASK			(3 << MXC_CCM_CCGR5_UART_SERIAL_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR5_SAI1_OFFSET			20
+#define MXC_CCM_CCGR5_SAI1_MASK				(3<<MXC_CCM_CCGR5_SAI1_OFFSET)
+#define MXC_CCM_CCGR5_SAI2_OFFSET			30
+#define MXC_CCM_CCGR5_SAI2_MASK				(3<<MXC_CCM_CCGR5_SAI2_OFFSET)
+#endif
 
 #define MXC_CCM_CCGR6_USBOH3_OFFSET		0
 #define MXC_CCM_CCGR6_USBOH3_MASK		(3 << MXC_CCM_CCGR6_USBOH3_OFFSET)
@@ -583,8 +872,25 @@ struct mxc_ccm_reg {
 #define MXC_CCM_CCGR6_USDHC4_MASK		(3 << MXC_CCM_CCGR6_USDHC4_OFFSET)
 #define MXC_CCM_CCGR6_EMI_SLOW_OFFSET		10
 #define MXC_CCM_CCGR6_EMI_SLOW_MASK		(3 << MXC_CCM_CCGR6_EMI_SLOW_OFFSET)
+#ifdef CONFIG_MX6SX
+#define MXC_CCM_CCGR6_PWM8_OFFSET		16
+#define MXC_CCM_CCGR6_PWM8_MASK			(3 << MXC_CCM_CCGR6_PWM8_OFFSET)
+#define MXC_CCM_CCGR6_VADC_OFFSET		20
+#define MXC_CCM_CCGR6_VADC_MASK			(3 << MXC_CCM_CCGR6_VADC_OFFSET)
+#define MXC_CCM_CCGR6_GIS_OFFSET		22
+#define MXC_CCM_CCGR6_GIS_MASK			(3 << MXC_CCM_CCGR6_GIS_OFFSET)
+#define MXC_CCM_CCGR6_I2C4_OFFSET		24
+#define MXC_CCM_CCGR6_I2C4_MASK			(3 << MXC_CCM_CCGR6_I2C4_OFFSET)
+#define MXC_CCM_CCGR6_PWM5_OFFSET		26
+#define MXC_CCM_CCGR6_PWM5_MASK			(3 << MXC_CCM_CCGR6_PWM5_OFFSET)
+#define MXC_CCM_CCGR6_PWM6_OFFSET		28
+#define MXC_CCM_CCGR6_PWM6_MASK			(3 << MXC_CCM_CCGR6_PWM6_OFFSET)
+#define MXC_CCM_CCGR6_PWM7_OFFSET		30
+#define MXC_CCM_CCGR6_PWM7_MASK			(3 << MXC_CCM_CCGR6_PWM7_OFFSET)
+#else
 #define MXC_CCM_CCGR6_VDOAXICLK_OFFSET		12
 #define MXC_CCM_CCGR6_VDOAXICLK_MASK		(3 << MXC_CCM_CCGR6_VDOAXICLK_OFFSET)
+#endif
 
 #define BM_ANADIG_PLL_SYS_LOCK 0x80000000
 #define BP_ANADIG_PLL_SYS_RSVD0      20
@@ -615,6 +921,11 @@ struct mxc_ccm_reg {
 #define BF_ANADIG_PLL_SYS_DIV_SELECT(v)  \
 	(((v) << 0) & BM_ANADIG_PLL_SYS_DIV_SELECT)
 
+#define HW_ANADIG_USB1_PLL_480_CTRL (0x00000010)
+#define HW_ANADIG_USB1_PLL_480_CTRL_SET (0x00000014)
+#define HW_ANADIG_USB1_PLL_480_CTRL_CLR (0x00000018)
+#define HW_ANADIG_USB1_PLL_480_CTRL_TOG (0x0000001c)
+
 #define BM_ANADIG_USB1_PLL_480_CTRL_LOCK 0x80000000
 #define BP_ANADIG_USB1_PLL_480_CTRL_RSVD1      17
 #define BM_ANADIG_USB1_PLL_480_CTRL_RSVD1 0x7FFE0000
@@ -824,6 +1135,8 @@ struct mxc_ccm_reg {
 #define BV_ANADIG_PLL_ENET_BYPASS_CLK_SRC__ANACLK_1 0x1
 #define BV_ANADIG_PLL_ENET_BYPASS_CLK_SRC__ANACLK_2 0x2
 #define BV_ANADIG_PLL_ENET_BYPASS_CLK_SRC__XOR      0x3
+#define BM_ANADIG_PLL_ENET_REF_25M_ENABLE 0x00200000
+#define BM_ANADIG_PLL_ENET2_ENABLE 0x00100000
 #define BM_ANADIG_PLL_ENET_ENABLE 0x00002000
 #define BM_ANADIG_PLL_ENET_POWERDOWN 0x00001000
 #define BM_ANADIG_PLL_ENET_HOLD_RING_OFF 0x00000800
@@ -840,6 +1153,11 @@ struct mxc_ccm_reg {
 #define BF_ANADIG_PLL_ENET_DIV_SELECT(v)  \
 	(((v) << 0) & BM_ANADIG_PLL_ENET_DIV_SELECT)
 
+#define BM_ANADIG_PLL_ENET2_DIV_SELECT 0x0000000C
+#define BF_ANADIG_PLL_ENET2_DIV_SELECT(v)  \
+	(((v) << 2) & BM_ANADIG_PLL_ENET2_DIV_SELECT)
+
+
 #define BM_ANADIG_PFD_480_PFD3_CLKGATE 0x80000000
 #define BM_ANADIG_PFD_480_PFD3_STABLE 0x40000000
 #define BP_ANADIG_PFD_480_PFD3_FRAC      24
@@ -890,4 +1208,545 @@ struct mxc_ccm_reg {
 #define BF_ANADIG_PFD_528_PFD0_FRAC(v)  \
 	(((v) << 0) & BM_ANADIG_PFD_528_PFD0_FRAC)
 
+#define HW_ANADIG_REG_1P1	(0x00000110)
+#define HW_ANADIG_REG_1P1_SET	(0x00000114)
+#define HW_ANADIG_REG_1P1_CLR	(0x00000118)
+#define HW_ANADIG_REG_1P1_TOG	(0x0000011c)
+
+#define BP_ANADIG_REG_1P1_RSVD2      18
+#define BM_ANADIG_REG_1P1_RSVD2 0xFFFC0000
+#define BF_ANADIG_REG_1P1_RSVD2(v) \
+	(((v) << 18) & BM_ANADIG_REG_1P1_RSVD2)
+#define BM_ANADIG_REG_1P1_OK_VDD1P1 0x00020000
+#define BM_ANADIG_REG_1P1_BO_VDD1P1 0x00010000
+#define BP_ANADIG_REG_1P1_RSVD1      13
+#define BM_ANADIG_REG_1P1_RSVD1 0x0000E000
+#define BF_ANADIG_REG_1P1_RSVD1(v)  \
+	(((v) << 13) & BM_ANADIG_REG_1P1_RSVD1)
+#define BP_ANADIG_REG_1P1_OUTPUT_TRG      8
+#define BM_ANADIG_REG_1P1_OUTPUT_TRG 0x00001F00
+#define BF_ANADIG_REG_1P1_OUTPUT_TRG(v)  \
+	(((v) << 8) & BM_ANADIG_REG_1P1_OUTPUT_TRG)
+#define BM_ANADIG_REG_1P1_RSVD0 0x00000080
+#define BP_ANADIG_REG_1P1_BO_OFFSET      4
+#define BM_ANADIG_REG_1P1_BO_OFFSET 0x00000070
+#define BF_ANADIG_REG_1P1_BO_OFFSET(v)  \
+	(((v) << 4) & BM_ANADIG_REG_1P1_BO_OFFSET)
+#define BM_ANADIG_REG_1P1_ENABLE_PULLDOWN 0x00000008
+#define BM_ANADIG_REG_1P1_ENABLE_ILIMIT 0x00000004
+#define BM_ANADIG_REG_1P1_ENABLE_BO 0x00000002
+#define BM_ANADIG_REG_1P1_ENABLE_LINREG 0x00000001
+
+#define HW_ANADIG_REG_3P0	(0x00000120)
+#define HW_ANADIG_REG_3P0_SET	(0x00000124)
+#define HW_ANADIG_REG_3P0_CLR	(0x00000128)
+#define HW_ANADIG_REG_3P0_TOG	(0x0000012c)
+
+#define BP_ANADIG_REG_3P0_RSVD2      18
+#define BM_ANADIG_REG_3P0_RSVD2 0xFFFC0000
+#define BF_ANADIG_REG_3P0_RSVD2(v) \
+	(((v) << 18) & BM_ANADIG_REG_3P0_RSVD2)
+#define BM_ANADIG_REG_3P0_OK_VDD3P0 0x00020000
+#define BM_ANADIG_REG_3P0_BO_VDD3P0 0x00010000
+#define BP_ANADIG_REG_3P0_RSVD1      13
+#define BM_ANADIG_REG_3P0_RSVD1 0x0000E000
+#define BF_ANADIG_REG_3P0_RSVD1(v)  \
+	(((v) << 13) & BM_ANADIG_REG_3P0_RSVD1)
+#define BP_ANADIG_REG_3P0_OUTPUT_TRG      8
+#define BM_ANADIG_REG_3P0_OUTPUT_TRG 0x00001F00
+#define BF_ANADIG_REG_3P0_OUTPUT_TRG(v)  \
+	(((v) << 8) & BM_ANADIG_REG_3P0_OUTPUT_TRG)
+#define BM_ANADIG_REG_3P0_VBUS_SEL 0x00000080
+#define BP_ANADIG_REG_3P0_BO_OFFSET      4
+#define BM_ANADIG_REG_3P0_BO_OFFSET 0x00000070
+#define BF_ANADIG_REG_3P0_BO_OFFSET(v)  \
+	(((v) << 4) & BM_ANADIG_REG_3P0_BO_OFFSET)
+#define BM_ANADIG_REG_3P0_RSVD0 0x00000008
+#define BM_ANADIG_REG_3P0_ENABLE_ILIMIT 0x00000004
+#define BM_ANADIG_REG_3P0_ENABLE_BO 0x00000002
+#define BM_ANADIG_REG_3P0_ENABLE_LINREG 0x00000001
+
+#define HW_ANADIG_REG_2P5	(0x00000130)
+#define HW_ANADIG_REG_2P5_SET	(0x00000134)
+#define HW_ANADIG_REG_2P5_CLR	(0x00000138)
+#define HW_ANADIG_REG_2P5_TOG	(0x0000013c)
+
+#define BP_ANADIG_REG_2P5_RSVD2      19
+#define BM_ANADIG_REG_2P5_RSVD2 0xFFF80000
+#define BF_ANADIG_REG_2P5_RSVD2(v) \
+	(((v) << 19) & BM_ANADIG_REG_2P5_RSVD2)
+#define BM_ANADIG_REG_2P5_ENABLE_WEAK_LINREG 0x00040000
+#define BM_ANADIG_REG_2P5_OK_VDD2P5 0x00020000
+#define BM_ANADIG_REG_2P5_BO_VDD2P5 0x00010000
+#define BP_ANADIG_REG_2P5_RSVD1      13
+#define BM_ANADIG_REG_2P5_RSVD1 0x0000E000
+#define BF_ANADIG_REG_2P5_RSVD1(v)  \
+	(((v) << 13) & BM_ANADIG_REG_2P5_RSVD1)
+#define BP_ANADIG_REG_2P5_OUTPUT_TRG      8
+#define BM_ANADIG_REG_2P5_OUTPUT_TRG 0x00001F00
+#define BF_ANADIG_REG_2P5_OUTPUT_TRG(v)  \
+	(((v) << 8) & BM_ANADIG_REG_2P5_OUTPUT_TRG)
+#define BM_ANADIG_REG_2P5_RSVD0 0x00000080
+#define BP_ANADIG_REG_2P5_BO_OFFSET      4
+#define BM_ANADIG_REG_2P5_BO_OFFSET 0x00000070
+#define BF_ANADIG_REG_2P5_BO_OFFSET(v)  \
+	(((v) << 4) & BM_ANADIG_REG_2P5_BO_OFFSET)
+#define BM_ANADIG_REG_2P5_ENABLE_PULLDOWN 0x00000008
+#define BM_ANADIG_REG_2P5_ENABLE_ILIMIT 0x00000004
+#define BM_ANADIG_REG_2P5_ENABLE_BO 0x00000002
+#define BM_ANADIG_REG_2P5_ENABLE_LINREG 0x00000001
+
+#define HW_ANADIG_REG_CORE	(0x00000140)
+#define HW_ANADIG_REG_CORE_SET	(0x00000144)
+#define HW_ANADIG_REG_CORE_CLR	(0x00000148)
+#define HW_ANADIG_REG_CORE_TOG	(0x0000014c)
+
+#define BM_ANADIG_REG_CORE_REF_SHIFT 0x80000000
+#define BM_ANADIG_REG_CORE_RSVD0 0x40000000
+#define BM_ANADIG_REG_CORE_FET_ODRIVE 0x20000000
+#define BP_ANADIG_REG_CORE_RAMP_RATE      27
+#define BM_ANADIG_REG_CORE_RAMP_RATE 0x18000000
+#define BF_ANADIG_REG_CORE_RAMP_RATE(v)  \
+	(((v) << 27) & BM_ANADIG_REG_CORE_RAMP_RATE)
+#define BP_ANADIG_REG_CORE_REG2_ADJ      23
+#define BM_ANADIG_REG_CORE_REG2_ADJ 0x07800000
+#define BF_ANADIG_REG_CORE_REG2_ADJ(v)  \
+	(((v) << 23) & BM_ANADIG_REG_CORE_REG2_ADJ)
+#define BP_ANADIG_REG_CORE_REG2_TRG      18
+#define BM_ANADIG_REG_CORE_REG2_TRG 0x007C0000
+#define BF_ANADIG_REG_CORE_REG2_TRG(v)  \
+	(((v) << 18) & BM_ANADIG_REG_CORE_REG2_TRG)
+#define BP_ANADIG_REG_CORE_REG1_ADJ      14
+#define BM_ANADIG_REG_CORE_REG1_ADJ 0x0003C000
+#define BF_ANADIG_REG_CORE_REG1_ADJ(v)  \
+	(((v) << 14) & BM_ANADIG_REG_CORE_REG1_ADJ)
+#define BP_ANADIG_REG_CORE_REG1_TRG      9
+#define BM_ANADIG_REG_CORE_REG1_TRG 0x00003E00
+#define BF_ANADIG_REG_CORE_REG1_TRG(v)  \
+	(((v) << 9) & BM_ANADIG_REG_CORE_REG1_TRG)
+#define BP_ANADIG_REG_CORE_REG0_ADJ      5
+#define BM_ANADIG_REG_CORE_REG0_ADJ 0x000001E0
+#define BF_ANADIG_REG_CORE_REG0_ADJ(v)  \
+	(((v) << 5) & BM_ANADIG_REG_CORE_REG0_ADJ)
+#define BP_ANADIG_REG_CORE_REG0_TRG      0
+#define BM_ANADIG_REG_CORE_REG0_TRG 0x0000001F
+#define BF_ANADIG_REG_CORE_REG0_TRG(v)  \
+	(((v) << 0) & BM_ANADIG_REG_CORE_REG0_TRG)
+
+#define HW_ANADIG_ANA_MISC0	(0x00000150)
+#define HW_ANADIG_ANA_MISC0_SET	(0x00000154)
+#define HW_ANADIG_ANA_MISC0_CLR	(0x00000158)
+#define HW_ANADIG_ANA_MISC0_TOG	(0x0000015c)
+
+#define BP_ANADIG_ANA_MISC0_RSVD2      29
+#define BM_ANADIG_ANA_MISC0_RSVD2 0xE0000000
+#define BF_ANADIG_ANA_MISC0_RSVD2(v) \
+	(((v) << 29) & BM_ANADIG_ANA_MISC0_RSVD2)
+#define BP_ANADIG_ANA_MISC0_CLKGATE_DELAY      26
+#define BM_ANADIG_ANA_MISC0_CLKGATE_DELAY 0x1C000000
+#define BF_ANADIG_ANA_MISC0_CLKGATE_DELAY(v)  \
+	(((v) << 26) & BM_ANADIG_ANA_MISC0_CLKGATE_DELAY)
+#define BM_ANADIG_ANA_MISC0_CLKGATE_CTRL 0x02000000
+#define BP_ANADIG_ANA_MISC0_ANAMUX      21
+#define BM_ANADIG_ANA_MISC0_ANAMUX 0x01E00000
+#define BF_ANADIG_ANA_MISC0_ANAMUX(v)  \
+	(((v) << 21) & BM_ANADIG_ANA_MISC0_ANAMUX)
+#define BM_ANADIG_ANA_MISC0_ANAMUX_EN 0x00100000
+#define BP_ANADIG_ANA_MISC0_WBCP_VPW_THRESH      18
+#define BM_ANADIG_ANA_MISC0_WBCP_VPW_THRESH 0x000C0000
+#define BF_ANADIG_ANA_MISC0_WBCP_VPW_THRESH(v)  \
+	(((v) << 18) & BM_ANADIG_ANA_MISC0_WBCP_VPW_THRESH)
+#define BM_ANADIG_ANA_MISC0_OSC_XTALOK_EN 0x00020000
+#define BM_ANADIG_ANA_MISC0_OSC_XTALOK 0x00010000
+#define BP_ANADIG_ANA_MISC0_OSC_I      14
+#define BM_ANADIG_ANA_MISC0_OSC_I 0x0000C000
+#define BF_ANADIG_ANA_MISC0_OSC_I(v)  \
+	(((v) << 14) & BM_ANADIG_ANA_MISC0_OSC_I)
+#define BM_ANADIG_ANA_MISC0_RTC_RINGOSC_EN 0x00002000
+#define BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG 0x00001000
+#define BP_ANADIG_ANA_MISC0_RSVD0      10
+#define BM_ANADIG_ANA_MISC0_RSVD0 0x00000C00
+#define BF_ANADIG_ANA_MISC0_RSVD0(v)  \
+	(((v) << 10) & BM_ANADIG_ANA_MISC0_RSVD0)
+#define BP_ANADIG_ANA_MISC0_REFTOP_BIAS_TST      8
+#define BM_ANADIG_ANA_MISC0_REFTOP_BIAS_TST 0x00000300
+#define BF_ANADIG_ANA_MISC0_REFTOP_BIAS_TST(v)  \
+	(((v) << 8) & BM_ANADIG_ANA_MISC0_REFTOP_BIAS_TST)
+#define BM_ANADIG_ANA_MISC0_REFTOP_VBGUP 0x00000080
+#define BP_ANADIG_ANA_MISC0_REFTOP_VBGADJ      4
+#define BM_ANADIG_ANA_MISC0_REFTOP_VBGADJ 0x00000070
+#define BF_ANADIG_ANA_MISC0_REFTOP_VBGADJ(v)  \
+	(((v) << 4) & BM_ANADIG_ANA_MISC0_REFTOP_VBGADJ)
+#define BM_ANADIG_ANA_MISC0_REFTOP_SELBIASOFF 0x00000008
+#define BM_ANADIG_ANA_MISC0_REFTOP_LOWPOWER 0x00000004
+#define BM_ANADIG_ANA_MISC0_REFTOP_PWDVBGUP 0x00000002
+#define BM_ANADIG_ANA_MISC0_REFTOP_PWD 0x00000001
+
+#define HW_ANADIG_ANA_MISC1	(0x00000160)
+#define HW_ANADIG_ANA_MISC1_SET	(0x00000164)
+#define HW_ANADIG_ANA_MISC1_CLR	(0x00000168)
+#define HW_ANADIG_ANA_MISC1_TOG	(0x0000016c)
+
+#define BM_ANADIG_ANA_MISC1_IRQ_DIG_BO 0x80000000
+#define BM_ANADIG_ANA_MISC1_IRQ_ANA_BO 0x40000000
+#define BM_ANADIG_ANA_MISC1_IRQ_TEMPSENSE_BO 0x20000000
+#define BP_ANADIG_ANA_MISC1_RSVD0      14
+#define BM_ANADIG_ANA_MISC1_RSVD0 0x1FFFC000
+#define BF_ANADIG_ANA_MISC1_RSVD0(v)  \
+	(((v) << 14) & BM_ANADIG_ANA_MISC1_RSVD0)
+#define BM_ANADIG_ANA_MISC1_LVDSCLK2_IBEN 0x00002000
+#define BM_ANADIG_ANA_MISC1_LVDSCLK1_IBEN 0x00001000
+#define BM_ANADIG_ANA_MISC1_LVDSCLK2_OBEN 0x00000800
+#define BM_ANADIG_ANA_MISC1_LVDSCLK1_OBEN 0x00000400
+#define BP_ANADIG_ANA_MISC1_LVDS2_CLK_SEL      5
+#define BM_ANADIG_ANA_MISC1_LVDS2_CLK_SEL 0x000003E0
+#define BF_ANADIG_ANA_MISC1_LVDS2_CLK_SEL(v)  \
+	(((v) << 5) & BM_ANADIG_ANA_MISC1_LVDS2_CLK_SEL)
+#define BP_ANADIG_ANA_MISC1_LVDS1_CLK_SEL      0
+#define BM_ANADIG_ANA_MISC1_LVDS1_CLK_SEL 0x0000001F
+#define BF_ANADIG_ANA_MISC1_LVDS1_CLK_SEL(v)  \
+	(((v) << 0) & BM_ANADIG_ANA_MISC1_LVDS1_CLK_SEL)
+
+#define HW_ANADIG_ANA_MISC2	(0x00000170)
+#define HW_ANADIG_ANA_MISC2_SET	(0x00000174)
+#define HW_ANADIG_ANA_MISC2_CLR	(0x00000178)
+#define HW_ANADIG_ANA_MISC2_TOG	(0x0000017c)
+
+#define BP_ANADIG_ANA_MISC2_CONTROL3      30
+#define BM_ANADIG_ANA_MISC2_CONTROL3 0xC0000000
+#define BF_ANADIG_ANA_MISC2_CONTROL3(v) \
+	(((v) << 30) & BM_ANADIG_ANA_MISC2_CONTROL3)
+#define BP_ANADIG_ANA_MISC2_REG2_STEP_TIME      28
+#define BM_ANADIG_ANA_MISC2_REG2_STEP_TIME 0x30000000
+#define BF_ANADIG_ANA_MISC2_REG2_STEP_TIME(v)  \
+	(((v) << 28) & BM_ANADIG_ANA_MISC2_REG2_STEP_TIME)
+#define BP_ANADIG_ANA_MISC2_REG1_STEP_TIME      26
+#define BM_ANADIG_ANA_MISC2_REG1_STEP_TIME 0x0C000000
+#define BF_ANADIG_ANA_MISC2_REG1_STEP_TIME(v)  \
+	(((v) << 26) & BM_ANADIG_ANA_MISC2_REG1_STEP_TIME)
+#define BP_ANADIG_ANA_MISC2_REG0_STEP_TIME      24
+#define BM_ANADIG_ANA_MISC2_REG0_STEP_TIME 0x03000000
+#define BF_ANADIG_ANA_MISC2_REG0_STEP_TIME(v)  \
+	(((v) << 24) & BM_ANADIG_ANA_MISC2_REG0_STEP_TIME)
+#define BM_ANADIG_ANA_MISC2_CONTROL2 0x00800000
+#define BM_ANADIG_ANA_MISC2_REG2_OK 0x00400000
+#define BM_ANADIG_ANA_MISC2_REG2_ENABLE_BO 0x00200000
+#define BM_ANADIG_ANA_MISC2_RSVD2 0x00100000
+#define BM_ANADIG_ANA_MISC2_REG2_BO_STATUS 0x00080000
+#define BP_ANADIG_ANA_MISC2_REG2_BO_OFFSET      16
+#define BM_ANADIG_ANA_MISC2_REG2_BO_OFFSET 0x00070000
+#define BF_ANADIG_ANA_MISC2_REG2_BO_OFFSET(v)  \
+	(((v) << 16) & BM_ANADIG_ANA_MISC2_REG2_BO_OFFSET)
+#define BM_ANADIG_ANA_MISC2_CONTROL1 0x00008000
+#define BM_ANADIG_ANA_MISC2_REG1_OK 0x00004000
+#define BM_ANADIG_ANA_MISC2_REG1_ENABLE_BO 0x00002000
+#define BM_ANADIG_ANA_MISC2_RSVD1 0x00001000
+#define BM_ANADIG_ANA_MISC2_REG1_BO_STATUS 0x00000800
+#define BP_ANADIG_ANA_MISC2_REG1_BO_OFFSET      8
+#define BM_ANADIG_ANA_MISC2_REG1_BO_OFFSET 0x00000700
+#define BF_ANADIG_ANA_MISC2_REG1_BO_OFFSET(v)  \
+	(((v) << 8) & BM_ANADIG_ANA_MISC2_REG1_BO_OFFSET)
+#define BM_ANADIG_ANA_MISC2_CONTROL0 0x00000080
+#define BM_ANADIG_ANA_MISC2_REG0_OK 0x00000040
+#define BM_ANADIG_ANA_MISC2_REG0_ENABLE_BO 0x00000020
+#define BM_ANADIG_ANA_MISC2_RSVD0 0x00000010
+#define BM_ANADIG_ANA_MISC2_REG0_BO_STATUS 0x00000008
+#define BP_ANADIG_ANA_MISC2_REG0_BO_OFFSET      0
+#define BM_ANADIG_ANA_MISC2_REG0_BO_OFFSET 0x00000007
+#define BF_ANADIG_ANA_MISC2_REG0_BO_OFFSET(v)  \
+	(((v) << 0) & BM_ANADIG_ANA_MISC2_REG0_BO_OFFSET)
+
+#define HW_ANADIG_TEMPSENSE0	(0x00000180)
+#define HW_ANADIG_TEMPSENSE0_SET	(0x00000184)
+#define HW_ANADIG_TEMPSENSE0_CLR	(0x00000188)
+#define HW_ANADIG_TEMPSENSE0_TOG	(0x0000018c)
+
+#define BP_ANADIG_TEMPSENSE0_ALARM_VALUE      20
+#define BM_ANADIG_TEMPSENSE0_ALARM_VALUE 0xFFF00000
+#define BF_ANADIG_TEMPSENSE0_ALARM_VALUE(v) \
+	(((v) << 20) & BM_ANADIG_TEMPSENSE0_ALARM_VALUE)
+#define BP_ANADIG_TEMPSENSE0_TEMP_VALUE      8
+#define BM_ANADIG_TEMPSENSE0_TEMP_VALUE 0x000FFF00
+#define BF_ANADIG_TEMPSENSE0_TEMP_VALUE(v)  \
+	(((v) << 8) & BM_ANADIG_TEMPSENSE0_TEMP_VALUE)
+#define BM_ANADIG_TEMPSENSE0_RSVD0 0x00000080
+#define BM_ANADIG_TEMPSENSE0_TEST 0x00000040
+#define BP_ANADIG_TEMPSENSE0_VBGADJ      3
+#define BM_ANADIG_TEMPSENSE0_VBGADJ 0x00000038
+#define BF_ANADIG_TEMPSENSE0_VBGADJ(v)  \
+	(((v) << 3) & BM_ANADIG_TEMPSENSE0_VBGADJ)
+#define BM_ANADIG_TEMPSENSE0_FINISHED 0x00000004
+#define BM_ANADIG_TEMPSENSE0_MEASURE_TEMP 0x00000002
+#define BM_ANADIG_TEMPSENSE0_POWER_DOWN 0x00000001
+
+#define HW_ANADIG_TEMPSENSE1	(0x00000190)
+#define HW_ANADIG_TEMPSENSE1_SET	(0x00000194)
+#define HW_ANADIG_TEMPSENSE1_CLR	(0x00000198)
+#define HW_ANADIG_TEMPSENSE1_TOG	(0x0000019c)
+
+#define BP_ANADIG_TEMPSENSE1_RSVD0      16
+#define BM_ANADIG_TEMPSENSE1_RSVD0 0xFFFF0000
+#define BF_ANADIG_TEMPSENSE1_RSVD0(v) \
+	(((v) << 16) & BM_ANADIG_TEMPSENSE1_RSVD0)
+#define BP_ANADIG_TEMPSENSE1_MEASURE_FREQ      0
+#define BM_ANADIG_TEMPSENSE1_MEASURE_FREQ 0x0000FFFF
+#define BF_ANADIG_TEMPSENSE1_MEASURE_FREQ(v)  \
+	(((v) << 0) & BM_ANADIG_TEMPSENSE1_MEASURE_FREQ)
+
+#define HW_ANADIG_USB1_VBUS_DETECT	(0x000001a0)
+#define HW_ANADIG_USB1_VBUS_DETECT_SET	(0x000001a4)
+#define HW_ANADIG_USB1_VBUS_DETECT_CLR	(0x000001a8)
+#define HW_ANADIG_USB1_VBUS_DETECT_TOG	(0x000001ac)
+
+#define BM_ANADIG_USB1_VBUS_DETECT_EN_CHARGER_RESISTOR 0x80000000
+#define BP_ANADIG_USB1_VBUS_DETECT_RSVD2      28
+#define BM_ANADIG_USB1_VBUS_DETECT_RSVD2 0x70000000
+#define BF_ANADIG_USB1_VBUS_DETECT_RSVD2(v)  \
+	(((v) << 28) & BM_ANADIG_USB1_VBUS_DETECT_RSVD2)
+#define BM_ANADIG_USB1_VBUS_DETECT_CHARGE_VBUS 0x08000000
+#define BM_ANADIG_USB1_VBUS_DETECT_DISCHARGE_VBUS 0x04000000
+#define BP_ANADIG_USB1_VBUS_DETECT_RSVD1      21
+#define BM_ANADIG_USB1_VBUS_DETECT_RSVD1 0x03E00000
+#define BF_ANADIG_USB1_VBUS_DETECT_RSVD1(v)  \
+	(((v) << 21) & BM_ANADIG_USB1_VBUS_DETECT_RSVD1)
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_PWRUP_CMPS 0x00100000
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_5VDETECT 0x00080000
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_TO_B 0x00040000
+#define BP_ANADIG_USB1_VBUS_DETECT_RSVD0      8
+#define BM_ANADIG_USB1_VBUS_DETECT_RSVD0 0x0003FF00
+#define BF_ANADIG_USB1_VBUS_DETECT_RSVD0(v)  \
+	(((v) << 8) & BM_ANADIG_USB1_VBUS_DETECT_RSVD0)
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_OVERRIDE 0x00000080
+#define BM_ANADIG_USB1_VBUS_DETECT_AVALID_OVERRIDE 0x00000040
+#define BM_ANADIG_USB1_VBUS_DETECT_BVALID_OVERRIDE 0x00000020
+#define BM_ANADIG_USB1_VBUS_DETECT_SESSEND_OVERRIDE 0x00000010
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUS_OVERRIDE_EN 0x00000008
+#define BP_ANADIG_USB1_VBUS_DETECT_VBUSVALID_THRESH      0
+#define BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_THRESH 0x00000007
+#define BF_ANADIG_USB1_VBUS_DETECT_VBUSVALID_THRESH(v)  \
+	(((v) << 0) & BM_ANADIG_USB1_VBUS_DETECT_VBUSVALID_THRESH)
+
+#define HW_ANADIG_USB1_CHRG_DETECT	(0x000001b0)
+#define HW_ANADIG_USB1_CHRG_DETECT_SET	(0x000001b4)
+#define HW_ANADIG_USB1_CHRG_DETECT_CLR	(0x000001b8)
+#define HW_ANADIG_USB1_CHRG_DETECT_TOG	(0x000001bc)
+
+#define BP_ANADIG_USB1_CHRG_DETECT_RSVD2      24
+#define BM_ANADIG_USB1_CHRG_DETECT_RSVD2 0xFF000000
+#define BF_ANADIG_USB1_CHRG_DETECT_RSVD2(v) \
+	(((v) << 24) & BM_ANADIG_USB1_CHRG_DETECT_RSVD2)
+#define BM_ANADIG_USB1_CHRG_DETECT_BGR_BIAS 0x00800000
+#define BP_ANADIG_USB1_CHRG_DETECT_RSVD1      21
+#define BM_ANADIG_USB1_CHRG_DETECT_RSVD1 0x00600000
+#define BF_ANADIG_USB1_CHRG_DETECT_RSVD1(v)  \
+	(((v) << 21) & BM_ANADIG_USB1_CHRG_DETECT_RSVD1)
+#define BM_ANADIG_USB1_CHRG_DETECT_EN_B 0x00100000
+#define BM_ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B 0x00080000
+#define BM_ANADIG_USB1_CHRG_DETECT_CHK_CONTACT 0x00040000
+#define BP_ANADIG_USB1_CHRG_DETECT_RSVD0      1
+#define BM_ANADIG_USB1_CHRG_DETECT_RSVD0 0x0003FFFE
+#define BF_ANADIG_USB1_CHRG_DETECT_RSVD0(v)  \
+	(((v) << 1) & BM_ANADIG_USB1_CHRG_DETECT_RSVD0)
+#define BM_ANADIG_USB1_CHRG_DETECT_FORCE_DETECT 0x00000001
+
+#define HW_ANADIG_USB1_VBUS_DET_STAT	(0x000001c0)
+#define HW_ANADIG_USB1_VBUS_DET_STAT_SET	(0x000001c4)
+#define HW_ANADIG_USB1_VBUS_DET_STAT_CLR	(0x000001c8)
+#define HW_ANADIG_USB1_VBUS_DET_STAT_TOG	(0x000001cc)
+
+#define BP_ANADIG_USB1_VBUS_DET_STAT_RSVD0      4
+#define BM_ANADIG_USB1_VBUS_DET_STAT_RSVD0 0xFFFFFFF0
+#define BF_ANADIG_USB1_VBUS_DET_STAT_RSVD0(v) \
+	(((v) << 4) & BM_ANADIG_USB1_VBUS_DET_STAT_RSVD0)
+#define BM_ANADIG_USB1_VBUS_DET_STAT_VBUS_VALID 0x00000008
+#define BM_ANADIG_USB1_VBUS_DET_STAT_AVALID 0x00000004
+#define BM_ANADIG_USB1_VBUS_DET_STAT_BVALID 0x00000002
+#define BM_ANADIG_USB1_VBUS_DET_STAT_SESSEND 0x00000001
+
+#define HW_ANADIG_USB1_CHRG_DET_STAT	(0x000001d0)
+#define HW_ANADIG_USB1_CHRG_DET_STAT_SET	(0x000001d4)
+#define HW_ANADIG_USB1_CHRG_DET_STAT_CLR	(0x000001d8)
+#define HW_ANADIG_USB1_CHRG_DET_STAT_TOG	(0x000001dc)
+
+#define BP_ANADIG_USB1_CHRG_DET_STAT_RSVD0      4
+#define BM_ANADIG_USB1_CHRG_DET_STAT_RSVD0 0xFFFFFFF0
+#define BF_ANADIG_USB1_CHRG_DET_STAT_RSVD0(v) \
+	(((v) << 4) & BM_ANADIG_USB1_CHRG_DET_STAT_RSVD0)
+#define BM_ANADIG_USB1_CHRG_DET_STAT_DP_STATE 0x00000008
+#define BM_ANADIG_USB1_CHRG_DET_STAT_DM_STATE 0x00000004
+#define BM_ANADIG_USB1_CHRG_DET_STAT_CHRG_DETECTED 0x00000002
+#define BM_ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT 0x00000001
+
+#define HW_ANADIG_USB1_LOOPBACK	(0x000001e0)
+#define HW_ANADIG_USB1_LOOPBACK_SET	(0x000001e4)
+#define HW_ANADIG_USB1_LOOPBACK_CLR	(0x000001e8)
+#define HW_ANADIG_USB1_LOOPBACK_TOG	(0x000001ec)
+
+#define BP_ANADIG_USB1_LOOPBACK_RSVD0      9
+#define BM_ANADIG_USB1_LOOPBACK_RSVD0 0xFFFFFE00
+#define BF_ANADIG_USB1_LOOPBACK_RSVD0(v) \
+	(((v) << 9) & BM_ANADIG_USB1_LOOPBACK_RSVD0)
+#define BM_ANADIG_USB1_LOOPBACK_UTMO_DIG_TST1 0x00000100
+#define BM_ANADIG_USB1_LOOPBACK_UTMO_DIG_TST0 0x00000080
+#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_HIZ 0x00000040
+#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_EN 0x00000020
+#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_LS_MODE 0x00000010
+#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_HS_MODE 0x00000008
+#define BM_ANADIG_USB1_LOOPBACK_UTMI_DIG_TST1 0x00000004
+#define BM_ANADIG_USB1_LOOPBACK_UTMI_DIG_TST0 0x00000002
+#define BM_ANADIG_USB1_LOOPBACK_UTMI_TESTSTART 0x00000001
+
+#define HW_ANADIG_USB1_MISC	(0x000001f0)
+#define HW_ANADIG_USB1_MISC_SET	(0x000001f4)
+#define HW_ANADIG_USB1_MISC_CLR	(0x000001f8)
+#define HW_ANADIG_USB1_MISC_TOG	(0x000001fc)
+
+#define BM_ANADIG_USB1_MISC_RSVD1 0x80000000
+#define BM_ANADIG_USB1_MISC_EN_CLK_UTMI 0x40000000
+#define BM_ANADIG_USB1_MISC_RX_VPIN_FS 0x20000000
+#define BM_ANADIG_USB1_MISC_RX_VMIN_FS 0x10000000
+#define BM_ANADIG_USB1_MISC_RX_RXD_FS 0x08000000
+#define BM_ANADIG_USB1_MISC_RX_SQUELCH 0x04000000
+#define BM_ANADIG_USB1_MISC_RX_DISCON_DET 0x02000000
+#define BM_ANADIG_USB1_MISC_RX_HS_DATA 0x01000000
+#define BP_ANADIG_USB1_MISC_RSVD0      2
+#define BM_ANADIG_USB1_MISC_RSVD0 0x00FFFFFC
+#define BF_ANADIG_USB1_MISC_RSVD0(v)  \
+	(((v) << 2) & BM_ANADIG_USB1_MISC_RSVD0)
+#define BM_ANADIG_USB1_MISC_EN_DEGLITCH 0x00000002
+#define BM_ANADIG_USB1_MISC_HS_USE_EXTERNAL_R 0x00000001
+
+#define HW_ANADIG_USB2_VBUS_DETECT	(0x00000200)
+#define HW_ANADIG_USB2_VBUS_DETECT_SET	(0x00000204)
+#define HW_ANADIG_USB2_VBUS_DETECT_CLR	(0x00000208)
+#define HW_ANADIG_USB2_VBUS_DETECT_TOG	(0x0000020c)
+
+#define BM_ANADIG_USB2_VBUS_DETECT_EN_CHARGER_RESISTOR 0x80000000
+#define BP_ANADIG_USB2_VBUS_DETECT_RSVD2      28
+#define BM_ANADIG_USB2_VBUS_DETECT_RSVD2 0x70000000
+#define BF_ANADIG_USB2_VBUS_DETECT_RSVD2(v)  \
+	(((v) << 28) & BM_ANADIG_USB2_VBUS_DETECT_RSVD2)
+#define BM_ANADIG_USB2_VBUS_DETECT_CHARGE_VBUS 0x08000000
+#define BM_ANADIG_USB2_VBUS_DETECT_DISCHARGE_VBUS 0x04000000
+#define BP_ANADIG_USB2_VBUS_DETECT_RSVD1      21
+#define BM_ANADIG_USB2_VBUS_DETECT_RSVD1 0x03E00000
+#define BF_ANADIG_USB2_VBUS_DETECT_RSVD1(v)  \
+	(((v) << 21) & BM_ANADIG_USB2_VBUS_DETECT_RSVD1)
+#define BM_ANADIG_USB2_VBUS_DETECT_VBUSVALID_PWRUP_CMPS 0x00100000
+#define BM_ANADIG_USB2_VBUS_DETECT_VBUSVALID_5VDETECT 0x00080000
+#define BM_ANADIG_USB2_VBUS_DETECT_VBUSVALID_TO_B 0x00040000
+#define BP_ANADIG_USB2_VBUS_DETECT_RSVD0      3
+#define BM_ANADIG_USB2_VBUS_DETECT_RSVD0 0x0003FFF8
+#define BF_ANADIG_USB2_VBUS_DETECT_RSVD0(v)  \
+	(((v) << 3) & BM_ANADIG_USB2_VBUS_DETECT_RSVD0)
+#define BP_ANADIG_USB2_VBUS_DETECT_VBUSVALID_THRESH      0
+#define BM_ANADIG_USB2_VBUS_DETECT_VBUSVALID_THRESH 0x00000007
+#define BF_ANADIG_USB2_VBUS_DETECT_VBUSVALID_THRESH(v)  \
+	(((v) << 0) & BM_ANADIG_USB2_VBUS_DETECT_VBUSVALID_THRESH)
+
+#define HW_ANADIG_USB2_CHRG_DETECT	(0x00000210)
+#define HW_ANADIG_USB2_CHRG_DETECT_SET	(0x00000214)
+#define HW_ANADIG_USB2_CHRG_DETECT_CLR	(0x00000218)
+#define HW_ANADIG_USB2_CHRG_DETECT_TOG	(0x0000021c)
+
+#define BP_ANADIG_USB2_CHRG_DETECT_RSVD2      24
+#define BM_ANADIG_USB2_CHRG_DETECT_RSVD2 0xFF000000
+#define BF_ANADIG_USB2_CHRG_DETECT_RSVD2(v) \
+	(((v) << 24) & BM_ANADIG_USB2_CHRG_DETECT_RSVD2)
+#define BM_ANADIG_USB2_CHRG_DETECT_BGR_BIAS 0x00800000
+#define BP_ANADIG_USB2_CHRG_DETECT_RSVD1      21
+#define BM_ANADIG_USB2_CHRG_DETECT_RSVD1 0x00600000
+#define BF_ANADIG_USB2_CHRG_DETECT_RSVD1(v)  \
+	(((v) << 21) & BM_ANADIG_USB2_CHRG_DETECT_RSVD1)
+#define BM_ANADIG_USB2_CHRG_DETECT_EN_B 0x00100000
+#define BM_ANADIG_USB2_CHRG_DETECT_CHK_CHRG_B 0x00080000
+#define BM_ANADIG_USB2_CHRG_DETECT_CHK_CONTACT 0x00040000
+#define BP_ANADIG_USB2_CHRG_DETECT_RSVD0      1
+#define BM_ANADIG_USB2_CHRG_DETECT_RSVD0 0x0003FFFE
+#define BF_ANADIG_USB2_CHRG_DETECT_RSVD0(v)  \
+	(((v) << 1) & BM_ANADIG_USB2_CHRG_DETECT_RSVD0)
+#define BM_ANADIG_USB2_CHRG_DETECT_FORCE_DETECT 0x00000001
+
+#define HW_ANADIG_USB2_VBUS_DET_STAT	(0x00000220)
+#define HW_ANADIG_USB2_VBUS_DET_STAT_SET	(0x00000224)
+#define HW_ANADIG_USB2_VBUS_DET_STAT_CLR	(0x00000228)
+#define HW_ANADIG_USB2_VBUS_DET_STAT_TOG	(0x0000022c)
+
+#define BP_ANADIG_USB2_VBUS_DET_STAT_RSVD0      4
+#define BM_ANADIG_USB2_VBUS_DET_STAT_RSVD0 0xFFFFFFF0
+#define BF_ANADIG_USB2_VBUS_DET_STAT_RSVD0(v) \
+	(((v) << 4) & BM_ANADIG_USB2_VBUS_DET_STAT_RSVD0)
+#define BM_ANADIG_USB2_VBUS_DET_STAT_VBUS_VALID 0x00000008
+#define BM_ANADIG_USB2_VBUS_DET_STAT_AVALID 0x00000004
+#define BM_ANADIG_USB2_VBUS_DET_STAT_BVALID 0x00000002
+#define BM_ANADIG_USB2_VBUS_DET_STAT_SESSEND 0x00000001
+
+#define HW_ANADIG_USB2_CHRG_DET_STAT	(0x00000230)
+#define HW_ANADIG_USB2_CHRG_DET_STAT_SET	(0x00000234)
+#define HW_ANADIG_USB2_CHRG_DET_STAT_CLR	(0x00000238)
+#define HW_ANADIG_USB2_CHRG_DET_STAT_TOG	(0x0000023c)
+
+#define BP_ANADIG_USB2_CHRG_DET_STAT_RSVD0      4
+#define BM_ANADIG_USB2_CHRG_DET_STAT_RSVD0 0xFFFFFFF0
+#define BF_ANADIG_USB2_CHRG_DET_STAT_RSVD0(v) \
+	(((v) << 4) & BM_ANADIG_USB2_CHRG_DET_STAT_RSVD0)
+#define BM_ANADIG_USB2_CHRG_DET_STAT_DP_STATE 0x00000008
+#define BM_ANADIG_USB2_CHRG_DET_STAT_DM_STATE 0x00000004
+#define BM_ANADIG_USB2_CHRG_DET_STAT_CHRG_DETECTED 0x00000002
+#define BM_ANADIG_USB2_CHRG_DET_STAT_PLUG_CONTACT 0x00000001
+
+#define HW_ANADIG_USB2_LOOPBACK	(0x00000240)
+#define HW_ANADIG_USB2_LOOPBACK_SET	(0x00000244)
+#define HW_ANADIG_USB2_LOOPBACK_CLR	(0x00000248)
+#define HW_ANADIG_USB2_LOOPBACK_TOG	(0x0000024c)
+
+#define BP_ANADIG_USB2_LOOPBACK_RSVD0      9
+#define BM_ANADIG_USB2_LOOPBACK_RSVD0 0xFFFFFE00
+#define BF_ANADIG_USB2_LOOPBACK_RSVD0(v) \
+	(((v) << 9) & BM_ANADIG_USB2_LOOPBACK_RSVD0)
+#define BM_ANADIG_USB2_LOOPBACK_UTMO_DIG_TST1 0x00000100
+#define BM_ANADIG_USB2_LOOPBACK_UTMO_DIG_TST0 0x00000080
+#define BM_ANADIG_USB2_LOOPBACK_TSTI_TX_HIZ 0x00000040
+#define BM_ANADIG_USB2_LOOPBACK_TSTI_TX_EN 0x00000020
+#define BM_ANADIG_USB2_LOOPBACK_TSTI_TX_LS_MODE 0x00000010
+#define BM_ANADIG_USB2_LOOPBACK_TSTI_TX_HS_MODE 0x00000008
+#define BM_ANADIG_USB2_LOOPBACK_UTMI_DIG_TST1 0x00000004
+#define BM_ANADIG_USB2_LOOPBACK_UTMI_DIG_TST0 0x00000002
+#define BM_ANADIG_USB2_LOOPBACK_UTMI_TESTSTART 0x00000001
+
+#define HW_ANADIG_USB2_MISC	(0x00000250)
+#define HW_ANADIG_USB2_MISC_SET	(0x00000254)
+#define HW_ANADIG_USB2_MISC_CLR	(0x00000258)
+#define HW_ANADIG_USB2_MISC_TOG	(0x0000025c)
+
+#define BM_ANADIG_USB2_MISC_RSVD1 0x80000000
+#define BM_ANADIG_USB2_MISC_EN_CLK_UTMI 0x40000000
+#define BM_ANADIG_USB2_MISC_RX_VPIN_FS 0x20000000
+#define BM_ANADIG_USB2_MISC_RX_VMIN_FS 0x10000000
+#define BM_ANADIG_USB2_MISC_RX_RXD_FS 0x08000000
+#define BM_ANADIG_USB2_MISC_RX_SQUELCH 0x04000000
+#define BM_ANADIG_USB2_MISC_RX_DISCON_DET 0x02000000
+#define BM_ANADIG_USB2_MISC_RX_HS_DATA 0x01000000
+#define BP_ANADIG_USB2_MISC_RSVD0      2
+#define BM_ANADIG_USB2_MISC_RSVD0 0x00FFFFFC
+#define BF_ANADIG_USB2_MISC_RSVD0(v)  \
+	(((v) << 2) & BM_ANADIG_USB2_MISC_RSVD0)
+#define BM_ANADIG_USB2_MISC_EN_DEGLITCH 0x00000002
+#define BM_ANADIG_USB2_MISC_HS_USE_EXTERNAL_R 0x00000001
+
+#define HW_ANADIG_DIGPROG	(0x00000260)
+
+#define BP_ANADIG_DIGPROG_RSVD      24
+#define BM_ANADIG_DIGPROG_RSVD 0xFF000000
+#define BF_ANADIG_DIGPROG_RSVD(v) \
+	(((v) << 24) & BM_ANADIG_DIGPROG_RSVD)
+#define BP_ANADIG_DIGPROG_MAJOR      8
+#define BM_ANADIG_DIGPROG_MAJOR 0x00FFFF00
+#define BF_ANADIG_DIGPROG_MAJOR(v)  \
+	(((v) << 8) & BM_ANADIG_DIGPROG_MAJOR)
+#define BP_ANADIG_DIGPROG_MINOR      0
+#define BM_ANADIG_DIGPROG_MINOR 0x000000FF
+#define BF_ANADIG_DIGPROG_MINOR(v)  \
+	(((v) << 0) & BM_ANADIG_DIGPROG_MINOR)
+
 #endif /*__ARCH_ARM_MACH_MX6_CCM_REGS_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/hab.h b/arch/arm/include/asm/arch-mx6/hab.h
index d724f20..2cd402b 100644
--- a/arch/arm/include/asm/arch-mx6/hab.h
+++ b/arch/arm/include/asm/arch-mx6/hab.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:    GPL-2.0+
  *
@@ -53,11 +53,31 @@ typedef void *hab_rvt_authenticate_image_t(uint8_t, ptrdiff_t,
 		void **, size_t *, hab_loader_callback_f_t);
 typedef void hapi_clock_init_t(void);
 
-#define HAB_RVT_REPORT_EVENT (*(uint32_t *)0x000000B4)
-#define HAB_RVT_REPORT_STATUS (*(uint32_t *)0x000000B8)
-#define HAB_RVT_AUTHENTICATE_IMAGE (*(uint32_t *)0x000000A4)
-#define HAB_RVT_ENTRY (*(uint32_t *)0x00000098)
-#define HAB_RVT_EXIT (*(uint32_t *)0x0000009C)
+#ifdef CONFIG_ROM_UNIFIED_SECTIONS
+
+#define HAB_RVT_UNIFIED_BASE			0x00000100
+#define HAB_RVT_ENTRY				(*(uint32_t *) (HAB_RVT_UNIFIED_BASE + 0x04))
+#define HAB_RVT_EXIT				(*(uint32_t *) (HAB_RVT_UNIFIED_BASE + 0x08))
+#define HAB_RVT_AUTHENTICATE_IMAGE		(*(uint32_t *) (HAB_RVT_UNIFIED_BASE + 0x10))
+#define HAB_RVT_REPORT_EVENT			(*(uint32_t *) (HAB_RVT_UNIFIED_BASE + 0x20))
+#define HAB_RVT_REPORT_STATUS			(*(uint32_t *) (HAB_RVT_UNIFIED_BASE + 0x24))
+
+#else
+
+#define HAB_RVT_REPORT_EVENT			(*(uint32_t *) 0x000000B4)
+#define HAB_RVT_REPORT_STATUS			(*(uint32_t *) 0x000000B8)
+#define HAB_RVT_AUTHENTICATE_IMAGE		(*(uint32_t *) 0x000000A4)
+#define HAB_RVT_ENTRY				(*(uint32_t *) 0x00000098)
+#define HAB_RVT_EXIT				(*(uint32_t *) 0x0000009C)
+
+#endif
+
+#define HAB_RVT_REPORT_EVENT_NEW		(*(uint32_t *) 0x000000B8)
+#define HAB_RVT_REPORT_STATUS_NEW		(*(uint32_t *) 0x000000BC)
+#define HAB_RVT_AUTHENTICATE_IMAGE_NEW		(*(uint32_t *) 0x000000A8)
+#define HAB_RVT_ENTRY_NEW			(*(uint32_t *) 0x0000009C)
+#define HAB_RVT_EXIT_NEW			(*(uint32_t *) 0x000000A0)
+
 #define HAB_RVT_CLOCK_INIT ((hapi_clock_init_t *)0x0000024D)
 
 #define HAB_CID_ROM 0 /**< ROM Caller ID */
diff --git a/arch/arm/include/asm/arch-mx6/imx-rdc.h b/arch/arm/include/asm/arch-mx6/imx-rdc.h
new file mode 100644
index 0000000..60e0b3b
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/imx-rdc.h
@@ -0,0 +1,16 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:  GPL-2.0+
+ */
+
+#ifndef __IMX_RDC_H__
+#define __IMX_RDC_H__
+
+#if defined(CONFIG_MX6SX)
+#include "mx6sx_rdc.h"
+#else
+#error "Please select cpu"
+#endif	/* CONFIG_MX6SX */
+
+#endif	/* __IMX_RDC_H__*/
diff --git a/arch/arm/include/asm/arch-mx6/imx-regs.h b/arch/arm/include/asm/arch-mx6/imx-regs.h
index 1f19727..fd85803 100644
--- a/arch/arm/include/asm/arch-mx6/imx-regs.h
+++ b/arch/arm/include/asm/arch-mx6/imx-regs.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -19,6 +19,20 @@
 #define GPU_2D_ARB_END_ADDR             0x02203FFF
 #define OPENVG_ARB_BASE_ADDR            0x02204000
 #define OPENVG_ARB_END_ADDR             0x02207FFF
+
+#elif CONFIG_MX6SX
+#define CAAM_ARB_BASE_ADDR              0x00100000
+#define CAAM_ARB_END_ADDR               0x00107FFF
+#define GPU_ARB_BASE_ADDR               0x01800000
+#define GPU_ARB_END_ADDR                0x01803FFF
+#define APBH_DMA_ARB_BASE_ADDR          0x01804000
+#define APBH_DMA_ARB_END_ADDR           0x0180BFFF
+#define M4_BOOTROM_BASE_ADDR            0x007F8000
+
+#define MXS_APBH_BASE			APBH_DMA_ARB_BASE_ADDR
+#define MXS_GPMI_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x02000)
+#define MXS_BCH_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x04000)
+
 #else
 #define CAAM_ARB_BASE_ADDR              0x00100000
 #define CAAM_ARB_END_ADDR               0x00103FFF
@@ -32,21 +46,35 @@
 #define GPU_2D_ARB_END_ADDR             0x00137FFF
 #define DTCP_ARB_BASE_ADDR              0x00138000
 #define DTCP_ARB_END_ADDR               0x0013BFFF
-#endif	/* CONFIG_MX6SL */
 
 #define MXS_APBH_BASE			APBH_DMA_ARB_BASE_ADDR
 #define MXS_GPMI_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x02000)
 #define MXS_BCH_BASE			(APBH_DMA_ARB_BASE_ADDR + 0x04000)
 
+#endif	/* CONFIG_MX6SL */
+
 /* GPV - PL301 configuration ports */
-#ifdef CONFIG_MX6SL
+#if (defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX))
 #define GPV2_BASE_ADDR                  0x00D00000
 #else
 #define GPV2_BASE_ADDR			0x00200000
 #endif
 
+#ifdef CONFIG_MX6SX
+#define GPV3_BASE_ADDR			0x00E00000
+#define GPV4_BASE_ADDR			0x00F00000
+#define GPV5_BASE_ADDR			0x01000000
+#define GPV6_BASE_ADDR			0x01100000
+#define PCIE_ARB_BASE_ADDR              0x08000000
+#define PCIE_ARB_END_ADDR               0x08FFFFFF
+
+#else
 #define GPV3_BASE_ADDR			0x00300000
 #define GPV4_BASE_ADDR			0x00800000
+#define PCIE_ARB_BASE_ADDR              0x01000000
+#define PCIE_ARB_END_ADDR               0x01FFFFFF
+#endif
+
 #define IRAM_BASE_ADDR			0x00900000
 #define SCU_BASE_ADDR                   0x00A00000
 #define IC_INTERFACES_BASE_ADDR         0x00A00100
@@ -56,13 +84,21 @@
 #define L2_PL310_BASE			0x00A02000
 #define GPV0_BASE_ADDR                  0x00B00000
 #define GPV1_BASE_ADDR                  0x00C00000
-#define PCIE_ARB_BASE_ADDR              0x01000000
-#define PCIE_ARB_END_ADDR               0x01FFFFFF
 
 #define AIPS1_ARB_BASE_ADDR             0x02000000
 #define AIPS1_ARB_END_ADDR              0x020FFFFF
 #define AIPS2_ARB_BASE_ADDR             0x02100000
 #define AIPS2_ARB_END_ADDR              0x021FFFFF
+#ifdef CONFIG_MX6SX
+#define AIPS3_ARB_BASE_ADDR             0x02200000
+#define AIPS3_ARB_END_ADDR              0x022FFFFF
+#define WEIM_ARB_BASE_ADDR              0x50000000
+#define WEIM_ARB_END_ADDR               0x57FFFFFF
+#define QSPI1_ARB_BASE_ADDR             0x60000000
+#define QSPI1_ARB_END_ADDR              0x6FFFFFFF
+#define QSPI2_ARB_BASE_ADDR             0x70000000
+#define QSPI2_ARB_END_ADDR              0x7FFFFFFF
+#else
 #define SATA_ARB_BASE_ADDR              0x02200000
 #define SATA_ARB_END_ADDR               0x02203FFF
 #define OPENVG_ARB_BASE_ADDR            0x02204000
@@ -75,8 +111,9 @@
 #define IPU2_ARB_END_ADDR               0x02BFFFFF
 #define WEIM_ARB_BASE_ADDR              0x08000000
 #define WEIM_ARB_END_ADDR               0x0FFFFFFF
+#endif
 
-#ifdef CONFIG_MX6SL
+#if (defined(CONFIG_MX6SL) || defined(CONFIG_MX6SX))
 #define MMDC0_ARB_BASE_ADDR             0x80000000
 #define MMDC0_ARB_END_ADDR              0xFFFFFFFF
 #define MMDC1_ARB_BASE_ADDR             0xC0000000
@@ -88,8 +125,10 @@
 #define MMDC1_ARB_END_ADDR              0xFFFFFFFF
 #endif
 
+#ifndef CONFIG_MX6SX
 #define IPU_SOC_BASE_ADDR		IPU1_ARB_BASE_ADDR
 #define IPU_SOC_OFFSET			0x00200000
+#endif
 
 /* Defines for Blocks connected via AIPS (SkyBlue) */
 #define ATZ1_BASE_ADDR              AIPS1_ARB_BASE_ADDR
@@ -112,7 +151,11 @@
 #define UART3_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x34000)
 #define UART4_IPS_BASE_ADDR         (ATZ1_BASE_ADDR + 0x38000)
 #else
+
+#ifndef CONFIG_MX6SX
 #define ECSPI5_BASE_ADDR            (ATZ1_BASE_ADDR + 0x18000)
+#endif
+
 #define UART1_BASE                  (ATZ1_BASE_ADDR + 0x20000)
 #define ESAI1_BASE_ADDR             (ATZ1_BASE_ADDR + 0x24000)
 #define SSI1_BASE_ADDR              (ATZ1_BASE_ADDR + 0x28000)
@@ -121,8 +164,10 @@
 #define ASRC_BASE_ADDR              (ATZ1_BASE_ADDR + 0x34000)
 #endif
 
+#ifndef CONFIG_MX6SX
 #define SPBA_BASE_ADDR              (ATZ1_BASE_ADDR + 0x3C000)
 #define VPU_BASE_ADDR               (ATZ1_BASE_ADDR + 0x40000)
+#endif
 #define AIPS1_ON_BASE_ADDR          (ATZ1_BASE_ADDR + 0x7C000)
 
 #define AIPS1_OFF_BASE_ADDR         (ATZ1_BASE_ADDR + 0x80000)
@@ -153,27 +198,33 @@
 #define SRC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x58000)
 #define GPC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x5C000)
 #define IOMUXC_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x60000)
+#define IOMUXC_GPR_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x64000)
 #ifdef CONFIG_MX6SL
 #define CSI_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x64000)
 #define SIPIX_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define SDMA_PORT_HOST_BASE_ADDR    (AIPS1_OFF_BASE_ADDR + 0x6C000)
+
+#elif CONFIG_MX6SX
+#define CANFD1_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x68000)
+#define SDMA_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x6C000)
+#define CANFD2_BASE_ADDR            (AIPS1_OFF_BASE_ADDR + 0x70000)
+#define SEMAPHORE1_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x74000)
+#define SEMAPHORE2_BASE_ADDR        (AIPS1_OFF_BASE_ADDR + 0x78000)
+#define RDC_BASE_ADDR               (AIPS1_OFF_BASE_ADDR + 0x7C000)
+
 #else
 #define DCIC1_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x64000)
 #define DCIC2_BASE_ADDR             (AIPS1_OFF_BASE_ADDR + 0x68000)
 #define DMA_REQ_PORT_HOST_BASE_ADDR (AIPS1_OFF_BASE_ADDR + 0x6C000)
 #endif
+#define EPDC_BASE_ADDR              (AIPS1_OFF_BASE_ADDR + 0x74000)
 
 #define AIPS2_ON_BASE_ADDR          (ATZ2_BASE_ADDR + 0x7C000)
 #define AIPS2_OFF_BASE_ADDR         (ATZ2_BASE_ADDR + 0x80000)
 #define CAAM_BASE_ADDR              (ATZ2_BASE_ADDR)
 #define ARM_BASE_ADDR		    (ATZ2_BASE_ADDR + 0x40000)
-#ifdef CONFIG_MX6SL
-#define USBO2H_PL301_IPS_BASE_ADDR  (AIPS2_OFF_BASE_ADDR + 0x0000)
-#define USBO2H_USB_BASE_ADDR        (AIPS2_OFF_BASE_ADDR + 0x4000)
-#else
-#define USBOH3_PL301_BASE_ADDR      (AIPS2_OFF_BASE_ADDR + 0x0000)
-#define USBOH3_USB_BASE_ADDR        (AIPS2_OFF_BASE_ADDR + 0x4000)
-#endif
+#define USB_PL301_BASE_ADDR         (AIPS2_OFF_BASE_ADDR + 0x0000)
+#define USB_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x4000)
 
 #define ENET_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x8000)
 #ifdef CONFIG_MX6SL
@@ -193,6 +244,9 @@
 #define MMDC_P0_BASE_ADDR           (AIPS2_OFF_BASE_ADDR + 0x30000)
 #ifdef CONFIG_MX6SL
 #define RNGB_IPS_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0x34000)
+
+#elif CONFIG_MX6SX
+#define ENET2_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x34000)
 #else
 #define MMDC_P1_BASE_ADDR           (AIPS2_OFF_BASE_ADDR + 0x34000)
 #endif
@@ -202,23 +256,82 @@
 #define CSU_BASE_ADDR               (AIPS2_OFF_BASE_ADDR + 0x40000)
 #define IP2APB_PERFMON1_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x44000)
 #define IP2APB_PERFMON2_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x48000)
+#ifdef CONFIG_MX6SX
+#define DEBUG_MONITOR_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x4C000)
+#else
 #define IP2APB_PERFMON3_BASE_ADDR   (AIPS2_OFF_BASE_ADDR + 0x4C000)
+#endif
 #define IP2APB_TZASC1_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x50000)
+#ifdef CONFIG_MX6SX
+#define SAI1_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x54000)
+#else
 #define IP2APB_TZASC2_BASE_ADDR     (AIPS2_OFF_BASE_ADDR + 0x54000)
+#endif
 #define AUDMUX_BASE_ADDR            (AIPS2_OFF_BASE_ADDR + 0x58000)
+#ifdef CONFIG_MX6SX
+#define SAI2_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x5C000)
+#define QSPI1_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x60000)
+#define QSPI2_BASE_ADDR             (AIPS2_OFF_BASE_ADDR + 0x64000)
+#else
 #define MIPI_CSI2_BASE_ADDR         (AIPS2_OFF_BASE_ADDR + 0x5C000)
 #define MIPI_DSI_BASE_ADDR          (AIPS2_OFF_BASE_ADDR + 0x60000)
 #define VDOA_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x64000)
+#endif
 #define UART2_BASE                  (AIPS2_OFF_BASE_ADDR + 0x68000)
 #define UART3_BASE                  (AIPS2_OFF_BASE_ADDR + 0x6C000)
 #define UART4_BASE                  (AIPS2_OFF_BASE_ADDR + 0x70000)
 #define UART5_BASE                  (AIPS2_OFF_BASE_ADDR + 0x74000)
+#ifdef CONFIG_MX6SX
+#define I2C4_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x78000)
+#define QOSC_BASE_ADDR              (AIPS2_OFF_BASE_ADDR + 0x7C000)
+#else
 #define IP2APB_USBPHY1_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x78000)
 #define IP2APB_USBPHY2_BASE_ADDR    (AIPS2_OFF_BASE_ADDR + 0x7C000)
+#endif
+
+#define OTG_BASE_ADDR               USB_BASE_ADDR
+
+#ifdef CONFIG_MX6SX
+#define GIS_BASE_ADDR               (AIPS3_ARB_BASE_ADDR + 0x04000)
+#define DCIC1_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x0C000)
+#define DCIC2_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x10000)
+#define CSI1_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x14000)
+#define PXP_BASE_ADDR               (AIPS3_ARB_BASE_ADDR + 0x18000)
+#define CSI2_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x1C000)
+#define LCDIF1_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x20000)
+#define LCDIF2_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x24000)
+#define VADC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x28000)
+#define VDEC_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x2C000)
+#define SPBA_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x3C000)
+#define AIPS3_CONFIG_BASE_ADDR      (AIPS3_ARB_BASE_ADDR + 0x7C000)
+#define ADC1_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x80000)
+#define ADC2_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0x84000)
+#define WDOG3_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x88000)
+#define ECSPI5_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x8C000)
+#define HS_BASE_ADDR                (AIPS3_ARB_BASE_ADDR + 0x90000)
+#define MU_MCU_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x94000)
+#define CANFD_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0x98000)
+#define MU_DSP_BASE_ADDR            (AIPS3_ARB_BASE_ADDR + 0x9C000)
+#define UART6_BASE_ADDR             (AIPS3_ARB_BASE_ADDR + 0xA0000)
+#define PWM5_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xA4000)
+#define PWM6_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xA8000)
+#define PWM7_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xAC000)
+#define PWM8_BASE_ADDR              (AIPS3_ARB_BASE_ADDR + 0xB0000)
+#endif
 
 #define CHIP_REV_1_0                 0x10
+#define CHIP_REV_1_1                 0x11
+#define CHIP_REV_1_2                 0x12
+#define CHIP_REV_1_3                 0x13
+#define CHIP_REV_1_4                 0x14
+#define CHIP_REV_1_5                 0x15
+#ifndef CONFIG_MX6SX
 #define IRAM_SIZE                    0x00040000
+#else
+#define IRAM_SIZE                    0x00020000
+#endif
 #define FEC_QUIRK_ENET_MAC
+#define SNVS_LPGPR                   0x68
 
 #if !(defined(__KERNEL_STRICT_NAMES) || defined(__ASSEMBLY__))
 #include <asm/types.h>
@@ -371,6 +484,14 @@ struct iomuxc {
 #define IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0		(IOMUXC_GPR2_MODE_ENABLED_DI0<<IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET)
 #define IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI1		(IOMUXC_GPR2_MODE_ENABLED_DI1<<IOMUXC_GPR2_LVDS_CH0_MODE_OFFSET)
 
+#ifdef CONFIG_MX6SX
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_MASK			(0x3 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_EXT_PIN		(0x0 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_CVD			(0x1 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_VDAC_TO_CSI	(0x2 << 4)
+#define IMX6SX_GPR5_CSI1_MUX_CTRL_GND			(0x3 << 4)
+#endif
+
 /* ECSPI registers */
 struct cspi_regs {
 	u32 rxdata;
@@ -425,6 +546,8 @@ struct cspi_regs {
 	ECSPI5_BASE_ADDR
 #endif
 
+#define ANATOP_PLL_VIDEO        0xA0
+
 struct ocotp_regs {
 	u32	ctrl;
 	u32	ctrl_set;
@@ -463,14 +586,42 @@ struct fuse_bank0_regs {
 	u32	rsvd1[3];
 	u32	uid_high;
 	u32	rsvd2[3];
-	u32	rsvd3[4];
-	u32	rsvd4[4];
-	u32	rsvd5[4];
+	u32	cfg2;
+	u32	rsvd3[3];
+	u32	cfg3;
+	u32	rsvd4[3];
+	u32 	cfg4;
+	u32	rsvd5[3];
 	u32	cfg5;
 	u32	rsvd6[3];
-	u32	rsvd7[4];
+	u32	cfg6;
+	u32	rsvd7[3];
 };
 
+struct fuse_bank1_regs {
+	u32     mem[0x18];
+	u32	ana1;
+	u32	rsvd1[3];
+	u32     ana2;
+	u32	rsvd2[3];
+};
+
+#ifdef CONFIG_MX6SX
+struct fuse_bank4_regs {
+	u32 sjc_resp_low;
+	u32 rsvd0[3];
+	u32 sjc_resp_high;
+	u32 rsvd1[3];
+	u32 mac_addr0;
+	u32 rsvd2[3];
+	u32 mac_addr1;
+	u32 rsvd3[3];
+	u32 mac_addr2;
+	u32 rsvd4[7];
+	u32 gp1;
+	u32 rsvd5[7];
+};
+#else
 struct fuse_bank4_regs {
 	u32	sjc_resp_low;
 	u32     rsvd0[3];
@@ -485,6 +636,7 @@ struct fuse_bank4_regs {
 	u32	gp2;
 	u32	rsvd5[3];
 };
+#endif
 
 struct aipstz_regs {
 	u32	mprot0;
@@ -497,150 +649,6 @@ struct aipstz_regs {
 	u32	opacr4;
 };
 
-struct anatop_regs {
-	u32	pll_sys;		/* 0x000 */
-	u32	pll_sys_set;		/* 0x004 */
-	u32	pll_sys_clr;		/* 0x008 */
-	u32	pll_sys_tog;		/* 0x00c */
-	u32	usb1_pll_480_ctrl;	/* 0x010 */
-	u32	usb1_pll_480_ctrl_set;	/* 0x014 */
-	u32	usb1_pll_480_ctrl_clr;	/* 0x018 */
-	u32	usb1_pll_480_ctrl_tog;	/* 0x01c */
-	u32	usb2_pll_480_ctrl;	/* 0x020 */
-	u32	usb2_pll_480_ctrl_set;	/* 0x024 */
-	u32	usb2_pll_480_ctrl_clr;	/* 0x028 */
-	u32	usb2_pll_480_ctrl_tog;	/* 0x02c */
-	u32	pll_528;		/* 0x030 */
-	u32	pll_528_set;		/* 0x034 */
-	u32	pll_528_clr;		/* 0x038 */
-	u32	pll_528_tog;		/* 0x03c */
-	u32	pll_528_ss;		/* 0x040 */
-	u32	rsvd0[3];
-	u32	pll_528_num;		/* 0x050 */
-	u32	rsvd1[3];
-	u32	pll_528_denom;		/* 0x060 */
-	u32	rsvd2[3];
-	u32	pll_audio;		/* 0x070 */
-	u32	pll_audio_set;		/* 0x074 */
-	u32	pll_audio_clr;		/* 0x078 */
-	u32	pll_audio_tog;		/* 0x07c */
-	u32	pll_audio_num;		/* 0x080 */
-	u32	rsvd3[3];
-	u32	pll_audio_denom;	/* 0x090 */
-	u32	rsvd4[3];
-	u32	pll_video;		/* 0x0a0 */
-	u32	pll_video_set;		/* 0x0a4 */
-	u32	pll_video_clr;		/* 0x0a8 */
-	u32	pll_video_tog;		/* 0x0ac */
-	u32	pll_video_num;		/* 0x0b0 */
-	u32	rsvd5[3];
-	u32	pll_video_denom;	/* 0x0c0 */
-	u32	rsvd6[3];
-	u32	pll_mlb;		/* 0x0d0 */
-	u32	pll_mlb_set;		/* 0x0d4 */
-	u32	pll_mlb_clr;		/* 0x0d8 */
-	u32	pll_mlb_tog;		/* 0x0dc */
-	u32	pll_enet;		/* 0x0e0 */
-	u32	pll_enet_set;		/* 0x0e4 */
-	u32	pll_enet_clr;		/* 0x0e8 */
-	u32	pll_enet_tog;		/* 0x0ec */
-	u32	pfd_480;		/* 0x0f0 */
-	u32	pfd_480_set;		/* 0x0f4 */
-	u32	pfd_480_clr;		/* 0x0f8 */
-	u32	pfd_480_tog;		/* 0x0fc */
-	u32	pfd_528;		/* 0x100 */
-	u32	pfd_528_set;		/* 0x104 */
-	u32	pfd_528_clr;		/* 0x108 */
-	u32	pfd_528_tog;		/* 0x10c */
-	u32	reg_1p1;		/* 0x110 */
-	u32	reg_1p1_set;		/* 0x114 */
-	u32	reg_1p1_clr;		/* 0x118 */
-	u32	reg_1p1_tog;		/* 0x11c */
-	u32	reg_3p0;		/* 0x120 */
-	u32	reg_3p0_set;		/* 0x124 */
-	u32	reg_3p0_clr;		/* 0x128 */
-	u32	reg_3p0_tog;		/* 0x12c */
-	u32	reg_2p5;		/* 0x130 */
-	u32	reg_2p5_set;		/* 0x134 */
-	u32	reg_2p5_clr;		/* 0x138 */
-	u32	reg_2p5_tog;		/* 0x13c */
-	u32	reg_core;		/* 0x140 */
-	u32	reg_core_set;		/* 0x144 */
-	u32	reg_core_clr;		/* 0x148 */
-	u32	reg_core_tog;		/* 0x14c */
-	u32	ana_misc0;		/* 0x150 */
-	u32	ana_misc0_set;		/* 0x154 */
-	u32	ana_misc0_clr;		/* 0x158 */
-	u32	ana_misc0_tog;		/* 0x15c */
-	u32	ana_misc1;		/* 0x160 */
-	u32	ana_misc1_set;		/* 0x164 */
-	u32	ana_misc1_clr;		/* 0x168 */
-	u32	ana_misc1_tog;		/* 0x16c */
-	u32	ana_misc2;		/* 0x170 */
-	u32	ana_misc2_set;		/* 0x174 */
-	u32	ana_misc2_clr;		/* 0x178 */
-	u32	ana_misc2_tog;		/* 0x17c */
-	u32	tempsense0;		/* 0x180 */
-	u32	tempsense0_set;		/* 0x184 */
-	u32	tempsense0_clr;		/* 0x188 */
-	u32	tempsense0_tog;		/* 0x18c */
-	u32	tempsense1;		/* 0x190 */
-	u32	tempsense1_set;		/* 0x194 */
-	u32	tempsense1_clr;		/* 0x198 */
-	u32	tempsense1_tog;		/* 0x19c */
-	u32	usb1_vbus_detect;	/* 0x1a0 */
-	u32	usb1_vbus_detect_set;	/* 0x1a4 */
-	u32	usb1_vbus_detect_clr;	/* 0x1a8 */
-	u32	usb1_vbus_detect_tog;	/* 0x1ac */
-	u32	usb1_chrg_detect;	/* 0x1b0 */
-	u32	usb1_chrg_detect_set;	/* 0x1b4 */
-	u32	usb1_chrg_detect_clr;	/* 0x1b8 */
-	u32	usb1_chrg_detect_tog;	/* 0x1bc */
-	u32	usb1_vbus_det_stat;	/* 0x1c0 */
-	u32	usb1_vbus_det_stat_set;	/* 0x1c4 */
-	u32	usb1_vbus_det_stat_clr;	/* 0x1c8 */
-	u32	usb1_vbus_det_stat_tog;	/* 0x1cc */
-	u32	usb1_chrg_det_stat;	/* 0x1d0 */
-	u32	usb1_chrg_det_stat_set;	/* 0x1d4 */
-	u32	usb1_chrg_det_stat_clr;	/* 0x1d8 */
-	u32	usb1_chrg_det_stat_tog;	/* 0x1dc */
-	u32	usb1_loopback;		/* 0x1e0 */
-	u32	usb1_loopback_set;	/* 0x1e4 */
-	u32	usb1_loopback_clr;	/* 0x1e8 */
-	u32	usb1_loopback_tog;	/* 0x1ec */
-	u32	usb1_misc;		/* 0x1f0 */
-	u32	usb1_misc_set;		/* 0x1f4 */
-	u32	usb1_misc_clr;		/* 0x1f8 */
-	u32	usb1_misc_tog;		/* 0x1fc */
-	u32	usb2_vbus_detect;	/* 0x200 */
-	u32	usb2_vbus_detect_set;	/* 0x204 */
-	u32	usb2_vbus_detect_clr;	/* 0x208 */
-	u32	usb2_vbus_detect_tog;	/* 0x20c */
-	u32	usb2_chrg_detect;	/* 0x210 */
-	u32	usb2_chrg_detect_set;	/* 0x214 */
-	u32	usb2_chrg_detect_clr;	/* 0x218 */
-	u32	usb2_chrg_detect_tog;	/* 0x21c */
-	u32	usb2_vbus_det_stat;	/* 0x220 */
-	u32	usb2_vbus_det_stat_set;	/* 0x224 */
-	u32	usb2_vbus_det_stat_clr;	/* 0x228 */
-	u32	usb2_vbus_det_stat_tog;	/* 0x22c */
-	u32	usb2_chrg_det_stat;	/* 0x230 */
-	u32	usb2_chrg_det_stat_set;	/* 0x234 */
-	u32	usb2_chrg_det_stat_clr;	/* 0x238 */
-	u32	usb2_chrg_det_stat_tog;	/* 0x23c */
-	u32	usb2_loopback;		/* 0x240 */
-	u32	usb2_loopback_set;	/* 0x244 */
-	u32	usb2_loopback_clr;	/* 0x248 */
-	u32	usb2_loopback_tog;	/* 0x24c */
-	u32	usb2_misc;		/* 0x250 */
-	u32	usb2_misc_set;		/* 0x254 */
-	u32	usb2_misc_clr;		/* 0x258 */
-	u32	usb2_misc_tog;		/* 0x25c */
-	u32	digprog;		/* 0x260 */
-	u32	reserved1[7];
-	u32	digprog_sololite;	/* 0x280 */
-};
-
 #define ANATOP_PFD_FRAC_SHIFT(n)	((n)*8)
 #define ANATOP_PFD_FRAC_MASK(n)	(0x3f<<ANATOP_PFD_FRAC_SHIFT(n))
 #define ANATOP_PFD_STABLE_SHIFT(n)	(6+((n)*8))
@@ -648,8 +656,14 @@ struct anatop_regs {
 #define ANATOP_PFD_CLKGATE_SHIFT(n)	(7+((n)*8))
 #define ANATOP_PFD_CLKGATE_MASK(n)	(1<<ANATOP_PFD_CLKGATE_SHIFT(n))
 
+struct iomuxc_gpr_base_regs {
+	u32     gpr[14];        /* 0x000 */
+};
+
 struct iomuxc_base_regs {
+#ifndef CONFIG_MX6SX
 	u32     gpr[14];        /* 0x000 */
+#endif
 	u32     obsrv[5];       /* 0x038 */
 	u32     swmux_ctl[197]; /* 0x04c */
 	u32     swpad_ctl[250]; /* 0x360 */
@@ -665,5 +679,297 @@ struct wdog_regs {
 	u16	wmcr;	/* Miscellaneous Control */
 };
 
+struct dbg_monitor_regs {
+	u32	ctrl[4];		/* Control */
+	u32	master_en[4];		/* Master enable */
+	u32	irq[4];			/* IRQ */
+	u32	trap_addr_low[4];	/* Trap address low */
+	u32	trap_addr_high[4];	/* Trap address high */
+	u32	trap_id[4];		/* Trap ID */
+	u32	snvs_addr[4];		/* SNVS address */
+	u32	snvs_data[4];		/* SNVS data */
+	u32	snvs_info[4];		/* SNVS info */
+	u32	version[4];		/* Version */
+};
+
+struct rdc_regs {
+	u32	vir;		/* Version information */
+	u32	reserved1[8];
+	u32	stat;		/* Status */
+	u32	intctrl;	/* Interrupt and Control */
+	u32	intstat;	/* Interrupt Status */
+	u32	reserved2[116];
+	u32	mda[32];		/* Master Domain Assignment */
+	u32	reserved3[96];
+	u32	pdap[104];		/* Peripheral Domain Access Permissions */
+	u32	reserved4[88];
+	struct {
+		u32 mrsa;		/* Memory Region Start Address */
+		u32 mrea;		/* Memory Region End Address */
+		u32 mrc;		/* Memory Region Control */
+		u32 mrvs;		/* Memory Region Violation Status */
+	} mem_region[55];
+};
+
+struct rdc_sema_regs {
+	u8	gate[64];	/* Gate */
+	u16	rstgt;		/* Reset Gate */
+};
+
+/* eLCDIF controller registers */
+struct mxs_lcdif_regs {
+	u32	hw_lcdif_ctrl;			/* 0x00 */
+	u32	hw_lcdif_ctrl_set;
+	u32	hw_lcdif_ctrl_clr;
+	u32	hw_lcdif_ctrl_tog;
+	u32	hw_lcdif_ctrl1;			/* 0x10 */
+	u32	hw_lcdif_ctrl1_set;
+	u32	hw_lcdif_ctrl1_clr;
+	u32	hw_lcdif_ctrl1_tog;
+	u32	hw_lcdif_ctrl2;			/* 0x20 */
+	u32	hw_lcdif_ctrl2_set;
+	u32	hw_lcdif_ctrl2_clr;
+	u32	hw_lcdif_ctrl2_tog;
+	u32	hw_lcdif_transfer_count;	/* 0x30 */
+	u32	reserved1[3];
+	u32	hw_lcdif_cur_buf;		/* 0x40 */
+	u32	reserved2[3];
+	u32	hw_lcdif_next_buf;		/* 0x50 */
+	u32	reserved3[3];
+	u32	hw_lcdif_timing;		/* 0x60 */
+	u32	reserved4[3];
+	u32	hw_lcdif_vdctrl0;		/* 0x70 */
+	u32	hw_lcdif_vdctrl0_set;
+	u32	hw_lcdif_vdctrl0_clr;
+	u32	hw_lcdif_vdctrl0_tog;
+	u32	hw_lcdif_vdctrl1;		/* 0x80 */
+	u32	reserved5[3];
+	u32	hw_lcdif_vdctrl2;		/* 0x90 */
+	u32	reserved6[3];
+	u32	hw_lcdif_vdctrl3;		/* 0xa0 */
+	u32	reserved7[3];
+	u32	hw_lcdif_vdctrl4;		/* 0xb0 */
+	u32	reserved8[3];
+	u32	hw_lcdif_dvictrl0;		/* 0xc0 */
+	u32	reserved9[3];
+	u32	hw_lcdif_dvictrl1;		/* 0xd0 */
+	u32	reserved10[3];
+	u32	hw_lcdif_dvictrl2;		/* 0xe0 */
+	u32	reserved11[3];
+	u32	hw_lcdif_dvictrl3;		/* 0xf0 */
+	u32	reserved12[3];
+	u32	hw_lcdif_dvictrl4;		/* 0x100 */
+	u32	reserved13[3];
+	u32	hw_lcdif_csc_coeffctrl0;	/* 0x110 */
+	u32	reserved14[3];
+	u32	hw_lcdif_csc_coeffctrl1;	/* 0x120 */
+	u32	reserved15[3];
+	u32	hw_lcdif_csc_coeffctrl2;	/* 0x130 */
+	u32	reserved16[3];
+	u32	hw_lcdif_csc_coeffctrl3;	/* 0x140 */
+	u32	reserved17[3];
+	u32	hw_lcdif_csc_coeffctrl4;	/* 0x150 */
+	u32	reserved18[3];
+	u32	hw_lcdif_csc_offset;	/* 0x160 */
+	u32	reserved19[3];
+	u32	hw_lcdif_csc_limit;		/* 0x170 */
+	u32	reserved20[3];
+	u32	hw_lcdif_data;			/* 0x180 */
+	u32	reserved21[3];
+	u32	hw_lcdif_bm_error_stat;	/* 0x190 */
+	u32	reserved22[3];
+	u32	hw_lcdif_crc_stat;		/* 0x1a0 */
+	u32	reserved23[3];
+	u32	hw_lcdif_lcdif_stat;	/* 0x1b0 */
+	u32	reserved24[3];
+	u32	hw_lcdif_version;		/* 0x1c0 */
+	u32	reserved25[3];
+	u32	hw_lcdif_debug0;		/* 0x1d0 */
+	u32	reserved26[3];
+	u32	hw_lcdif_debug1;		/* 0x1e0 */
+	u32	reserved27[3];
+	u32	hw_lcdif_debug2;		/* 0x1f0 */
+	u32	reserved28[3];
+	u32	hw_lcdif_thres;			/* 0x200 */
+	u32	reserved29[3];
+	u32	hw_lcdif_as_ctrl;		/* 0x210 */
+	u32	reserved30[3];
+	u32	hw_lcdif_as_buf;		/* 0x220 */
+	u32	reserved31[3];
+	u32	hw_lcdif_as_next_buf;	/* 0x230 */
+	u32	reserved32[3];
+	u32	hw_lcdif_as_clrkeylow;	/* 0x240 */
+	u32	reserved33[3];
+	u32	hw_lcdif_as_clrkeyhigh;	/* 0x250 */
+	u32	reserved34[3];
+	u32	hw_lcdif_as_sync_delay;	/* 0x260 */
+	u32	reserved35[3];
+	u32	hw_lcdif_as_debug3;		/* 0x270 */
+	u32	reserved36[3];
+	u32	hw_lcdif_as_debug4;		/* 0x280 */
+	u32	reserved37[3];
+	u32	hw_lcdif_as_debug5;		/* 0x290 */
+};
+
+#define MXS_LCDIF_BASE LCDIF2_BASE_ADDR
+
+#define	LCDIF_CTRL_SFTRST					(1 << 31)
+#define	LCDIF_CTRL_CLKGATE					(1 << 30)
+#define	LCDIF_CTRL_YCBCR422_INPUT				(1 << 29)
+#define	LCDIF_CTRL_READ_WRITEB					(1 << 28)
+#define	LCDIF_CTRL_WAIT_FOR_VSYNC_EDGE				(1 << 27)
+#define	LCDIF_CTRL_DATA_SHIFT_DIR				(1 << 26)
+#define	LCDIF_CTRL_SHIFT_NUM_BITS_MASK				(0x1f << 21)
+#define	LCDIF_CTRL_SHIFT_NUM_BITS_OFFSET			21
+#define	LCDIF_CTRL_DVI_MODE					(1 << 20)
+#define	LCDIF_CTRL_BYPASS_COUNT					(1 << 19)
+#define	LCDIF_CTRL_VSYNC_MODE					(1 << 18)
+#define	LCDIF_CTRL_DOTCLK_MODE					(1 << 17)
+#define	LCDIF_CTRL_DATA_SELECT					(1 << 16)
+#define	LCDIF_CTRL_INPUT_DATA_SWIZZLE_MASK			(0x3 << 14)
+#define	LCDIF_CTRL_INPUT_DATA_SWIZZLE_OFFSET			14
+#define	LCDIF_CTRL_CSC_DATA_SWIZZLE_MASK			(0x3 << 12)
+#define	LCDIF_CTRL_CSC_DATA_SWIZZLE_OFFSET			12
+#define	LCDIF_CTRL_LCD_DATABUS_WIDTH_MASK			(0x3 << 10)
+#define	LCDIF_CTRL_LCD_DATABUS_WIDTH_OFFSET			10
+#define	LCDIF_CTRL_LCD_DATABUS_WIDTH_16BIT			(0 << 10)
+#define	LCDIF_CTRL_LCD_DATABUS_WIDTH_8BIT			(1 << 10)
+#define	LCDIF_CTRL_LCD_DATABUS_WIDTH_18BIT			(2 << 10)
+#define	LCDIF_CTRL_LCD_DATABUS_WIDTH_24BIT			(3 << 10)
+#define	LCDIF_CTRL_WORD_LENGTH_MASK				(0x3 << 8)
+#define	LCDIF_CTRL_WORD_LENGTH_OFFSET				8
+#define	LCDIF_CTRL_WORD_LENGTH_16BIT				(0 << 8)
+#define	LCDIF_CTRL_WORD_LENGTH_8BIT				(1 << 8)
+#define	LCDIF_CTRL_WORD_LENGTH_18BIT				(2 << 8)
+#define	LCDIF_CTRL_WORD_LENGTH_24BIT				(3 << 8)
+#define	LCDIF_CTRL_RGB_TO_YCBCR422_CSC				(1 << 7)
+#define	LCDIF_CTRL_LCDIF_MASTER					(1 << 5)
+#define	LCDIF_CTRL_DATA_FORMAT_16_BIT				(1 << 3)
+#define	LCDIF_CTRL_DATA_FORMAT_18_BIT				(1 << 2)
+#define	LCDIF_CTRL_DATA_FORMAT_24_BIT				(1 << 1)
+#define	LCDIF_CTRL_RUN						(1 << 0)
+
+#define	LCDIF_CTRL1_COMBINE_MPU_WR_STRB				(1 << 27)
+#define	LCDIF_CTRL1_BM_ERROR_IRQ_EN				(1 << 26)
+#define	LCDIF_CTRL1_BM_ERROR_IRQ				(1 << 25)
+#define	LCDIF_CTRL1_RECOVER_ON_UNDERFLOW			(1 << 24)
+#define	LCDIF_CTRL1_INTERLACE_FIELDS				(1 << 23)
+#define	LCDIF_CTRL1_START_INTERLACE_FROM_SECOND_FIELD		(1 << 22)
+#define	LCDIF_CTRL1_FIFO_CLEAR					(1 << 21)
+#define	LCDIF_CTRL1_IRQ_ON_ALTERNATE_FIELDS			(1 << 20)
+#define	LCDIF_CTRL1_BYTE_PACKING_FORMAT_MASK			(0xf << 16)
+#define	LCDIF_CTRL1_BYTE_PACKING_FORMAT_OFFSET			16
+#define	LCDIF_CTRL1_OVERFLOW_IRQ_EN				(1 << 15)
+#define	LCDIF_CTRL1_UNDERFLOW_IRQ_EN				(1 << 14)
+#define	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ_EN			(1 << 13)
+#define	LCDIF_CTRL1_VSYNC_EDGE_IRQ_EN				(1 << 12)
+#define	LCDIF_CTRL1_OVERFLOW_IRQ				(1 << 11)
+#define	LCDIF_CTRL1_UNDERFLOW_IRQ				(1 << 10)
+#define	LCDIF_CTRL1_CUR_FRAME_DONE_IRQ				(1 << 9)
+#define	LCDIF_CTRL1_VSYNC_EDGE_IRQ				(1 << 8)
+#define	LCDIF_CTRL1_BUSY_ENABLE					(1 << 2)
+#define	LCDIF_CTRL1_MODE86					(1 << 1)
+#define	LCDIF_CTRL1_RESET					(1 << 0)
+
+#define	LCDIF_CTRL2_OUTSTANDING_REQS_MASK			(0x7 << 21)
+#define	LCDIF_CTRL2_OUTSTANDING_REQS_OFFSET			21
+#define	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_1			(0x0 << 21)
+#define	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_2			(0x1 << 21)
+#define	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_4			(0x2 << 21)
+#define	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_8			(0x3 << 21)
+#define	LCDIF_CTRL2_OUTSTANDING_REQS_REQ_16			(0x4 << 21)
+#define	LCDIF_CTRL2_BURST_LEN_8					(1 << 20)
+#define	LCDIF_CTRL2_ODD_LINE_PATTERN_MASK			(0x7 << 16)
+#define	LCDIF_CTRL2_ODD_LINE_PATTERN_OFFSET			16
+#define	LCDIF_CTRL2_ODD_LINE_PATTERN_RGB			(0x0 << 16)
+#define	LCDIF_CTRL2_ODD_LINE_PATTERN_RBG			(0x1 << 16)
+#define	LCDIF_CTRL2_ODD_LINE_PATTERN_GBR			(0x2 << 16)
+#define	LCDIF_CTRL2_ODD_LINE_PATTERN_GRB			(0x3 << 16)
+#define	LCDIF_CTRL2_ODD_LINE_PATTERN_BRG			(0x4 << 16)
+#define	LCDIF_CTRL2_ODD_LINE_PATTERN_BGR			(0x5 << 16)
+#define	LCDIF_CTRL2_EVEN_LINE_PATTERN_MASK			(0x7 << 12)
+#define	LCDIF_CTRL2_EVEN_LINE_PATTERN_OFFSET			12
+#define	LCDIF_CTRL2_EVEN_LINE_PATTERN_RGB			(0x0 << 12)
+#define	LCDIF_CTRL2_EVEN_LINE_PATTERN_RBG			(0x1 << 12)
+#define	LCDIF_CTRL2_EVEN_LINE_PATTERN_GBR			(0x2 << 12)
+#define	LCDIF_CTRL2_EVEN_LINE_PATTERN_GRB			(0x3 << 12)
+#define	LCDIF_CTRL2_EVEN_LINE_PATTERN_BRG			(0x4 << 12)
+#define	LCDIF_CTRL2_EVEN_LINE_PATTERN_BGR			(0x5 << 12)
+#define	LCDIF_CTRL2_READ_PACK_DIR				(1 << 10)
+#define	LCDIF_CTRL2_READ_MODE_OUTPUT_IN_RGB_FORMAT		(1 << 9)
+#define	LCDIF_CTRL2_READ_MODE_6_BIT_INPUT			(1 << 8)
+#define	LCDIF_CTRL2_READ_MODE_NUM_PACKED_SUBWORDS_MASK		(0x7 << 4)
+#define	LCDIF_CTRL2_READ_MODE_NUM_PACKED_SUBWORDS_OFFSET	4
+#define	LCDIF_CTRL2_INITIAL_DUMMY_READ_MASK			(0x7 << 1)
+#define	LCDIF_CTRL2_INITIAL_DUMMY_READ_OFFSET			1
+
+#define	LCDIF_TRANSFER_COUNT_V_COUNT_MASK			(0xffff << 16)
+#define	LCDIF_TRANSFER_COUNT_V_COUNT_OFFSET			16
+#define	LCDIF_TRANSFER_COUNT_H_COUNT_MASK			(0xffff << 0)
+#define	LCDIF_TRANSFER_COUNT_H_COUNT_OFFSET			0
+
+#define	LCDIF_CUR_BUF_ADDR_MASK					0xffffffff
+#define	LCDIF_CUR_BUF_ADDR_OFFSET				0
+
+#define	LCDIF_NEXT_BUF_ADDR_MASK				0xffffffff
+#define	LCDIF_NEXT_BUF_ADDR_OFFSET				0
+
+#define	LCDIF_TIMING_CMD_HOLD_MASK				(0xff << 24)
+#define	LCDIF_TIMING_CMD_HOLD_OFFSET				24
+#define	LCDIF_TIMING_CMD_SETUP_MASK				(0xff << 16)
+#define	LCDIF_TIMING_CMD_SETUP_OFFSET				16
+#define	LCDIF_TIMING_DATA_HOLD_MASK				(0xff << 8)
+#define	LCDIF_TIMING_DATA_HOLD_OFFSET				8
+#define	LCDIF_TIMING_DATA_SETUP_MASK				(0xff << 0)
+#define	LCDIF_TIMING_DATA_SETUP_OFFSET				0
+
+#define	LCDIF_VDCTRL0_VSYNC_OEB					(1 << 29)
+#define	LCDIF_VDCTRL0_ENABLE_PRESENT				(1 << 28)
+#define	LCDIF_VDCTRL0_VSYNC_POL					(1 << 27)
+#define	LCDIF_VDCTRL0_HSYNC_POL					(1 << 26)
+#define	LCDIF_VDCTRL0_DOTCLK_POL				(1 << 25)
+#define	LCDIF_VDCTRL0_ENABLE_POL				(1 << 24)
+#define	LCDIF_VDCTRL0_VSYNC_PERIOD_UNIT				(1 << 21)
+#define	LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_UNIT			(1 << 20)
+#define	LCDIF_VDCTRL0_HALF_LINE					(1 << 19)
+#define	LCDIF_VDCTRL0_HALF_LINE_MODE				(1 << 18)
+#define	LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_MASK			0x3ffff
+#define	LCDIF_VDCTRL0_VSYNC_PULSE_WIDTH_OFFSET			0
+
+#define	LCDIF_VDCTRL1_VSYNC_PERIOD_MASK				0xffffffff
+#define	LCDIF_VDCTRL1_VSYNC_PERIOD_OFFSET			0
+
+#define	LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH_MASK			(0x3fff << 18)
+#define	LCDIF_VDCTRL2_HSYNC_PULSE_WIDTH_OFFSET			18
+#define	LCDIF_VDCTRL2_HSYNC_PERIOD_MASK				0x3ffff
+#define	LCDIF_VDCTRL2_HSYNC_PERIOD_OFFSET			0
+
+#define	LCDIF_VDCTRL3_MUX_SYNC_SIGNALS				(1 << 29)
+#define	LCDIF_VDCTRL3_VSYNC_ONLY				(1 << 28)
+#define	LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT_MASK			(0xfff << 16)
+#define	LCDIF_VDCTRL3_HORIZONTAL_WAIT_CNT_OFFSET		16
+#define	LCDIF_VDCTRL3_VERTICAL_WAIT_CNT_MASK			(0xffff << 0)
+#define	LCDIF_VDCTRL3_VERTICAL_WAIT_CNT_OFFSET			0
+
+#define	LCDIF_VDCTRL4_DOTCLK_DLY_SEL_MASK			(0x7 << 29)
+#define	LCDIF_VDCTRL4_DOTCLK_DLY_SEL_OFFSET			29
+#define	LCDIF_VDCTRL4_SYNC_SIGNALS_ON				(1 << 18)
+#define	LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT_MASK		0x3ffff
+#define	LCDIF_VDCTRL4_DOTCLK_H_VALID_DATA_CNT_OFFSET		0
+
+
+extern void check_cpu_temperature(void);
+#ifdef CONFIG_MX6SX
+extern void vadc_power_up(void);
+extern void vadc_power_down(void);
+extern void pcie_power_up(void);
+extern void pcie_power_off(void);
+#endif
+
+/* If ROM fail back to USB recover mode, USBPH0_PWD will be clear to use USB
+ * If boot from the other mode, USB0_PWD will keep reset value
+ */
+#define  is_boot_from_usb(void) (!(readl(USB_PHY0_BASE_ADDR) & (1<<20)))
+
 #endif /* __ASSEMBLER__*/
 #endif /* __ASM_ARCH_MX6_IMX_REGS_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/iomux.h b/arch/arm/include/asm/arch-mx6/iomux.h
index f9ee0d9..dba2186 100644
--- a/arch/arm/include/asm/arch-mx6/iomux.h
+++ b/arch/arm/include/asm/arch-mx6/iomux.h
@@ -19,6 +19,12 @@
 #define IOMUXC_GPR1_TEST_POWERDOWN		(1 << 18)
 
 /*
+ * IOMUXC_GPR5 bit fields
+ */
+#define IOMUXC_GPR5_PCIE_BTNRST		(1 << 19)
+#define IOMUXC_GPR5_PCIE_PERST		(1 << 18)
+
+/*
  * IOMUXC_GPR8 bit fields
  */
 #define IOMUXC_GPR8_PCS_TX_DEEMPH_GEN1_MASK		(0x3f << 0)
@@ -35,12 +41,15 @@
 /*
  * IOMUXC_GPR12 bit fields
  */
+#define IOMUXC_GPR12_RX_EQ_2		(0x2 << 0)
+#define IOMUXC_GPR12_RX_EQ_MASK		(0x7 << 0)
 #define IOMUXC_GPR12_LOS_LEVEL_9		(0x9 << 4)
 #define IOMUXC_GPR12_LOS_LEVEL_MASK		(0x1f << 4)
 #define IOMUXC_GPR12_APPS_LTSSM_ENABLE		(1 << 10)
 #define IOMUXC_GPR12_DEVICE_TYPE_EP		(0x0 << 12)
-#define IOMUXC_GPR12_DEVICE_TYPE_RC		(0x2 << 12)
+#define IOMUXC_GPR12_DEVICE_TYPE_RC		(0x4 << 12)
 #define IOMUXC_GPR12_DEVICE_TYPE_MASK		(0xf << 12)
+#define IOMUXC_GPR12_TEST_POWERDOWN		(1 << 30)
 
 /*
  * IOMUXC_GPR13 bit fields
@@ -65,6 +74,16 @@
 #define IOMUX_GPR1_FEC_MASK    (IOMUX_GPR1_FEC_CLOCK_MUX1_SEL_MASK \
 				| IOMUX_GPR1_FEC_CLOCK_MUX2_SEL_MASK)
 
+#define IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK (0x1 << 17)
+#define IOMUX_GPR1_FEC1_CLOCK_MUX2_SEL_MASK (0x1 << 13)
+#define IOMUX_GPR1_FEC1_MASK	(IOMUX_GPR1_FEC1_CLOCK_MUX1_SEL_MASK \
+				| IOMUX_GPR1_FEC1_CLOCK_MUX2_SEL_MASK)
+
+#define IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK (0x1 << 18)
+#define IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK (0x1 << 14)
+#define IOMUX_GPR1_FEC2_MASK	(IOMUX_GPR1_FEC2_CLOCK_MUX1_SEL_MASK \
+				| IOMUX_GPR1_FEC2_CLOCK_MUX2_SEL_MASK)
+
 #define IOMUXC_GPR13_SATA_PHY_8_RXEQ_0P5DB	(0<<24)
 #define IOMUXC_GPR13_SATA_PHY_8_RXEQ_1P0DB	(1<<24)
 #define IOMUXC_GPR13_SATA_PHY_8_RXEQ_1P5DB	(2<<24)
@@ -157,4 +176,5 @@
 				|IOMUXC_GPR13_SATA_PHY_3_MASK \
 				|IOMUXC_GPR13_SATA_PHY_2_MASK \
 				|IOMUXC_GPR13_SATA_PHY_1_MASK)
+
 #endif	/* __ASM_ARCH_IOMUX_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/mx6-ddr.h b/arch/arm/include/asm/arch-mx6/mx6-ddr.h
index 43d377a..f034028 100644
--- a/arch/arm/include/asm/arch-mx6/mx6-ddr.h
+++ b/arch/arm/include/asm/arch-mx6/mx6-ddr.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2013 Boundary Devices Inc.
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -12,7 +13,11 @@
 #if defined(CONFIG_MX6DL) || defined(CONFIG_MX6S)
 #include "mx6dl-ddr.h"
 #else
+#if CONFIG_MX6SX
+#include "mx6sx-ddr.h"
+#else
 #error "Please select cpu"
+#endif	/* CONFIG_MX6SX */
 #endif	/* CONFIG_MX6DL or CONFIG_MX6S */
 #endif	/* CONFIG_MX6Q */
 
diff --git a/arch/arm/include/asm/arch-mx6/mx6-pins.h b/arch/arm/include/asm/arch-mx6/mx6-pins.h
index dcd7f8f..25c162b 100644
--- a/arch/arm/include/asm/arch-mx6/mx6-pins.h
+++ b/arch/arm/include/asm/arch-mx6/mx6-pins.h
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2013 Boundary Devices Inc.
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -35,6 +36,8 @@ enum {
 };
 #elif defined(CONFIG_MX6SL)
 #include "mx6sl_pins.h"
+#elif defined(CONFIG_MX6SX)
+#include "mx6sx_pins.h"
 #else
 #error "Please select cpu"
 #endif	/* CONFIG_MX6Q */
diff --git a/arch/arm/include/asm/arch-mx6/mx6_plugin.S b/arch/arm/include/asm/arch-mx6/mx6_plugin.S
new file mode 100644
index 0000000..1f5ae83
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6_plugin.S
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <config.h>
+
+#ifdef CONFIG_ROM_UNIFIED_SECTIONS
+#define ROM_API_TABLE_BASE_ADDR_LEGACY		0x180
+#define ROM_VERSION_OFFSET               	0x80
+#else
+#define ROM_API_TABLE_BASE_ADDR_LEGACY		0xC0
+#define ROM_VERSION_OFFSET               	0x48
+#endif
+#define ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15	0xC4
+#define ROM_API_TABLE_BASE_ADDR_MX6DL_TO12	0xC4
+#define ROM_API_HWCNFG_SETUP_OFFSET		0x08
+#define ROM_VERSION_TO10			0x10
+#define ROM_VERSION_TO12			0x12
+#define ROM_VERSION_TO15			0x15
+
+plugin_start:
+
+	push    {r0-r4, lr}
+
+	imx6_ddr_setting
+	imx6_clock_gating
+	imx6_qos_setting
+
+/*
+ * The following is to fill in those arguments for this ROM function
+ * pu_irom_hwcnfg_setup(void **start, size_t *bytes, const void *boot_data)
+ * This function is used to copy data from the storage media into DDR.
+ * start - Initial (possibly partial) image load address on entry.
+ *         Final image load address on exit.
+ * bytes - Initial (possibly partial) image size on entry.
+ *         Final image size on exit.
+ * boot_data - Initial @ref ivt Boot Data load address.
+ */
+	adr r0, boot_data2
+	adr r1, image_len2
+	adr r2, boot_data2
+
+#ifdef CONFIG_SYS_BOOT_EIMNOR
+#ifdef CONFIG_MX6SX
+	ldr r3, =ROM_VERSION_OFFSET
+	ldr r4, [r3]
+	cmp r4, #ROM_VERSION_TO10
+	bgt before_calling_rom___pu_irom_hwcnfg_setup
+	ldr r3, =0x00900b00
+	ldr r4, =0x50000000
+	str r4, [r3, #0x5c]
+#else
+	ldr r3, =0x00900800
+	ldr r4, =0x08000000
+	str r4, [r3, #0xc0]
+#endif
+#endif
+
+/*
+ * check the _pu_irom_api_table for the address
+ */
+before_calling_rom___pu_irom_hwcnfg_setup:
+	ldr r3, =ROM_VERSION_OFFSET
+	ldr r4, [r3]
+#if defined(CONFIG_MX6SOLO) || defined(CONFIG_MX6DL)
+	ldr r3, =ROM_VERSION_TO12
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DL_TO12
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#elif defined(CONFIG_MX6Q)
+	ldr r3, =ROM_VERSION_TO15
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#else
+	ldr r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#endif
+	ldr r4, [r3, #ROM_API_HWCNFG_SETUP_OFFSET]
+	blx r4
+after_calling_rom___pu_irom_hwcnfg_setup:
+
+
+/* To return to ROM from plugin, we need to fill in these argument.
+ * Here is what need to do:
+ * Need to construct the paramters for this function before return to ROM:
+ * plugin_download(void **start, size_t *bytes, UINT32 *ivt_offset)
+ */
+	pop {r0-r4, lr}
+	push {r5}
+	ldr r5, boot_data2
+	str r5, [r0]
+	ldr r5, image_len2
+	str r5, [r1]
+	ldr r5, second_ivt_offset
+	str r5, [r2]
+	mov r0, #1
+	pop {r5}
+
+	/* return back to ROM code */
+	bx lr
+
+/* make the following data right in the end of the output*/
+.ltorg
+
+#if (defined(CONFIG_SYS_BOOT_EIMNOR) || defined(CONFIG_SYS_BOOT_QSPI))
+#define FLASH_OFFSET 0x1000
+#else
+#define FLASH_OFFSET 0x400
+#endif
+
+/*
+ * second_ivt_offset is the offset from the "second_ivt_header" to
+ * "image_copy_start", which involves FLASH_OFFSET, plus the first
+ * ivt_header, the plugin code size itself recorded by "ivt2_header"
+ */
+
+second_ivt_offset:      .long (ivt2_header + 0x2C + FLASH_OFFSET)
+
+/*
+ * The following is the second IVT header plus the second boot data
+ */
+ivt2_header:            .long 0x0
+app2_code_jump_v:       .long 0x0
+reserv3:                .long 0x0
+dcd2_ptr:               .long 0x0
+boot_data2_ptr:         .long 0x0
+self_ptr2:              .long 0x0
+app_code_csf2:          .long 0x0
+reserv4:                .long 0x0
+boot_data2:             .long 0x0
+image_len2:             .long 0x0
+plugin2:                .long 0x0
diff --git a/arch/arm/include/asm/arch-mx6/mx6_usbphy.h b/arch/arm/include/asm/arch-mx6/mx6_usbphy.h
new file mode 100644
index 0000000..0d9a4f5
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6_usbphy.h
@@ -0,0 +1,480 @@
+/*
+ * Copyright (C) 2008-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6_MX6_USBPHY_H__
+#define __ASM_ARCH_MX6_MX6_USBPHY_H__
+
+#define HW_USBPHY_PWD	(0x00000000)
+#define HW_USBPHY_PWD_SET	(0x00000004)
+#define HW_USBPHY_PWD_CLR	(0x00000008)
+#define HW_USBPHY_PWD_TOG	(0x0000000c)
+
+#define BP_USBPHY_PWD_RSVD2      21
+#define BM_USBPHY_PWD_RSVD2 0xFFE00000
+#define BF_USBPHY_PWD_RSVD2(v) \
+	(((v) << 21) & BM_USBPHY_PWD_RSVD2)
+#define BM_USBPHY_PWD_RXPWDRX 0x00100000
+#define BM_USBPHY_PWD_RXPWDDIFF 0x00080000
+#define BM_USBPHY_PWD_RXPWD1PT1 0x00040000
+#define BM_USBPHY_PWD_RXPWDENV 0x00020000
+#define BP_USBPHY_PWD_RSVD1      13
+#define BM_USBPHY_PWD_RSVD1 0x0001E000
+#define BF_USBPHY_PWD_RSVD1(v)  \
+	(((v) << 13) & BM_USBPHY_PWD_RSVD1)
+#define BM_USBPHY_PWD_TXPWDV2I 0x00001000
+#define BM_USBPHY_PWD_TXPWDIBIAS 0x00000800
+#define BM_USBPHY_PWD_TXPWDFS 0x00000400
+#define BP_USBPHY_PWD_RSVD0      0
+#define BM_USBPHY_PWD_RSVD0 0x000003FF
+#define BF_USBPHY_PWD_RSVD0(v)  \
+	(((v) << 0) & BM_USBPHY_PWD_RSVD0)
+
+#define HW_USBPHY_TX	(0x00000010)
+#define HW_USBPHY_TX_SET	(0x00000014)
+#define HW_USBPHY_TX_CLR	(0x00000018)
+#define HW_USBPHY_TX_TOG	(0x0000001c)
+
+#define BP_USBPHY_TX_RSVD5      29
+#define BM_USBPHY_TX_RSVD5 0xE0000000
+#define BF_USBPHY_TX_RSVD5(v) \
+	(((v) << 29) & BM_USBPHY_TX_RSVD5)
+#define BP_USBPHY_TX_USBPHY_TX_EDGECTRL      26
+#define BM_USBPHY_TX_USBPHY_TX_EDGECTRL 0x1C000000
+#define BF_USBPHY_TX_USBPHY_TX_EDGECTRL(v)  \
+	(((v) << 26) & BM_USBPHY_TX_USBPHY_TX_EDGECTRL)
+#define BM_USBPHY_TX_USBPHY_TX_SYNC_INVERT 0x02000000
+#define BM_USBPHY_TX_USBPHY_TX_SYNC_MUX 0x01000000
+#define BP_USBPHY_TX_RSVD4      22
+#define BM_USBPHY_TX_RSVD4 0x00C00000
+#define BF_USBPHY_TX_RSVD4(v)  \
+	(((v) << 22) & BM_USBPHY_TX_RSVD4)
+#define BM_USBPHY_TX_TXENCAL45DP 0x00200000
+#define BM_USBPHY_TX_RSVD3 0x00100000
+#define BP_USBPHY_TX_TXCAL45DP      16
+#define BM_USBPHY_TX_TXCAL45DP 0x000F0000
+#define BF_USBPHY_TX_TXCAL45DP(v)  \
+	(((v) << 16) & BM_USBPHY_TX_TXCAL45DP)
+#define BP_USBPHY_TX_RSVD2      14
+#define BM_USBPHY_TX_RSVD2 0x0000C000
+#define BF_USBPHY_TX_RSVD2(v)  \
+	(((v) << 14) & BM_USBPHY_TX_RSVD2)
+#define BM_USBPHY_TX_TXENCAL45DN 0x00002000
+#define BM_USBPHY_TX_RSVD1 0x00001000
+#define BP_USBPHY_TX_TXCAL45DN      8
+#define BM_USBPHY_TX_TXCAL45DN 0x00000F00
+#define BF_USBPHY_TX_TXCAL45DN(v)  \
+	(((v) << 8) & BM_USBPHY_TX_TXCAL45DN)
+#define BP_USBPHY_TX_RSVD0      4
+#define BM_USBPHY_TX_RSVD0 0x000000F0
+#define BF_USBPHY_TX_RSVD0(v)  \
+	(((v) << 4) & BM_USBPHY_TX_RSVD0)
+#define BP_USBPHY_TX_D_CAL      0
+#define BM_USBPHY_TX_D_CAL 0x0000000F
+#define BF_USBPHY_TX_D_CAL(v)  \
+	(((v) << 0) & BM_USBPHY_TX_D_CAL)
+
+#define HW_USBPHY_RX	(0x00000020)
+#define HW_USBPHY_RX_SET	(0x00000024)
+#define HW_USBPHY_RX_CLR	(0x00000028)
+#define HW_USBPHY_RX_TOG	(0x0000002c)
+
+#define BP_USBPHY_RX_RSVD2      23
+#define BM_USBPHY_RX_RSVD2 0xFF800000
+#define BF_USBPHY_RX_RSVD2(v) \
+	(((v) << 23) & BM_USBPHY_RX_RSVD2)
+#define BM_USBPHY_RX_RXDBYPASS 0x00400000
+#define BP_USBPHY_RX_RSVD1      7
+#define BM_USBPHY_RX_RSVD1 0x003FFF80
+#define BF_USBPHY_RX_RSVD1(v)  \
+	(((v) << 7) & BM_USBPHY_RX_RSVD1)
+#define BP_USBPHY_RX_DISCONADJ      4
+#define BM_USBPHY_RX_DISCONADJ 0x00000070
+#define BF_USBPHY_RX_DISCONADJ(v)  \
+	(((v) << 4) & BM_USBPHY_RX_DISCONADJ)
+#define BM_USBPHY_RX_RSVD0 0x00000008
+#define BP_USBPHY_RX_ENVADJ      0
+#define BM_USBPHY_RX_ENVADJ 0x00000007
+#define BF_USBPHY_RX_ENVADJ(v)  \
+	(((v) << 0) & BM_USBPHY_RX_ENVADJ)
+
+#define HW_USBPHY_CTRL	(0x00000030)
+#define HW_USBPHY_CTRL_SET	(0x00000034)
+#define HW_USBPHY_CTRL_CLR	(0x00000038)
+#define HW_USBPHY_CTRL_TOG	(0x0000003c)
+
+#define BM_USBPHY_CTRL_SFTRST 0x80000000
+#define BM_USBPHY_CTRL_CLKGATE 0x40000000
+#define BM_USBPHY_CTRL_UTMI_SUSPENDM 0x20000000
+#define BM_USBPHY_CTRL_HOST_FORCE_LS_SE0 0x10000000
+#define BM_USBPHY_CTRL_OTG_ID_VALUE 0x08000000
+#define BM_USBPHY_CTRL_ENAUTOSET_USBCLKS 0x04000000
+#define BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE 0x02000000
+#define BM_USBPHY_CTRL_FSDLL_RST_EN 0x01000000
+#define BM_USBPHY_CTRL_ENVBUSCHG_WKUP 0x00800000
+#define BM_USBPHY_CTRL_ENIDCHG_WKUP 0x00400000
+#define BM_USBPHY_CTRL_ENDPDMCHG_WKUP 0x00200000
+#define BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD 0x00100000
+#define BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE 0x00080000
+#define BM_USBPHY_CTRL_ENAUTO_PWRON_PLL 0x00040000
+#define BM_USBPHY_CTRL_WAKEUP_IRQ 0x00020000
+#define BM_USBPHY_CTRL_ENIRQWAKEUP 0x00010000
+#define BM_USBPHY_CTRL_ENUTMILEVEL3 0x00008000
+#define BM_USBPHY_CTRL_ENUTMILEVEL2 0x00004000
+#define BM_USBPHY_CTRL_DATA_ON_LRADC 0x00002000
+#define BM_USBPHY_CTRL_DEVPLUGIN_IRQ 0x00001000
+#define BM_USBPHY_CTRL_ENIRQDEVPLUGIN 0x00000800
+#define BM_USBPHY_CTRL_RESUME_IRQ 0x00000400
+#define BM_USBPHY_CTRL_ENIRQRESUMEDETECT 0x00000200
+#define BM_USBPHY_CTRL_RESUMEIRQSTICKY 0x00000100
+#define BM_USBPHY_CTRL_ENOTGIDDETECT 0x00000080
+#define BM_USBPHY_CTRL_OTG_ID_CHG_IRQ 0x00000040
+#define BM_USBPHY_CTRL_DEVPLUGIN_POLARITY 0x00000020
+#define BM_USBPHY_CTRL_ENDEVPLUGINDETECT 0x00000010
+#define BM_USBPHY_CTRL_HOSTDISCONDETECT_IRQ 0x00000008
+#define BM_USBPHY_CTRL_ENIRQHOSTDISCON 0x00000004
+#define BM_USBPHY_CTRL_ENHOSTDISCONDETECT 0x00000002
+#define BM_USBPHY_CTRL_ENOTG_ID_CHG_IRQ 0x00000001
+
+#define HW_USBPHY_STATUS	(0x00000040)
+
+#define BP_USBPHY_STATUS_RSVD4      11
+#define BM_USBPHY_STATUS_RSVD4 0xFFFFF800
+#define BF_USBPHY_STATUS_RSVD4(v) \
+	(((v) << 11) & BM_USBPHY_STATUS_RSVD4)
+#define BM_USBPHY_STATUS_RESUME_STATUS 0x00000400
+#define BM_USBPHY_STATUS_RSVD3 0x00000200
+#define BM_USBPHY_STATUS_OTGID_STATUS 0x00000100
+#define BM_USBPHY_STATUS_RSVD2 0x00000080
+#define BM_USBPHY_STATUS_DEVPLUGIN_STATUS 0x00000040
+#define BP_USBPHY_STATUS_RSVD1      4
+#define BM_USBPHY_STATUS_RSVD1 0x00000030
+#define BF_USBPHY_STATUS_RSVD1(v)  \
+	(((v) << 4) & BM_USBPHY_STATUS_RSVD1)
+#define BM_USBPHY_STATUS_HOSTDISCONDETECT_STATUS 0x00000008
+#define BP_USBPHY_STATUS_RSVD0      0
+#define BM_USBPHY_STATUS_RSVD0 0x00000007
+#define BF_USBPHY_STATUS_RSVD0(v)  \
+	(((v) << 0) & BM_USBPHY_STATUS_RSVD0)
+
+#define HW_USBPHY_DEBUG	(0x00000050)
+#define HW_USBPHY_DEBUG_SET	(0x00000054)
+#define HW_USBPHY_DEBUG_CLR	(0x00000058)
+#define HW_USBPHY_DEBUG_TOG	(0x0000005c)
+
+#define BM_USBPHY_DEBUG_RSVD3 0x80000000
+#define BM_USBPHY_DEBUG_CLKGATE 0x40000000
+#define BM_USBPHY_DEBUG_HOST_RESUME_DEBUG 0x20000000
+#define BP_USBPHY_DEBUG_SQUELCHRESETLENGTH      25
+#define BM_USBPHY_DEBUG_SQUELCHRESETLENGTH 0x1E000000
+#define BF_USBPHY_DEBUG_SQUELCHRESETLENGTH(v)  \
+	(((v) << 25) & BM_USBPHY_DEBUG_SQUELCHRESETLENGTH)
+#define BM_USBPHY_DEBUG_ENSQUELCHRESET 0x01000000
+#define BP_USBPHY_DEBUG_RSVD2      21
+#define BM_USBPHY_DEBUG_RSVD2 0x00E00000
+#define BF_USBPHY_DEBUG_RSVD2(v)  \
+	(((v) << 21) & BM_USBPHY_DEBUG_RSVD2)
+#define BP_USBPHY_DEBUG_SQUELCHRESETCOUNT      16
+#define BM_USBPHY_DEBUG_SQUELCHRESETCOUNT 0x001F0000
+#define BF_USBPHY_DEBUG_SQUELCHRESETCOUNT(v)  \
+	(((v) << 16) & BM_USBPHY_DEBUG_SQUELCHRESETCOUNT)
+#define BP_USBPHY_DEBUG_RSVD1      13
+#define BM_USBPHY_DEBUG_RSVD1 0x0000E000
+#define BF_USBPHY_DEBUG_RSVD1(v)  \
+	(((v) << 13) & BM_USBPHY_DEBUG_RSVD1)
+#define BM_USBPHY_DEBUG_ENTX2RXCOUNT 0x00001000
+#define BP_USBPHY_DEBUG_TX2RXCOUNT      8
+#define BM_USBPHY_DEBUG_TX2RXCOUNT 0x00000F00
+#define BF_USBPHY_DEBUG_TX2RXCOUNT(v)  \
+	(((v) << 8) & BM_USBPHY_DEBUG_TX2RXCOUNT)
+#define BP_USBPHY_DEBUG_RSVD0      6
+#define BM_USBPHY_DEBUG_RSVD0 0x000000C0
+#define BF_USBPHY_DEBUG_RSVD0(v)  \
+	(((v) << 6) & BM_USBPHY_DEBUG_RSVD0)
+#define BP_USBPHY_DEBUG_ENHSTPULLDOWN      4
+#define BM_USBPHY_DEBUG_ENHSTPULLDOWN 0x00000030
+#define BF_USBPHY_DEBUG_ENHSTPULLDOWN(v)  \
+	(((v) << 4) & BM_USBPHY_DEBUG_ENHSTPULLDOWN)
+#define BP_USBPHY_DEBUG_HSTPULLDOWN      2
+#define BM_USBPHY_DEBUG_HSTPULLDOWN 0x0000000C
+#define BF_USBPHY_DEBUG_HSTPULLDOWN(v)  \
+	(((v) << 2) & BM_USBPHY_DEBUG_HSTPULLDOWN)
+#define BM_USBPHY_DEBUG_DEBUG_INTERFACE_HOLD 0x00000002
+#define BM_USBPHY_DEBUG_OTGIDPIOLOCK 0x00000001
+
+#define HW_USBPHY_DEBUG0_STATUS	(0x00000060)
+
+#define BP_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT      26
+#define BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT 0xFC000000
+#define BF_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT(v) \
+	(((v) << 26) & BM_USBPHY_DEBUG0_STATUS_SQUELCH_COUNT)
+#define BP_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT      16
+#define BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT 0x03FF0000
+#define BF_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT(v)  \
+	(((v) << 16) & BM_USBPHY_DEBUG0_STATUS_UTMI_RXERROR_FAIL_COUNT)
+#define BP_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT      0
+#define BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT 0x0000FFFF
+#define BF_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT(v)  \
+	(((v) << 0) & BM_USBPHY_DEBUG0_STATUS_LOOP_BACK_FAIL_COUNT)
+
+#define HW_USBPHY_DEBUG1	(0x00000070)
+#define HW_USBPHY_DEBUG1_SET	(0x00000074)
+#define HW_USBPHY_DEBUG1_CLR	(0x00000078)
+#define HW_USBPHY_DEBUG1_TOG	(0x0000007c)
+
+#define BP_USBPHY_DEBUG1_RSVD1      15
+#define BM_USBPHY_DEBUG1_RSVD1 0xFFFF8000
+#define BF_USBPHY_DEBUG1_RSVD1(v) \
+	(((v) << 15) & BM_USBPHY_DEBUG1_RSVD1)
+#define BP_USBPHY_DEBUG1_ENTAILADJVD      13
+#define BM_USBPHY_DEBUG1_ENTAILADJVD 0x00006000
+#define BF_USBPHY_DEBUG1_ENTAILADJVD(v)  \
+	(((v) << 13) & BM_USBPHY_DEBUG1_ENTAILADJVD)
+#define BM_USBPHY_DEBUG1_ENTX2TX 0x00001000
+#define BP_USBPHY_DEBUG1_RSVD0      4
+#define BM_USBPHY_DEBUG1_RSVD0 0x00000FF0
+#define BF_USBPHY_DEBUG1_RSVD0(v)  \
+	(((v) << 4) & BM_USBPHY_DEBUG1_RSVD0)
+#define BP_USBPHY_DEBUG1_DBG_ADDRESS      0
+#define BM_USBPHY_DEBUG1_DBG_ADDRESS 0x0000000F
+#define BF_USBPHY_DEBUG1_DBG_ADDRESS(v)  \
+	(((v) << 0) & BM_USBPHY_DEBUG1_DBG_ADDRESS)
+
+#define HW_USBPHY_VERSION	(0x00000080)
+
+#define BP_USBPHY_VERSION_MAJOR      24
+#define BM_USBPHY_VERSION_MAJOR 0xFF000000
+#define BF_USBPHY_VERSION_MAJOR(v) \
+	(((v) << 24) & BM_USBPHY_VERSION_MAJOR)
+#define BP_USBPHY_VERSION_MINOR      16
+#define BM_USBPHY_VERSION_MINOR 0x00FF0000
+#define BF_USBPHY_VERSION_MINOR(v)  \
+	(((v) << 16) & BM_USBPHY_VERSION_MINOR)
+#define BP_USBPHY_VERSION_STEP      0
+#define BM_USBPHY_VERSION_STEP 0x0000FFFF
+#define BF_USBPHY_VERSION_STEP(v)  \
+	(((v) << 0) & BM_USBPHY_VERSION_STEP)
+
+#define HW_USBPHY_IP	(0x00000090)
+#define HW_USBPHY_IP_SET	(0x00000094)
+#define HW_USBPHY_IP_CLR	(0x00000098)
+#define HW_USBPHY_IP_TOG	(0x0000009c)
+
+#define BP_USBPHY_IP_RSVD1      25
+#define BM_USBPHY_IP_RSVD1 0xFE000000
+#define BF_USBPHY_IP_RSVD1(v) \
+	(((v) << 25) & BM_USBPHY_IP_RSVD1)
+#define BP_USBPHY_IP_DIV_SEL      23
+#define BM_USBPHY_IP_DIV_SEL 0x01800000
+#define BF_USBPHY_IP_DIV_SEL(v)  \
+	(((v) << 23) & BM_USBPHY_IP_DIV_SEL)
+#define BV_USBPHY_IP_DIV_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_DIV_SEL__LOWER     0x1
+#define BV_USBPHY_IP_DIV_SEL__LOWEST    0x2
+#define BV_USBPHY_IP_DIV_SEL__UNDEFINED 0x3
+#define BP_USBPHY_IP_LFR_SEL      21
+#define BM_USBPHY_IP_LFR_SEL 0x00600000
+#define BF_USBPHY_IP_LFR_SEL(v)  \
+	(((v) << 21) & BM_USBPHY_IP_LFR_SEL)
+#define BV_USBPHY_IP_LFR_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_LFR_SEL__TIMES_2   0x1
+#define BV_USBPHY_IP_LFR_SEL__TIMES_05  0x2
+#define BV_USBPHY_IP_LFR_SEL__UNDEFINED 0x3
+#define BP_USBPHY_IP_CP_SEL      19
+#define BM_USBPHY_IP_CP_SEL 0x00180000
+#define BF_USBPHY_IP_CP_SEL(v)  \
+	(((v) << 19) & BM_USBPHY_IP_CP_SEL)
+#define BV_USBPHY_IP_CP_SEL__DEFAULT   0x0
+#define BV_USBPHY_IP_CP_SEL__TIMES_2   0x1
+#define BV_USBPHY_IP_CP_SEL__TIMES_05  0x2
+#define BV_USBPHY_IP_CP_SEL__UNDEFINED 0x3
+#define BM_USBPHY_IP_TSTI_TX_DP 0x00040000
+#define BM_USBPHY_IP_TSTI_TX_DM 0x00020000
+#define BM_USBPHY_IP_ANALOG_TESTMODE 0x00010000
+#define BP_USBPHY_IP_RSVD0      3
+#define BM_USBPHY_IP_RSVD0 0x0000FFF8
+#define BF_USBPHY_IP_RSVD0(v)  \
+	(((v) << 3) & BM_USBPHY_IP_RSVD0)
+#define BM_USBPHY_IP_EN_USB_CLKS 0x00000004
+#define BM_USBPHY_IP_PLL_LOCKED 0x00000002
+#define BM_USBPHY_IP_PLL_POWER 0x00000001
+
+/* The register definition for usbphy which includes at usb core's register set
+ * (from USB_CORE_BASE + 0x800)
+ */
+#define USB_CTRL			USBOTHER_REG(0x00)	/* USB OTG Control register */
+#define USB_H1_CTRL			USBOTHER_REG(0x04)	/* USB H1 Control register */
+#define USB_H2_CTRL			USBOTHER_REG(0x08)	/* USB H2 Control register */
+#define USB_H3_CTRL			USBOTHER_REG(0x0c)	/* USB H3 Control register */
+
+/* USB Host2 HSIC Control Register */
+#define USB_UH2_HSIC_CTRL		USBOTHER_REG(0x10)
+
+/* USB Host3 HSIC Control Register */
+#define USB_UH3_HSIC_CTRL		USBOTHER_REG(0x14)
+
+/* OTG UTMI PHY Control 0 Register */
+#define USB_OTG_PHY_CTRL_0		USBOTHER_REG(0x18)
+
+/* OTG UTMI PHY Control 1 Register */
+#define USB_H1_PHY_CTRL_0		USBOTHER_REG(0x1c)
+
+/* USB Host2 HSIC DLL Configuration Register 1 */
+#define USB_UH2_HSIC_DLL_CFG1		USBOTHER_REG(0x20)
+
+/* USB Host2 HSIC DLL Configuration Register 2 */
+#define USB_UH2_HSIC_DLL_CFG2		USBOTHER_REG(0x24)
+
+/* USB Host2 HSIC DLL Configuration Register 3 */
+#define USB_UH2_HSIC_DLL_CFG3		USBOTHER_REG(0x28)
+
+/* USB Host3 HSIC DLL Configuration Register 1 */
+#define USB_UH3_HSIC_DLL_CFG1		USBOTHER_REG(0x30)
+
+/* USB Host3 HSIC DLL Configuration Register 2 */
+#define USB_UH3_HSIC_DLL_CFG2		USBOTHER_REG(0x34)
+
+/* USB Host3 HSIC DLL Configuration Register 3 */
+#define USB_UH3_HSIC_DLL_CFG3		USBOTHER_REG(0x38)
+
+/*
+ * register bits
+ */
+
+/* USBCTRL */
+#define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
+#define UCTRL_OSIC_DU6		(0 << 29)	/* Differential/unidirectional 6 wire */
+#define UCTRL_OSIC_DB4		(1 << 29)	/* Differential/bidirectional  4 wire */
+#define UCTRL_OSIC_SU6		(2 << 29)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_OSIC_SB3		(3 << 29)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_OUIE		(1 << 28)	/* OTG ULPI intr enable */
+#define UCTRL_OBPVAL_RXDP	(1 << 26)	/* OTG RxDp status in bypass mode */
+#define UCTRL_OBPVAL_RXDM	(1 << 25)	/* OTG RxDm status in bypass mode */
+#define UCTRL_OPM		(1 << 24)	/* OTG power mask */
+#define UCTRL_O_PWR_POL	(1 << 24)	/* OTG power pin polarity */
+#define UCTRL_H2WIR		(1 << 17)	/* HOST2 wakeup intr request received */
+#define UCTRL_H2SIC_MASK	(3 << 21)	/* HOST2 Serial Interface Config: */
+#define UCTRL_H2SIC_DU6		(0 << 21)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H2SIC_DB4		(1 << 21)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H2SIC_SU6		(2 << 21)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H2SIC_SB3		(3 << 21)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_H2UIE		(1 << 8)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 7)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PP		0	/* Power Polarity for uh2 */
+#define UCTRL_H2PM		(1 << 4)	/* HOST2 power mask */
+#define UCTRL_H2OVBWK_EN	(1 << 6) /* OTG VBUS Wakeup Enable */
+#define UCTRL_H2OIDWK_EN	(1 << 5) /* OTG ID Wakeup Enable */
+
+#define UCTRL_H1WIR		(1 << 15)	/* HOST1 wakeup intr request received */
+#define UCTRL_H1SIC_MASK	(3 << 13)	/* HOST1 Serial Interface Config: */
+#define UCTRL_H1SIC_DU6		(0 << 13)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H1SIC_DB4		(1 << 13)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H1SIC_SU6		(2 << 13)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H1SIC_SB3		(3 << 13)	/* single-ended/bidirectional  3 wire */
+#define UCTRL_OLOCKD		(1 << 13)	/* otg lock disable */
+#define UCTRL_H2LOCKD		(1 << 12)	/* HOST2 lock disable */
+#define UCTRL_H1UIE		(1 << 12)	/* Host1 ULPI interrupt enable */
+
+#define UCTRL_PP                (1 << 11)       /* power polarity bit */
+#define UCTRL_H1WIE		(1 << 11)	/* HOST1 wakeup intr enable */
+#define UCTRL_H1BPVAL_RXDP	(1 << 10)	/* HOST1 RxDp status in bypass mode */
+#define UCTRL_XCSO              (1 << 10)       /* Xcvr Clock Select for OTG port */
+#define UCTRL_H1BPVAL_RXDM	(1 <<  9)	/* HOST1 RxDm status in bypass mode */
+#define UCTRL_XCSH2             (1 <<  9)       /* Xcvr Clock Select for Host port */
+#define UCTRL_H1PM		(1 <<  8)	/* HOST1 power mask */
+#define UCTRL_IP_PULIDP         (1 <<  8)       /* Ipp_Puimpel_Pullup_Dp */
+
+#define UCTRL_IP_PUE_UP         (1 <<  7)       /* ipp_pue_pullup_dp */
+#define UCTRL_IP_PUE_DOWN       (1 <<  6)       /* ipp_pue_pulldwn_dpdm */
+#define UCTRL_H2DT		(1 <<  5)	/* HOST2 TLL disabled */
+#define UCTRL_H1DT		(1 <<  4)	/* HOST1 TLL disabled */
+#define UCTRL_USBTE             (1 <<  4)       /* USBT Transceiver enable */
+#define UCTRL_OCPOL             (1 <<  3)       /* OverCurrent Polarity */
+#define UCTRL_OCE               (1 <<  2)       /* OverCurrent Enable */
+#define UCTRL_H2OCPOL		(1 <<  2)       /* OverCurrent Polarity of Host2 */
+#define UCTRL_H2OCS             (1 <<  1)       /* Host OverCurrent State */
+#define UCTRL_BPE		(1 <<  0)	/* bypass mode enable */
+#define UCTRL_OTD		(1 <<  0)	/* OTG TLL Disable */
+#define UCTRL_OOCS              (1 <<  0)       /* OTG OverCurrent State */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)	/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)	/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)	/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)	/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)	/* OTG ID pin status */
+				/* 1=high: Operate as B-device */
+				/* 0=low : Operate as A-device */
+
+/* USB_PHY_CTRL_FUNC */
+/* PHY control0 Register Bit Masks */
+#define USB_UTMI_PHYCTRL_CONF2	(1 << 26)
+
+#define USB_UTMI_PHYCTRL_UTMI_ENABLE (1 << 24)
+#define USB_UTMI_PHYCTRL_CHGRDETEN (1 << 24)  /* Enable Charger Detector */
+#define USB_UTMI_PHYCTRL_CHGRDETON (1 << 23)  /* Charger Detector Power On Control */
+#define USB_UTMI_PHYCTRL_OC_POL	(1 << 9)	/* OTG Polarity of Overcurrent */
+#define USB_UTMI_PHYCTRL_OC_DIS	(1 << 8)	/* OTG Disable Overcurrent Event */
+#define USB_UH1_OC_DIS	(1 << 5)		/* UH1 Disable Overcurrent Event */
+#define USB_UH1_OC_POL	(1 << 6)		/* UH1 Polarity of OC,Low active */
+/* USB_PHY_CTRL_FUNC2*/
+#define USB_UTMI_PHYCTRL2_PLLDIV_MASK		0x3
+#define USB_UTMI_PHYCTRL2_PLLDIV_SHIFT		0
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_MASK		0x3
+#define USB_UTMI_PHYCTRL2_HSDEVSEL_SHIFT	19
+
+/* USB_CTRL_1 */
+#define USB_CTRL_UH1_EXT_CLK_EN			(1 << 25)
+#define USB_CTRL_UH2_EXT_CLK_EN			(1 << 26)
+#define USB_CTRL_UH2_CLK_FROM_ULPI_PHY  	(1 << 2)
+/* ULPIVIEW register bits */
+#define ULPIVW_OFF		(0x170)
+#define ULPIVW_WU		(1 << 31)	/* Wakeup */
+#define ULPIVW_RUN		(1 << 30)	/* read/write run */
+#define ULPIVW_WRITE		(1 << 29)	/* 0=read  1=write */
+#define ULPIVW_SS		(1 << 27)	/* SyncState */
+#define ULPIVW_PORT_MASK	0x07	/* Port field */
+#define ULPIVW_PORT_SHIFT	24
+#define ULPIVW_ADDR_MASK	0xFF	/* data address field */
+#define ULPIVW_ADDR_SHIFT	16
+#define ULPIVW_RDATA_MASK	0xFF	/* read data field */
+#define ULPIVW_RDATA_SHIFT	8
+#define ULPIVW_WDATA_MASK	0xFF	/* write data field */
+#define ULPIVW_WDATA_SHIFT	0
+
+/* USB Clock on/off Control Register */
+#define OTG_AHBCLK_OFF          (0x1<<17)      /* 1: OFF */
+#define H1_AHBCLK_OFF           (0x1<<18)      /* 1: OFF */
+
+/* mx6q's register bit begins*/
+
+/* OTG CTRL - H3 CTRL */
+#define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
+/* bit 18 - bit 30 is reserved at mx6q */
+#define UCTRL_WKUP_VBUS_EN	(1 << 17)	/* OTG wake-up on VBUS change enable */
+#define UCTRL_WKUP_ID_EN	(1 << 16)	/* OTG wake-up on ID change enable */
+#define UCTRL_WKUP_SW		(1 << 15)	/* OTG Software Wake-up */
+#define UCTRL_WKUP_SW_EN	(1 << 14)	/* OTG Software Wake-up enable */
+#define UCTRL_UTMI_ON_CLOCK	(1 << 13)	/* Force OTG UTMI PHY clock output on
+										     even if suspend mode */
+#define UCTRL_SUSPENDM		(1 << 12)	/* Force OTG UTMI PHY Suspend */
+#define UCTRL_RESET		(1 << 11)	/* Force OTG UTMI PHY Reset */
+#define UCTRL_OWIE		(1 << 10)	/* OTG wakeup intr request received */
+#define UCTRL_PM		(1 << 9)	/* OTG Power Mask */
+#define UCTRL_OVER_CUR_POL	(1 << 8)	/* OTG Polarity of Overcurrent */
+#define UCTRL_OVER_CUR_DIS	(1 << 7)	/* Disable OTG Overcurrent Detection */
+/* bit 0 - bit 6 is reserved at mx6q */
+
+/* Host2/3 HSIC Ctrl */
+#define CLK_VLD		(1 << 31)	/* Indicating whether HSIC clock is valid */
+#define HSIC_EN		(1 << 12)	/* HSIC enable */
+#define HSIC_CLK_ON		(1 << 11)	/* Force HSIC module 480M clock on,
+						 * even when in Host is in suspend mode
+						 */
+/* OTG/HOST1 Phy Ctrl */
+#define PHY_UTMI_CLK_VLD	(1 << 31) /* Indicating whether OTG UTMI PHY Clock Valid */
+
+#define NOP_XCVR		(0xffffffff)	/* Indicate it is no usb phy */
+#endif /* __ARCH_ARM___USBPHY_H */
diff --git a/arch/arm/include/asm/arch-mx6/mx6sl_pins.h b/arch/arm/include/asm/arch-mx6/mx6sl_pins.h
index 5f9c90a..90cc965 100644
--- a/arch/arm/include/asm/arch-mx6/mx6sl_pins.h
+++ b/arch/arm/include/asm/arch-mx6/mx6sl_pins.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -10,12 +10,34 @@
 #include <asm/imx-common/iomux-v3.h>
 
 enum {
+	MX6_PAD_SD1_CLK__USDHC1_CLK             = IOMUX_PAD(0x0534, 0x022C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_CMD__USDHC1_CMD             = IOMUX_PAD(0x0538, 0x0230, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT0__USDHC1_DAT0           = IOMUX_PAD(0x053C, 0x0234, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT1__USDHC1_DAT1           = IOMUX_PAD(0x0540, 0x0238, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT2__USDHC1_DAT2           = IOMUX_PAD(0x0544, 0x023C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT3__USDHC1_DAT3           = IOMUX_PAD(0x0548, 0x0240, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT4__USDHC1_DAT4           = IOMUX_PAD(0x054C, 0x0244, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT5__USDHC1_DAT5           = IOMUX_PAD(0x0550, 0x0248, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT6__USDHC1_DAT6           = IOMUX_PAD(0x0554, 0x024C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD1_DAT7__USDHC1_DAT7           = IOMUX_PAD(0x0558, 0x0250, 0, 0x0000, 0, 0),
+	MX6_PAD_KEY_ROW7__GPIO_4_7              = IOMUX_PAD(0x04B0, 0x01A8, 5, 0x0000, 0, 0),
+
 	MX6_PAD_SD2_CLK__USDHC2_CLK				= IOMUX_PAD(0x055C, 0x0254, 0, 0x0000, 0, 0),
 	MX6_PAD_SD2_CMD__USDHC2_CMD				= IOMUX_PAD(0x0560, 0x0258, 0, 0x0000, 0, 0),
 	MX6_PAD_SD2_DAT0__USDHC2_DAT0				= IOMUX_PAD(0x0564, 0x025C, 0, 0x0000, 0, 0),
 	MX6_PAD_SD2_DAT1__USDHC2_DAT1				= IOMUX_PAD(0x0568, 0x0260, 0, 0x0000, 0, 0),
 	MX6_PAD_SD2_DAT2__USDHC2_DAT2				= IOMUX_PAD(0x056C, 0x0264, 0, 0x0000, 0, 0),
 	MX6_PAD_SD2_DAT3__USDHC2_DAT3				= IOMUX_PAD(0x0570, 0x0268, 0, 0x0000, 0, 0),
+	MX6_PAD_SD2_DAT7__GPIO_5_0              = IOMUX_PAD(0x0580, 0x0278, 5, 0x0000, 0, 0),
+
+	MX6_PAD_SD3_CLK__USDHC3_CLK              = IOMUX_PAD(0x0588, 0x0280, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_CMD__USDHC3_CMD              = IOMUX_PAD(0x058C, 0x0284, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DAT0__USDHC3_DAT0            = IOMUX_PAD(0x0590, 0x0288, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DAT1__USDHC3_DAT1            = IOMUX_PAD(0x0594, 0x028C, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DAT2__USDHC3_DAT2            = IOMUX_PAD(0x0598, 0x0290, 0, 0x0000, 0, 0),
+	MX6_PAD_SD3_DAT3__USDHC3_DAT3            = IOMUX_PAD(0x059C, 0x0294, 0, 0x0000, 0, 0),
+	MX6_PAD_REF_CLK_32K__GPIO_3_22           = IOMUX_PAD(0x0530, 0x0228, 5, 0x0000, 0, 0),
+
 	MX6_PAD_UART1_RXD__UART1_RXD				= IOMUX_PAD(0x05A0, 0x0298, 0, 0x07FC, 0, 0),
 	MX6_PAD_UART1_TXD__UART1_TXD				= IOMUX_PAD(0x05A4, 0x029C, 0, 0x0000, 0, 0),
 
@@ -30,5 +52,73 @@ enum {
 	MX6_PAD_FEC_REF_CLK__FEC_REF_OUT			= IOMUX_PAD(0x424, 0x134, 0x10, 0x000, 0, 0),
 	MX6_PAD_FEC_RX_ER__GPIO_4_19				= IOMUX_PAD(0x0428, 0x0138, 5, 0x0000, 0, 0),
 	MX6_PAD_FEC_TX_CLK__GPIO_4_21				= IOMUX_PAD(0x0434, 0x0144, 5, 0x0000, 0, 0),
+
+	MX6_PAD_I2C1_SDA__I2C1_SDA				= IOMUX_PAD(0x0450, 0x0160, 0x10, 0x0720, 2, 0),
+	MX6_PAD_I2C1_SDA__GPIO_3_13				= IOMUX_PAD(0x0450, 0x0160, 5, 0x0000, 0, 0),
+	MX6_PAD_I2C1_SCL__I2C1_SCL				= IOMUX_PAD(0x044C, 0x015C, 0x10, 0x071C, 2, 0),
+	MX6_PAD_I2C1_SCL__GPIO_3_12				= IOMUX_PAD(0x044C, 0x015C, 5, 0x0000, 0, 0),
+
+	MX6_PAD_EPDC_PWRSTAT__GPIO_2_13				= IOMUX_PAD(0x03E8, 0x00F8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_VCOM0__GPIO_2_3				= IOMUX_PAD(0x0410, 0x0120, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRWAKEUP__GPIO_2_14			= IOMUX_PAD(0x03EC, 0x00FC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRCTRL0__GPIO_2_7				= IOMUX_PAD(0x03D4, 0x00E4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D0__EPDC_SDDO_0				= IOMUX_PAD(0x0380, 0x0090, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D1__EPDC_SDDO_1				= IOMUX_PAD(0x0384, 0x0094, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D2__EPDC_SDDO_2				= IOMUX_PAD(0x03A0, 0x00B0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D3__EPDC_SDDO_3				= IOMUX_PAD(0x03A4, 0x00B4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D4__EPDC_SDDO_4				= IOMUX_PAD(0x03A8, 0x00B8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D5__EPDC_SDDO_5				= IOMUX_PAD(0x03AC, 0x00BC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D6__EPDC_SDDO_6				= IOMUX_PAD(0x03B0, 0x00C0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D7__EPDC_SDDO_7				= IOMUX_PAD(0x03B4, 0x00C4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK				= IOMUX_PAD(0x03C0, 0x00D0, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP				= IOMUX_PAD(0x03CC, 0x00DC, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE				= IOMUX_PAD(0x03C4, 0x00D4, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL				= IOMUX_PAD(0x03C8, 0x00D8, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK				= IOMUX_PAD(0x0400, 0x0110, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE				= IOMUX_PAD(0x0408, 0x0118, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE				= IOMUX_PAD(0x0404, 0x0114, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR				= IOMUX_PAD(0x040C, 0x011C, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__EPDC_BDR_0				= IOMUX_PAD(0x0378, 0x0088, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE_0				= IOMUX_PAD(0x03F0, 0x0100, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__EPDC_SDCE_1				= IOMUX_PAD(0x03F4, 0x0104, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__EPDC_SDCE_2				= IOMUX_PAD(0x03F8, 0x0108, 0, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D0__GPIO_1_7				= IOMUX_PAD(0x0380, 0x0090, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D1__GPIO_1_8				= IOMUX_PAD(0x0384, 0x0094, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D2__GPIO_1_9				= IOMUX_PAD(0x03A0, 0x00B0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D3__GPIO_1_10				= IOMUX_PAD(0x03A4, 0x00B4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D4__GPIO_1_11				= IOMUX_PAD(0x03A8, 0x00B8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D5__GPIO_1_12				= IOMUX_PAD(0x03AC, 0x00BC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D6__GPIO_1_13				= IOMUX_PAD(0x03B0, 0x00C0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_D7__GPIO_1_14				= IOMUX_PAD(0x03B4, 0x00C4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDCLK__GPIO_1_31				= IOMUX_PAD(0x03C0, 0x00D0, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDSP__GPIO_2_2				= IOMUX_PAD(0x03CC, 0x00DC, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDOE__GPIO_2_0				= IOMUX_PAD(0x03C4, 0x00D4, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_GDRL__GPIO_2_1				= IOMUX_PAD(0x03C8, 0x00D8, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCLK__GPIO_1_23				= IOMUX_PAD(0x0400, 0x0110, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDOE__GPIO_1_25				= IOMUX_PAD(0x0408, 0x0118, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDLE__GPIO_1_24				= IOMUX_PAD(0x0404, 0x0114, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDSHR__GPIO_1_26				= IOMUX_PAD(0x040C, 0x011C, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_BDR0__GPIO_2_5				= IOMUX_PAD(0x0378, 0x0088, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE0__GPIO_1_27				= IOMUX_PAD(0x03F0, 0x0100, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE1__GPIO_1_28				= IOMUX_PAD(0x03F4, 0x0104, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_SDCE2__GPIO_1_29				= IOMUX_PAD(0x03F8, 0x0108, 5, 0x0000, 0, 0),
+	MX6_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID      = IOMUX_PAD(0x03D0, 0x00E0, 4, 0x05DC, 0, 0),
+
+	MX6_PAD_KEY_COL0__KPP_COL_0				= IOMUX_PAD(0x0474, 0x016C, 0, 0x0734, 0, 0),
+	MX6_PAD_KEY_COL1__KPP_COL_1				= IOMUX_PAD(0x0478, 0x0170, 0, 0x0738, 0, 0),
+	MX6_PAD_KEY_COL2__KPP_COL_2				= IOMUX_PAD(0x047C, 0x0174, 0, 0x073C, 0, 0),
+	MX6_PAD_KEY_COL3__KPP_COL_3				= IOMUX_PAD(0x0480, 0x0178, 0, 0x0740, 0, 0),
+	MX6_PAD_KEY_ROW0__KPP_ROW_0				= IOMUX_PAD(0x0494, 0x018C, 0, 0x0754, 0, 0),
+	MX6_PAD_KEY_ROW1__KPP_ROW_1				= IOMUX_PAD(0x0498, 0x0190, 0, 0x0758, 0, 0),
+	MX6_PAD_KEY_ROW2__KPP_ROW_2				= IOMUX_PAD(0x049C, 0x0194, 0, 0x075C, 0, 0),
+	MX6_PAD_KEY_ROW3__KPP_ROW_3				= IOMUX_PAD(0x04A0, 0x0198, 0, 0x0760, 0, 0),
+
+	MX6_PAD_KEY_COL4__USB_USBOTG1_PWR       = IOMUX_PAD(0x0484, 0x017C, 6, 0x0000, 0, 0),
+	MX6_PAD_KEY_COL5__USB_USBOTG2_PWR       = IOMUX_PAD(0x0488, 0x0180, 6, 0x0000, 0, 0),
+
+	MX6_PAD_ECSPI1_MISO__ECSPI1_MISO        = IOMUX_PAD(0x0358, 0x0068, 0, 0x0684, 0, 0),
+	MX6_PAD_ECSPI1_MOSI__ECSPI1_MOSI        = IOMUX_PAD(0x035C, 0x006C, 0, 0x0688, 0, 0),
+	MX6_PAD_ECSPI1_SCLK__ECSPI1_SCLK        = IOMUX_PAD(0x0360, 0x0070, 0, 0x067C, 0, 0),
+	MX6_PAD_ECSPI1_SS0__GPIO_4_11           = IOMUX_PAD(0x0364, 0x0074, 5, 0x0000, 0, 0),
 };
 #endif	/* __ASM_ARCH_MX6_MX6SL_PINS_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/mx6sx-ddr.h b/arch/arm/include/asm/arch-mx6/mx6sx-ddr.h
new file mode 100644
index 0000000..2cc94aa
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6sx-ddr.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6SX_DDR_H__
+#define __ASM_ARCH_MX6SX_DDR_H__
+
+#ifndef CONFIG_MX6SX
+#error "wrong CPU"
+#endif
+
+#define MX6_IOM_DRAM_DQM0	0x020e02ec
+#define MX6_IOM_DRAM_DQM1	0x020e02f0
+#define MX6_IOM_DRAM_DQM2	0x020e02f4
+#define MX6_IOM_DRAM_DQM3	0x020e02f8
+
+#define MX6_IOM_DRAM_RAS	0x020e02fc
+#define MX6_IOM_DRAM_CAS	0x020e0300
+#define MX6_IOM_DRAM_SDODT0	0x020e0310
+#define MX6_IOM_DRAM_SDODT1	0x020e0314
+#define MX6_IOM_DRAM_SDBA2	0x020e0320
+#define MX6_IOM_DRAM_SDCKE0	0x020e0324
+#define MX6_IOM_DRAM_SDCKE1	0x020e0328
+#define MX6_IOM_DRAM_SDCLK_0	0x020e032c
+#define MX6_IOM_DRAM_RESET	0x020e0340
+
+#define MX6_IOM_DRAM_SDQS0	0x020e0330
+#define MX6_IOM_DRAM_SDQS1	0x020e0334
+#define MX6_IOM_DRAM_SDQS2	0x020e0338
+#define MX6_IOM_DRAM_SDQS3	0x020e033c
+
+#define MX6_IOM_GRP_ADDDS	0x020e05f4
+#define MX6_IOM_DDRMODE_CTL	0x020e05f8
+#define MX6_IOM_GRP_DDRPKE	0x020e05fc
+#define MX6_IOM_GRP_DDRMODE	0x020e0608
+#define MX6_IOM_GRP_B0DS	0x020e060c
+#define MX6_IOM_GRP_B1DS	0x020e0610
+#define MX6_IOM_GRP_CTLDS	0x020e0614
+#define MX6_IOM_GRP_DDR_TYPE	0x020e0618
+#define MX6_IOM_GRP_B2DS	0x020e061c
+#define MX6_IOM_GRP_B3DS	0x020e0620
+
+#endif	/*__ASM_ARCH_MX6SX_DDR_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/mx6sx_pins.h b/arch/arm/include/asm/arch-mx6/mx6sx_pins.h
new file mode 100644
index 0000000..7ac6794
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6sx_pins.h
@@ -0,0 +1,1675 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __ASM_ARCH_MX6_MX6SX_PINS_H__
+#define __ASM_ARCH_MX6_MX6SX_PINS_H__
+
+#include <asm/imx-common/iomux-v3.h>
+
+enum {
+	MX6SX_PAD_GPIO1_IO00__I2C1_SCL                           = IOMUX_PAD(0x035C, 0x0014, 0x10 | 0, 0x07A8, 1, 0),
+	MX6SX_PAD_GPIO1_IO00__USDHC1_VSELECT                     = IOMUX_PAD(0x035C, 0x0014, 1, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO00__SPDIF_LOCK                         = IOMUX_PAD(0x035C, 0x0014, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO00__CCM_WAIT                           = IOMUX_PAD(0x035C, 0x0014, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO00__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x035C, 0x0014, 4, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO00__GPIO1_IO_0                         = IOMUX_PAD(0x035C, 0x0014, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO00__SNVS_HP_WRAPPER_VIO_5              = IOMUX_PAD(0x035C, 0x0014, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO00__PHY_DTB_1                          = IOMUX_PAD(0x035C, 0x0014, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO01__I2C1_SDA                           = IOMUX_PAD(0x0360, 0x0018, 0x10 | 0, 0x07AC, 1, 0),
+	MX6SX_PAD_GPIO1_IO01__USDHC1_RESET_B                     = IOMUX_PAD(0x0360, 0x0018, 1, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO01__SPDIF_SR_CLK                       = IOMUX_PAD(0x0360, 0x0018, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO01__CCM_STOP                           = IOMUX_PAD(0x0360, 0x0018, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO01__WDOG3_WDOG_B                       = IOMUX_PAD(0x0360, 0x0018, 4, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO01__GPIO1_IO_1                         = IOMUX_PAD(0x0360, 0x0018, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO01__SNVS_HP_WRAPPER_VIO_5_CTL          = IOMUX_PAD(0x0360, 0x0018, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO01__PHY_DTB_0                          = IOMUX_PAD(0x0360, 0x0018, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO02__I2C2_SCL                           = IOMUX_PAD(0x0364, 0x001C, 0x10 | 0, 0x07B0, 1, 0),
+	MX6SX_PAD_GPIO1_IO02__USDHC1_CD_B                        = IOMUX_PAD(0x0364, 0x001C, 1, 0x0864, 1, 0),
+	MX6SX_PAD_GPIO1_IO02__CSI2_MCLK                          = IOMUX_PAD(0x0364, 0x001C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO02__CCM_DI0_EXT_CLK                    = IOMUX_PAD(0x0364, 0x001C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO02__WDOG1_WDOG_B                       = IOMUX_PAD(0x0364, 0x001C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO02__GPIO1_IO_2                         = IOMUX_PAD(0x0364, 0x001C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO02__CCM_REF_EN_B                       = IOMUX_PAD(0x0364, 0x001C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO02__PHY_TDI                            = IOMUX_PAD(0x0364, 0x001C, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO03__I2C2_SDA                           = IOMUX_PAD(0x0368, 0x0020, 0x10 | 0, 0x07B4, 1, 0),
+	MX6SX_PAD_GPIO1_IO03__USDHC1_WP                          = IOMUX_PAD(0x0368, 0x0020, 1, 0x0868, 1, 0),
+	MX6SX_PAD_GPIO1_IO03__ENET1_REF_CLK_25M                  = IOMUX_PAD(0x0368, 0x0020, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO03__CCM_DI1_EXT_CLK                    = IOMUX_PAD(0x0368, 0x0020, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO03__WDOG2_WDOG_B                       = IOMUX_PAD(0x0368, 0x0020, 4, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO03__GPIO1_IO_3                         = IOMUX_PAD(0x0368, 0x0020, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO03__CCM_PLL3_BYP                       = IOMUX_PAD(0x0368, 0x0020, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO03__PHY_TCK                            = IOMUX_PAD(0x0368, 0x0020, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO04__UART1_TX                           = IOMUX_PAD(0x036C, 0x0024, 0, 0x0830, 0, 0),
+	MX6SX_PAD_GPIO1_IO04__USDHC2_RESET_B                     = IOMUX_PAD(0x036C, 0x0024, 1, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO04__ENET1_MDC                          = IOMUX_PAD(0x036C, 0x0024, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO04__OSC32K_32K_OUT                     = IOMUX_PAD(0x036C, 0x0024, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO04__ENET2_REF_CLK2                     = IOMUX_PAD(0x036C, 0x0024, 4, 0x076C, 0, 0),
+	MX6SX_PAD_GPIO1_IO04__GPIO1_IO_4                         = IOMUX_PAD(0x036C, 0x0024, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO04__CCM_PLL2_BYP                       = IOMUX_PAD(0x036C, 0x0024, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO04__PHY_TMS                            = IOMUX_PAD(0x036C, 0x0024, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO05__UART1_RX                           = IOMUX_PAD(0x0370, 0x0028, 0, 0x0830, 1, 0),
+	MX6SX_PAD_GPIO1_IO05__USDHC2_VSELECT                     = IOMUX_PAD(0x0370, 0x0028, 1, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO05__ENET1_MDIO                         = IOMUX_PAD(0x0370, 0x0028, 2, 0x0764, 0, 0),
+	MX6SX_PAD_GPIO1_IO05__ASRC_ASRC_EXT_CLK                  = IOMUX_PAD(0x0370, 0x0028, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO05__ENET1_REF_CLK1                     = IOMUX_PAD(0x0370, 0x0028, 4, 0x0760, 0, 0),
+	MX6SX_PAD_GPIO1_IO05__GPIO1_IO_5                         = IOMUX_PAD(0x0370, 0x0028, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO05__SRC_TESTER_ACK                     = IOMUX_PAD(0x0370, 0x0028, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO05__PHY_TDO                            = IOMUX_PAD(0x0370, 0x0028, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO06__UART2_TX                           = IOMUX_PAD(0x0374, 0x002C, 0, 0x0838, 0, 0),
+	MX6SX_PAD_GPIO1_IO06__USDHC2_CD_B                        = IOMUX_PAD(0x0374, 0x002C, 1, 0x086C, 1, 0),
+	MX6SX_PAD_GPIO1_IO06__ENET2_MDC                          = IOMUX_PAD(0x0374, 0x002C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO06__CSI1_MCLK                          = IOMUX_PAD(0x0374, 0x002C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO06__UART1_RTS_B                        = IOMUX_PAD(0x0374, 0x002C, 4, 0x082C, 0, 0),
+	MX6SX_PAD_GPIO1_IO06__GPIO1_IO_6                         = IOMUX_PAD(0x0374, 0x002C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO06__SRC_ANY_PU_RESET                   = IOMUX_PAD(0x0374, 0x002C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO06__OCOTP_CTRL_WRAPPER_FUSE_LATCHED    = IOMUX_PAD(0x0374, 0x002C, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO07__UART2_RX                           = IOMUX_PAD(0x0378, 0x0030, 0, 0x0838, 1, 0),
+	MX6SX_PAD_GPIO1_IO07__USDHC2_WP                          = IOMUX_PAD(0x0378, 0x0030, 1, 0x0870, 1, 0),
+	MX6SX_PAD_GPIO1_IO07__ENET2_MDIO                         = IOMUX_PAD(0x0378, 0x0030, 2, 0x0770, 0, 0),
+	MX6SX_PAD_GPIO1_IO07__AUDMUX_MCLK                        = IOMUX_PAD(0x0378, 0x0030, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO07__UART1_CTS_B                        = IOMUX_PAD(0x0378, 0x0030, 4, 0x082C, 1, 0),
+	MX6SX_PAD_GPIO1_IO07__GPIO1_IO_7                         = IOMUX_PAD(0x0378, 0x0030, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO07__SRC_EARLY_RESET                    = IOMUX_PAD(0x0378, 0x0030, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO07__DCIC2_OUT                          = IOMUX_PAD(0x0378, 0x0030, 7, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO07__VDEC_DEBUG_44                      = IOMUX_PAD(0x0378, 0x0030, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO08__USB_OTG1_OC                        = IOMUX_PAD(0x037C, 0x0034, 0, 0x0860, 0, 0),
+	MX6SX_PAD_GPIO1_IO08__WDOG1_WDOG_B                       = IOMUX_PAD(0x037C, 0x0034, 1, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO08__SDMA_EXT_EVENT_0                   = IOMUX_PAD(0x037C, 0x0034, 2, 0x081C, 0, 0),
+	MX6SX_PAD_GPIO1_IO08__CCM_PMIC_RDY                       = IOMUX_PAD(0x037C, 0x0034, 3, 0x069C, 1, 0),
+	MX6SX_PAD_GPIO1_IO08__UART2_RTS_B                        = IOMUX_PAD(0x037C, 0x0034, 4, 0x0834, 0, 0),
+	MX6SX_PAD_GPIO1_IO08__GPIO1_IO_8                         = IOMUX_PAD(0x037C, 0x0034, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO08__SRC_SYSTEM_RESET                   = IOMUX_PAD(0x037C, 0x0034, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO08__DCIC1_OUT                          = IOMUX_PAD(0x037C, 0x0034, 7, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO08__VDEC_DEBUG_43                      = IOMUX_PAD(0x037C, 0x0034, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO09__USB_OTG1_PWR                       = IOMUX_PAD(0x0380, 0x0038, 0, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO09__WDOG2_WDOG_B                       = IOMUX_PAD(0x0380, 0x0038, 1, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO09__SDMA_EXT_EVENT_1                   = IOMUX_PAD(0x0380, 0x0038, 2, 0x0820, 0, 0),
+	MX6SX_PAD_GPIO1_IO09__CCM_OUT0                           = IOMUX_PAD(0x0380, 0x0038, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO09__UART2_CTS_B                        = IOMUX_PAD(0x0380, 0x0038, 4, 0x0834, 1, 0),
+	MX6SX_PAD_GPIO1_IO09__GPIO1_IO_9                         = IOMUX_PAD(0x0380, 0x0038, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO09__SRC_INT_BOOT                       = IOMUX_PAD(0x0380, 0x0038, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO09__OBSERVE_MUX_OUT_4                  = IOMUX_PAD(0x0380, 0x0038, 7, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO09__VDEC_DEBUG_42                      = IOMUX_PAD(0x0380, 0x0038, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID                     = IOMUX_PAD(0x0384, 0x003C, 0, 0x0624, 0, 0),
+	MX6SX_PAD_GPIO1_IO10__SPDIF_EXT_CLK                      = IOMUX_PAD(0x0384, 0x003C, 1, 0x0828, 0, 0),
+	MX6SX_PAD_GPIO1_IO10__PWM1_OUT                           = IOMUX_PAD(0x0384, 0x003C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO10__CCM_OUT1                           = IOMUX_PAD(0x0384, 0x003C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO10__CSI1_FIELD                         = IOMUX_PAD(0x0384, 0x003C, 4, 0x070C, 1, 0),
+	MX6SX_PAD_GPIO1_IO10__GPIO1_IO_10                        = IOMUX_PAD(0x0384, 0x003C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO10__CSU_CSU_INT_DEB                    = IOMUX_PAD(0x0384, 0x003C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO10__OBSERVE_MUX_OUT_3                  = IOMUX_PAD(0x0384, 0x003C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO10__VDEC_DEBUG_41                      = IOMUX_PAD(0x0384, 0x003C, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO11__USB_OTG2_OC                        = IOMUX_PAD(0x0388, 0x0040, 0, 0x085C, 0, 0),
+	MX6SX_PAD_GPIO1_IO11__SPDIF_IN                           = IOMUX_PAD(0x0388, 0x0040, 1, 0x0824, 2, 0),
+	MX6SX_PAD_GPIO1_IO11__PWM2_OUT                           = IOMUX_PAD(0x0388, 0x0040, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO11__CCM_CLKO1                          = IOMUX_PAD(0x0388, 0x0040, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO11__MLB_DATA                           = IOMUX_PAD(0x0388, 0x0040, 4, 0x07EC, 0, 0),
+	MX6SX_PAD_GPIO1_IO11__GPIO1_IO_11                        = IOMUX_PAD(0x0388, 0x0040, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO11__CSU_CSU_ALARM_AUT_0                = IOMUX_PAD(0x0388, 0x0040, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO11__OBSERVE_MUX_OUT_2                  = IOMUX_PAD(0x0388, 0x0040, 7, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO11__VDEC_DEBUG_40                      = IOMUX_PAD(0x0388, 0x0040, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO12__USB_OTG2_PWR                       = IOMUX_PAD(0x038C, 0x0044, 0, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO12__SPDIF_OUT                          = IOMUX_PAD(0x038C, 0x0044, 1, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO12__PWM3_OUT                           = IOMUX_PAD(0x038C, 0x0044, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO12__CCM_CLKO2                          = IOMUX_PAD(0x038C, 0x0044, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO12__MLB_CLK                            = IOMUX_PAD(0x038C, 0x0044, 4, 0x07E8, 0, 0),
+	MX6SX_PAD_GPIO1_IO12__GPIO1_IO_12                        = IOMUX_PAD(0x038C, 0x0044, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO12__CSU_CSU_ALARM_AUT_1                = IOMUX_PAD(0x038C, 0x0044, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO12__OBSERVE_MUX_OUT_1                  = IOMUX_PAD(0x038C, 0x0044, 7, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO12__VDEC_DEBUG_39                      = IOMUX_PAD(0x038C, 0x0044, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_GPIO1_IO13__WDOG1_WDOG_ANY                     = IOMUX_PAD(0x0390, 0x0048, 0, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO13__ANATOP_OTG2_ID                     = IOMUX_PAD(0x0390, 0x0048, 1, 0x0628, 0, 0),
+	MX6SX_PAD_GPIO1_IO13__PWM4_OUT                           = IOMUX_PAD(0x0390, 0x0048, 2, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO13__CCM_OUT2                           = IOMUX_PAD(0x0390, 0x0048, 3, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO13__MLB_SIG                            = IOMUX_PAD(0x0390, 0x0048, 4, 0x07F0, 0, 0),
+	MX6SX_PAD_GPIO1_IO13__GPIO1_IO_13                        = IOMUX_PAD(0x0390, 0x0048, 5, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO13__CSU_CSU_ALARM_AUT_2                = IOMUX_PAD(0x0390, 0x0048, 6, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO13__OBSERVE_MUX_OUT_0                  = IOMUX_PAD(0x0390, 0x0048, 7, 0x0000, 0, 0),
+	MX6SX_PAD_GPIO1_IO13__VDEC_DEBUG_38                      = IOMUX_PAD(0x0390, 0x0048, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_DATA00__CSI1_DATA_2                        = IOMUX_PAD(0x0394, 0x004C, 0, 0x06A8, 0, 0),
+	MX6SX_PAD_CSI_DATA00__ESAI_TX_CLK                        = IOMUX_PAD(0x0394, 0x004C, 1, 0x078C, 1, 0),
+	MX6SX_PAD_CSI_DATA00__AUDMUX_AUD6_TXC                    = IOMUX_PAD(0x0394, 0x004C, 2, 0x0684, 1, 0),
+	MX6SX_PAD_CSI_DATA00__I2C1_SCL                           = IOMUX_PAD(0x0394, 0x004C, 3, 0x07A8, 0, 0),
+	MX6SX_PAD_CSI_DATA00__UART6_RI_B                         = IOMUX_PAD(0x0394, 0x004C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA00__GPIO1_IO_14                        = IOMUX_PAD(0x0394, 0x004C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA00__WEIM_DATA_23                       = IOMUX_PAD(0x0394, 0x004C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA00__SAI1_TX_BCLK                       = IOMUX_PAD(0x0394, 0x004C, 7, 0x0800, 0, 0),
+	MX6SX_PAD_CSI_DATA00__VADC_DATA_4                        = IOMUX_PAD(0x0394, 0x004C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA00__MMDC_DEBUG_37                      = IOMUX_PAD(0x0394, 0x004C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_DATA01__CSI1_DATA_3                        = IOMUX_PAD(0x0398, 0x0050, 0, 0x06AC, 0, 0),
+	MX6SX_PAD_CSI_DATA01__ESAI_TX_FS                         = IOMUX_PAD(0x0398, 0x0050, 1, 0x077C, 1, 0),
+	MX6SX_PAD_CSI_DATA01__AUDMUX_AUD6_TXFS                   = IOMUX_PAD(0x0398, 0x0050, 2, 0x0688, 1, 0),
+	MX6SX_PAD_CSI_DATA01__I2C1_SDA                           = IOMUX_PAD(0x0398, 0x0050, 3, 0x07AC, 0, 0),
+	MX6SX_PAD_CSI_DATA01__UART6_DSR_B                        = IOMUX_PAD(0x0398, 0x0050, 4, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA01__GPIO1_IO_15                        = IOMUX_PAD(0x0398, 0x0050, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA01__WEIM_DATA_22                       = IOMUX_PAD(0x0398, 0x0050, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA01__SAI1_TX_SYNC                       = IOMUX_PAD(0x0398, 0x0050, 7, 0x0804, 0, 0),
+	MX6SX_PAD_CSI_DATA01__VADC_DATA_5                        = IOMUX_PAD(0x0398, 0x0050, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA01__MMDC_DEBUG_38                      = IOMUX_PAD(0x0398, 0x0050, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_DATA02__CSI1_DATA_4                        = IOMUX_PAD(0x039C, 0x0054, 0, 0x06B0, 0, 0),
+	MX6SX_PAD_CSI_DATA02__ESAI_RX_CLK                        = IOMUX_PAD(0x039C, 0x0054, 1, 0x0788, 1, 0),
+	MX6SX_PAD_CSI_DATA02__AUDMUX_AUD6_RXC                    = IOMUX_PAD(0x039C, 0x0054, 2, 0x067C, 1, 0),
+	MX6SX_PAD_CSI_DATA02__KPP_COL_5                          = IOMUX_PAD(0x039C, 0x0054, 3, 0x07C8, 0, 0),
+	MX6SX_PAD_CSI_DATA02__UART6_DTR_B                        = IOMUX_PAD(0x039C, 0x0054, 4, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA02__GPIO1_IO_16                        = IOMUX_PAD(0x039C, 0x0054, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA02__WEIM_DATA_21                       = IOMUX_PAD(0x039C, 0x0054, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA02__SAI1_RX_BCLK                       = IOMUX_PAD(0x039C, 0x0054, 7, 0x07F4, 0, 0),
+	MX6SX_PAD_CSI_DATA02__VADC_DATA_6                        = IOMUX_PAD(0x039C, 0x0054, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA02__MMDC_DEBUG_39                      = IOMUX_PAD(0x039C, 0x0054, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_DATA03__CSI1_DATA_5                        = IOMUX_PAD(0x03A0, 0x0058, 0, 0x06B4, 0, 0),
+	MX6SX_PAD_CSI_DATA03__ESAI_RX_FS                         = IOMUX_PAD(0x03A0, 0x0058, 1, 0x0778, 1, 0),
+	MX6SX_PAD_CSI_DATA03__AUDMUX_AUD6_RXFS                   = IOMUX_PAD(0x03A0, 0x0058, 2, 0x0680, 1, 0),
+	MX6SX_PAD_CSI_DATA03__KPP_ROW_5                          = IOMUX_PAD(0x03A0, 0x0058, 3, 0x07D4, 0, 0),
+	MX6SX_PAD_CSI_DATA03__UART6_DCD_B                        = IOMUX_PAD(0x03A0, 0x0058, 4, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA03__GPIO1_IO_17                        = IOMUX_PAD(0x03A0, 0x0058, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA03__WEIM_DATA_20                       = IOMUX_PAD(0x03A0, 0x0058, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA03__SAI1_RX_SYNC                       = IOMUX_PAD(0x03A0, 0x0058, 7, 0x07FC, 0, 0),
+	MX6SX_PAD_CSI_DATA03__VADC_DATA_7                        = IOMUX_PAD(0x03A0, 0x0058, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA03__MMDC_DEBUG_40                      = IOMUX_PAD(0x03A0, 0x0058, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_DATA04__CSI1_DATA_6                        = IOMUX_PAD(0x03A4, 0x005C, 0, 0x06B8, 0, 0),
+	MX6SX_PAD_CSI_DATA04__ESAI_TX1                           = IOMUX_PAD(0x03A4, 0x005C, 1, 0x0794, 1, 0),
+	MX6SX_PAD_CSI_DATA04__SPDIF_OUT                          = IOMUX_PAD(0x03A4, 0x005C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA04__KPP_COL_6                          = IOMUX_PAD(0x03A4, 0x005C, 3, 0x07CC, 0, 0),
+	MX6SX_PAD_CSI_DATA04__UART6_RX                           = IOMUX_PAD(0x03A4, 0x005C, 4, 0x0858, 0, 0),
+	MX6SX_PAD_CSI_DATA04__GPIO1_IO_18                        = IOMUX_PAD(0x03A4, 0x005C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA04__WEIM_DATA_19                       = IOMUX_PAD(0x03A4, 0x005C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA04__PWM5_OUT                           = IOMUX_PAD(0x03A4, 0x005C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA04__VADC_DATA_8                        = IOMUX_PAD(0x03A4, 0x005C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA04__MMDC_DEBUG_41                      = IOMUX_PAD(0x03A4, 0x005C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_DATA05__CSI1_DATA_7                        = IOMUX_PAD(0x03A8, 0x0060, 0, 0x06BC, 0, 0),
+	MX6SX_PAD_CSI_DATA05__ESAI_TX4_RX1                       = IOMUX_PAD(0x03A8, 0x0060, 1, 0x07A0, 1, 0),
+	MX6SX_PAD_CSI_DATA05__SPDIF_IN                           = IOMUX_PAD(0x03A8, 0x0060, 2, 0x0824, 1, 0),
+	MX6SX_PAD_CSI_DATA05__KPP_ROW_6                          = IOMUX_PAD(0x03A8, 0x0060, 3, 0x07D8, 0, 0),
+	MX6SX_PAD_CSI_DATA05__UART6_TX                           = IOMUX_PAD(0x03A8, 0x0060, 4, 0x0858, 1, 0),
+	MX6SX_PAD_CSI_DATA05__GPIO1_IO_19                        = IOMUX_PAD(0x03A8, 0x0060, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA05__WEIM_DATA_18                       = IOMUX_PAD(0x03A8, 0x0060, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA05__PWM6_OUT                           = IOMUX_PAD(0x03A8, 0x0060, 7, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA05__VADC_DATA_9                        = IOMUX_PAD(0x03A8, 0x0060, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA05__MMDC_DEBUG_42                      = IOMUX_PAD(0x03A8, 0x0060, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_DATA06__CSI1_DATA_8                        = IOMUX_PAD(0x03AC, 0x0064, 0, 0x06C0, 0, 0),
+	MX6SX_PAD_CSI_DATA06__ESAI_TX2_RX3                       = IOMUX_PAD(0x03AC, 0x0064, 1, 0x0798, 1, 0),
+	MX6SX_PAD_CSI_DATA06__I2C4_SCL                           = IOMUX_PAD(0x03AC, 0x0064, 2, 0x07C0, 2, 0),
+	MX6SX_PAD_CSI_DATA06__KPP_COL_7                          = IOMUX_PAD(0x03AC, 0x0064, 3, 0x07D0, 0, 0),
+	MX6SX_PAD_CSI_DATA06__UART6_RTS_B                        = IOMUX_PAD(0x03AC, 0x0064, 4, 0x0854, 0, 0),
+	MX6SX_PAD_CSI_DATA06__GPIO1_IO_20                        = IOMUX_PAD(0x03AC, 0x0064, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA06__WEIM_DATA_17                       = IOMUX_PAD(0x03AC, 0x0064, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA06__DCIC2_OUT                          = IOMUX_PAD(0x03AC, 0x0064, 7, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA06__VADC_DATA_10                       = IOMUX_PAD(0x03AC, 0x0064, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA06__MMDC_DEBUG_43                      = IOMUX_PAD(0x03AC, 0x0064, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_DATA07__CSI1_DATA_9                        = IOMUX_PAD(0x03B0, 0x0068, 0, 0x06C4, 0, 0),
+	MX6SX_PAD_CSI_DATA07__ESAI_TX3_RX2                       = IOMUX_PAD(0x03B0, 0x0068, 1, 0x079C, 1, 0),
+	MX6SX_PAD_CSI_DATA07__I2C4_SDA                           = IOMUX_PAD(0x03B0, 0x0068, 2, 0x07C4, 2, 0),
+	MX6SX_PAD_CSI_DATA07__KPP_ROW_7                          = IOMUX_PAD(0x03B0, 0x0068, 3, 0x07DC, 0, 0),
+	MX6SX_PAD_CSI_DATA07__UART6_CTS_B                        = IOMUX_PAD(0x03B0, 0x0068, 4, 0x0854, 1, 0),
+	MX6SX_PAD_CSI_DATA07__GPIO1_IO_21                        = IOMUX_PAD(0x03B0, 0x0068, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA07__WEIM_DATA_16                       = IOMUX_PAD(0x03B0, 0x0068, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA07__DCIC1_OUT                          = IOMUX_PAD(0x03B0, 0x0068, 7, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA07__VADC_DATA_11                       = IOMUX_PAD(0x03B0, 0x0068, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_DATA07__MMDC_DEBUG_44                      = IOMUX_PAD(0x03B0, 0x0068, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_HSYNC__CSI1_HSYNC                          = IOMUX_PAD(0x03B4, 0x006C, 0, 0x0700, 0, 0),
+	MX6SX_PAD_CSI_HSYNC__ESAI_TX0                            = IOMUX_PAD(0x03B4, 0x006C, 1, 0x0790, 1, 0),
+	MX6SX_PAD_CSI_HSYNC__AUDMUX_AUD6_TXD                     = IOMUX_PAD(0x03B4, 0x006C, 2, 0x0678, 1, 0),
+	MX6SX_PAD_CSI_HSYNC__UART4_RTS_B                         = IOMUX_PAD(0x03B4, 0x006C, 3, 0x0844, 2, 0),
+	MX6SX_PAD_CSI_HSYNC__MQS_LEFT                            = IOMUX_PAD(0x03B4, 0x006C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_HSYNC__GPIO1_IO_22                         = IOMUX_PAD(0x03B4, 0x006C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_HSYNC__WEIM_DATA_25                        = IOMUX_PAD(0x03B4, 0x006C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_HSYNC__SAI1_TX_DATA_0                      = IOMUX_PAD(0x03B4, 0x006C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_HSYNC__VADC_DATA_2                         = IOMUX_PAD(0x03B4, 0x006C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_HSYNC__MMDC_DEBUG_35                       = IOMUX_PAD(0x03B4, 0x006C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_MCLK__CSI1_MCLK                            = IOMUX_PAD(0x03B8, 0x0070, 0, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_MCLK__ESAI_TX_HF_CLK                       = IOMUX_PAD(0x03B8, 0x0070, 1, 0x0784, 1, 0),
+	MX6SX_PAD_CSI_MCLK__OSC32K_32K_OUT                       = IOMUX_PAD(0x03B8, 0x0070, 2, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_MCLK__UART4_RX                             = IOMUX_PAD(0x03B8, 0x0070, 3, 0x0848, 2, 0),
+	MX6SX_PAD_CSI_MCLK__ANATOP_32K_OUT                       = IOMUX_PAD(0x03B8, 0x0070, 4, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_MCLK__GPIO1_IO_23                          = IOMUX_PAD(0x03B8, 0x0070, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_MCLK__WEIM_DATA_26                         = IOMUX_PAD(0x03B8, 0x0070, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_MCLK__CSI1_FIELD                           = IOMUX_PAD(0x03B8, 0x0070, 7, 0x070C, 0, 0),
+	MX6SX_PAD_CSI_MCLK__VADC_DATA_1                          = IOMUX_PAD(0x03B8, 0x0070, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_MCLK__MMDC_DEBUG_34                        = IOMUX_PAD(0x03B8, 0x0070, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_PIXCLK__CSI1_PIXCLK                        = IOMUX_PAD(0x03BC, 0x0074, 0, 0x0704, 0, 0),
+	MX6SX_PAD_CSI_PIXCLK__ESAI_RX_HF_CLK                     = IOMUX_PAD(0x03BC, 0x0074, 1, 0x0780, 1, 0),
+	MX6SX_PAD_CSI_PIXCLK__AUDMUX_MCLK                        = IOMUX_PAD(0x03BC, 0x0074, 2, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_PIXCLK__UART4_TX                           = IOMUX_PAD(0x03BC, 0x0074, 3, 0x0848, 3, 0),
+	MX6SX_PAD_CSI_PIXCLK__ANATOP_24M_OUT                     = IOMUX_PAD(0x03BC, 0x0074, 4, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_PIXCLK__GPIO1_IO_24                        = IOMUX_PAD(0x03BC, 0x0074, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_PIXCLK__WEIM_DATA_27                       = IOMUX_PAD(0x03BC, 0x0074, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_PIXCLK__ESAI_TX_HF_CLK                     = IOMUX_PAD(0x03BC, 0x0074, 7, 0x0784, 2, 0),
+	MX6SX_PAD_CSI_PIXCLK__VADC_CLK                           = IOMUX_PAD(0x03BC, 0x0074, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_PIXCLK__MMDC_DEBUG_33                      = IOMUX_PAD(0x03BC, 0x0074, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_CSI_VSYNC__CSI1_VSYNC                          = IOMUX_PAD(0x03C0, 0x0078, 0, 0x0708, 0, 0),
+	MX6SX_PAD_CSI_VSYNC__ESAI_TX5_RX0                        = IOMUX_PAD(0x03C0, 0x0078, 1, 0x07A4, 1, 0),
+	MX6SX_PAD_CSI_VSYNC__AUDMUX_AUD6_RXD                     = IOMUX_PAD(0x03C0, 0x0078, 2, 0x0674, 1, 0),
+	MX6SX_PAD_CSI_VSYNC__UART4_CTS_B                         = IOMUX_PAD(0x03C0, 0x0078, 3, 0x0844, 3, 0),
+	MX6SX_PAD_CSI_VSYNC__MQS_RIGHT                           = IOMUX_PAD(0x03C0, 0x0078, 4, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_VSYNC__GPIO1_IO_25                         = IOMUX_PAD(0x03C0, 0x0078, 5, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_VSYNC__WEIM_DATA_24                        = IOMUX_PAD(0x03C0, 0x0078, 6, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_VSYNC__SAI1_RX_DATA_0                      = IOMUX_PAD(0x03C0, 0x0078, 7, 0x07F8, 0, 0),
+	MX6SX_PAD_CSI_VSYNC__VADC_DATA_3                         = IOMUX_PAD(0x03C0, 0x0078, 8, 0x0000, 0, 0),
+	MX6SX_PAD_CSI_VSYNC__MMDC_DEBUG_36                       = IOMUX_PAD(0x03C0, 0x0078, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET1_COL__ENET1_COL                           = IOMUX_PAD(0x03C4, 0x007C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_COL__ENET2_MDC                           = IOMUX_PAD(0x03C4, 0x007C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_COL__AUDMUX_AUD4_TXC                     = IOMUX_PAD(0x03C4, 0x007C, 2, 0x0654, 1, 0),
+	MX6SX_PAD_ENET1_COL__UART1_RI_B                          = IOMUX_PAD(0x03C4, 0x007C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_COL__SPDIF_EXT_CLK                       = IOMUX_PAD(0x03C4, 0x007C, 4, 0x0828, 1, 0),
+	MX6SX_PAD_ENET1_COL__GPIO2_IO_0                          = IOMUX_PAD(0x03C4, 0x007C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_COL__CSI2_DATA_23                        = IOMUX_PAD(0x03C4, 0x007C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_COL__LCDIF2_DATA_16                      = IOMUX_PAD(0x03C4, 0x007C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_COL__VDEC_DEBUG_37                       = IOMUX_PAD(0x03C4, 0x007C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_COL__PCIE_CTRL_DEBUG_31                  = IOMUX_PAD(0x03C4, 0x007C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET1_CRS__ENET1_CRS                           = IOMUX_PAD(0x03C8, 0x0080, 0, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_CRS__ENET2_MDIO                          = IOMUX_PAD(0x03C8, 0x0080, 1, 0x0770, 1, 0),
+	MX6SX_PAD_ENET1_CRS__AUDMUX_AUD4_TXD                     = IOMUX_PAD(0x03C8, 0x0080, 2, 0x0648, 1, 0),
+	MX6SX_PAD_ENET1_CRS__UART1_DCD_B                         = IOMUX_PAD(0x03C8, 0x0080, 3, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_CRS__SPDIF_LOCK                          = IOMUX_PAD(0x03C8, 0x0080, 4, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_CRS__GPIO2_IO_1                          = IOMUX_PAD(0x03C8, 0x0080, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_CRS__CSI2_DATA_22                        = IOMUX_PAD(0x03C8, 0x0080, 6, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_CRS__LCDIF2_DATA_17                      = IOMUX_PAD(0x03C8, 0x0080, 7, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_CRS__VDEC_DEBUG_36                       = IOMUX_PAD(0x03C8, 0x0080, 8, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_CRS__PCIE_CTRL_DEBUG_30                  = IOMUX_PAD(0x03C8, 0x0080, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET1_MDC__ENET1_MDC                           = IOMUX_PAD(0x03CC, 0x0084, 0, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDC__ENET2_MDC                           = IOMUX_PAD(0x03CC, 0x0084, 1, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDC__AUDMUX_AUD3_RXFS                    = IOMUX_PAD(0x03CC, 0x0084, 2, 0x0638, 1, 0),
+	MX6SX_PAD_ENET1_MDC__ANATOP_24M_OUT                      = IOMUX_PAD(0x03CC, 0x0084, 3, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDC__EPIT2_OUT                           = IOMUX_PAD(0x03CC, 0x0084, 4, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDC__GPIO2_IO_2                          = IOMUX_PAD(0x03CC, 0x0084, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDC__USB_OTG1_PWR                        = IOMUX_PAD(0x03CC, 0x0084, 6, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDC__PWM7_OUT                            = IOMUX_PAD(0x03CC, 0x0084, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET1_MDIO__ENET1_MDIO                         = IOMUX_PAD(0x03D0, 0x0088, 0, 0x0764, 1, 0),
+	MX6SX_PAD_ENET1_MDIO__ENET2_MDIO                         = IOMUX_PAD(0x03D0, 0x0088, 1, 0x0770, 2, 0),
+	MX6SX_PAD_ENET1_MDIO__AUDMUX_MCLK                        = IOMUX_PAD(0x03D0, 0x0088, 2, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDIO__OSC32K_32K_OUT                     = IOMUX_PAD(0x03D0, 0x0088, 3, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDIO__EPIT1_OUT                          = IOMUX_PAD(0x03D0, 0x0088, 4, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDIO__GPIO2_IO_3                         = IOMUX_PAD(0x03D0, 0x0088, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_MDIO__USB_OTG1_OC                        = IOMUX_PAD(0x03D0, 0x0088, 6, 0x0860, 1, 0),
+	MX6SX_PAD_ENET1_MDIO__PWM8_OUT                           = IOMUX_PAD(0x03D0, 0x0088, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET1_RX_CLK__ENET1_RX_CLK                     = IOMUX_PAD(0x03D4, 0x008C, 0, 0x0768, 0, 0),
+	MX6SX_PAD_ENET1_RX_CLK__ENET1_REF_CLK_25M                = IOMUX_PAD(0x03D4, 0x008C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_RX_CLK__AUDMUX_AUD4_TXFS                 = IOMUX_PAD(0x03D4, 0x008C, 2, 0x0658, 1, 0),
+	MX6SX_PAD_ENET1_RX_CLK__UART1_DSR_B                      = IOMUX_PAD(0x03D4, 0x008C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_RX_CLK__SPDIF_OUT                        = IOMUX_PAD(0x03D4, 0x008C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_RX_CLK__GPIO2_IO_4                       = IOMUX_PAD(0x03D4, 0x008C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_RX_CLK__CSI2_DATA_21                     = IOMUX_PAD(0x03D4, 0x008C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_RX_CLK__LCDIF2_DATA_18                   = IOMUX_PAD(0x03D4, 0x008C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_RX_CLK__VDEC_DEBUG_35                    = IOMUX_PAD(0x03D4, 0x008C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_RX_CLK__PCIE_CTRL_DEBUG_29               = IOMUX_PAD(0x03D4, 0x008C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET1_TX_CLK__ENET1_TX_CLK                     = IOMUX_PAD(0x03D8, 0x0090, 0, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_TX_CLK__ENET1_REF_CLK1                   = IOMUX_PAD(0x03D8, 0x0090, 1, 0x0760, 1, 0),
+	MX6SX_PAD_ENET1_TX_CLK__AUDMUX_AUD4_RXD                  = IOMUX_PAD(0x03D8, 0x0090, 2, 0x0644, 1, 0),
+	MX6SX_PAD_ENET1_TX_CLK__UART1_DTR_B                      = IOMUX_PAD(0x03D8, 0x0090, 3, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_TX_CLK__SPDIF_SR_CLK                     = IOMUX_PAD(0x03D8, 0x0090, 4, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_TX_CLK__GPIO2_IO_5                       = IOMUX_PAD(0x03D8, 0x0090, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_TX_CLK__CSI2_DATA_20                     = IOMUX_PAD(0x03D8, 0x0090, 6, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_TX_CLK__LCDIF2_DATA_19                   = IOMUX_PAD(0x03D8, 0x0090, 7, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_TX_CLK__VDEC_DEBUG_34                    = IOMUX_PAD(0x03D8, 0x0090, 8, 0x0000, 0, 0),
+	MX6SX_PAD_ENET1_TX_CLK__PCIE_CTRL_DEBUG_28               = IOMUX_PAD(0x03D8, 0x0090, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET2_COL__ENET2_COL                           = IOMUX_PAD(0x03DC, 0x0094, 0, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_COL__ENET1_MDC                           = IOMUX_PAD(0x03DC, 0x0094, 1, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_COL__AUDMUX_AUD4_RXC                     = IOMUX_PAD(0x03DC, 0x0094, 2, 0x064C, 1, 0),
+	MX6SX_PAD_ENET2_COL__UART1_RX                            = IOMUX_PAD(0x03DC, 0x0094, 3, 0x0830, 2, 0),
+	MX6SX_PAD_ENET2_COL__SPDIF_IN                            = IOMUX_PAD(0x03DC, 0x0094, 4, 0x0824, 3, 0),
+	MX6SX_PAD_ENET2_COL__GPIO2_IO_6                          = IOMUX_PAD(0x03DC, 0x0094, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_COL__ANATOP_OTG1_ID                      = IOMUX_PAD(0x03DC, 0x0094, 6, 0x0624, 1, 0),
+	MX6SX_PAD_ENET2_COL__LCDIF2_DATA_20                      = IOMUX_PAD(0x03DC, 0x0094, 7, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_COL__VDEC_DEBUG_33                       = IOMUX_PAD(0x03DC, 0x0094, 8, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_COL__PCIE_CTRL_DEBUG_27                  = IOMUX_PAD(0x03DC, 0x0094, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET2_CRS__ENET2_CRS                           = IOMUX_PAD(0x03E0, 0x0098, 0, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_CRS__ENET1_MDIO                          = IOMUX_PAD(0x03E0, 0x0098, 1, 0x0764, 2, 0),
+	MX6SX_PAD_ENET2_CRS__AUDMUX_AUD4_RXFS                    = IOMUX_PAD(0x03E0, 0x0098, 2, 0x0650, 1, 0),
+	MX6SX_PAD_ENET2_CRS__UART1_TX                            = IOMUX_PAD(0x03E0, 0x0098, 3, 0x0830, 3, 0),
+	MX6SX_PAD_ENET2_CRS__MLB_SIG                             = IOMUX_PAD(0x03E0, 0x0098, 4, 0x07F0, 1, 0),
+	MX6SX_PAD_ENET2_CRS__GPIO2_IO_7                          = IOMUX_PAD(0x03E0, 0x0098, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_CRS__ANATOP_OTG2_ID                      = IOMUX_PAD(0x03E0, 0x0098, 6, 0x0628, 1, 0),
+	MX6SX_PAD_ENET2_CRS__LCDIF2_DATA_21                      = IOMUX_PAD(0x03E0, 0x0098, 7, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_CRS__VDEC_DEBUG_32                       = IOMUX_PAD(0x03E0, 0x0098, 8, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_CRS__PCIE_CTRL_DEBUG_26                  = IOMUX_PAD(0x03E0, 0x0098, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET2_RX_CLK__ENET2_RX_CLK                     = IOMUX_PAD(0x03E4, 0x009C, 0, 0x0774, 0, 0),
+	MX6SX_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M                = IOMUX_PAD(0x03E4, 0x009C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_RX_CLK__I2C3_SCL                         = IOMUX_PAD(0x03E4, 0x009C, 2, 0x07B8, 1, 0),
+	MX6SX_PAD_ENET2_RX_CLK__UART1_RTS_B                      = IOMUX_PAD(0x03E4, 0x009C, 3, 0x082C, 2, 0),
+	MX6SX_PAD_ENET2_RX_CLK__MLB_DATA                         = IOMUX_PAD(0x03E4, 0x009C, 4, 0x07EC, 1, 0),
+	MX6SX_PAD_ENET2_RX_CLK__GPIO2_IO_8                       = IOMUX_PAD(0x03E4, 0x009C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_RX_CLK__USB_OTG2_OC                      = IOMUX_PAD(0x03E4, 0x009C, 6, 0x085C, 1, 0),
+	MX6SX_PAD_ENET2_RX_CLK__LCDIF2_DATA_22                   = IOMUX_PAD(0x03E4, 0x009C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_RX_CLK__VDEC_DEBUG_31                    = IOMUX_PAD(0x03E4, 0x009C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_RX_CLK__PCIE_CTRL_DEBUG_25               = IOMUX_PAD(0x03E4, 0x009C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_ENET2_TX_CLK__ENET2_TX_CLK                     = IOMUX_PAD(0x03E8, 0x00A0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_TX_CLK__ENET2_REF_CLK2                   = IOMUX_PAD(0x03E8, 0x00A0, 1, 0x076C, 1, 0),
+	MX6SX_PAD_ENET2_TX_CLK__I2C3_SDA                         = IOMUX_PAD(0x03E8, 0x00A0, 2, 0x07BC, 1, 0),
+	MX6SX_PAD_ENET2_TX_CLK__UART1_CTS_B                      = IOMUX_PAD(0x03E8, 0x00A0, 3, 0x082C, 3, 0),
+	MX6SX_PAD_ENET2_TX_CLK__MLB_CLK                          = IOMUX_PAD(0x03E8, 0x00A0, 4, 0x07E8, 1, 0),
+	MX6SX_PAD_ENET2_TX_CLK__GPIO2_IO_9                       = IOMUX_PAD(0x03E8, 0x00A0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_TX_CLK__USB_OTG2_PWR                     = IOMUX_PAD(0x03E8, 0x00A0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_TX_CLK__LCDIF2_DATA_23                   = IOMUX_PAD(0x03E8, 0x00A0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_TX_CLK__VDEC_DEBUG_30                    = IOMUX_PAD(0x03E8, 0x00A0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_ENET2_TX_CLK__PCIE_CTRL_DEBUG_24               = IOMUX_PAD(0x03E8, 0x00A0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_KEY_COL0__KPP_COL_0                            = IOMUX_PAD(0x03EC, 0x00A4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL0__USDHC3_CD_B                          = IOMUX_PAD(0x03EC, 0x00A4, 1, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL0__UART6_RTS_B                          = IOMUX_PAD(0x03EC, 0x00A4, 2, 0x0854, 2, 0),
+	MX6SX_PAD_KEY_COL0__ECSPI1_SCLK                          = IOMUX_PAD(0x03EC, 0x00A4, 3, 0x0710, 0, 0),
+	MX6SX_PAD_KEY_COL0__AUDMUX_AUD5_TXC                      = IOMUX_PAD(0x03EC, 0x00A4, 4, 0x066C, 0, 0),
+	MX6SX_PAD_KEY_COL0__GPIO2_IO_10                          = IOMUX_PAD(0x03EC, 0x00A4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL0__SDMA_EXT_EVENT_1                     = IOMUX_PAD(0x03EC, 0x00A4, 6, 0x0820, 1, 0),
+	MX6SX_PAD_KEY_COL0__SAI2_TX_BCLK                         = IOMUX_PAD(0x03EC, 0x00A4, 7, 0x0814, 0, 0),
+	MX6SX_PAD_KEY_COL0__VADC_DATA_0                          = IOMUX_PAD(0x03EC, 0x00A4, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_KEY_COL1__KPP_COL_1                            = IOMUX_PAD(0x03F0, 0x00A8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL1__USDHC3_RESET_B                       = IOMUX_PAD(0x03F0, 0x00A8, 1, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL1__UART6_TX                             = IOMUX_PAD(0x03F0, 0x00A8, 2, 0x0858, 2, 0),
+	MX6SX_PAD_KEY_COL1__ECSPI1_MISO                          = IOMUX_PAD(0x03F0, 0x00A8, 3, 0x0714, 0, 0),
+	MX6SX_PAD_KEY_COL1__AUDMUX_AUD5_TXFS                     = IOMUX_PAD(0x03F0, 0x00A8, 4, 0x0670, 0, 0),
+	MX6SX_PAD_KEY_COL1__GPIO2_IO_11                          = IOMUX_PAD(0x03F0, 0x00A8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL1__USDHC3_RESET                         = IOMUX_PAD(0x03F0, 0x00A8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL1__SAI2_TX_SYNC                         = IOMUX_PAD(0x03F0, 0x00A8, 7, 0x0818, 0, 0),
+
+	MX6SX_PAD_KEY_COL2__KPP_COL_2                            = IOMUX_PAD(0x03F4, 0x00AC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL2__USDHC4_CD_B                          = IOMUX_PAD(0x03F4, 0x00AC, 1, 0x0874, 1, 0),
+	MX6SX_PAD_KEY_COL2__UART5_RTS_B                          = IOMUX_PAD(0x03F4, 0x00AC, 2, 0x084C, 2, 0),
+	MX6SX_PAD_KEY_COL2__CAN1_TX                              = IOMUX_PAD(0x03F4, 0x00AC, 3, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL2__CANFD_TX1                            = IOMUX_PAD(0x03F4, 0x00AC, 4, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL2__GPIO2_IO_12                          = IOMUX_PAD(0x03F4, 0x00AC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL2__WEIM_DATA_30                         = IOMUX_PAD(0x03F4, 0x00AC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL2__ECSPI1_RDY                           = IOMUX_PAD(0x03F4, 0x00AC, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_KEY_COL3__KPP_COL_3                            = IOMUX_PAD(0x03F8, 0x00B0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL3__USDHC4_LCTL                          = IOMUX_PAD(0x03F8, 0x00B0, 1, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL3__UART5_TX                             = IOMUX_PAD(0x03F8, 0x00B0, 2, 0x0850, 2, 0),
+	MX6SX_PAD_KEY_COL3__CAN2_TX                              = IOMUX_PAD(0x03F8, 0x00B0, 3, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL3__CANFD_TX2                            = IOMUX_PAD(0x03F8, 0x00B0, 4, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL3__GPIO2_IO_13                          = IOMUX_PAD(0x03F8, 0x00B0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL3__WEIM_DATA_28                         = IOMUX_PAD(0x03F8, 0x00B0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL3__ECSPI1_SS2                           = IOMUX_PAD(0x03F8, 0x00B0, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_KEY_COL4__KPP_COL_4                            = IOMUX_PAD(0x03FC, 0x00B4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL4__ENET2_MDC                            = IOMUX_PAD(0x03FC, 0x00B4, 1, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL4__I2C3_SCL                             = IOMUX_PAD(0x03FC, 0x00B4, IOMUX_CONFIG_SION | 2, 0x07B8, 2, 0),
+	MX6SX_PAD_KEY_COL4__USDHC2_LCTL                          = IOMUX_PAD(0x03FC, 0x00B4, 3, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL4__AUDMUX_AUD5_RXC                      = IOMUX_PAD(0x03FC, 0x00B4, 4, 0x0664, 0, 0),
+	MX6SX_PAD_KEY_COL4__GPIO2_IO_14                          = IOMUX_PAD(0x03FC, 0x00B4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL4__WEIM_CRE                             = IOMUX_PAD(0x03FC, 0x00B4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_COL4__SAI2_RX_BCLK                         = IOMUX_PAD(0x03FC, 0x00B4, 7, 0x0808, 0, 0),
+
+	MX6SX_PAD_KEY_ROW0__KPP_ROW_0                            = IOMUX_PAD(0x0400, 0x00B8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW0__USDHC3_WP                            = IOMUX_PAD(0x0400, 0x00B8, 1, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW0__UART6_CTS_B                          = IOMUX_PAD(0x0400, 0x00B8, 2, 0x0854, 3, 0),
+	MX6SX_PAD_KEY_ROW0__ECSPI1_MOSI                          = IOMUX_PAD(0x0400, 0x00B8, 3, 0x0718, 0, 0),
+	MX6SX_PAD_KEY_ROW0__AUDMUX_AUD5_TXD                      = IOMUX_PAD(0x0400, 0x00B8, 4, 0x0660, 0, 0),
+	MX6SX_PAD_KEY_ROW0__GPIO2_IO_15                          = IOMUX_PAD(0x0400, 0x00B8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW0__SDMA_EXT_EVENT_0                     = IOMUX_PAD(0x0400, 0x00B8, 6, 0x081C, 1, 0),
+	MX6SX_PAD_KEY_ROW0__SAI2_TX_DATA_0                       = IOMUX_PAD(0x0400, 0x00B8, 7, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW0__GPU_IDLE                             = IOMUX_PAD(0x0400, 0x00B8, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_KEY_ROW1__KPP_ROW_1                            = IOMUX_PAD(0x0404, 0x00BC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW1__USDHC4_VSELECT                       = IOMUX_PAD(0x0404, 0x00BC, 1, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW1__UART6_RX                             = IOMUX_PAD(0x0404, 0x00BC, 2, 0x0858, 3, 0),
+	MX6SX_PAD_KEY_ROW1__ECSPI1_SS0                           = IOMUX_PAD(0x0404, 0x00BC, 3, 0x071C, 0, 0),
+	MX6SX_PAD_KEY_ROW1__AUDMUX_AUD5_RXD                      = IOMUX_PAD(0x0404, 0x00BC, 4, 0x065C, 0, 0),
+	MX6SX_PAD_KEY_ROW1__GPIO2_IO_16                          = IOMUX_PAD(0x0404, 0x00BC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW1__WEIM_DATA_31                         = IOMUX_PAD(0x0404, 0x00BC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW1__SAI2_RX_DATA_0                       = IOMUX_PAD(0x0404, 0x00BC, 7, 0x080C, 0, 0),
+	MX6SX_PAD_KEY_ROW1__M4_NMI                               = IOMUX_PAD(0x0404, 0x00BC, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_KEY_ROW2__KPP_ROW_2                            = IOMUX_PAD(0x0408, 0x00C0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW2__USDHC4_WP                            = IOMUX_PAD(0x0408, 0x00C0, 1, 0x0878, 1, 0),
+	MX6SX_PAD_KEY_ROW2__UART5_CTS_B                          = IOMUX_PAD(0x0408, 0x00C0, 2, 0x084C, 3, 0),
+	MX6SX_PAD_KEY_ROW2__CAN1_RX                              = IOMUX_PAD(0x0408, 0x00C0, 3, 0x068C, 1, 0),
+	MX6SX_PAD_KEY_ROW2__CANFD_RX1                            = IOMUX_PAD(0x0408, 0x00C0, 4, 0x0694, 1, 0),
+	MX6SX_PAD_KEY_ROW2__GPIO2_IO_17                          = IOMUX_PAD(0x0408, 0x00C0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW2__WEIM_DATA_29                         = IOMUX_PAD(0x0408, 0x00C0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW2__ECSPI1_SS3                           = IOMUX_PAD(0x0408, 0x00C0, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_KEY_ROW3__KPP_ROW_3                            = IOMUX_PAD(0x040C, 0x00C4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW3__USDHC3_LCTL                          = IOMUX_PAD(0x040C, 0x00C4, 1, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW3__UART5_RX                             = IOMUX_PAD(0x040C, 0x00C4, 2, 0x0850, 3, 0),
+	MX6SX_PAD_KEY_ROW3__CAN2_RX                              = IOMUX_PAD(0x040C, 0x00C4, 3, 0x0690, 1, 0),
+	MX6SX_PAD_KEY_ROW3__CANFD_RX2                            = IOMUX_PAD(0x040C, 0x00C4, 4, 0x0698, 1, 0),
+	MX6SX_PAD_KEY_ROW3__GPIO2_IO_18                          = IOMUX_PAD(0x040C, 0x00C4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW3__WEIM_DTACK_B                         = IOMUX_PAD(0x040C, 0x00C4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW3__ECSPI1_SS1                           = IOMUX_PAD(0x040C, 0x00C4, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_KEY_ROW4__KPP_ROW_4                            = IOMUX_PAD(0x0410, 0x00C8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW4__ENET2_MDIO                           = IOMUX_PAD(0x0410, 0x00C8, 1, 0x0770, 3, 0),
+	MX6SX_PAD_KEY_ROW4__I2C3_SDA                             = IOMUX_PAD(0x0410, 0x00C8, IOMUX_CONFIG_SION | 2, 0x07BC, 2, 0),
+	MX6SX_PAD_KEY_ROW4__USDHC1_LCTL                          = IOMUX_PAD(0x0410, 0x00C8, 3, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW4__AUDMUX_AUD5_RXFS                     = IOMUX_PAD(0x0410, 0x00C8, 4, 0x0668, 0, 0),
+	MX6SX_PAD_KEY_ROW4__GPIO2_IO_19                          = IOMUX_PAD(0x0410, 0x00C8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW4__WEIM_ACLK_FREERUN                    = IOMUX_PAD(0x0410, 0x00C8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_KEY_ROW4__SAI2_RX_SYNC                         = IOMUX_PAD(0x0410, 0x00C8, 7, 0x0810, 0, 0),
+
+	MX6SX_PAD_LCD1_CLK__LCDIF1_CLK                           = IOMUX_PAD(0x0414, 0x00CC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_CLK__LCDIF1_WR_RWN                        = IOMUX_PAD(0x0414, 0x00CC, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_CLK__AUDMUX_AUD3_RXC                      = IOMUX_PAD(0x0414, 0x00CC, 2, 0x0634, 1, 0),
+	MX6SX_PAD_LCD1_CLK__ENET1_1588_EVENT2_IN                 = IOMUX_PAD(0x0414, 0x00CC, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_CLK__CSI1_DATA_16                         = IOMUX_PAD(0x0414, 0x00CC, 4, 0x06DC, 0, 0),
+	MX6SX_PAD_LCD1_CLK__GPIO3_IO_0                           = IOMUX_PAD(0x0414, 0x00CC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_CLK__USDHC1_WP                            = IOMUX_PAD(0x0414, 0x00CC, 6, 0x0868, 0, 0),
+	MX6SX_PAD_LCD1_CLK__SIM_M_HADDR_16                       = IOMUX_PAD(0x0414, 0x00CC, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_CLK__VADC_TEST_0                          = IOMUX_PAD(0x0414, 0x00CC, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_CLK__MMDC_DEBUG_0                         = IOMUX_PAD(0x0414, 0x00CC, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA00__LCDIF1_DATA_0                     = IOMUX_PAD(0x0418, 0x00D0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__WEIM_CS1_B                        = IOMUX_PAD(0x0418, 0x00D0, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__M4_TRACE_0                        = IOMUX_PAD(0x0418, 0x00D0, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__KITTEN_TRACE_0                    = IOMUX_PAD(0x0418, 0x00D0, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__CSI1_DATA_20                      = IOMUX_PAD(0x0418, 0x00D0, 4, 0x06EC, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__GPIO3_IO_1                        = IOMUX_PAD(0x0418, 0x00D0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__SRC_BT_CFG_0                      = IOMUX_PAD(0x0418, 0x00D0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__SIM_M_HADDR_21                    = IOMUX_PAD(0x0418, 0x00D0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__VADC_TEST_5                       = IOMUX_PAD(0x0418, 0x00D0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA00__MMDC_DEBUG_5                      = IOMUX_PAD(0x0418, 0x00D0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA01__LCDIF1_DATA_1                     = IOMUX_PAD(0x041C, 0x00D4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__WEIM_CS2_B                        = IOMUX_PAD(0x041C, 0x00D4, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__M4_TRACE_1                        = IOMUX_PAD(0x041C, 0x00D4, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__KITTEN_TRACE_1                    = IOMUX_PAD(0x041C, 0x00D4, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__CSI1_DATA_21                      = IOMUX_PAD(0x041C, 0x00D4, 4, 0x06F0, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__GPIO3_IO_2                        = IOMUX_PAD(0x041C, 0x00D4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__SRC_BT_CFG_1                      = IOMUX_PAD(0x041C, 0x00D4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__SIM_M_HADDR_22                    = IOMUX_PAD(0x041C, 0x00D4, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__VADC_TEST_6                       = IOMUX_PAD(0x041C, 0x00D4, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA01__MMDC_DEBUG_6                      = IOMUX_PAD(0x041C, 0x00D4, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA02__LCDIF1_DATA_2                     = IOMUX_PAD(0x0420, 0x00D8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__WEIM_CS3_B                        = IOMUX_PAD(0x0420, 0x00D8, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__M4_TRACE_2                        = IOMUX_PAD(0x0420, 0x00D8, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__KITTEN_TRACE_2                    = IOMUX_PAD(0x0420, 0x00D8, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__CSI1_DATA_22                      = IOMUX_PAD(0x0420, 0x00D8, 4, 0x06F4, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__GPIO3_IO_3                        = IOMUX_PAD(0x0420, 0x00D8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__SRC_BT_CFG_2                      = IOMUX_PAD(0x0420, 0x00D8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__SIM_M_HADDR_23                    = IOMUX_PAD(0x0420, 0x00D8, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__VADC_TEST_7                       = IOMUX_PAD(0x0420, 0x00D8, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA02__MMDC_DEBUG_7                      = IOMUX_PAD(0x0420, 0x00D8, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA03__LCDIF1_DATA_3                     = IOMUX_PAD(0x0424, 0x00DC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__WEIM_ADDR_24                      = IOMUX_PAD(0x0424, 0x00DC, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__M4_TRACE_3                        = IOMUX_PAD(0x0424, 0x00DC, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__KITTEN_TRACE_3                    = IOMUX_PAD(0x0424, 0x00DC, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__CSI1_DATA_23                      = IOMUX_PAD(0x0424, 0x00DC, 4, 0x06F8, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__GPIO3_IO_4                        = IOMUX_PAD(0x0424, 0x00DC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__SRC_BT_CFG_3                      = IOMUX_PAD(0x0424, 0x00DC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__SIM_M_HADDR_24                    = IOMUX_PAD(0x0424, 0x00DC, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__VADC_TEST_8                       = IOMUX_PAD(0x0424, 0x00DC, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA03__MMDC_DEBUG_8                      = IOMUX_PAD(0x0424, 0x00DC, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA04__LCDIF1_DATA_4                     = IOMUX_PAD(0x0428, 0x00E0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA04__WEIM_ADDR_25                      = IOMUX_PAD(0x0428, 0x00E0, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA04__KITTEN_TRACE_4                    = IOMUX_PAD(0x0428, 0x00E0, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA04__CSI1_VSYNC                        = IOMUX_PAD(0x0428, 0x00E0, 4, 0x0708, 1, 0),
+	MX6SX_PAD_LCD1_DATA04__GPIO3_IO_5                        = IOMUX_PAD(0x0428, 0x00E0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA04__SRC_BT_CFG_4                      = IOMUX_PAD(0x0428, 0x00E0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA04__SIM_M_HADDR_25                    = IOMUX_PAD(0x0428, 0x00E0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA04__VADC_TEST_9                       = IOMUX_PAD(0x0428, 0x00E0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA04__MMDC_DEBUG_9                      = IOMUX_PAD(0x0428, 0x00E0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA05__LCDIF1_DATA_5                     = IOMUX_PAD(0x042C, 0x00E4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA05__WEIM_ADDR_26                      = IOMUX_PAD(0x042C, 0x00E4, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA05__KITTEN_TRACE_5                    = IOMUX_PAD(0x042C, 0x00E4, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA05__CSI1_HSYNC                        = IOMUX_PAD(0x042C, 0x00E4, 4, 0x0700, 1, 0),
+	MX6SX_PAD_LCD1_DATA05__GPIO3_IO_6                        = IOMUX_PAD(0x042C, 0x00E4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA05__SRC_BT_CFG_5                      = IOMUX_PAD(0x042C, 0x00E4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA05__SIM_M_HADDR_26                    = IOMUX_PAD(0x042C, 0x00E4, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA05__VADC_TEST_10                      = IOMUX_PAD(0x042C, 0x00E4, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA05__MMDC_DEBUG_10                     = IOMUX_PAD(0x042C, 0x00E4, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA06__LCDIF1_DATA_6                     = IOMUX_PAD(0x0430, 0x00E8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA06__WEIM_EB_B_2                       = IOMUX_PAD(0x0430, 0x00E8, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA06__KITTEN_TRACE_6                    = IOMUX_PAD(0x0430, 0x00E8, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA06__CSI1_PIXCLK                       = IOMUX_PAD(0x0430, 0x00E8, 4, 0x0704, 1, 0),
+	MX6SX_PAD_LCD1_DATA06__GPIO3_IO_7                        = IOMUX_PAD(0x0430, 0x00E8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA06__SRC_BT_CFG_6                      = IOMUX_PAD(0x0430, 0x00E8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA06__SIM_M_HADDR_27                    = IOMUX_PAD(0x0430, 0x00E8, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA06__VADC_TEST_11                      = IOMUX_PAD(0x0430, 0x00E8, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA06__MMDC_DEBUG_11                     = IOMUX_PAD(0x0430, 0x00E8, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA07__LCDIF1_DATA_7                     = IOMUX_PAD(0x0434, 0x00EC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA07__WEIM_EB_B_3                       = IOMUX_PAD(0x0434, 0x00EC, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA07__KITTEN_TRACE_7                    = IOMUX_PAD(0x0434, 0x00EC, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA07__CSI1_MCLK                         = IOMUX_PAD(0x0434, 0x00EC, 4, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA07__GPIO3_IO_8                        = IOMUX_PAD(0x0434, 0x00EC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA07__SRC_BT_CFG_7                      = IOMUX_PAD(0x0434, 0x00EC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA07__SIM_M_HADDR_28                    = IOMUX_PAD(0x0434, 0x00EC, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA07__VADC_TEST_12                      = IOMUX_PAD(0x0434, 0x00EC, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA07__MMDC_DEBUG_12                     = IOMUX_PAD(0x0434, 0x00EC, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA08__LCDIF1_DATA_8                     = IOMUX_PAD(0x0438, 0x00F0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA08__WEIM_AD_8                         = IOMUX_PAD(0x0438, 0x00F0, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA08__KITTEN_TRACE_8                    = IOMUX_PAD(0x0438, 0x00F0, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA08__CSI1_DATA_9                       = IOMUX_PAD(0x0438, 0x00F0, 4, 0x06C4, 1, 0),
+	MX6SX_PAD_LCD1_DATA08__GPIO3_IO_9                        = IOMUX_PAD(0x0438, 0x00F0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA08__SRC_BT_CFG_8                      = IOMUX_PAD(0x0438, 0x00F0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA08__SIM_M_HADDR_29                    = IOMUX_PAD(0x0438, 0x00F0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA08__VADC_TEST_13                      = IOMUX_PAD(0x0438, 0x00F0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA08__MMDC_DEBUG_13                     = IOMUX_PAD(0x0438, 0x00F0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA09__LCDIF1_DATA_9                     = IOMUX_PAD(0x043C, 0x00F4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA09__WEIM_AD_9                         = IOMUX_PAD(0x043C, 0x00F4, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA09__KITTEN_TRACE_9                    = IOMUX_PAD(0x043C, 0x00F4, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA09__CSI1_DATA_8                       = IOMUX_PAD(0x043C, 0x00F4, 4, 0x06C0, 1, 0),
+	MX6SX_PAD_LCD1_DATA09__GPIO3_IO_10                       = IOMUX_PAD(0x043C, 0x00F4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA09__SRC_BT_CFG_9                      = IOMUX_PAD(0x043C, 0x00F4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA09__SIM_M_HADDR_30                    = IOMUX_PAD(0x043C, 0x00F4, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA09__VADC_TEST_14                      = IOMUX_PAD(0x043C, 0x00F4, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA09__MMDC_DEBUG_14                     = IOMUX_PAD(0x043C, 0x00F4, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA10__LCDIF1_DATA_10                    = IOMUX_PAD(0x0440, 0x00F8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA10__WEIM_AD_10                        = IOMUX_PAD(0x0440, 0x00F8, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA10__KITTEN_TRACE_10                   = IOMUX_PAD(0x0440, 0x00F8, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA10__CSI1_DATA_7                       = IOMUX_PAD(0x0440, 0x00F8, 4, 0x06BC, 1, 0),
+	MX6SX_PAD_LCD1_DATA10__GPIO3_IO_11                       = IOMUX_PAD(0x0440, 0x00F8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA10__SRC_BT_CFG_10                     = IOMUX_PAD(0x0440, 0x00F8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA10__SIM_M_HADDR_31                    = IOMUX_PAD(0x0440, 0x00F8, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA10__VADC_TEST_15                      = IOMUX_PAD(0x0440, 0x00F8, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA10__MMDC_DEBUG_15                     = IOMUX_PAD(0x0440, 0x00F8, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA11__LCDIF1_DATA_11                    = IOMUX_PAD(0x0444, 0x00FC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA11__WEIM_AD_11                        = IOMUX_PAD(0x0444, 0x00FC, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA11__KITTEN_TRACE_11                   = IOMUX_PAD(0x0444, 0x00FC, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA11__CSI1_DATA_6                       = IOMUX_PAD(0x0444, 0x00FC, 4, 0x06B8, 1, 0),
+	MX6SX_PAD_LCD1_DATA11__GPIO3_IO_12                       = IOMUX_PAD(0x0444, 0x00FC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA11__SRC_BT_CFG_11                     = IOMUX_PAD(0x0444, 0x00FC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA11__SIM_M_HBURST_0                    = IOMUX_PAD(0x0444, 0x00FC, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA11__VADC_TEST_16                      = IOMUX_PAD(0x0444, 0x00FC, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA11__MMDC_DEBUG_16                     = IOMUX_PAD(0x0444, 0x00FC, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA12__LCDIF1_DATA_12                    = IOMUX_PAD(0x0448, 0x0100, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA12__WEIM_AD_12                        = IOMUX_PAD(0x0448, 0x0100, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA12__KITTEN_TRACE_12                   = IOMUX_PAD(0x0448, 0x0100, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA12__CSI1_DATA_5                       = IOMUX_PAD(0x0448, 0x0100, 4, 0x06B4, 1, 0),
+	MX6SX_PAD_LCD1_DATA12__GPIO3_IO_13                       = IOMUX_PAD(0x0448, 0x0100, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA12__SRC_BT_CFG_12                     = IOMUX_PAD(0x0448, 0x0100, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA12__SIM_M_HBURST_1                    = IOMUX_PAD(0x0448, 0x0100, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA12__VADC_TEST_17                      = IOMUX_PAD(0x0448, 0x0100, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA12__MMDC_DEBUG_17                     = IOMUX_PAD(0x0448, 0x0100, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA13__LCDIF1_DATA_13                    = IOMUX_PAD(0x044C, 0x0104, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA13__WEIM_AD_13                        = IOMUX_PAD(0x044C, 0x0104, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA13__KITTEN_TRACE_13                   = IOMUX_PAD(0x044C, 0x0104, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA13__CSI1_DATA_4                       = IOMUX_PAD(0x044C, 0x0104, 4, 0x06B0, 1, 0),
+	MX6SX_PAD_LCD1_DATA13__GPIO3_IO_14                       = IOMUX_PAD(0x044C, 0x0104, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA13__SRC_BT_CFG_13                     = IOMUX_PAD(0x044C, 0x0104, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA13__SIM_M_HBURST_2                    = IOMUX_PAD(0x044C, 0x0104, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA13__VADC_TEST_18                      = IOMUX_PAD(0x044C, 0x0104, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA13__MMDC_DEBUG_18                     = IOMUX_PAD(0x044C, 0x0104, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA14__LCDIF1_DATA_14                    = IOMUX_PAD(0x0450, 0x0108, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA14__WEIM_AD_14                        = IOMUX_PAD(0x0450, 0x0108, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA14__KITTEN_TRACE_14                   = IOMUX_PAD(0x0450, 0x0108, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA14__CSI1_DATA_3                       = IOMUX_PAD(0x0450, 0x0108, 4, 0x06AC, 1, 0),
+	MX6SX_PAD_LCD1_DATA14__GPIO3_IO_15                       = IOMUX_PAD(0x0450, 0x0108, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA14__SRC_BT_CFG_14                     = IOMUX_PAD(0x0450, 0x0108, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA14__SIM_M_HMASTLOCK                   = IOMUX_PAD(0x0450, 0x0108, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA14__VADC_TEST_19                      = IOMUX_PAD(0x0450, 0x0108, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA14__MMDC_DEBUG_19                     = IOMUX_PAD(0x0450, 0x0108, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA15__LCDIF1_DATA_15                    = IOMUX_PAD(0x0454, 0x010C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA15__WEIM_AD_15                        = IOMUX_PAD(0x0454, 0x010C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA15__KITTEN_TRACE_15                   = IOMUX_PAD(0x0454, 0x010C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA15__CSI1_DATA_2                       = IOMUX_PAD(0x0454, 0x010C, 4, 0x06A8, 1, 0),
+	MX6SX_PAD_LCD1_DATA15__GPIO3_IO_16                       = IOMUX_PAD(0x0454, 0x010C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA15__SRC_BT_CFG_15                     = IOMUX_PAD(0x0454, 0x010C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA15__SIM_M_HPROT_0                     = IOMUX_PAD(0x0454, 0x010C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA15__VDEC_DEBUG_0                      = IOMUX_PAD(0x0454, 0x010C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA15__MMDC_DEBUG_20                     = IOMUX_PAD(0x0454, 0x010C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA16__LCDIF1_DATA_16                    = IOMUX_PAD(0x0458, 0x0110, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__WEIM_ADDR_16                      = IOMUX_PAD(0x0458, 0x0110, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__M4_TRACE_CLK                      = IOMUX_PAD(0x0458, 0x0110, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__KITTEN_TRACE_CLK                  = IOMUX_PAD(0x0458, 0x0110, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__CSI1_DATA_1                       = IOMUX_PAD(0x0458, 0x0110, 4, 0x06A4, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__GPIO3_IO_17                       = IOMUX_PAD(0x0458, 0x0110, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__SRC_BT_CFG_24                     = IOMUX_PAD(0x0458, 0x0110, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__SIM_M_HPROT_1                     = IOMUX_PAD(0x0458, 0x0110, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__VDEC_DEBUG_1                      = IOMUX_PAD(0x0458, 0x0110, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA16__MMDC_DEBUG_21                     = IOMUX_PAD(0x0458, 0x0110, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA17__LCDIF1_DATA_17                    = IOMUX_PAD(0x045C, 0x0114, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA17__WEIM_ADDR_17                      = IOMUX_PAD(0x045C, 0x0114, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA17__KITTEN_TRACE_CTL                  = IOMUX_PAD(0x045C, 0x0114, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA17__CSI1_DATA_0                       = IOMUX_PAD(0x045C, 0x0114, 4, 0x06A0, 0, 0),
+	MX6SX_PAD_LCD1_DATA17__GPIO3_IO_18                       = IOMUX_PAD(0x045C, 0x0114, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA17__SRC_BT_CFG_25                     = IOMUX_PAD(0x045C, 0x0114, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA17__SIM_M_HPROT_2                     = IOMUX_PAD(0x045C, 0x0114, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA17__VDEC_DEBUG_2                      = IOMUX_PAD(0x045C, 0x0114, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA17__MMDC_DEBUG_22                     = IOMUX_PAD(0x045C, 0x0114, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA18__LCDIF1_DATA_18                    = IOMUX_PAD(0x0460, 0x0118, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__WEIM_ADDR_18                      = IOMUX_PAD(0x0460, 0x0118, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__M4_EVENTO                         = IOMUX_PAD(0x0460, 0x0118, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__KITTEN_EVENTO                     = IOMUX_PAD(0x0460, 0x0118, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__CSI1_DATA_15                      = IOMUX_PAD(0x0460, 0x0118, 4, 0x06D8, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__GPIO3_IO_19                       = IOMUX_PAD(0x0460, 0x0118, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__SRC_BT_CFG_26                     = IOMUX_PAD(0x0460, 0x0118, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__SIM_M_HPROT_3                     = IOMUX_PAD(0x0460, 0x0118, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__VDEC_DEBUG_3                      = IOMUX_PAD(0x0460, 0x0118, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA18__MMDC_DEBUG_23                     = IOMUX_PAD(0x0460, 0x0118, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA19__LCDIF1_DATA_19                    = IOMUX_PAD(0x0464, 0x011C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA19__WEIM_ADDR_19                      = IOMUX_PAD(0x0464, 0x011C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA19__M4_TRACE_SWO                      = IOMUX_PAD(0x0464, 0x011C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA19__CSI1_DATA_14                      = IOMUX_PAD(0x0464, 0x011C, 4, 0x06D4, 0, 0),
+	MX6SX_PAD_LCD1_DATA19__GPIO3_IO_20                       = IOMUX_PAD(0x0464, 0x011C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA19__SRC_BT_CFG_27                     = IOMUX_PAD(0x0464, 0x011C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA19__SIM_M_HREADYOUT                   = IOMUX_PAD(0x0464, 0x011C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA19__VDEC_DEBUG_4                      = IOMUX_PAD(0x0464, 0x011C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA19__MMDC_DEBUG_24                     = IOMUX_PAD(0x0464, 0x011C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA20__LCDIF1_DATA_20                    = IOMUX_PAD(0x0468, 0x0120, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__WEIM_ADDR_20                      = IOMUX_PAD(0x0468, 0x0120, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__PWM8_OUT                          = IOMUX_PAD(0x0468, 0x0120, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__ENET1_1588_EVENT2_OUT             = IOMUX_PAD(0x0468, 0x0120, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__CSI1_DATA_13                      = IOMUX_PAD(0x0468, 0x0120, 4, 0x06D0, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__GPIO3_IO_21                       = IOMUX_PAD(0x0468, 0x0120, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__SRC_BT_CFG_28                     = IOMUX_PAD(0x0468, 0x0120, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__SIM_M_HRESP                       = IOMUX_PAD(0x0468, 0x0120, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__VDEC_DEBUG_5                      = IOMUX_PAD(0x0468, 0x0120, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA20__MMDC_DEBUG_25                     = IOMUX_PAD(0x0468, 0x0120, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA21__LCDIF1_DATA_21                    = IOMUX_PAD(0x046C, 0x0124, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__WEIM_ADDR_21                      = IOMUX_PAD(0x046C, 0x0124, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__PWM7_OUT                          = IOMUX_PAD(0x046C, 0x0124, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__ENET1_1588_EVENT3_OUT             = IOMUX_PAD(0x046C, 0x0124, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__CSI1_DATA_12                      = IOMUX_PAD(0x046C, 0x0124, 4, 0x06CC, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__GPIO3_IO_22                       = IOMUX_PAD(0x046C, 0x0124, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__SRC_BT_CFG_29                     = IOMUX_PAD(0x046C, 0x0124, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__SIM_M_HSIZE_0                     = IOMUX_PAD(0x046C, 0x0124, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__VDEC_DEBUG_6                      = IOMUX_PAD(0x046C, 0x0124, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA21__MMDC_DEBUG_26                     = IOMUX_PAD(0x046C, 0x0124, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA22__LCDIF1_DATA_22                    = IOMUX_PAD(0x0470, 0x0128, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__WEIM_ADDR_22                      = IOMUX_PAD(0x0470, 0x0128, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__PWM6_OUT                          = IOMUX_PAD(0x0470, 0x0128, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__ENET2_1588_EVENT2_OUT             = IOMUX_PAD(0x0470, 0x0128, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__CSI1_DATA_11                      = IOMUX_PAD(0x0470, 0x0128, 4, 0x06C8, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__GPIO3_IO_23                       = IOMUX_PAD(0x0470, 0x0128, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__SRC_BT_CFG_30                     = IOMUX_PAD(0x0470, 0x0128, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__SIM_M_HSIZE_1                     = IOMUX_PAD(0x0470, 0x0128, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__VDEC_DEBUG_7                      = IOMUX_PAD(0x0470, 0x0128, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA22__MMDC_DEBUG_27                     = IOMUX_PAD(0x0470, 0x0128, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_DATA23__LCDIF1_DATA_23                    = IOMUX_PAD(0x0474, 0x012C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__WEIM_ADDR_23                      = IOMUX_PAD(0x0474, 0x012C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__PWM5_OUT                          = IOMUX_PAD(0x0474, 0x012C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__ENET2_1588_EVENT3_OUT             = IOMUX_PAD(0x0474, 0x012C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__CSI1_DATA_10                      = IOMUX_PAD(0x0474, 0x012C, 4, 0x06FC, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__GPIO3_IO_24                       = IOMUX_PAD(0x0474, 0x012C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__SRC_BT_CFG_31                     = IOMUX_PAD(0x0474, 0x012C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__SIM_M_HSIZE_2                     = IOMUX_PAD(0x0474, 0x012C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__VDEC_DEBUG_8                      = IOMUX_PAD(0x0474, 0x012C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_DATA23__MMDC_DEBUG_28                     = IOMUX_PAD(0x0474, 0x012C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_ENABLE__LCDIF1_ENABLE                     = IOMUX_PAD(0x0478, 0x0130, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_ENABLE__LCDIF1_RD_E                       = IOMUX_PAD(0x0478, 0x0130, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_ENABLE__AUDMUX_AUD3_TXC                   = IOMUX_PAD(0x0478, 0x0130, 2, 0x063C, 1, 0),
+	MX6SX_PAD_LCD1_ENABLE__ENET1_1588_EVENT3_IN              = IOMUX_PAD(0x0478, 0x0130, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_ENABLE__CSI1_DATA_17                      = IOMUX_PAD(0x0478, 0x0130, 4, 0x06E0, 0, 0),
+	MX6SX_PAD_LCD1_ENABLE__GPIO3_IO_25                       = IOMUX_PAD(0x0478, 0x0130, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_ENABLE__USDHC1_CD_B                       = IOMUX_PAD(0x0478, 0x0130, 6, 0x0864, 0, 0),
+	MX6SX_PAD_LCD1_ENABLE__SIM_M_HADDR_17                    = IOMUX_PAD(0x0478, 0x0130, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_ENABLE__VADC_TEST_1                       = IOMUX_PAD(0x0478, 0x0130, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_ENABLE__MMDC_DEBUG_1                      = IOMUX_PAD(0x0478, 0x0130, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_HSYNC__LCDIF1_HSYNC                       = IOMUX_PAD(0x047C, 0x0134, 0, 0x07E0, 0, 0),
+	MX6SX_PAD_LCD1_HSYNC__LCDIF1_RS                          = IOMUX_PAD(0x047C, 0x0134, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_HSYNC__AUDMUX_AUD3_TXD                    = IOMUX_PAD(0x047C, 0x0134, 2, 0x0630, 1, 0),
+	MX6SX_PAD_LCD1_HSYNC__ENET2_1588_EVENT2_IN               = IOMUX_PAD(0x047C, 0x0134, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_HSYNC__CSI1_DATA_18                       = IOMUX_PAD(0x047C, 0x0134, 4, 0x06E4, 0, 0),
+	MX6SX_PAD_LCD1_HSYNC__GPIO3_IO_26                        = IOMUX_PAD(0x047C, 0x0134, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_HSYNC__USDHC2_WP                          = IOMUX_PAD(0x047C, 0x0134, 6, 0x0870, 0, 0),
+	MX6SX_PAD_LCD1_HSYNC__SIM_M_HADDR_18                     = IOMUX_PAD(0x047C, 0x0134, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_HSYNC__VADC_TEST_2                        = IOMUX_PAD(0x047C, 0x0134, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_HSYNC__MMDC_DEBUG_2                       = IOMUX_PAD(0x047C, 0x0134, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_RESET__LCDIF1_RESET                       = IOMUX_PAD(0x0480, 0x0138, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_RESET__LCDIF1_CS                          = IOMUX_PAD(0x0480, 0x0138, 1, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_RESET__AUDMUX_AUD3_RXD                    = IOMUX_PAD(0x0480, 0x0138, 2, 0x062C, 1, 0),
+	MX6SX_PAD_LCD1_RESET__KITTEN_EVENTI                      = IOMUX_PAD(0x0480, 0x0138, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_RESET__M4_EVENTI                          = IOMUX_PAD(0x0480, 0x0138, 4, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_RESET__GPIO3_IO_27                        = IOMUX_PAD(0x0480, 0x0138, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_RESET__CCM_PMIC_RDY                       = IOMUX_PAD(0x0480, 0x0138, 6, 0x069C, 0, 0),
+	MX6SX_PAD_LCD1_RESET__SIM_M_HADDR_20                     = IOMUX_PAD(0x0480, 0x0138, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_RESET__VADC_TEST_4                        = IOMUX_PAD(0x0480, 0x0138, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_RESET__MMDC_DEBUG_4                       = IOMUX_PAD(0x0480, 0x0138, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_LCD1_VSYNC__LCDIF1_VSYNC                       = IOMUX_PAD(0x0484, 0x013C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_VSYNC__LCDIF1_BUSY                        = IOMUX_PAD(0x0484, 0x013C, 1, 0x07E0, 1, 0),
+	MX6SX_PAD_LCD1_VSYNC__AUDMUX_AUD3_TXFS                   = IOMUX_PAD(0x0484, 0x013C, 2, 0x0640, 1, 0),
+	MX6SX_PAD_LCD1_VSYNC__ENET2_1588_EVENT3_IN               = IOMUX_PAD(0x0484, 0x013C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_VSYNC__CSI1_DATA_19                       = IOMUX_PAD(0x0484, 0x013C, 4, 0x06E8, 0, 0),
+	MX6SX_PAD_LCD1_VSYNC__GPIO3_IO_28                        = IOMUX_PAD(0x0484, 0x013C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_VSYNC__USDHC2_CD_B                        = IOMUX_PAD(0x0484, 0x013C, 6, 0x086C, 0, 0),
+	MX6SX_PAD_LCD1_VSYNC__SIM_M_HADDR_19                     = IOMUX_PAD(0x0484, 0x013C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_VSYNC__VADC_TEST_3                        = IOMUX_PAD(0x0484, 0x013C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_LCD1_VSYNC__MMDC_DEBUG_3                       = IOMUX_PAD(0x0484, 0x013C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_ALE__RAWNAND_ALE                          = IOMUX_PAD(0x0488, 0x0140, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_ALE__I2C3_SDA                             = IOMUX_PAD(0x0488, 0x0140, 1, 0x07BC, 0, 0),
+	MX6SX_PAD_NAND_ALE__QSPI2_A_SS0_B                        = IOMUX_PAD(0x0488, 0x0140, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_ALE__ECSPI2_SS0                           = IOMUX_PAD(0x0488, 0x0140, 3, 0x072C, 0, 0),
+	MX6SX_PAD_NAND_ALE__ESAI_TX3_RX2                         = IOMUX_PAD(0x0488, 0x0140, 4, 0x079C, 0, 0),
+	MX6SX_PAD_NAND_ALE__GPIO4_IO_0                           = IOMUX_PAD(0x0488, 0x0140, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_ALE__WEIM_CS0_B                           = IOMUX_PAD(0x0488, 0x0140, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_ALE__TPSMP_HDATA_0                        = IOMUX_PAD(0x0488, 0x0140, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_ALE__ANATOP_USBPHY1_TSTI_TX_EN            = IOMUX_PAD(0x0488, 0x0140, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_ALE__SDMA_DEBUG_PC_12                     = IOMUX_PAD(0x0488, 0x0140, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_CE0_B__RAWNAND_CE0_B                      = IOMUX_PAD(0x048C, 0x0144, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__USDHC2_VSELECT                     = IOMUX_PAD(0x048C, 0x0144, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__QSPI2_A_DATA_2                     = IOMUX_PAD(0x048C, 0x0144, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__AUDMUX_AUD4_TXC                    = IOMUX_PAD(0x048C, 0x0144, 3, 0x0654, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__ESAI_TX_CLK                        = IOMUX_PAD(0x048C, 0x0144, 4, 0x078C, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__GPIO4_IO_1                         = IOMUX_PAD(0x048C, 0x0144, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__WEIM_LBA_B                         = IOMUX_PAD(0x048C, 0x0144, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__TPSMP_HDATA_3                      = IOMUX_PAD(0x048C, 0x0144, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__ANATOP_USBPHY1_TSTI_TX_HIZ         = IOMUX_PAD(0x048C, 0x0144, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE0_B__SDMA_DEBUG_PC_9                    = IOMUX_PAD(0x048C, 0x0144, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_CE1_B__RAWNAND_CE1_B                      = IOMUX_PAD(0x0490, 0x0148, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__USDHC3_RESET_B                     = IOMUX_PAD(0x0490, 0x0148, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__QSPI2_A_DATA_3                     = IOMUX_PAD(0x0490, 0x0148, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__AUDMUX_AUD4_TXD                    = IOMUX_PAD(0x0490, 0x0148, 3, 0x0648, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__ESAI_TX0                           = IOMUX_PAD(0x0490, 0x0148, 4, 0x0790, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__GPIO4_IO_2                         = IOMUX_PAD(0x0490, 0x0148, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__WEIM_OE                            = IOMUX_PAD(0x0490, 0x0148, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__TPSMP_HDATA_4                      = IOMUX_PAD(0x0490, 0x0148, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__ANATOP_USBPHY1_TSTI_TX_LS_MODE     = IOMUX_PAD(0x0490, 0x0148, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CE1_B__SDMA_DEBUG_PC_8                    = IOMUX_PAD(0x0490, 0x0148, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_CLE__RAWNAND_CLE                          = IOMUX_PAD(0x0494, 0x014C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CLE__I2C3_SCL                             = IOMUX_PAD(0x0494, 0x014C, 1, 0x07B8, 0, 0),
+	MX6SX_PAD_NAND_CLE__QSPI2_A_SCLK                         = IOMUX_PAD(0x0494, 0x014C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CLE__ECSPI2_SCLK                          = IOMUX_PAD(0x0494, 0x014C, 3, 0x0720, 0, 0),
+	MX6SX_PAD_NAND_CLE__ESAI_TX2_RX3                         = IOMUX_PAD(0x0494, 0x014C, 4, 0x0798, 0, 0),
+	MX6SX_PAD_NAND_CLE__GPIO4_IO_3                           = IOMUX_PAD(0x0494, 0x014C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CLE__WEIM_BCLK                            = IOMUX_PAD(0x0494, 0x014C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CLE__TPSMP_CLK                            = IOMUX_PAD(0x0494, 0x014C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CLE__ANATOP_USBPHY1_TSTI_TX_DP            = IOMUX_PAD(0x0494, 0x014C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_CLE__SDMA_DEBUG_PC_13                     = IOMUX_PAD(0x0494, 0x014C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_DATA00__RAWNAND_DATA00                    = IOMUX_PAD(0x0498, 0x0150, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA00__USDHC1_DATA4                      = IOMUX_PAD(0x0498, 0x0150, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA00__QSPI2_B_DATA_1                    = IOMUX_PAD(0x0498, 0x0150, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA00__ECSPI5_MISO                       = IOMUX_PAD(0x0498, 0x0150, 3, 0x0754, 0, 0),
+	MX6SX_PAD_NAND_DATA00__ESAI_RX_CLK                       = IOMUX_PAD(0x0498, 0x0150, 4, 0x0788, 0, 0),
+	MX6SX_PAD_NAND_DATA00__GPIO4_IO_4                        = IOMUX_PAD(0x0498, 0x0150, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA00__WEIM_AD_0                         = IOMUX_PAD(0x0498, 0x0150, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA00__TPSMP_HDATA_7                     = IOMUX_PAD(0x0498, 0x0150, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA00__ANATOP_USBPHY1_TSTO_RX_DISCON_DET = IOMUX_PAD(0x0498, 0x0150, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA00__SDMA_DEBUG_EVT_CHN_LINES_5        = IOMUX_PAD(0x0498, 0x0150, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_DATA01__RAWNAND_DATA01                    = IOMUX_PAD(0x049C, 0x0154, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA01__USDHC1_DATA5                      = IOMUX_PAD(0x049C, 0x0154, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA01__QSPI2_B_DATA_0                    = IOMUX_PAD(0x049C, 0x0154, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA01__ECSPI5_MOSI                       = IOMUX_PAD(0x049C, 0x0154, 3, 0x0758, 0, 0),
+	MX6SX_PAD_NAND_DATA01__ESAI_RX_FS                        = IOMUX_PAD(0x049C, 0x0154, 4, 0x0778, 0, 0),
+	MX6SX_PAD_NAND_DATA01__GPIO4_IO_5                        = IOMUX_PAD(0x049C, 0x0154, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA01__WEIM_AD_1                         = IOMUX_PAD(0x049C, 0x0154, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA01__TPSMP_HDATA_8                     = IOMUX_PAD(0x049C, 0x0154, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA01__ANATOP_USBPHY1_TSTO_RX_HS_RXD     = IOMUX_PAD(0x049C, 0x0154, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA01__SDMA_DEBUG_EVT_CHN_LINES_4        = IOMUX_PAD(0x049C, 0x0154, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_DATA02__RAWNAND_DATA02                    = IOMUX_PAD(0x04A0, 0x0158, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA02__USDHC1_DATA6                      = IOMUX_PAD(0x04A0, 0x0158, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA02__QSPI2_B_SCLK                      = IOMUX_PAD(0x04A0, 0x0158, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA02__ECSPI5_SCLK                       = IOMUX_PAD(0x04A0, 0x0158, 3, 0x0750, 0, 0),
+	MX6SX_PAD_NAND_DATA02__ESAI_TX_HF_CLK                    = IOMUX_PAD(0x04A0, 0x0158, 4, 0x0784, 0, 0),
+	MX6SX_PAD_NAND_DATA02__GPIO4_IO_6                        = IOMUX_PAD(0x04A0, 0x0158, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA02__WEIM_AD_2                         = IOMUX_PAD(0x04A0, 0x0158, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA02__TPSMP_HDATA_9                     = IOMUX_PAD(0x04A0, 0x0158, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA02__ANATOP_USBPHY2_TSTO_PLL_CLK20DIV  = IOMUX_PAD(0x04A0, 0x0158, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA02__SDMA_DEBUG_EVT_CHN_LINES_3        = IOMUX_PAD(0x04A0, 0x0158, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_DATA03__RAWNAND_DATA03                    = IOMUX_PAD(0x04A4, 0x015C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA03__USDHC1_DATA7                      = IOMUX_PAD(0x04A4, 0x015C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA03__QSPI2_B_SS0_B                     = IOMUX_PAD(0x04A4, 0x015C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA03__ECSPI5_SS0                        = IOMUX_PAD(0x04A4, 0x015C, 3, 0x075C, 0, 0),
+	MX6SX_PAD_NAND_DATA03__ESAI_RX_HF_CLK                    = IOMUX_PAD(0x04A4, 0x015C, 4, 0x0780, 0, 0),
+	MX6SX_PAD_NAND_DATA03__GPIO4_IO_7                        = IOMUX_PAD(0x04A4, 0x015C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA03__WEIM_AD_3                         = IOMUX_PAD(0x04A4, 0x015C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA03__TPSMP_HDATA_10                    = IOMUX_PAD(0x04A4, 0x015C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA03__ANATOP_USBPHY1_TSTO_RX_SQUELCH    = IOMUX_PAD(0x04A4, 0x015C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA03__SDMA_DEBUG_EVT_CHN_LINES_6        = IOMUX_PAD(0x04A4, 0x015C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_DATA04__RAWNAND_DATA04                    = IOMUX_PAD(0x04A8, 0x0160, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA04__USDHC2_DATA4                      = IOMUX_PAD(0x04A8, 0x0160, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA04__QSPI2_B_SS1_B                     = IOMUX_PAD(0x04A8, 0x0160, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA04__UART3_RTS_B                       = IOMUX_PAD(0x04A8, 0x0160, 3, 0x083C, 0, 0),
+	MX6SX_PAD_NAND_DATA04__AUDMUX_AUD4_RXFS                  = IOMUX_PAD(0x04A8, 0x0160, 4, 0x0650, 0, 0),
+	MX6SX_PAD_NAND_DATA04__GPIO4_IO_8                        = IOMUX_PAD(0x04A8, 0x0160, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA04__WEIM_AD_4                         = IOMUX_PAD(0x04A8, 0x0160, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA04__TPSMP_HDATA_11                    = IOMUX_PAD(0x04A8, 0x0160, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA04__ANATOP_USBPHY2_TSTO_RX_SQUELCH    = IOMUX_PAD(0x04A8, 0x0160, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA04__SDMA_DEBUG_CORE_STATE_0           = IOMUX_PAD(0x04A8, 0x0160, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_DATA05__RAWNAND_DATA05                    = IOMUX_PAD(0x04AC, 0x0164, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA05__USDHC2_DATA5                      = IOMUX_PAD(0x04AC, 0x0164, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA05__QSPI2_B_DQS                       = IOMUX_PAD(0x04AC, 0x0164, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA05__UART3_CTS_B                       = IOMUX_PAD(0x04AC, 0x0164, 3, 0x083C, 1, 0),
+	MX6SX_PAD_NAND_DATA05__AUDMUX_AUD4_RXC                   = IOMUX_PAD(0x04AC, 0x0164, 4, 0x064C, 0, 0),
+	MX6SX_PAD_NAND_DATA05__GPIO4_IO_9                        = IOMUX_PAD(0x04AC, 0x0164, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA05__WEIM_AD_5                         = IOMUX_PAD(0x04AC, 0x0164, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA05__TPSMP_HDATA_12                    = IOMUX_PAD(0x04AC, 0x0164, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA05__ANATOP_USBPHY2_TSTO_RX_DISCON_DET = IOMUX_PAD(0x04AC, 0x0164, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA05__SDMA_DEBUG_CORE_STATE_1           = IOMUX_PAD(0x04AC, 0x0164, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_DATA06__RAWNAND_DATA06                    = IOMUX_PAD(0x04B0, 0x0168, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA06__USDHC2_DATA6                      = IOMUX_PAD(0x04B0, 0x0168, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA06__QSPI2_A_SS1_B                     = IOMUX_PAD(0x04B0, 0x0168, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA06__UART3_RX                          = IOMUX_PAD(0x04B0, 0x0168, 3, 0x0840, 0, 0),
+	MX6SX_PAD_NAND_DATA06__PWM3_OUT                          = IOMUX_PAD(0x04B0, 0x0168, 4, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA06__GPIO4_IO_10                       = IOMUX_PAD(0x04B0, 0x0168, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA06__WEIM_AD_6                         = IOMUX_PAD(0x04B0, 0x0168, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA06__TPSMP_HDATA_13                    = IOMUX_PAD(0x04B0, 0x0168, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA06__ANATOP_USBPHY2_TSTO_RX_FS_RXD     = IOMUX_PAD(0x04B0, 0x0168, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA06__SDMA_DEBUG_CORE_STATE_2           = IOMUX_PAD(0x04B0, 0x0168, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_DATA07__RAWNAND_DATA07                    = IOMUX_PAD(0x04B4, 0x016C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA07__USDHC2_DATA7                      = IOMUX_PAD(0x04B4, 0x016C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA07__QSPI2_A_DQS                       = IOMUX_PAD(0x04B4, 0x016C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA07__UART3_TX                          = IOMUX_PAD(0x04B4, 0x016C, 3, 0x0840, 1, 0),
+	MX6SX_PAD_NAND_DATA07__PWM4_OUT                          = IOMUX_PAD(0x04B4, 0x016C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA07__GPIO4_IO_11                       = IOMUX_PAD(0x04B4, 0x016C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA07__WEIM_AD_7                         = IOMUX_PAD(0x04B4, 0x016C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA07__TPSMP_HDATA_14                    = IOMUX_PAD(0x04B4, 0x016C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA07__ANATOP_USBPHY1_TSTO_RX_FS_RXD     = IOMUX_PAD(0x04B4, 0x016C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_DATA07__SDMA_DEBUG_CORE_STATE_3           = IOMUX_PAD(0x04B4, 0x016C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_RE_B__RAWNAND_RE_B                        = IOMUX_PAD(0x04B8, 0x0170, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_RE_B__USDHC2_RESET_B                      = IOMUX_PAD(0x04B8, 0x0170, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_RE_B__QSPI2_B_DATA_3                      = IOMUX_PAD(0x04B8, 0x0170, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_RE_B__AUDMUX_AUD4_TXFS                    = IOMUX_PAD(0x04B8, 0x0170, 3, 0x0658, 0, 0),
+	MX6SX_PAD_NAND_RE_B__ESAI_TX_FS                          = IOMUX_PAD(0x04B8, 0x0170, 4, 0x077C, 0, 0),
+	MX6SX_PAD_NAND_RE_B__GPIO4_IO_12                         = IOMUX_PAD(0x04B8, 0x0170, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_RE_B__WEIM_RW                             = IOMUX_PAD(0x04B8, 0x0170, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_RE_B__TPSMP_HDATA_5                       = IOMUX_PAD(0x04B8, 0x0170, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_RE_B__ANATOP_USBPHY2_TSTO_RX_HS_RXD       = IOMUX_PAD(0x04B8, 0x0170, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_RE_B__SDMA_DEBUG_PC_7                     = IOMUX_PAD(0x04B8, 0x0170, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_READY_B__RAWNAND_READY_B                  = IOMUX_PAD(0x04BC, 0x0174, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_READY_B__USDHC1_VSELECT                   = IOMUX_PAD(0x04BC, 0x0174, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_READY_B__QSPI2_A_DATA_1                   = IOMUX_PAD(0x04BC, 0x0174, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_READY_B__ECSPI2_MISO                      = IOMUX_PAD(0x04BC, 0x0174, 3, 0x0724, 0, 0),
+	MX6SX_PAD_NAND_READY_B__ESAI_TX1                         = IOMUX_PAD(0x04BC, 0x0174, 4, 0x0794, 0, 0),
+	MX6SX_PAD_NAND_READY_B__GPIO4_IO_13                      = IOMUX_PAD(0x04BC, 0x0174, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_READY_B__WEIM_EB_B_1                      = IOMUX_PAD(0x04BC, 0x0174, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_READY_B__TPSMP_HDATA_2                    = IOMUX_PAD(0x04BC, 0x0174, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_READY_B__ANATOP_USBPHY1_TSTI_TX_DN        = IOMUX_PAD(0x04BC, 0x0174, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_READY_B__SDMA_DEBUG_PC_10                 = IOMUX_PAD(0x04BC, 0x0174, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_WE_B__RAWNAND_WE_B                        = IOMUX_PAD(0x04C0, 0x0178, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WE_B__USDHC4_VSELECT                      = IOMUX_PAD(0x04C0, 0x0178, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WE_B__QSPI2_B_DATA_2                      = IOMUX_PAD(0x04C0, 0x0178, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WE_B__AUDMUX_AUD4_RXD                     = IOMUX_PAD(0x04C0, 0x0178, 3, 0x0644, 0, 0),
+	MX6SX_PAD_NAND_WE_B__ESAI_TX5_RX0                        = IOMUX_PAD(0x04C0, 0x0178, 4, 0x07A4, 0, 0),
+	MX6SX_PAD_NAND_WE_B__GPIO4_IO_14                         = IOMUX_PAD(0x04C0, 0x0178, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WE_B__WEIM_WAIT                           = IOMUX_PAD(0x04C0, 0x0178, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WE_B__TPSMP_HDATA_6                       = IOMUX_PAD(0x04C0, 0x0178, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WE_B__ANATOP_USBPHY1_TSTO_PLL_CLK20DIV    = IOMUX_PAD(0x04C0, 0x0178, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WE_B__SDMA_DEBUG_PC_6                     = IOMUX_PAD(0x04C0, 0x0178, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_NAND_WP_B__RAWNAND_WP_B                        = IOMUX_PAD(0x04C4, 0x017C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WP_B__USDHC1_RESET_B                      = IOMUX_PAD(0x04C4, 0x017C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WP_B__QSPI2_A_DATA_0                      = IOMUX_PAD(0x04C4, 0x017C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WP_B__ECSPI2_MOSI                         = IOMUX_PAD(0x04C4, 0x017C, 3, 0x0728, 0, 0),
+	MX6SX_PAD_NAND_WP_B__ESAI_TX4_RX1                        = IOMUX_PAD(0x04C4, 0x017C, 4, 0x07A0, 0, 0),
+	MX6SX_PAD_NAND_WP_B__GPIO4_IO_15                         = IOMUX_PAD(0x04C4, 0x017C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WP_B__WEIM_EB_B_0                         = IOMUX_PAD(0x04C4, 0x017C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WP_B__TPSMP_HDATA_1                       = IOMUX_PAD(0x04C4, 0x017C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WP_B__ANATOP_USBPHY1_TSTI_TX_HS_MODE      = IOMUX_PAD(0x04C4, 0x017C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_NAND_WP_B__SDMA_DEBUG_PC_11                    = IOMUX_PAD(0x04C4, 0x017C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1A_DATA0__QSPI1_A_DATA_0                   = IOMUX_PAD(0x04C8, 0x0180, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA0__USB_OTG2_OC                      = IOMUX_PAD(0x04C8, 0x0180, 1, 0x085C, 2, 0),
+	MX6SX_PAD_QSPI1A_DATA0__ECSPI1_MOSI                      = IOMUX_PAD(0x04C8, 0x0180, 2, 0x0718, 1, 0),
+	MX6SX_PAD_QSPI1A_DATA0__ESAI_TX4_RX1                     = IOMUX_PAD(0x04C8, 0x0180, 3, 0x07A0, 2, 0),
+	MX6SX_PAD_QSPI1A_DATA0__CSI1_DATA_14                     = IOMUX_PAD(0x04C8, 0x0180, 4, 0x06D4, 1, 0),
+	MX6SX_PAD_QSPI1A_DATA0__GPIO4_IO_16                      = IOMUX_PAD(0x04C8, 0x0180, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA0__WEIM_DATA_6                      = IOMUX_PAD(0x04C8, 0x0180, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA0__SIM_M_HADDR_3                    = IOMUX_PAD(0x04C8, 0x0180, 7, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA0__SDMA_DEBUG_BUS_DEVICE_3          = IOMUX_PAD(0x04C8, 0x0180, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1A_DATA1__QSPI1_A_DATA_1                   = IOMUX_PAD(0x04CC, 0x0184, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA1__ANATOP_OTG1_ID                   = IOMUX_PAD(0x04CC, 0x0184, 1, 0x0624, 2, 0),
+	MX6SX_PAD_QSPI1A_DATA1__ECSPI1_MISO                      = IOMUX_PAD(0x04CC, 0x0184, 2, 0x0714, 1, 0),
+	MX6SX_PAD_QSPI1A_DATA1__ESAI_TX1                         = IOMUX_PAD(0x04CC, 0x0184, 3, 0x0794, 2, 0),
+	MX6SX_PAD_QSPI1A_DATA1__CSI1_DATA_13                     = IOMUX_PAD(0x04CC, 0x0184, 4, 0x06D0, 1, 0),
+	MX6SX_PAD_QSPI1A_DATA1__GPIO4_IO_17                      = IOMUX_PAD(0x04CC, 0x0184, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA1__WEIM_DATA_5                      = IOMUX_PAD(0x04CC, 0x0184, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA1__SIM_M_HADDR_4                    = IOMUX_PAD(0x04CC, 0x0184, 7, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA1__SDMA_DEBUG_PC_0                  = IOMUX_PAD(0x04CC, 0x0184, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1A_DATA2__QSPI1_A_DATA_2                   = IOMUX_PAD(0x04D0, 0x0188, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA2__USB_OTG1_PWR                     = IOMUX_PAD(0x04D0, 0x0188, 1, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA2__ECSPI5_SS1                       = IOMUX_PAD(0x04D0, 0x0188, 2, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA2__ESAI_TX_CLK                      = IOMUX_PAD(0x04D0, 0x0188, 3, 0x078C, 2, 0),
+	MX6SX_PAD_QSPI1A_DATA2__CSI1_DATA_12                     = IOMUX_PAD(0x04D0, 0x0188, 4, 0x06CC, 1, 0),
+	MX6SX_PAD_QSPI1A_DATA2__GPIO4_IO_18                      = IOMUX_PAD(0x04D0, 0x0188, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA2__WEIM_DATA_4                      = IOMUX_PAD(0x04D0, 0x0188, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA2__SIM_M_HADDR_6                    = IOMUX_PAD(0x04D0, 0x0188, 7, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA2__SDMA_DEBUG_PC_1                  = IOMUX_PAD(0x04D0, 0x0188, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1A_DATA3__QSPI1_A_DATA_3                   = IOMUX_PAD(0x04D4, 0x018C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA3__USB_OTG1_OC                      = IOMUX_PAD(0x04D4, 0x018C, 1, 0x0860, 2, 0),
+	MX6SX_PAD_QSPI1A_DATA3__ECSPI5_SS2                       = IOMUX_PAD(0x04D4, 0x018C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA3__ESAI_TX0                         = IOMUX_PAD(0x04D4, 0x018C, 3, 0x0790, 2, 0),
+	MX6SX_PAD_QSPI1A_DATA3__CSI1_DATA_11                     = IOMUX_PAD(0x04D4, 0x018C, 4, 0x06C8, 1, 0),
+	MX6SX_PAD_QSPI1A_DATA3__GPIO4_IO_19                      = IOMUX_PAD(0x04D4, 0x018C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA3__WEIM_DATA_3                      = IOMUX_PAD(0x04D4, 0x018C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA3__SIM_M_HADDR_7                    = IOMUX_PAD(0x04D4, 0x018C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DATA3__SDMA_DEBUG_PC_2                  = IOMUX_PAD(0x04D4, 0x018C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1A_DQS__QSPI1_A_DQS                        = IOMUX_PAD(0x04D8, 0x0190, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DQS__CAN2_TX                            = IOMUX_PAD(0x04D8, 0x0190, 1, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DQS__CANFD_TX2                          = IOMUX_PAD(0x04D8, 0x0190, 2, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DQS__ECSPI5_MOSI                        = IOMUX_PAD(0x04D8, 0x0190, 3, 0x0758, 1, 0),
+	MX6SX_PAD_QSPI1A_DQS__CSI1_DATA_15                       = IOMUX_PAD(0x04D8, 0x0190, 4, 0x06D8, 1, 0),
+	MX6SX_PAD_QSPI1A_DQS__GPIO4_IO_20                        = IOMUX_PAD(0x04D8, 0x0190, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DQS__WEIM_DATA_7                        = IOMUX_PAD(0x04D8, 0x0190, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DQS__SIM_M_HADDR_13                     = IOMUX_PAD(0x04D8, 0x0190, 7, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_DQS__SDMA_DEBUG_BUS_DEVICE_4            = IOMUX_PAD(0x04D8, 0x0190, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1A_SCLK__QSPI1_A_SCLK                      = IOMUX_PAD(0x04DC, 0x0194, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SCLK__ANATOP_OTG2_ID                    = IOMUX_PAD(0x04DC, 0x0194, 1, 0x0628, 2, 0),
+	MX6SX_PAD_QSPI1A_SCLK__ECSPI1_SCLK                       = IOMUX_PAD(0x04DC, 0x0194, 2, 0x0710, 1, 0),
+	MX6SX_PAD_QSPI1A_SCLK__ESAI_TX2_RX3                      = IOMUX_PAD(0x04DC, 0x0194, 3, 0x0798, 2, 0),
+	MX6SX_PAD_QSPI1A_SCLK__CSI1_DATA_1                       = IOMUX_PAD(0x04DC, 0x0194, 4, 0x06A4, 1, 0),
+	MX6SX_PAD_QSPI1A_SCLK__GPIO4_IO_21                       = IOMUX_PAD(0x04DC, 0x0194, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SCLK__WEIM_DATA_0                       = IOMUX_PAD(0x04DC, 0x0194, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SCLK__SIM_M_HADDR_0                     = IOMUX_PAD(0x04DC, 0x0194, 7, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SCLK__SDMA_DEBUG_PC_5                   = IOMUX_PAD(0x04DC, 0x0194, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1A_SS0_B__QSPI1_A_SS0_B                    = IOMUX_PAD(0x04E0, 0x0198, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS0_B__USB_OTG2_PWR                     = IOMUX_PAD(0x04E0, 0x0198, 1, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS0_B__ECSPI1_SS0                       = IOMUX_PAD(0x04E0, 0x0198, 2, 0x071C, 1, 0),
+	MX6SX_PAD_QSPI1A_SS0_B__ESAI_TX3_RX2                     = IOMUX_PAD(0x04E0, 0x0198, 3, 0x079C, 2, 0),
+	MX6SX_PAD_QSPI1A_SS0_B__CSI1_DATA_0                      = IOMUX_PAD(0x04E0, 0x0198, 4, 0x06A0, 1, 0),
+	MX6SX_PAD_QSPI1A_SS0_B__GPIO4_IO_22                      = IOMUX_PAD(0x04E0, 0x0198, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS0_B__WEIM_DATA_1                      = IOMUX_PAD(0x04E0, 0x0198, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS0_B__SIM_M_HADDR_1                    = IOMUX_PAD(0x04E0, 0x0198, 7, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS0_B__SDMA_DEBUG_PC_4                  = IOMUX_PAD(0x04E0, 0x0198, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1A_SS1_B__QSPI1_A_SS1_B                    = IOMUX_PAD(0x04E4, 0x019C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS1_B__CAN1_RX                          = IOMUX_PAD(0x04E4, 0x019C, 1, 0x068C, 2, 0),
+	MX6SX_PAD_QSPI1A_SS1_B__CANFD_RX1                        = IOMUX_PAD(0x04E4, 0x019C, 2, 0x0694, 2, 0),
+	MX6SX_PAD_QSPI1A_SS1_B__ECSPI5_MISO                      = IOMUX_PAD(0x04E4, 0x019C, 3, 0x0754, 1, 0),
+	MX6SX_PAD_QSPI1A_SS1_B__CSI1_DATA_10                     = IOMUX_PAD(0x04E4, 0x019C, 4, 0x06FC, 1, 0),
+	MX6SX_PAD_QSPI1A_SS1_B__GPIO4_IO_23                      = IOMUX_PAD(0x04E4, 0x019C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS1_B__WEIM_DATA_2                      = IOMUX_PAD(0x04E4, 0x019C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS1_B__SIM_M_HADDR_12                   = IOMUX_PAD(0x04E4, 0x019C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1A_SS1_B__SDMA_DEBUG_PC_3                  = IOMUX_PAD(0x04E4, 0x019C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1B_DATA0__QSPI1_B_DATA_0                   = IOMUX_PAD(0x04E8, 0x01A0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA0__UART3_CTS_B                      = IOMUX_PAD(0x04E8, 0x01A0, 1, 0x083C, 4, 0),
+	MX6SX_PAD_QSPI1B_DATA0__ECSPI3_MOSI                      = IOMUX_PAD(0x04E8, 0x01A0, 2, 0x0738, 1, 0),
+	MX6SX_PAD_QSPI1B_DATA0__ESAI_RX_FS                       = IOMUX_PAD(0x04E8, 0x01A0, 3, 0x0778, 2, 0),
+	MX6SX_PAD_QSPI1B_DATA0__CSI1_DATA_22                     = IOMUX_PAD(0x04E8, 0x01A0, 4, 0x06F4, 1, 0),
+	MX6SX_PAD_QSPI1B_DATA0__GPIO4_IO_24                      = IOMUX_PAD(0x04E8, 0x01A0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA0__WEIM_DATA_14                     = IOMUX_PAD(0x04E8, 0x01A0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA0__SIM_M_HADDR_9                    = IOMUX_PAD(0x04E8, 0x01A0, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1B_DATA1__QSPI1_B_DATA_1                   = IOMUX_PAD(0x04EC, 0x01A4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA1__UART3_RTS_B                      = IOMUX_PAD(0x04EC, 0x01A4, 1, 0x083C, 5, 0),
+	MX6SX_PAD_QSPI1B_DATA1__ECSPI3_MISO                      = IOMUX_PAD(0x04EC, 0x01A4, 2, 0x0734, 1, 0),
+	MX6SX_PAD_QSPI1B_DATA1__ESAI_RX_CLK                      = IOMUX_PAD(0x04EC, 0x01A4, 3, 0x0788, 2, 0),
+	MX6SX_PAD_QSPI1B_DATA1__CSI1_DATA_21                     = IOMUX_PAD(0x04EC, 0x01A4, 4, 0x06F0, 1, 0),
+	MX6SX_PAD_QSPI1B_DATA1__GPIO4_IO_25                      = IOMUX_PAD(0x04EC, 0x01A4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA1__WEIM_DATA_13                     = IOMUX_PAD(0x04EC, 0x01A4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA1__SIM_M_HADDR_8                    = IOMUX_PAD(0x04EC, 0x01A4, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1B_DATA2__QSPI1_B_DATA_2                   = IOMUX_PAD(0x04F0, 0x01A8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA2__I2C2_SDA                         = IOMUX_PAD(0x04F0, 0x01A8, 1, 0x07B4, 2, 0),
+	MX6SX_PAD_QSPI1B_DATA2__ECSPI5_RDY                       = IOMUX_PAD(0x04F0, 0x01A8, 2, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA2__ESAI_TX5_RX0                     = IOMUX_PAD(0x04F0, 0x01A8, 3, 0x07A4, 2, 0),
+	MX6SX_PAD_QSPI1B_DATA2__CSI1_DATA_20                     = IOMUX_PAD(0x04F0, 0x01A8, 4, 0x06EC, 1, 0),
+	MX6SX_PAD_QSPI1B_DATA2__GPIO4_IO_26                      = IOMUX_PAD(0x04F0, 0x01A8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA2__WEIM_DATA_12                     = IOMUX_PAD(0x04F0, 0x01A8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA2__SIM_M_HADDR_5                    = IOMUX_PAD(0x04F0, 0x01A8, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1B_DATA3__QSPI1_B_DATA_3                   = IOMUX_PAD(0x04F4, 0x01AC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA3__I2C2_SCL                         = IOMUX_PAD(0x04F4, 0x01AC, 1, 0x07B0, 2, 0),
+	MX6SX_PAD_QSPI1B_DATA3__ECSPI5_SS3                       = IOMUX_PAD(0x04F4, 0x01AC, 2, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA3__ESAI_TX_FS                       = IOMUX_PAD(0x04F4, 0x01AC, 3, 0x077C, 2, 0),
+	MX6SX_PAD_QSPI1B_DATA3__CSI1_DATA_19                     = IOMUX_PAD(0x04F4, 0x01AC, 4, 0x06E8, 1, 0),
+	MX6SX_PAD_QSPI1B_DATA3__GPIO4_IO_27                      = IOMUX_PAD(0x04F4, 0x01AC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA3__WEIM_DATA_11                     = IOMUX_PAD(0x04F4, 0x01AC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DATA3__SIM_M_HADDR_2                    = IOMUX_PAD(0x04F4, 0x01AC, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1B_DQS__QSPI1_B_DQS                        = IOMUX_PAD(0x04F8, 0x01B0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DQS__CAN1_TX                            = IOMUX_PAD(0x04F8, 0x01B0, 1, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DQS__CANFD_TX1                          = IOMUX_PAD(0x04F8, 0x01B0, 2, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DQS__ECSPI5_SS0                         = IOMUX_PAD(0x04F8, 0x01B0, 3, 0x075C, 1, 0),
+	MX6SX_PAD_QSPI1B_DQS__CSI1_DATA_23                       = IOMUX_PAD(0x04F8, 0x01B0, 4, 0x06F8, 1, 0),
+	MX6SX_PAD_QSPI1B_DQS__GPIO4_IO_28                        = IOMUX_PAD(0x04F8, 0x01B0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DQS__WEIM_DATA_15                       = IOMUX_PAD(0x04F8, 0x01B0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_DQS__SIM_M_HADDR_15                     = IOMUX_PAD(0x04F8, 0x01B0, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1B_SCLK__QSPI1_B_SCLK                      = IOMUX_PAD(0x04FC, 0x01B4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SCLK__UART3_RX                          = IOMUX_PAD(0x04FC, 0x01B4, 1, 0x0840, 4, 0),
+	MX6SX_PAD_QSPI1B_SCLK__ECSPI3_SCLK                       = IOMUX_PAD(0x04FC, 0x01B4, 2, 0x0730, 1, 0),
+	MX6SX_PAD_QSPI1B_SCLK__ESAI_RX_HF_CLK                    = IOMUX_PAD(0x04FC, 0x01B4, 3, 0x0780, 2, 0),
+	MX6SX_PAD_QSPI1B_SCLK__CSI1_DATA_16                      = IOMUX_PAD(0x04FC, 0x01B4, 4, 0x06DC, 1, 0),
+	MX6SX_PAD_QSPI1B_SCLK__GPIO4_IO_29                       = IOMUX_PAD(0x04FC, 0x01B4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SCLK__WEIM_DATA_8                       = IOMUX_PAD(0x04FC, 0x01B4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SCLK__SIM_M_HADDR_11                    = IOMUX_PAD(0x04FC, 0x01B4, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1B_SS0_B__QSPI1_B_SS0_B                    = IOMUX_PAD(0x0500, 0x01B8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SS0_B__UART3_TX                         = IOMUX_PAD(0x0500, 0x01B8, 1, 0x0840, 5, 0),
+	MX6SX_PAD_QSPI1B_SS0_B__ECSPI3_SS0                       = IOMUX_PAD(0x0500, 0x01B8, 2, 0x073C, 1, 0),
+	MX6SX_PAD_QSPI1B_SS0_B__ESAI_TX_HF_CLK                   = IOMUX_PAD(0x0500, 0x01B8, 3, 0x0784, 3, 0),
+	MX6SX_PAD_QSPI1B_SS0_B__CSI1_DATA_17                     = IOMUX_PAD(0x0500, 0x01B8, 4, 0x06E0, 1, 0),
+	MX6SX_PAD_QSPI1B_SS0_B__GPIO4_IO_30                      = IOMUX_PAD(0x0500, 0x01B8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SS0_B__WEIM_DATA_9                      = IOMUX_PAD(0x0500, 0x01B8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SS0_B__SIM_M_HADDR_10                   = IOMUX_PAD(0x0500, 0x01B8, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_QSPI1B_SS1_B__QSPI1_B_SS1_B                    = IOMUX_PAD(0x0504, 0x01BC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SS1_B__CAN2_RX                          = IOMUX_PAD(0x0504, 0x01BC, 1, 0x0690, 2, 0),
+	MX6SX_PAD_QSPI1B_SS1_B__CANFD_RX2                        = IOMUX_PAD(0x0504, 0x01BC, 2, 0x0698, 2, 0),
+	MX6SX_PAD_QSPI1B_SS1_B__ECSPI5_SCLK                      = IOMUX_PAD(0x0504, 0x01BC, 3, 0x0750, 1, 0),
+	MX6SX_PAD_QSPI1B_SS1_B__CSI1_DATA_18                     = IOMUX_PAD(0x0504, 0x01BC, 4, 0x06E4, 1, 0),
+	MX6SX_PAD_QSPI1B_SS1_B__GPIO4_IO_31                      = IOMUX_PAD(0x0504, 0x01BC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SS1_B__WEIM_DATA_10                     = IOMUX_PAD(0x0504, 0x01BC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_QSPI1B_SS1_B__SIM_M_HADDR_14                   = IOMUX_PAD(0x0504, 0x01BC, 7, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0                    = IOMUX_PAD(0x0508, 0x01C0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD0__GPIO5_IO_0                         = IOMUX_PAD(0x0508, 0x01C0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD0__CSI2_DATA_10                       = IOMUX_PAD(0x0508, 0x01C0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD0__ANATOP_TESTI_0                     = IOMUX_PAD(0x0508, 0x01C0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD0__RAWNAND_TESTER_TRIGGER             = IOMUX_PAD(0x0508, 0x01C0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD0__PCIE_CTRL_DEBUG_0                  = IOMUX_PAD(0x0508, 0x01C0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1                    = IOMUX_PAD(0x050C, 0x01C4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD1__GPIO5_IO_1                         = IOMUX_PAD(0x050C, 0x01C4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD1__CSI2_DATA_11                       = IOMUX_PAD(0x050C, 0x01C4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD1__ANATOP_TESTI_1                     = IOMUX_PAD(0x050C, 0x01C4, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD1__USDHC1_TESTER_TRIGGER              = IOMUX_PAD(0x050C, 0x01C4, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD1__PCIE_CTRL_DEBUG_1                  = IOMUX_PAD(0x050C, 0x01C4, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_RD2__ENET1_RX_DATA_2                    = IOMUX_PAD(0x0510, 0x01C8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD2__GPIO5_IO_2                         = IOMUX_PAD(0x0510, 0x01C8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD2__CSI2_DATA_12                       = IOMUX_PAD(0x0510, 0x01C8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD2__ANATOP_TESTI_2                     = IOMUX_PAD(0x0510, 0x01C8, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD2__USDHC2_TESTER_TRIGGER              = IOMUX_PAD(0x0510, 0x01C8, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD2__PCIE_CTRL_DEBUG_2                  = IOMUX_PAD(0x0510, 0x01C8, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_RD3__ENET1_RX_DATA_3                    = IOMUX_PAD(0x0514, 0x01CC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD3__GPIO5_IO_3                         = IOMUX_PAD(0x0514, 0x01CC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD3__CSI2_DATA_13                       = IOMUX_PAD(0x0514, 0x01CC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD3__ANATOP_TESTI_3                     = IOMUX_PAD(0x0514, 0x01CC, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD3__USDHC3_TESTER_TRIGGER              = IOMUX_PAD(0x0514, 0x01CC, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RD3__PCIE_CTRL_DEBUG_3                  = IOMUX_PAD(0x0514, 0x01CC, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN                     = IOMUX_PAD(0x0518, 0x01D0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RX_CTL__GPIO5_IO_4                      = IOMUX_PAD(0x0518, 0x01D0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RX_CTL__CSI2_DATA_14                    = IOMUX_PAD(0x0518, 0x01D0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RX_CTL__ANATOP_TESTO_0                  = IOMUX_PAD(0x0518, 0x01D0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RX_CTL__USDHC4_TESTER_TRIGGER           = IOMUX_PAD(0x0518, 0x01D0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RX_CTL__PCIE_CTRL_DEBUG_4               = IOMUX_PAD(0x0518, 0x01D0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_RXC__ENET1_RX_CLK                       = IOMUX_PAD(0x051C, 0x01D4, 0, 0x0768, 1, 0),
+	MX6SX_PAD_RGMII1_RXC__ENET1_RX_ER                        = IOMUX_PAD(0x051C, 0x01D4, 1, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RXC__GPIO5_IO_5                         = IOMUX_PAD(0x051C, 0x01D4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RXC__CSI2_DATA_15                       = IOMUX_PAD(0x051C, 0x01D4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RXC__ANATOP_TESTO_1                     = IOMUX_PAD(0x051C, 0x01D4, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RXC__ECSPI1_TESTER_TRIGGER              = IOMUX_PAD(0x051C, 0x01D4, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_RXC__PCIE_CTRL_DEBUG_5                  = IOMUX_PAD(0x051C, 0x01D4, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0                    = IOMUX_PAD(0x0520, 0x01D8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD0__SAI2_RX_SYNC                       = IOMUX_PAD(0x0520, 0x01D8, 2, 0x0810, 1, 0),
+	MX6SX_PAD_RGMII1_TD0__GPIO5_IO_6                         = IOMUX_PAD(0x0520, 0x01D8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD0__CSI2_DATA_16                       = IOMUX_PAD(0x0520, 0x01D8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD0__ANATOP_TESTO_2                     = IOMUX_PAD(0x0520, 0x01D8, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD0__ECSPI2_TESTER_TRIGGER              = IOMUX_PAD(0x0520, 0x01D8, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD0__PCIE_CTRL_DEBUG_6                  = IOMUX_PAD(0x0520, 0x01D8, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1                    = IOMUX_PAD(0x0524, 0x01DC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD1__SAI2_RX_BCLK                       = IOMUX_PAD(0x0524, 0x01DC, 2, 0x0808, 1, 0),
+	MX6SX_PAD_RGMII1_TD1__GPIO5_IO_7                         = IOMUX_PAD(0x0524, 0x01DC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD1__CSI2_DATA_17                       = IOMUX_PAD(0x0524, 0x01DC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD1__ANATOP_TESTO_3                     = IOMUX_PAD(0x0524, 0x01DC, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD1__ECSPI3_TESTER_TRIGGER              = IOMUX_PAD(0x0524, 0x01DC, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD1__PCIE_CTRL_DEBUG_7                  = IOMUX_PAD(0x0524, 0x01DC, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_TD2__ENET1_TX_DATA_2                    = IOMUX_PAD(0x0528, 0x01E0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD2__SAI2_TX_SYNC                       = IOMUX_PAD(0x0528, 0x01E0, 2, 0x0818, 1, 0),
+	MX6SX_PAD_RGMII1_TD2__GPIO5_IO_8                         = IOMUX_PAD(0x0528, 0x01E0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD2__CSI2_DATA_18                       = IOMUX_PAD(0x0528, 0x01E0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD2__ANATOP_TESTO_4                     = IOMUX_PAD(0x0528, 0x01E0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD2__ECSPI4_TESTER_TRIGGER              = IOMUX_PAD(0x0528, 0x01E0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD2__PCIE_CTRL_DEBUG_8                  = IOMUX_PAD(0x0528, 0x01E0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_TD3__ENET1_TX_DATA_3                    = IOMUX_PAD(0x052C, 0x01E4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD3__SAI2_TX_BCLK                       = IOMUX_PAD(0x052C, 0x01E4, 2, 0x0814, 1, 0),
+	MX6SX_PAD_RGMII1_TD3__GPIO5_IO_9                         = IOMUX_PAD(0x052C, 0x01E4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD3__CSI2_DATA_19                       = IOMUX_PAD(0x052C, 0x01E4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD3__ANATOP_TESTO_5                     = IOMUX_PAD(0x052C, 0x01E4, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD3__ECSPI5_TESTER_TRIGGER              = IOMUX_PAD(0x052C, 0x01E4, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TD3__PCIE_CTRL_DEBUG_9                  = IOMUX_PAD(0x052C, 0x01E4, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN                     = IOMUX_PAD(0x0530, 0x01E8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TX_CTL__SAI2_RX_DATA_0                  = IOMUX_PAD(0x0530, 0x01E8, 2, 0x080C, 1, 0),
+	MX6SX_PAD_RGMII1_TX_CTL__GPIO5_IO_10                     = IOMUX_PAD(0x0530, 0x01E8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TX_CTL__CSI2_DATA_0                     = IOMUX_PAD(0x0530, 0x01E8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TX_CTL__ANATOP_TESTO_6                  = IOMUX_PAD(0x0530, 0x01E8, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TX_CTL__QSPI1_TESTER_TRIGGER            = IOMUX_PAD(0x0530, 0x01E8, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TX_CTL__PCIE_CTRL_DEBUG_10              = IOMUX_PAD(0x0530, 0x01E8, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII1_TXC__ENET1_RGMII_TXC                    = IOMUX_PAD(0x0534, 0x01EC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TXC__ENET1_TX_ER                        = IOMUX_PAD(0x0534, 0x01EC, 1, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TXC__SAI2_TX_DATA_0                     = IOMUX_PAD(0x0534, 0x01EC, 2, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TXC__GPIO5_IO_11                        = IOMUX_PAD(0x0534, 0x01EC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TXC__CSI2_DATA_1                        = IOMUX_PAD(0x0534, 0x01EC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TXC__ANATOP_TESTO_7                     = IOMUX_PAD(0x0534, 0x01EC, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TXC__QSPI2_TESTER_TRIGGER               = IOMUX_PAD(0x0534, 0x01EC, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII1_TXC__PCIE_CTRL_DEBUG_11                 = IOMUX_PAD(0x0534, 0x01EC, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_RD0__ENET2_RX_DATA_0                    = IOMUX_PAD(0x0538, 0x01F0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD0__PWM4_OUT                           = IOMUX_PAD(0x0538, 0x01F0, 2, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD0__GPIO5_IO_12                        = IOMUX_PAD(0x0538, 0x01F0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD0__CSI2_DATA_2                        = IOMUX_PAD(0x0538, 0x01F0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD0__ANATOP_TESTO_8                     = IOMUX_PAD(0x0538, 0x01F0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD0__VDEC_DEBUG_18                      = IOMUX_PAD(0x0538, 0x01F0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD0__PCIE_CTRL_DEBUG_12                 = IOMUX_PAD(0x0538, 0x01F0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_RD1__ENET2_RX_DATA_1                    = IOMUX_PAD(0x053C, 0x01F4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD1__PWM3_OUT                           = IOMUX_PAD(0x053C, 0x01F4, 2, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD1__GPIO5_IO_13                        = IOMUX_PAD(0x053C, 0x01F4, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD1__CSI2_DATA_3                        = IOMUX_PAD(0x053C, 0x01F4, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD1__ANATOP_TESTO_9                     = IOMUX_PAD(0x053C, 0x01F4, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD1__VDEC_DEBUG_19                      = IOMUX_PAD(0x053C, 0x01F4, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD1__PCIE_CTRL_DEBUG_13                 = IOMUX_PAD(0x053C, 0x01F4, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_RD2__ENET2_RX_DATA_2                    = IOMUX_PAD(0x0540, 0x01F8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD2__PWM2_OUT                           = IOMUX_PAD(0x0540, 0x01F8, 2, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD2__GPIO5_IO_14                        = IOMUX_PAD(0x0540, 0x01F8, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD2__CSI2_DATA_4                        = IOMUX_PAD(0x0540, 0x01F8, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD2__ANATOP_TESTO_10                    = IOMUX_PAD(0x0540, 0x01F8, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD2__VDEC_DEBUG_20                      = IOMUX_PAD(0x0540, 0x01F8, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD2__PCIE_CTRL_DEBUG_14                 = IOMUX_PAD(0x0540, 0x01F8, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_RD3__ENET2_RX_DATA_3                    = IOMUX_PAD(0x0544, 0x01FC, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD3__PWM1_OUT                           = IOMUX_PAD(0x0544, 0x01FC, 2, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD3__GPIO5_IO_15                        = IOMUX_PAD(0x0544, 0x01FC, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD3__CSI2_DATA_5                        = IOMUX_PAD(0x0544, 0x01FC, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD3__ANATOP_TESTO_11                    = IOMUX_PAD(0x0544, 0x01FC, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD3__VDEC_DEBUG_21                      = IOMUX_PAD(0x0544, 0x01FC, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RD3__PCIE_CTRL_DEBUG_15                 = IOMUX_PAD(0x0544, 0x01FC, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_RX_CTL__ENET2_RX_EN                     = IOMUX_PAD(0x0548, 0x0200, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RX_CTL__GPIO5_IO_16                     = IOMUX_PAD(0x0548, 0x0200, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RX_CTL__CSI2_DATA_6                     = IOMUX_PAD(0x0548, 0x0200, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RX_CTL__ANATOP_TESTO_12                 = IOMUX_PAD(0x0548, 0x0200, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RX_CTL__VDEC_DEBUG_22                   = IOMUX_PAD(0x0548, 0x0200, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RX_CTL__PCIE_CTRL_DEBUG_16              = IOMUX_PAD(0x0548, 0x0200, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_RXC__ENET2_RX_CLK                       = IOMUX_PAD(0x054C, 0x0204, 0, 0x0774, 1, 0),
+	MX6SX_PAD_RGMII2_RXC__ENET2_RX_ER                        = IOMUX_PAD(0x054C, 0x0204, 1, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RXC__GPIO5_IO_17                        = IOMUX_PAD(0x054C, 0x0204, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RXC__CSI2_DATA_7                        = IOMUX_PAD(0x054C, 0x0204, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RXC__ANATOP_TESTO_13                    = IOMUX_PAD(0x054C, 0x0204, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RXC__VDEC_DEBUG_23                      = IOMUX_PAD(0x054C, 0x0204, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_RXC__PCIE_CTRL_DEBUG_17                 = IOMUX_PAD(0x054C, 0x0204, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_TD0__ENET2_TX_DATA_0                    = IOMUX_PAD(0x0550, 0x0208, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD0__SAI1_RX_SYNC                       = IOMUX_PAD(0x0550, 0x0208, 2, 0x07FC, 1, 0),
+	MX6SX_PAD_RGMII2_TD0__PWM8_OUT                           = IOMUX_PAD(0x0550, 0x0208, 3, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD0__GPIO5_IO_18                        = IOMUX_PAD(0x0550, 0x0208, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD0__CSI2_DATA_8                        = IOMUX_PAD(0x0550, 0x0208, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD0__ANATOP_TESTO_14                    = IOMUX_PAD(0x0550, 0x0208, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD0__VDEC_DEBUG_24                      = IOMUX_PAD(0x0550, 0x0208, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD0__PCIE_CTRL_DEBUG_18                 = IOMUX_PAD(0x0550, 0x0208, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_TD1__ENET2_TX_DATA_1                    = IOMUX_PAD(0x0554, 0x020C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD1__SAI1_RX_BCLK                       = IOMUX_PAD(0x0554, 0x020C, 2, 0x07F4, 1, 0),
+	MX6SX_PAD_RGMII2_TD1__PWM7_OUT                           = IOMUX_PAD(0x0554, 0x020C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD1__GPIO5_IO_19                        = IOMUX_PAD(0x0554, 0x020C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD1__CSI2_DATA_9                        = IOMUX_PAD(0x0554, 0x020C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD1__ANATOP_TESTO_15                    = IOMUX_PAD(0x0554, 0x020C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD1__VDEC_DEBUG_25                      = IOMUX_PAD(0x0554, 0x020C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD1__PCIE_CTRL_DEBUG_19                 = IOMUX_PAD(0x0554, 0x020C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_TD2__ENET2_TX_DATA_2                    = IOMUX_PAD(0x0558, 0x0210, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD2__SAI1_TX_SYNC                       = IOMUX_PAD(0x0558, 0x0210, 2, 0x0804, 1, 0),
+	MX6SX_PAD_RGMII2_TD2__PWM6_OUT                           = IOMUX_PAD(0x0558, 0x0210, 3, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD2__GPIO5_IO_20                        = IOMUX_PAD(0x0558, 0x0210, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD2__CSI2_VSYNC                         = IOMUX_PAD(0x0558, 0x0210, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD2__SJC_FAIL                           = IOMUX_PAD(0x0558, 0x0210, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD2__VDEC_DEBUG_26                      = IOMUX_PAD(0x0558, 0x0210, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD2__PCIE_CTRL_DEBUG_20                 = IOMUX_PAD(0x0558, 0x0210, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_TD3__ENET2_TX_DATA_3                    = IOMUX_PAD(0x055C, 0x0214, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD3__SAI1_TX_BCLK                       = IOMUX_PAD(0x055C, 0x0214, 2, 0x0800, 1, 0),
+	MX6SX_PAD_RGMII2_TD3__PWM5_OUT                           = IOMUX_PAD(0x055C, 0x0214, 3, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD3__GPIO5_IO_21                        = IOMUX_PAD(0x055C, 0x0214, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD3__CSI2_HSYNC                         = IOMUX_PAD(0x055C, 0x0214, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD3__SJC_JTAG_ACT                       = IOMUX_PAD(0x055C, 0x0214, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD3__VDEC_DEBUG_27                      = IOMUX_PAD(0x055C, 0x0214, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TD3__PCIE_CTRL_DEBUG_21                 = IOMUX_PAD(0x055C, 0x0214, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_TX_CTL__ENET2_TX_EN                     = IOMUX_PAD(0x0560, 0x0218, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TX_CTL__SAI1_RX_DATA_0                  = IOMUX_PAD(0x0560, 0x0218, 2, 0x07F8, 1, 0),
+	MX6SX_PAD_RGMII2_TX_CTL__GPIO5_IO_22                     = IOMUX_PAD(0x0560, 0x0218, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TX_CTL__CSI2_FIELD                      = IOMUX_PAD(0x0560, 0x0218, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TX_CTL__SJC_DE_B                        = IOMUX_PAD(0x0560, 0x0218, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TX_CTL__VDEC_DEBUG_28                   = IOMUX_PAD(0x0560, 0x0218, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TX_CTL__PCIE_CTRL_DEBUG_22              = IOMUX_PAD(0x0560, 0x0218, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_RGMII2_TXC__ENET2_RGMII_TXC                    = IOMUX_PAD(0x0564, 0x021C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TXC__ENET2_TX_ER                        = IOMUX_PAD(0x0564, 0x021C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TXC__SAI1_TX_DATA_0                     = IOMUX_PAD(0x0564, 0x021C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TXC__GPIO5_IO_23                        = IOMUX_PAD(0x0564, 0x021C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TXC__CSI2_PIXCLK                        = IOMUX_PAD(0x0564, 0x021C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TXC__SJC_DONE                           = IOMUX_PAD(0x0564, 0x021C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TXC__VDEC_DEBUG_29                      = IOMUX_PAD(0x0564, 0x021C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_RGMII2_TXC__PCIE_CTRL_DEBUG_23                 = IOMUX_PAD(0x0564, 0x021C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD1_CLK__USDHC1_CLK                            = IOMUX_PAD(0x0568, 0x0220, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CLK__AUDMUX_AUD5_RXFS                      = IOMUX_PAD(0x0568, 0x0220, 1, 0x0668, 1, 0),
+	MX6SX_PAD_SD1_CLK__WDOG2_WDOG_B                          = IOMUX_PAD(0x0568, 0x0220, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CLK__GPT_CLK                               = IOMUX_PAD(0x0568, 0x0220, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CLK__WDOG2_WDOG_RST_B_DEB                  = IOMUX_PAD(0x0568, 0x0220, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CLK__GPIO6_IO_0                            = IOMUX_PAD(0x0568, 0x0220, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CLK__ENET2_1588_EVENT1_OUT                 = IOMUX_PAD(0x0568, 0x0220, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CLK__CCM_OUT1                              = IOMUX_PAD(0x0568, 0x0220, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CLK__VADC_ADC_PROC_CLK                     = IOMUX_PAD(0x0568, 0x0220, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CLK__MMDC_DEBUG_45                         = IOMUX_PAD(0x0568, 0x0220, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD1_CMD__USDHC1_CMD                            = IOMUX_PAD(0x056C, 0x0224, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CMD__AUDMUX_AUD5_RXC                       = IOMUX_PAD(0x056C, 0x0224, 1, 0x0664, 1, 0),
+	MX6SX_PAD_SD1_CMD__WDOG1_WDOG_B                          = IOMUX_PAD(0x056C, 0x0224, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CMD__GPT_COMPARE1                          = IOMUX_PAD(0x056C, 0x0224, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CMD__WDOG1_WDOG_RST_B_DEB                  = IOMUX_PAD(0x056C, 0x0224, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CMD__GPIO6_IO_1                            = IOMUX_PAD(0x056C, 0x0224, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CMD__ENET2_1588_EVENT1_IN                  = IOMUX_PAD(0x056C, 0x0224, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CMD__CCM_CLKO1                             = IOMUX_PAD(0x056C, 0x0224, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CMD__VADC_EXT_SYSCLK                       = IOMUX_PAD(0x056C, 0x0224, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_CMD__MMDC_DEBUG_46                         = IOMUX_PAD(0x056C, 0x0224, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD1_DATA0__USDHC1_DATA0                        = IOMUX_PAD(0x0570, 0x0228, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA0__AUDMUX_AUD5_RXD                     = IOMUX_PAD(0x0570, 0x0228, 1, 0x065C, 1, 0),
+	MX6SX_PAD_SD1_DATA0__CAAM_WRAPPER_RNG_OSC_OBS            = IOMUX_PAD(0x0570, 0x0228, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA0__GPT_CAPTURE1                        = IOMUX_PAD(0x0570, 0x0228, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA0__UART2_RX                            = IOMUX_PAD(0x0570, 0x0228, 4, 0x0838, 2, 0),
+	MX6SX_PAD_SD1_DATA0__GPIO6_IO_2                          = IOMUX_PAD(0x0570, 0x0228, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA0__ENET1_1588_EVENT1_IN                = IOMUX_PAD(0x0570, 0x0228, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA0__CCM_OUT2                            = IOMUX_PAD(0x0570, 0x0228, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA0__VADC_CLAMP_UP                       = IOMUX_PAD(0x0570, 0x0228, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA0__MMDC_DEBUG_48                       = IOMUX_PAD(0x0570, 0x0228, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD1_DATA1__USDHC1_DATA1                        = IOMUX_PAD(0x0574, 0x022C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA1__AUDMUX_AUD5_TXC                     = IOMUX_PAD(0x0574, 0x022C, 1, 0x066C, 1, 0),
+	MX6SX_PAD_SD1_DATA1__PWM4_OUT                            = IOMUX_PAD(0x0574, 0x022C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA1__GPT_CAPTURE2                        = IOMUX_PAD(0x0574, 0x022C, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA1__UART2_TX                            = IOMUX_PAD(0x0574, 0x022C, 4, 0x0838, 3, 0),
+	MX6SX_PAD_SD1_DATA1__GPIO6_IO_3                          = IOMUX_PAD(0x0574, 0x022C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA1__ENET1_1588_EVENT1_OUT               = IOMUX_PAD(0x0574, 0x022C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA1__CCM_CLKO2                           = IOMUX_PAD(0x0574, 0x022C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA1__VADC_CLAMP_DOWN                     = IOMUX_PAD(0x0574, 0x022C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA1__MMDC_DEBUG_47                       = IOMUX_PAD(0x0574, 0x022C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD1_DATA2__USDHC1_DATA2                        = IOMUX_PAD(0x0578, 0x0230, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA2__AUDMUX_AUD5_TXFS                    = IOMUX_PAD(0x0578, 0x0230, 1, 0x0670, 1, 0),
+	MX6SX_PAD_SD1_DATA2__PWM3_OUT                            = IOMUX_PAD(0x0578, 0x0230, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA2__GPT_COMPARE2                        = IOMUX_PAD(0x0578, 0x0230, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA2__UART2_CTS_B                         = IOMUX_PAD(0x0578, 0x0230, 4, 0x0834, 2, 0),
+	MX6SX_PAD_SD1_DATA2__GPIO6_IO_4                          = IOMUX_PAD(0x0578, 0x0230, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA2__ECSPI4_RDY                          = IOMUX_PAD(0x0578, 0x0230, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA2__CCM_OUT0                            = IOMUX_PAD(0x0578, 0x0230, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA2__VADC_EXT_PD_N                       = IOMUX_PAD(0x0578, 0x0230, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD1_DATA3__USDHC1_DATA3                        = IOMUX_PAD(0x057C, 0x0234, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA3__AUDMUX_AUD5_TXD                     = IOMUX_PAD(0x057C, 0x0234, 1, 0x0660, 1, 0),
+	MX6SX_PAD_SD1_DATA3__AUDMUX_AUD5_RXD                     = IOMUX_PAD(0x057C, 0x0234, 2, 0x065C, 2, 0),
+	MX6SX_PAD_SD1_DATA3__GPT_COMPARE3                        = IOMUX_PAD(0x057C, 0x0234, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA3__UART2_RTS_B                         = IOMUX_PAD(0x057C, 0x0234, 4, 0x0834, 3, 0),
+	MX6SX_PAD_SD1_DATA3__GPIO6_IO_5                          = IOMUX_PAD(0x057C, 0x0234, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA3__ECSPI4_SS1                          = IOMUX_PAD(0x057C, 0x0234, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD1_DATA3__CCM_PMIC_RDY                        = IOMUX_PAD(0x057C, 0x0234, 7, 0x069C, 2, 0),
+	MX6SX_PAD_SD1_DATA3__VADC_RST_N                          = IOMUX_PAD(0x057C, 0x0234, 8, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD2_CLK__USDHC2_CLK                            = IOMUX_PAD(0x0580, 0x0238, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CLK__AUDMUX_AUD6_RXFS                      = IOMUX_PAD(0x0580, 0x0238, 1, 0x0680, 2, 0),
+	MX6SX_PAD_SD2_CLK__KPP_COL_5                             = IOMUX_PAD(0x0580, 0x0238, 2, 0x07C8, 1, 0),
+	MX6SX_PAD_SD2_CLK__ECSPI4_SCLK                           = IOMUX_PAD(0x0580, 0x0238, 3, 0x0740, 1, 0),
+	MX6SX_PAD_SD2_CLK__MLB_SIG                               = IOMUX_PAD(0x0580, 0x0238, 4, 0x07F0, 2, 0),
+	MX6SX_PAD_SD2_CLK__GPIO6_IO_6                            = IOMUX_PAD(0x0580, 0x0238, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CLK__MQS_RIGHT                             = IOMUX_PAD(0x0580, 0x0238, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CLK__WDOG1_WDOG_ANY                        = IOMUX_PAD(0x0580, 0x0238, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CLK__VADC_CLAMP_CURRENT_5                  = IOMUX_PAD(0x0580, 0x0238, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CLK__MMDC_DEBUG_29                         = IOMUX_PAD(0x0580, 0x0238, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD2_CMD__USDHC2_CMD                            = IOMUX_PAD(0x0584, 0x023C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CMD__AUDMUX_AUD6_RXC                       = IOMUX_PAD(0x0584, 0x023C, 1, 0x067C, 2, 0),
+	MX6SX_PAD_SD2_CMD__KPP_ROW_5                             = IOMUX_PAD(0x0584, 0x023C, 2, 0x07D4, 1, 0),
+	MX6SX_PAD_SD2_CMD__ECSPI4_MOSI                           = IOMUX_PAD(0x0584, 0x023C, 3, 0x0748, 1, 0),
+	MX6SX_PAD_SD2_CMD__MLB_CLK                               = IOMUX_PAD(0x0584, 0x023C, 4, 0x07E8, 2, 0),
+	MX6SX_PAD_SD2_CMD__GPIO6_IO_7                            = IOMUX_PAD(0x0584, 0x023C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CMD__MQS_LEFT                              = IOMUX_PAD(0x0584, 0x023C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CMD__WDOG3_WDOG_B                          = IOMUX_PAD(0x0584, 0x023C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CMD__VADC_CLAMP_CURRENT_4                  = IOMUX_PAD(0x0584, 0x023C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_CMD__MMDC_DEBUG_30                         = IOMUX_PAD(0x0584, 0x023C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD2_DATA0__USDHC2_DATA0                        = IOMUX_PAD(0x0588, 0x0240, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA0__AUDMUX_AUD6_RXD                     = IOMUX_PAD(0x0588, 0x0240, 1, 0x0674, 2, 0),
+	MX6SX_PAD_SD2_DATA0__KPP_ROW_7                           = IOMUX_PAD(0x0588, 0x0240, 2, 0x07DC, 1, 0),
+	MX6SX_PAD_SD2_DATA0__PWM1_OUT                            = IOMUX_PAD(0x0588, 0x0240, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA0__I2C4_SDA                            = IOMUX_PAD(0x0588, 0x0240, 4, 0x07C4, 3, 0),
+	MX6SX_PAD_SD2_DATA0__GPIO6_IO_8                          = IOMUX_PAD(0x0588, 0x0240, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA0__ECSPI4_SS3                          = IOMUX_PAD(0x0588, 0x0240, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA0__UART4_RX                            = IOMUX_PAD(0x0588, 0x0240, 7, 0x0848, 4, 0),
+	MX6SX_PAD_SD2_DATA0__VADC_CLAMP_CURRENT_0                = IOMUX_PAD(0x0588, 0x0240, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA0__MMDC_DEBUG_50                       = IOMUX_PAD(0x0588, 0x0240, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD2_DATA1__USDHC2_DATA1                        = IOMUX_PAD(0x058C, 0x0244, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA1__AUDMUX_AUD6_TXC                     = IOMUX_PAD(0x058C, 0x0244, 1, 0x0684, 2, 0),
+	MX6SX_PAD_SD2_DATA1__KPP_COL_7                           = IOMUX_PAD(0x058C, 0x0244, 2, 0x07D0, 1, 0),
+	MX6SX_PAD_SD2_DATA1__PWM2_OUT                            = IOMUX_PAD(0x058C, 0x0244, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA1__I2C4_SCL                            = IOMUX_PAD(0x058C, 0x0244, 4, 0x07C0, 3, 0),
+	MX6SX_PAD_SD2_DATA1__GPIO6_IO_9                          = IOMUX_PAD(0x058C, 0x0244, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA1__ECSPI4_SS2                          = IOMUX_PAD(0x058C, 0x0244, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA1__UART4_TX                            = IOMUX_PAD(0x058C, 0x0244, 7, 0x0848, 5, 0),
+	MX6SX_PAD_SD2_DATA1__VADC_CLAMP_CURRENT_1                = IOMUX_PAD(0x058C, 0x0244, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA1__MMDC_DEBUG_49                       = IOMUX_PAD(0x058C, 0x0244, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD2_DATA2__USDHC2_DATA2                        = IOMUX_PAD(0x0590, 0x0248, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA2__AUDMUX_AUD6_TXFS                    = IOMUX_PAD(0x0590, 0x0248, 1, 0x0688, 2, 0),
+	MX6SX_PAD_SD2_DATA2__KPP_ROW_6                           = IOMUX_PAD(0x0590, 0x0248, 2, 0x07D8, 1, 0),
+	MX6SX_PAD_SD2_DATA2__ECSPI4_SS0                          = IOMUX_PAD(0x0590, 0x0248, 3, 0x074C, 1, 0),
+	MX6SX_PAD_SD2_DATA2__SDMA_EXT_EVENT_0                    = IOMUX_PAD(0x0590, 0x0248, 4, 0x081C, 2, 0),
+	MX6SX_PAD_SD2_DATA2__GPIO6_IO_10                         = IOMUX_PAD(0x0590, 0x0248, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA2__SPDIF_OUT                           = IOMUX_PAD(0x0590, 0x0248, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA2__UART6_RX                            = IOMUX_PAD(0x0590, 0x0248, 7, 0x0858, 4, 0),
+	MX6SX_PAD_SD2_DATA2__VADC_CLAMP_CURRENT_2                = IOMUX_PAD(0x0590, 0x0248, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA2__MMDC_DEBUG_32                       = IOMUX_PAD(0x0590, 0x0248, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD2_DATA3__USDHC2_DATA3                        = IOMUX_PAD(0x0594, 0x024C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA3__AUDMUX_AUD6_TXD                     = IOMUX_PAD(0x0594, 0x024C, 1, 0x0678, 2, 0),
+	MX6SX_PAD_SD2_DATA3__KPP_COL_6                           = IOMUX_PAD(0x0594, 0x024C, 2, 0x07CC, 1, 0),
+	MX6SX_PAD_SD2_DATA3__ECSPI4_MISO                         = IOMUX_PAD(0x0594, 0x024C, 3, 0x0744, 1, 0),
+	MX6SX_PAD_SD2_DATA3__MLB_DATA                            = IOMUX_PAD(0x0594, 0x024C, 4, 0x07EC, 2, 0),
+	MX6SX_PAD_SD2_DATA3__GPIO6_IO_11                         = IOMUX_PAD(0x0594, 0x024C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA3__SPDIF_IN                            = IOMUX_PAD(0x0594, 0x024C, 6, 0x0824, 4, 0),
+	MX6SX_PAD_SD2_DATA3__UART6_TX                            = IOMUX_PAD(0x0594, 0x024C, 7, 0x0858, 5, 0),
+	MX6SX_PAD_SD2_DATA3__VADC_CLAMP_CURRENT_3                = IOMUX_PAD(0x0594, 0x024C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD2_DATA3__MMDC_DEBUG_31                       = IOMUX_PAD(0x0594, 0x024C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_CLK__USDHC3_CLK                            = IOMUX_PAD(0x0598, 0x0250, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_CLK__UART4_CTS_B                           = IOMUX_PAD(0x0598, 0x0250, 1, 0x0844, 0, 0),
+	MX6SX_PAD_SD3_CLK__ECSPI4_SCLK                           = IOMUX_PAD(0x0598, 0x0250, 2, 0x0740, 0, 0),
+	MX6SX_PAD_SD3_CLK__AUDMUX_AUD6_RXFS                      = IOMUX_PAD(0x0598, 0x0250, 3, 0x0680, 0, 0),
+	MX6SX_PAD_SD3_CLK__LCDIF2_VSYNC                          = IOMUX_PAD(0x0598, 0x0250, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_CLK__GPIO7_IO_0                            = IOMUX_PAD(0x0598, 0x0250, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_CLK__LCDIF2_BUSY                           = IOMUX_PAD(0x0598, 0x0250, 6, 0x07E4, 0, 0),
+	MX6SX_PAD_SD3_CLK__TPSMP_HDATA_29                        = IOMUX_PAD(0x0598, 0x0250, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_CLK__SDMA_DEBUG_EVENT_CHANNEL_5            = IOMUX_PAD(0x0598, 0x0250, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_CMD__USDHC3_CMD                            = IOMUX_PAD(0x059C, 0x0254, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_CMD__UART4_TX                              = IOMUX_PAD(0x059C, 0x0254, 1, 0x0848, 0, 0),
+	MX6SX_PAD_SD3_CMD__ECSPI4_MOSI                           = IOMUX_PAD(0x059C, 0x0254, 2, 0x0748, 0, 0),
+	MX6SX_PAD_SD3_CMD__AUDMUX_AUD6_RXC                       = IOMUX_PAD(0x059C, 0x0254, 3, 0x067C, 0, 0),
+	MX6SX_PAD_SD3_CMD__LCDIF2_HSYNC                          = IOMUX_PAD(0x059C, 0x0254, 4, 0x07E4, 1, 0),
+	MX6SX_PAD_SD3_CMD__GPIO7_IO_1                            = IOMUX_PAD(0x059C, 0x0254, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_CMD__LCDIF2_RS                             = IOMUX_PAD(0x059C, 0x0254, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_CMD__TPSMP_HDATA_28                        = IOMUX_PAD(0x059C, 0x0254, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_CMD__SDMA_DEBUG_EVENT_CHANNEL_4            = IOMUX_PAD(0x059C, 0x0254, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_DATA0__USDHC3_DATA0                        = IOMUX_PAD(0x05A0, 0x0258, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA0__I2C4_SCL                            = IOMUX_PAD(0x05A0, 0x0258, 1, 0x07C0, 0, 0),
+	MX6SX_PAD_SD3_DATA0__ECSPI2_SS1                          = IOMUX_PAD(0x05A0, 0x0258, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA0__AUDMUX_AUD6_RXD                     = IOMUX_PAD(0x05A0, 0x0258, 3, 0x0674, 0, 0),
+	MX6SX_PAD_SD3_DATA0__LCDIF2_DATA_1                       = IOMUX_PAD(0x05A0, 0x0258, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA0__GPIO7_IO_2                          = IOMUX_PAD(0x05A0, 0x0258, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA0__DCIC1_OUT                           = IOMUX_PAD(0x05A0, 0x0258, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA0__TPSMP_HDATA_30                      = IOMUX_PAD(0x05A0, 0x0258, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA0__GPU_DEBUG_0                         = IOMUX_PAD(0x05A0, 0x0258, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA0__SDMA_DEBUG_EVT_CHN_LINES_0          = IOMUX_PAD(0x05A0, 0x0258, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_DATA1__USDHC3_DATA1                        = IOMUX_PAD(0x05A4, 0x025C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA1__I2C4_SDA                            = IOMUX_PAD(0x05A4, 0x025C, 1, 0x07C4, 0, 0),
+	MX6SX_PAD_SD3_DATA1__ECSPI2_SS2                          = IOMUX_PAD(0x05A4, 0x025C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA1__AUDMUX_AUD6_TXC                     = IOMUX_PAD(0x05A4, 0x025C, 3, 0x0684, 0, 0),
+	MX6SX_PAD_SD3_DATA1__LCDIF2_DATA_0                       = IOMUX_PAD(0x05A4, 0x025C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA1__GPIO7_IO_3                          = IOMUX_PAD(0x05A4, 0x025C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA1__DCIC2_OUT                           = IOMUX_PAD(0x05A4, 0x025C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA1__TPSMP_HDATA_31                      = IOMUX_PAD(0x05A4, 0x025C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA1__GPU_DEBUG_1                         = IOMUX_PAD(0x05A4, 0x025C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA1__SDMA_DEBUG_EVT_CHN_LINES_1          = IOMUX_PAD(0x05A4, 0x025C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_DATA2__USDHC3_DATA2                        = IOMUX_PAD(0x05A8, 0x0260, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA2__UART4_RTS_B                         = IOMUX_PAD(0x05A8, 0x0260, 1, 0x0844, 1, 0),
+	MX6SX_PAD_SD3_DATA2__ECSPI4_SS0                          = IOMUX_PAD(0x05A8, 0x0260, 2, 0x074C, 0, 0),
+	MX6SX_PAD_SD3_DATA2__AUDMUX_AUD6_TXFS                    = IOMUX_PAD(0x05A8, 0x0260, 3, 0x0688, 0, 0),
+	MX6SX_PAD_SD3_DATA2__LCDIF2_CLK                          = IOMUX_PAD(0x05A8, 0x0260, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA2__GPIO7_IO_4                          = IOMUX_PAD(0x05A8, 0x0260, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA2__LCDIF2_WR_RWN                       = IOMUX_PAD(0x05A8, 0x0260, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA2__TPSMP_HDATA_26                      = IOMUX_PAD(0x05A8, 0x0260, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA2__GPU_DEBUG_2                         = IOMUX_PAD(0x05A8, 0x0260, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA2__SDMA_DEBUG_EVENT_CHANNEL_2          = IOMUX_PAD(0x05A8, 0x0260, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_DATA3__USDHC3_DATA3                        = IOMUX_PAD(0x05AC, 0x0264, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA3__UART4_RX                            = IOMUX_PAD(0x05AC, 0x0264, 1, 0x0848, 1, 0),
+	MX6SX_PAD_SD3_DATA3__ECSPI4_MISO                         = IOMUX_PAD(0x05AC, 0x0264, 2, 0x0744, 0, 0),
+	MX6SX_PAD_SD3_DATA3__AUDMUX_AUD6_TXD                     = IOMUX_PAD(0x05AC, 0x0264, 3, 0x0678, 0, 0),
+	MX6SX_PAD_SD3_DATA3__LCDIF2_ENABLE                       = IOMUX_PAD(0x05AC, 0x0264, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA3__GPIO7_IO_5                          = IOMUX_PAD(0x05AC, 0x0264, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA3__LCDIF2_RD_E                         = IOMUX_PAD(0x05AC, 0x0264, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA3__TPSMP_HDATA_27                      = IOMUX_PAD(0x05AC, 0x0264, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA3__GPU_DEBUG_3                         = IOMUX_PAD(0x05AC, 0x0264, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA3__SDMA_DEBUG_EVENT_CHANNEL_3          = IOMUX_PAD(0x05AC, 0x0264, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_DATA4__USDHC3_DATA4                        = IOMUX_PAD(0x05B0, 0x0268, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA4__CAN2_RX                             = IOMUX_PAD(0x05B0, 0x0268, 1, 0x0690, 0, 0),
+	MX6SX_PAD_SD3_DATA4__CANFD_RX2                           = IOMUX_PAD(0x05B0, 0x0268, 2, 0x0698, 0, 0),
+	MX6SX_PAD_SD3_DATA4__UART3_RX                            = IOMUX_PAD(0x05B0, 0x0268, 3, 0x0840, 2, 0),
+	MX6SX_PAD_SD3_DATA4__LCDIF2_DATA_3                       = IOMUX_PAD(0x05B0, 0x0268, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA4__GPIO7_IO_6                          = IOMUX_PAD(0x05B0, 0x0268, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA4__ENET2_1588_EVENT0_IN                = IOMUX_PAD(0x05B0, 0x0268, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA4__TPSMP_HTRANS_1                      = IOMUX_PAD(0x05B0, 0x0268, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA4__GPU_DEBUG_4                         = IOMUX_PAD(0x05B0, 0x0268, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA4__SDMA_DEBUG_BUS_DEVICE_0             = IOMUX_PAD(0x05B0, 0x0268, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_DATA5__USDHC3_DATA5                        = IOMUX_PAD(0x05B4, 0x026C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA5__CAN1_TX                             = IOMUX_PAD(0x05B4, 0x026C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA5__CANFD_TX1                           = IOMUX_PAD(0x05B4, 0x026C, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA5__UART3_TX                            = IOMUX_PAD(0x05B4, 0x026C, 3, 0x0840, 3, 0),
+	MX6SX_PAD_SD3_DATA5__LCDIF2_DATA_2                       = IOMUX_PAD(0x05B4, 0x026C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA5__GPIO7_IO_7                          = IOMUX_PAD(0x05B4, 0x026C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA5__ENET2_1588_EVENT0_OUT               = IOMUX_PAD(0x05B4, 0x026C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA5__SIM_M_HWRITE                        = IOMUX_PAD(0x05B4, 0x026C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA5__GPU_DEBUG_5                         = IOMUX_PAD(0x05B4, 0x026C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA5__SDMA_DEBUG_BUS_DEVICE_1             = IOMUX_PAD(0x05B4, 0x026C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_DATA6__USDHC3_DATA6                        = IOMUX_PAD(0x05B8, 0x0270, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA6__CAN2_TX                             = IOMUX_PAD(0x05B8, 0x0270, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA6__CANFD_TX2                           = IOMUX_PAD(0x05B8, 0x0270, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA6__UART3_RTS_B                         = IOMUX_PAD(0x05B8, 0x0270, 3, 0x083C, 2, 0),
+	MX6SX_PAD_SD3_DATA6__LCDIF2_DATA_4                       = IOMUX_PAD(0x05B8, 0x0270, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA6__GPIO7_IO_8                          = IOMUX_PAD(0x05B8, 0x0270, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA6__ENET1_1588_EVENT0_OUT               = IOMUX_PAD(0x05B8, 0x0270, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA6__TPSMP_HTRANS_0                      = IOMUX_PAD(0x05B8, 0x0270, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA6__GPU_DEBUG_7                         = IOMUX_PAD(0x05B8, 0x0270, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA6__SDMA_DEBUG_EVT_CHN_LINES_7          = IOMUX_PAD(0x05B8, 0x0270, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD3_DATA7__USDHC3_DATA7                        = IOMUX_PAD(0x05BC, 0x0274, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA7__CAN1_RX                             = IOMUX_PAD(0x05BC, 0x0274, 1, 0x068C, 0, 0),
+	MX6SX_PAD_SD3_DATA7__CANFD_RX1                           = IOMUX_PAD(0x05BC, 0x0274, 2, 0x0694, 0, 0),
+	MX6SX_PAD_SD3_DATA7__UART3_CTS_B                         = IOMUX_PAD(0x05BC, 0x0274, 3, 0x083C, 3, 0),
+	MX6SX_PAD_SD3_DATA7__LCDIF2_DATA_5                       = IOMUX_PAD(0x05BC, 0x0274, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA7__GPIO7_IO_9                          = IOMUX_PAD(0x05BC, 0x0274, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA7__ENET1_1588_EVENT0_IN                = IOMUX_PAD(0x05BC, 0x0274, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA7__TPSMP_HDATA_DIR                     = IOMUX_PAD(0x05BC, 0x0274, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA7__GPU_DEBUG_6                         = IOMUX_PAD(0x05BC, 0x0274, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD3_DATA7__SDMA_DEBUG_EVT_CHN_LINES_2          = IOMUX_PAD(0x05BC, 0x0274, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_CLK__USDHC4_CLK                            = IOMUX_PAD(0x05C0, 0x0278, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CLK__RAWNAND_DATA15                        = IOMUX_PAD(0x05C0, 0x0278, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CLK__ECSPI2_MISO                           = IOMUX_PAD(0x05C0, 0x0278, 2, 0x0724, 1, 0),
+	MX6SX_PAD_SD4_CLK__AUDMUX_AUD3_RXFS                      = IOMUX_PAD(0x05C0, 0x0278, 3, 0x0638, 0, 0),
+	MX6SX_PAD_SD4_CLK__LCDIF2_DATA_13                        = IOMUX_PAD(0x05C0, 0x0278, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CLK__GPIO6_IO_12                           = IOMUX_PAD(0x05C0, 0x0278, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CLK__ECSPI3_SS2                            = IOMUX_PAD(0x05C0, 0x0278, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CLK__TPSMP_HDATA_20                        = IOMUX_PAD(0x05C0, 0x0278, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CLK__VDEC_DEBUG_12                         = IOMUX_PAD(0x05C0, 0x0278, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CLK__SDMA_DEBUG_EVENT_CHANNEL_SEL          = IOMUX_PAD(0x05C0, 0x0278, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_CMD__USDHC4_CMD                            = IOMUX_PAD(0x05C4, 0x027C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CMD__RAWNAND_DATA14                        = IOMUX_PAD(0x05C4, 0x027C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CMD__ECSPI2_MOSI                           = IOMUX_PAD(0x05C4, 0x027C, 2, 0x0728, 1, 0),
+	MX6SX_PAD_SD4_CMD__AUDMUX_AUD3_RXC                       = IOMUX_PAD(0x05C4, 0x027C, 3, 0x0634, 0, 0),
+	MX6SX_PAD_SD4_CMD__LCDIF2_DATA_14                        = IOMUX_PAD(0x05C4, 0x027C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CMD__GPIO6_IO_13                           = IOMUX_PAD(0x05C4, 0x027C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CMD__ECSPI3_SS1                            = IOMUX_PAD(0x05C4, 0x027C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CMD__TPSMP_HDATA_19                        = IOMUX_PAD(0x05C4, 0x027C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CMD__VDEC_DEBUG_11                         = IOMUX_PAD(0x05C4, 0x027C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_CMD__SDMA_DEBUG_CORE_RUN                   = IOMUX_PAD(0x05C4, 0x027C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_DATA0__USDHC4_DATA0                        = IOMUX_PAD(0x05C8, 0x0280, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA0__RAWNAND_DATA10                      = IOMUX_PAD(0x05C8, 0x0280, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA0__ECSPI2_SS0                          = IOMUX_PAD(0x05C8, 0x0280, 2, 0x072C, 1, 0),
+	MX6SX_PAD_SD4_DATA0__AUDMUX_AUD3_RXD                     = IOMUX_PAD(0x05C8, 0x0280, 3, 0x062C, 0, 0),
+	MX6SX_PAD_SD4_DATA0__LCDIF2_DATA_12                      = IOMUX_PAD(0x05C8, 0x0280, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA0__GPIO6_IO_14                         = IOMUX_PAD(0x05C8, 0x0280, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA0__ECSPI3_SS3                          = IOMUX_PAD(0x05C8, 0x0280, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA0__TPSMP_HDATA_21                      = IOMUX_PAD(0x05C8, 0x0280, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA0__VDEC_DEBUG_13                       = IOMUX_PAD(0x05C8, 0x0280, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA0__SDMA_DEBUG_MODE                     = IOMUX_PAD(0x05C8, 0x0280, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_DATA1__USDHC4_DATA1                        = IOMUX_PAD(0x05CC, 0x0284, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA1__RAWNAND_DATA11                      = IOMUX_PAD(0x05CC, 0x0284, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA1__ECSPI2_SCLK                         = IOMUX_PAD(0x05CC, 0x0284, 2, 0x0720, 1, 0),
+	MX6SX_PAD_SD4_DATA1__AUDMUX_AUD3_TXC                     = IOMUX_PAD(0x05CC, 0x0284, 3, 0x063C, 0, 0),
+	MX6SX_PAD_SD4_DATA1__LCDIF2_DATA_11                      = IOMUX_PAD(0x05CC, 0x0284, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA1__GPIO6_IO_15                         = IOMUX_PAD(0x05CC, 0x0284, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA1__ECSPI3_RDY                          = IOMUX_PAD(0x05CC, 0x0284, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA1__TPSMP_HDATA_22                      = IOMUX_PAD(0x05CC, 0x0284, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA1__VDEC_DEBUG_14                       = IOMUX_PAD(0x05CC, 0x0284, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA1__SDMA_DEBUG_BUS_ERROR                = IOMUX_PAD(0x05CC, 0x0284, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_DATA2__USDHC4_DATA2                        = IOMUX_PAD(0x05D0, 0x0288, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA2__RAWNAND_DATA12                      = IOMUX_PAD(0x05D0, 0x0288, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA2__I2C2_SDA                            = IOMUX_PAD(0x05D0, 0x0288, 2, 0x07B4, 0, 0),
+	MX6SX_PAD_SD4_DATA2__AUDMUX_AUD3_TXFS                    = IOMUX_PAD(0x05D0, 0x0288, 3, 0x0640, 0, 0),
+	MX6SX_PAD_SD4_DATA2__LCDIF2_DATA_10                      = IOMUX_PAD(0x05D0, 0x0288, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA2__GPIO6_IO_16                         = IOMUX_PAD(0x05D0, 0x0288, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA2__ECSPI2_SS3                          = IOMUX_PAD(0x05D0, 0x0288, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA2__TPSMP_HDATA_23                      = IOMUX_PAD(0x05D0, 0x0288, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA2__VDEC_DEBUG_15                       = IOMUX_PAD(0x05D0, 0x0288, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA2__SDMA_DEBUG_BUS_RWB                  = IOMUX_PAD(0x05D0, 0x0288, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_DATA3__USDHC4_DATA3                        = IOMUX_PAD(0x05D4, 0x028C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA3__RAWNAND_DATA13                      = IOMUX_PAD(0x05D4, 0x028C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA3__I2C2_SCL                            = IOMUX_PAD(0x05D4, 0x028C, 2, 0x07B0, 0, 0),
+	MX6SX_PAD_SD4_DATA3__AUDMUX_AUD3_TXD                     = IOMUX_PAD(0x05D4, 0x028C, 3, 0x0630, 0, 0),
+	MX6SX_PAD_SD4_DATA3__LCDIF2_DATA_9                       = IOMUX_PAD(0x05D4, 0x028C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA3__GPIO6_IO_17                         = IOMUX_PAD(0x05D4, 0x028C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA3__ECSPI2_RDY                          = IOMUX_PAD(0x05D4, 0x028C, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA3__TPSMP_HDATA_24                      = IOMUX_PAD(0x05D4, 0x028C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA3__VDEC_DEBUG_16                       = IOMUX_PAD(0x05D4, 0x028C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA3__SDMA_DEBUG_MATCHED_DMBUS            = IOMUX_PAD(0x05D4, 0x028C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_DATA4__USDHC4_DATA4                        = IOMUX_PAD(0x05D8, 0x0290, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA4__RAWNAND_DATA09                      = IOMUX_PAD(0x05D8, 0x0290, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA4__UART5_RX                            = IOMUX_PAD(0x05D8, 0x0290, 2, 0x0850, 0, 0),
+	MX6SX_PAD_SD4_DATA4__ECSPI3_SCLK                         = IOMUX_PAD(0x05D8, 0x0290, 3, 0x0730, 0, 0),
+	MX6SX_PAD_SD4_DATA4__LCDIF2_DATA_8                       = IOMUX_PAD(0x05D8, 0x0290, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA4__GPIO6_IO_18                         = IOMUX_PAD(0x05D8, 0x0290, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA4__SPDIF_OUT                           = IOMUX_PAD(0x05D8, 0x0290, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA4__TPSMP_HDATA_16                      = IOMUX_PAD(0x05D8, 0x0290, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA4__USB_OTG_HOST_MODE                   = IOMUX_PAD(0x05D8, 0x0290, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA4__SDMA_DEBUG_RTBUFFER_WRITE           = IOMUX_PAD(0x05D8, 0x0290, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_DATA5__USDHC4_DATA5                        = IOMUX_PAD(0x05DC, 0x0294, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA5__RAWNAND_CE2_B                       = IOMUX_PAD(0x05DC, 0x0294, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA5__UART5_TX                            = IOMUX_PAD(0x05DC, 0x0294, 2, 0x0850, 1, 0),
+	MX6SX_PAD_SD4_DATA5__ECSPI3_MOSI                         = IOMUX_PAD(0x05DC, 0x0294, 3, 0x0738, 0, 0),
+	MX6SX_PAD_SD4_DATA5__LCDIF2_DATA_7                       = IOMUX_PAD(0x05DC, 0x0294, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA5__GPIO6_IO_19                         = IOMUX_PAD(0x05DC, 0x0294, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA5__SPDIF_IN                            = IOMUX_PAD(0x05DC, 0x0294, 6, 0x0824, 0, 0),
+	MX6SX_PAD_SD4_DATA5__TPSMP_HDATA_17                      = IOMUX_PAD(0x05DC, 0x0294, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA5__VDEC_DEBUG_9                        = IOMUX_PAD(0x05DC, 0x0294, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA5__SDMA_DEBUG_EVENT_CHANNEL_0          = IOMUX_PAD(0x05DC, 0x0294, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_DATA6__USDHC4_DATA6                        = IOMUX_PAD(0x05E0, 0x0298, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA6__RAWNAND_CE3_B                       = IOMUX_PAD(0x05E0, 0x0298, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA6__UART5_RTS_B                         = IOMUX_PAD(0x05E0, 0x0298, 2, 0x084C, 0, 0),
+	MX6SX_PAD_SD4_DATA6__ECSPI3_MISO                         = IOMUX_PAD(0x05E0, 0x0298, 3, 0x0734, 0, 0),
+	MX6SX_PAD_SD4_DATA6__LCDIF2_DATA_6                       = IOMUX_PAD(0x05E0, 0x0298, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA6__GPIO6_IO_20                         = IOMUX_PAD(0x05E0, 0x0298, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA6__USDHC4_WP                           = IOMUX_PAD(0x05E0, 0x0298, 6, 0x0878, 0, 0),
+	MX6SX_PAD_SD4_DATA6__TPSMP_HDATA_18                      = IOMUX_PAD(0x05E0, 0x0298, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA6__VDEC_DEBUG_10                       = IOMUX_PAD(0x05E0, 0x0298, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA6__SDMA_DEBUG_EVENT_CHANNEL_1          = IOMUX_PAD(0x05E0, 0x0298, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_DATA7__USDHC4_DATA7                        = IOMUX_PAD(0x05E4, 0x029C, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA7__RAWNAND_DATA08                      = IOMUX_PAD(0x05E4, 0x029C, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA7__UART5_CTS_B                         = IOMUX_PAD(0x05E4, 0x029C, 2, 0x084C, 1, 0),
+	MX6SX_PAD_SD4_DATA7__ECSPI3_SS0                          = IOMUX_PAD(0x05E4, 0x029C, 3, 0x073C, 0, 0),
+	MX6SX_PAD_SD4_DATA7__LCDIF2_DATA_15                      = IOMUX_PAD(0x05E4, 0x029C, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA7__GPIO6_IO_21                         = IOMUX_PAD(0x05E4, 0x029C, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA7__USDHC4_CD_B                         = IOMUX_PAD(0x05E4, 0x029C, 6, 0x0874, 0, 0),
+	MX6SX_PAD_SD4_DATA7__TPSMP_HDATA_15                      = IOMUX_PAD(0x05E4, 0x029C, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA7__USB_OTG_PWR_WAKE                    = IOMUX_PAD(0x05E4, 0x029C, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_DATA7__SDMA_DEBUG_YIELD                    = IOMUX_PAD(0x05E4, 0x029C, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_SD4_RESET_B__USDHC4_RESET_B                    = IOMUX_PAD(0x05E8, 0x02A0, 0, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__RAWNAND_DQS                       = IOMUX_PAD(0x05E8, 0x02A0, 1, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__USDHC4_RESET                      = IOMUX_PAD(0x05E8, 0x02A0, 2, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__AUDMUX_MCLK                       = IOMUX_PAD(0x05E8, 0x02A0, 3, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__LCDIF2_RESET                      = IOMUX_PAD(0x05E8, 0x02A0, 4, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__GPIO6_IO_22                       = IOMUX_PAD(0x05E8, 0x02A0, 5, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__LCDIF2_CS                         = IOMUX_PAD(0x05E8, 0x02A0, 6, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__TPSMP_HDATA_25                    = IOMUX_PAD(0x05E8, 0x02A0, 7, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__VDEC_DEBUG_17                     = IOMUX_PAD(0x05E8, 0x02A0, 8, 0x0000, 0, 0),
+	MX6SX_PAD_SD4_RESET_B__SDMA_DEBUG_BUS_DEVICE_2           = IOMUX_PAD(0x05E8, 0x02A0, 9, 0x0000, 0, 0),
+
+	MX6SX_PAD_USB_H_DATA__USB_H_DATA                         = IOMUX_PAD(0x05EC, 0x02A4, 0, 0x0000, 0, 0),
+	MX6SX_PAD_USB_H_DATA__PWM2_OUT                           = IOMUX_PAD(0x05EC, 0x02A4, 1, 0x0000, 0, 0),
+	MX6SX_PAD_USB_H_DATA__ANATOP_24M_OUT                     = IOMUX_PAD(0x05EC, 0x02A4, 2, 0x0000, 0, 0),
+	MX6SX_PAD_USB_H_DATA__I2C4_SDA                           = IOMUX_PAD(0x05EC, 0x02A4, 3, 0x07C4, 1, 0),
+	MX6SX_PAD_USB_H_DATA__WDOG3_WDOG_B                       = IOMUX_PAD(0x05EC, 0x02A4, 4, 0x0000, 0, 0),
+	MX6SX_PAD_USB_H_DATA__GPIO7_IO_10                        = IOMUX_PAD(0x05EC, 0x02A4, 5, 0x0000, 0, 0),
+
+	MX6SX_PAD_USB_H_STROBE__USB_H_STROBE                     = IOMUX_PAD(0x05F0, 0x02A8, 0, 0x0000, 0, 0),
+	MX6SX_PAD_USB_H_STROBE__PWM1_OUT                         = IOMUX_PAD(0x05F0, 0x02A8, 1, 0x0000, 0, 0),
+	MX6SX_PAD_USB_H_STROBE__ANATOP_32K_OUT                   = IOMUX_PAD(0x05F0, 0x02A8, 2, 0x0000, 0, 0),
+	MX6SX_PAD_USB_H_STROBE__I2C4_SCL                         = IOMUX_PAD(0x05F0, 0x02A8, 3, 0x07C0, 1, 0),
+	MX6SX_PAD_USB_H_STROBE__WDOG3_WDOG_RST_B_DEB             = IOMUX_PAD(0x05F0, 0x02A8, 4, 0x0000, 0, 0),
+	MX6SX_PAD_USB_H_STROBE__GPIO7_IO_11                      = IOMUX_PAD(0x05F0, 0x02A8, 5, 0x0000, 0, 0),
+};
+#endif  /* __ASM_ARCH_MX6_MX6SX_PINS_H__ */
diff --git a/arch/arm/include/asm/arch-mx6/mx6sx_rdc.h b/arch/arm/include/asm/arch-mx6/mx6sx_rdc.h
new file mode 100644
index 0000000..addfe01
--- /dev/null
+++ b/arch/arm/include/asm/arch-mx6/mx6sx_rdc.h
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:  GPL-2.0+
+ */
+
+#ifndef __MX6SX_RDC_H__
+#define __MX6SX_RDC_H__
+
+#define RDC_SEMA_PROC_ID 2  /* The processor ID for main CPU */
+
+enum {
+	RDC_PER_PWM1 = 0,
+	RDC_PER_PWM2,
+	RDC_PER_PWM3,
+	RDC_PER_PWM4,
+	RDC_PER_CAN1,
+	RDC_PER_CAN2,
+	RDC_PER_GPT,
+	RDC_PER_GPIO1,
+	RDC_PER_GPIO2,
+	RDC_PER_GPIO3,
+	RDC_PER_GPIO4,
+	RDC_PER_GPIO5,
+	RDC_PER_GPIO6,
+	RDC_PER_GPIO7,
+	RDC_PER_KPP,
+	RDC_PER_WDOG1,
+	RDC_PER_WODG2,
+	RDC_PER_CCM,
+	RDC_PER_ANATOPDIG,
+	RDC_PER_SNVSHP,
+	RDC_PER_EPIT1,
+	RDC_PER_EPIT2,
+	RDC_PER_SRC,
+	RDC_PER_GPC,
+	RDC_PER_IOMUXC,
+	RDC_PER_IOMUXCGPR,
+	RDC_PER_CANFD1,
+	RDC_PER_SDMA,
+	RDC_PER_CANFD2,
+	RDC_PER_SEMA1,
+	RDC_PER_SEMA2,
+	RDC_PER_RDC,
+	RDC_PER_AIPSTZ1_GE1,
+	RDC_PER_AIPSTZ2_GE2,
+	RDC_PER_USBO2H_PL301,
+	RDC_PER_USBO2H_USB,
+	RDC_PER_ENET1,
+	RDC_PER_MLB25,
+	RDC_PER_USDHC1,
+	RDC_PER_USDHC2,
+	RDC_PER_USDHC3,
+	RDC_PER_USDHC4,
+	RDC_PER_I2C1,
+	RDC_PER_I2C2,
+	RDC_PER_I2C3,
+	RDC_PER_ROMCP,
+	RDC_PER_MMDC,
+	RDC_PER_ENET2,
+	RDC_PER_EIM,
+	RDC_PER_OCOTP,
+	RDC_PER_CSU,
+	RDC_PER_PERFMON1,
+	RDC_PER_PERFMON2,
+	RDC_PER_AXIMON,
+	RDC_PER_TZASC1,
+	RDC_PER_SAI1,
+	RDC_PER_AUDMUX,
+	RDC_PER_SAI2,
+	RDC_PER_QSPI1,
+	RDC_PER_QSPI2,
+	RDC_PER_UART2,
+	RDC_PER_UART3,
+	RDC_PER_UART4,
+	RDC_PER_UART5,
+	RDC_PER_I2C4,
+	RDC_PER_QOSC,
+	RDC_PER_CAAM,
+	RDC_PER_DAP,
+	RDC_PER_ADC1,
+	RDC_PER_ADC2,
+	RDC_PER_WDOG3,
+	RDC_PER_ECSPI5,
+	RDC_PER_SEMA4,
+	RDC_PER_MUPORT1,
+	RDC_PER_CANFD_CPU,
+	RDC_PER_MUPORT2,
+	RDC_PER_UART6,
+	RDC_PER_PWM5,
+	RDC_PER_PWM6,
+	RDC_PER_PWM7,
+	RDC_PER_PWM8,
+	RDC_PER_AIPSTZ3_GE0,
+	RDC_PER_AIPSTZ3_GE1,
+	RDC_PER_RESERVED1,
+	RDC_PER_SPDIF,
+	RDC_PER_ECSPI1,
+	RDC_PER_ECSPI2,
+	RDC_PER_ECSPI3,
+	RDC_PER_ECSPI4,
+	RDC_PER_RESERVED2,
+	RDC_PER_RESERVED3,
+	RDC_PER_UART1,
+	RDC_PER_ESAI,
+	RDC_PER_SSI1,
+	RDC_PER_SSI2,
+	RDC_PER_SSI3,
+	RDC_PER_ASRC,
+	RDC_PER_RESERVED4,
+	RDC_PER_SPBA_MA,
+	RDC_PER_GIS,
+	RDC_PER_DCIC1,
+	RDC_PER_DCIC2,
+	RDC_PER_CSI1,
+	RDC_PER_PXP,
+	RDC_PER_CSI2,
+	RDC_PER_LCDIF1,
+	RDC_PER_LCDIF2,
+	RDC_PER_VADC,
+	RDC_PER_VDEC,
+	RDC_PER_SPBA_DISPLAYMIX,
+};
+
+enum {
+	RDC_MA_A9_L2CACHE = 0,
+	RDC_MA_M4,
+	RDC_MA_GPU,
+	RDC_MA_CSI1,
+	RDC_MA_CSI2,
+	RDC_MA_LCDIF1,
+	RDC_MA_LCDIF2,
+	RDC_MA_PXP,
+	RDC_MA_PCIE_CTRL,
+	RDC_MA_DAP,
+	RDC_MA_CAAM,
+	RDC_MA_SDMA_PERI,
+	RDC_MA_SDMA_BURST,
+	RDC_MA_APBHDMA,
+	RDC_MA_RAWNAND,
+	RDC_MA_USDHC1,
+	RDC_MA_USDHC2,
+	RDC_MA_USDHC3,
+	RDC_MA_USDHC4,
+	RDC_MA_USB,
+	RDC_MA_MLB,
+	RDC_MA_TEST,
+	RDC_MA_ENET1_TX,
+	RDC_MA_ENET1_RX,
+	RDC_MA_ENET2_TX,
+	RDC_MA_ENET2_RX,
+	RDC_MA_SDMA,
+};
+
+#endif	/* __MX6SX_RDC_H__*/
diff --git a/arch/arm/include/asm/arch-mx6/sys_proto.h b/arch/arm/include/asm/arch-mx6/sys_proto.h
index 38851a1..cc309cd 100644
--- a/arch/arm/include/asm/arch-mx6/sys_proto.h
+++ b/arch/arm/include/asm/arch-mx6/sys_proto.h
@@ -11,7 +11,7 @@
 #include <asm/imx-common/regs-common.h>
 #include "../arch-imx/cpu.h"
 
-#define is_soc_rev(rev)	((get_cpu_rev() & 0xFF) - rev)
+#define is_soc_rev(rev)		((int)((get_cpu_rev() & 0xFF) - rev))
 u32 get_cpu_rev(void);
 
 /* returns MXC_CPU_ value */
@@ -22,6 +22,21 @@ u32 get_cpu_rev(void);
 
 const char *get_imx_type(u32 imxtype);
 unsigned imx_ddr_size(void);
+void set_wdog_reset(struct wdog_regs *wdog);
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+int check_ldo_bypass(void);
+int check_1_2G(void);
+int set_anatop_bypass(int wdog_reset_pin);
+void ldo_mode_set(int ldo_bypass);
+void prep_anatop_bypass(void);
+void finish_anatop_bypass(void);
+#endif
+
+#ifdef CONFIG_MX6SX
+int arch_auxiliary_core_up(u32 core_id, u32 boot_private_data);
+int arch_auxiliary_core_check_up(u32 core_id);
+#endif
 
 /*
  * Initializes on-chip ethernet controllers.
diff --git a/arch/arm/include/asm/arch-mxs/clock.h b/arch/arm/include/asm/arch-mxs/clock.h
index fc9d75b..8840335 100644
--- a/arch/arm/include/asm/arch-mxs/clock.h
+++ b/arch/arm/include/asm/arch-mxs/clock.h
@@ -46,7 +46,7 @@ uint32_t mxc_get_clock(enum mxc_clock clk);
 void mxs_set_ioclk(enum mxs_ioclock io, uint32_t freq);
 void mxs_set_sspclk(enum mxs_sspclock ssp, uint32_t freq, int xtal);
 void mxs_set_ssp_busclock(unsigned int bus, uint32_t freq);
-void mxs_set_lcdclk(uint32_t freq);
+void mxs_set_lcdclk(uint32_t base_addr, uint32_t freq);
 
 /* Compatibility with the FEC Ethernet driver */
 #define	imx_get_fecclk()	mxc_get_clock(MXC_AHB_CLK)
diff --git a/arch/arm/include/asm/imx-common/boot_mode.h b/arch/arm/include/asm/imx-common/boot_mode.h
index de0205c..b3b75cd 100644
--- a/arch/arm/include/asm/imx-common/boot_mode.h
+++ b/arch/arm/include/asm/imx-common/boot_mode.h
@@ -9,6 +9,26 @@
 #define MAKE_CFGVAL(cfg1, cfg2, cfg3, cfg4) \
 	((cfg4) << 24) | ((cfg3) << 16) | ((cfg2) << 8) | (cfg1)
 
+enum boot_device {
+    WEIM_NOR_BOOT,
+    ONE_NAND_BOOT,
+    PATA_BOOT,
+    SATA_BOOT,
+    I2C_BOOT,
+    SPI_NOR_BOOT,
+    SD1_BOOT,
+    SD2_BOOT,
+    SD3_BOOT,
+    SD4_BOOT,
+    MMC1_BOOT,
+    MMC2_BOOT,
+    MMC3_BOOT,
+    MMC4_BOOT,
+    NAND_BOOT,
+    UNKNOWN_BOOT,
+    BOOT_DEV_NUM = UNKNOWN_BOOT,
+};
+
 struct boot_mode {
 	const char *name;
 	unsigned cfg_val;
@@ -16,5 +36,6 @@ struct boot_mode {
 
 void add_board_boot_modes(const struct boot_mode *p);
 void boot_mode_apply(unsigned cfg_val);
+enum boot_device get_boot_device(void);
 extern const struct boot_mode soc_boot_modes[];
 #endif
diff --git a/arch/arm/include/asm/imx-common/iomux-v3.h b/arch/arm/include/asm/imx-common/iomux-v3.h
index dec11a1..4004ba4 100644
--- a/arch/arm/include/asm/imx-common/iomux-v3.h
+++ b/arch/arm/include/asm/imx-common/iomux-v3.h
@@ -3,7 +3,7 @@
  * Copyright (C) 2009 by Jan Weitzel Phytec Messtechnik GmbH,
  *			<armlinux@phytec.de>
  *
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -98,7 +98,11 @@ typedef u64 iomux_v3_cfg_t;
 
 #define PAD_CTL_ODE		(1 << 11)
 
+#ifdef CONFIG_MX6SX
+#define PAD_CTL_SPEED_LOW	(0 << 6)
+#else
 #define PAD_CTL_SPEED_LOW	(1 << 6)
+#endif
 #define PAD_CTL_SPEED_MED	(2 << 6)
 #define PAD_CTL_SPEED_HIGH	(3 << 6)
 
@@ -169,5 +173,10 @@ typedef u64 iomux_v3_cfg_t;
 void imx_iomux_v3_setup_pad(iomux_v3_cfg_t pad);
 void imx_iomux_v3_setup_multiple_pads(iomux_v3_cfg_t const *pad_list,
 				     unsigned count);
+/*
+* Set bits for general purpose registers
+*/
+void mxc_iomux_set_gpr_register(int group, int start_bit,
+					 int num_bits, int value);
 
 #endif	/* __MACH_IOMUX_V3_H__*/
diff --git a/arch/arm/include/asm/imx-common/mxc_key_defs.h b/arch/arm/include/asm/imx-common/mxc_key_defs.h
new file mode 100644
index 0000000..5a1fec7
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/mxc_key_defs.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2009-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _MXC_KEYPAD_H_
+#define _MXC_KEYPAD_H_
+
+#include <config.h>
+
+#define KEY_1                   2
+#define KEY_2                   3
+#define KEY_3                   4
+#define KEY_F1                  59
+#define KEY_UP                  103
+#define KEY_F2                  60
+
+#define KEY_4                   5
+#define KEY_5                   6
+#define KEY_6                   7
+#define KEY_LEFT                105
+#define KEY_SELECT              0x161
+#define KEY_RIGHT               106
+
+#define KEY_7                   8
+#define KEY_8                   9
+#define KEY_9                   10
+#define KEY_F3                  61
+#define KEY_DOWN                108
+#define KEY_F4                  62
+
+#define KEY_0                   11
+#define KEY_OK                  0x160
+#define KEY_ESC                 1
+#define KEY_ENTER               28
+#define KEY_MENU                139     /* Menu (show menu) */
+#define KEY_BACK                158     /* AC Back */
+
+#endif
diff --git a/arch/arm/include/asm/imx-common/rdc-sema.h b/arch/arm/include/asm/imx-common/rdc-sema.h
new file mode 100644
index 0000000..01ffab2
--- /dev/null
+++ b/arch/arm/include/asm/imx-common/rdc-sema.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:  GPL-2.0+
+ */
+
+#ifndef __RDC_SEMA_H__
+#define __RDC_SEMA_H__
+
+typedef u32 rdc_peri_cfg_t;
+typedef u32 rdc_ma_cfg_t;
+
+#define RDC_PERI_MASK 0xFF
+#define RDC_PERI_SHIFT 0
+
+#define RDC_DOMAIN_SHIFT_BASE   16
+#define RDC_DOMAIN_MASK 0xFF0000
+#define RDC_DOMAIN_SHIFT(x)   (RDC_DOMAIN_SHIFT_BASE + ((x << 1)))
+#define RDC_DOMAIN(x)	((rdc_peri_cfg_t)(0x3 << RDC_DOMAIN_SHIFT(x)))
+
+#define RDC_MASTER_SHIFT   8
+#define RDC_MASTER_MASK 0xFF00
+#define RDC_MASTER_CFG(master_id, domain_id) (rdc_ma_cfg_t)((master_id << 8) | (domain_id << RDC_DOMAIN_SHIFT_BASE))
+
+int imx_rdc_check_permission(int per_id);
+int imx_rdc_sema_lock(int per_id);
+int imx_rdc_sema_unlock(int per_id);
+int imx_rdc_setup_peri(rdc_peri_cfg_t p);
+int imx_rdc_setup_peripherals(rdc_peri_cfg_t const *peripherals_list,
+	unsigned count);
+int imx_rdc_setup_ma(rdc_ma_cfg_t p);
+int imx_rdc_setup_masters(rdc_ma_cfg_t const *masters_list,
+	unsigned count);
+
+#endif	/* __RDC_SEMA_H__*/
diff --git a/arch/arm/lib/board.c b/arch/arm/lib/board.c
index 92e85c4..e962241 100644
--- a/arch/arm/lib/board.c
+++ b/arch/arm/lib/board.c
@@ -44,6 +44,10 @@
 #include <miiphy.h>
 #endif
 
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
 ulong monitor_flash_len;
@@ -655,6 +659,10 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	board_late_init();
 #endif
 
+#ifdef CONFIG_FASTBOOT
+	fastboot_setup();
+#endif
+
 #ifdef CONFIG_BITBANGMII
 	bb_miiphy_init();
 #endif
@@ -694,6 +702,10 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	}
 #endif
 
+#ifdef CONFIG_FASTBOOT
+	check_fastboot();
+#endif
+
 	/* main_loop() can return to retry autoboot, if so just run it again. */
 	for (;;) {
 		main_loop();
diff --git a/board/axent/ag11005/Makefile b/board/axent/ag11005/Makefile
new file mode 100644
index 0000000..47dbb48
--- /dev/null
+++ b/board/axent/ag11005/Makefile
@@ -0,0 +1,14 @@
+#
+# (C) Copyright 2003-2008
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Stelian Pop <stelian@popies.net>
+# Lead Tech Design <www.leadtechdesign.com>
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y += ag11005.o
+obj-y += fpga.o
+obj-y += led.o
diff --git a/board/axent/ag11005/ag11005.c b/board/axent/ag11005/ag11005.c
new file mode 100644
index 0000000..f270730
--- /dev/null
+++ b/board/axent/ag11005/ag11005.c
@@ -0,0 +1,411 @@
+/*
+ * (C) Copyright 2011-2014
+ * Daniel Dyer, Axent Global, daniel_dyer@axent.com.au
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/at91sam9g45_matrix.h>
+#include <asm/arch/at91sam9_smc.h>
+#include <asm/arch/at91_common.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/clk.h>
+#include <atmel_mci.h>
+#include <lcd.h>
+#include <atmel_lcdc.h>
+#include <net.h>
+#include <netdev.h>
+#include <mmc.h>
+#include <i2c.h>
+#include "fpga.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Miscelaneous platform dependent initialisations
+ */
+
+#ifdef CONFIG_CMD_NAND
+static void ag11005_nand_hw_init(void)
+{
+	struct at91_smc *smc = (struct at91_smc *)ATMEL_BASE_SMC;
+	struct at91_matrix *matrix = (struct at91_matrix *)ATMEL_BASE_MATRIX;
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+	unsigned long csa;
+
+	/* Enable CS3 */
+	csa = readl(&matrix->ebicsa);
+	csa |= AT91_MATRIX_EBI_CS3A_SMC_SMARTMEDIA;
+	writel(csa, &matrix->ebicsa);
+   
+	/*
+	 * Set DDR and EBI drive strength low (apparently required to improve USB performance).
+	 */
+	csa = readl(&matrix->ebicsa);
+	csa &= ~(7 << 16);
+	writel(csa, &matrix->ebicsa);
+
+	/* Configure SMC CS3 for NAND/SmartMedia */
+	writel(AT91_SMC_SETUP_NWE(1) | AT91_SMC_SETUP_NCS_WR(0) |
+	       AT91_SMC_SETUP_NRD(1) | AT91_SMC_SETUP_NCS_RD(0),
+	       &smc->cs[3].setup);
+	writel(AT91_SMC_PULSE_NWE(4) | AT91_SMC_PULSE_NCS_WR(3) |
+	       AT91_SMC_PULSE_NRD(3) | AT91_SMC_PULSE_NCS_RD(2),
+	       &smc->cs[3].pulse);
+	writel(AT91_SMC_CYCLE_NWE(7) | AT91_SMC_CYCLE_NRD(4),
+	       &smc->cs[3].cycle);
+	writel(AT91_SMC_MODE_RM_NRD | AT91_SMC_MODE_WM_NWE |
+	       AT91_SMC_MODE_EXNW_DISABLE |
+#ifdef CONFIG_SYS_NAND_DBW_16
+	       AT91_SMC_MODE_DBW_16 |
+#else /* CONFIG_SYS_NAND_DBW_8 */
+	       AT91_SMC_MODE_DBW_8 |
+#endif
+	       AT91_SMC_MODE_TDF_CYCLE(3),
+	       &smc->cs[3].mode);
+
+	writel(1 << ATMEL_ID_PIOC, &pmc->pcer);
+
+	/* Configure RDY/BSY */
+	at91_set_gpio_input(CONFIG_SYS_NAND_READY_PIN, 1);
+
+	/* Enable NandFlash */
+	at91_set_gpio_output(CONFIG_SYS_NAND_ENABLE_PIN, 1);
+}
+#endif
+
+#ifdef CONFIG_SOFT_I2C
+static void ag11005_soft_i2c_init(void)
+{
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+
+	at91_set_pio_output(AT91_PIO_PORTA, 20, 1);		/* TWD (SDA) */
+	at91_set_pio_multi_drive(AT91_PIO_PORTA, 20, 1);
+
+	at91_set_pio_output(AT91_PIO_PORTA, 21, 1);		/* TWCK (SCL) */
+	at91_set_pio_multi_drive(AT91_PIO_PORTA, 21, 1);
+
+	/* Enable clock */
+	writel(1 << ATMEL_ID_PIOA, &pmc->pcer);
+}
+#endif
+
+#ifdef CONFIG_CMD_USB
+static void ag11005_usb_hw_init(void)
+{
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+
+	writel(1 << ATMEL_ID_PIODE, &pmc->pcer);
+}
+#endif
+
+#ifdef CONFIG_MACB
+static void ag11005_macb_hw_init(void)
+{
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+	struct at91_port *pioa = (struct at91_port *)ATMEL_BASE_PIOA;
+	
+	/* Make sure PWR_DOWN pin is high */
+	at91_set_gpio_output(AT91_PIN_PA22, 1);
+
+	/* Enable clock */
+	writel(1 << ATMEL_ID_EMAC, &pmc->pcer);
+
+	/*
+	 * Disable pull-up on:
+	 *      RXDV (PA15) => PHY normal mode (not Test mode)
+	 *      ERX0 (PA12) => PHY ADDR0
+	 *      ERX1 (PA13) => PHY ADDR1 => PHYADDR = 0x0
+	 *
+	 * PHY has internal pull-down
+	 */
+	writel(pin_to_mask(AT91_PIN_PA15) |
+	       pin_to_mask(AT91_PIN_PA12) |
+	       pin_to_mask(AT91_PIN_PA13),
+	       &pioa->pudr);
+
+	at91_phy_reset();
+
+	/* Re-enable pull-up */
+	writel(pin_to_mask(AT91_PIN_PA15) |
+	       pin_to_mask(AT91_PIN_PA12) |
+	       pin_to_mask(AT91_PIN_PA13),
+	       &pioa->puer);
+
+	/* And the pins. */
+	at91_macb_hw_init();
+}
+#endif
+
+#ifdef CONFIG_LCD
+
+vidinfo_t panel_info = {
+	vl_col:		480,
+	vl_row:		272,
+	vl_clk:		9000000,
+	vl_sync:	ATMEL_LCDC_INVLINE_INVERTED |
+			ATMEL_LCDC_INVFRAME_INVERTED,
+	vl_bpix:	5,
+	vl_tft:		1,
+	vl_hsync_len:	41,
+	vl_left_margin:	2,
+	vl_right_margin:2,
+	vl_vsync_len:	10,
+	vl_upper_margin:12,
+	vl_lower_margin:2,
+	mmio:		ATMEL_BASE_LCDC,
+};
+
+#ifdef CONFIG_GENERIC_ATMEL_MCI
+int board_mmc_init(bd_t *bd)
+{
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+
+    /* Enable clock */
+    writel(1 << ATMEL_ID_MCI0, &pmc->pcer);
+    at91_mci_hw_init();
+    
+    /* This calls the atmel_mci_init in gen_atmel_mci.c */
+    return atmel_mci_init((void *)ATMEL_BASE_MCI0);
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+    return at91_get_gpio_value(CONFIG_SYS_MMC_CD_PIN) ? 1 : 0;
+}
+#endif
+
+void lcd_enable(void)
+{
+	at91_set_A_periph(AT91_PIN_PE6, 1);	/* power up */
+}
+
+void lcd_disable(void)
+{
+	at91_set_A_periph(AT91_PIN_PE6, 0);	/* power down */
+}
+
+static void ag11005_lcd_hw_init(void)
+{
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+
+	at91_set_gpio_output(AT91_PIN_PE0, 0); /* LCDPWR */
+
+	at91_set_A_periph(AT91_PIN_PE2, 0);	/* LCDCC */
+	at91_set_A_periph(AT91_PIN_PE3, 0);	/* LCDVSYNC */
+	at91_set_A_periph(AT91_PIN_PE4, 0);	/* LCDHSYNC */
+	at91_set_A_periph(AT91_PIN_PE5, 0);	/* LCDDOTCK */
+	at91_set_A_periph(AT91_PIN_PE6, 0);	/* LCDDEN */
+	at91_set_A_periph(AT91_PIN_PE7, 0);	/* LCDD0 */
+	at91_set_A_periph(AT91_PIN_PE8, 0);	/* LCDD1 */
+	at91_set_A_periph(AT91_PIN_PE9, 0);	/* LCDD2 */
+	at91_set_A_periph(AT91_PIN_PE10, 0);	/* LCDD3 */
+	at91_set_A_periph(AT91_PIN_PE11, 0);	/* LCDD4 */
+	at91_set_A_periph(AT91_PIN_PE12, 0);	/* LCDD5 */
+	at91_set_A_periph(AT91_PIN_PE13, 0);	/* LCDD6 */
+	at91_set_A_periph(AT91_PIN_PE14, 0);	/* LCDD7 */
+	at91_set_A_periph(AT91_PIN_PE15, 0);	/* LCDD8 */
+	at91_set_A_periph(AT91_PIN_PE16, 0);	/* LCDD9 */
+	at91_set_A_periph(AT91_PIN_PE17, 0);	/* LCDD10 */
+	at91_set_A_periph(AT91_PIN_PE18, 0);	/* LCDD11 */
+	at91_set_A_periph(AT91_PIN_PE19, 0);	/* LCDD12 */
+	at91_set_A_periph(AT91_PIN_PE20, 0);	/* LCDD13 */
+	at91_set_A_periph(AT91_PIN_PE21, 0);	/* LCDD14 */
+	at91_set_A_periph(AT91_PIN_PE22, 0);	/* LCDD15 */
+	at91_set_A_periph(AT91_PIN_PE23, 0);	/* LCDD16 */
+	at91_set_A_periph(AT91_PIN_PE24, 0);	/* LCDD17 */
+	at91_set_A_periph(AT91_PIN_PE25, 0);	/* LCDD18 */
+	at91_set_A_periph(AT91_PIN_PE26, 0);	/* LCDD19 */
+	at91_set_A_periph(AT91_PIN_PE27, 0);	/* LCDD20 */
+	at91_set_A_periph(AT91_PIN_PE28, 0);	/* LCDD21 */
+	at91_set_A_periph(AT91_PIN_PE29, 0);	/* LCDD22 */
+	at91_set_A_periph(AT91_PIN_PE30, 0);	/* LCDD23 */
+	
+	at91_set_gpio_output(AT91_PIN_PE31, 1);
+	
+	udelay(5000);
+	
+	/* Enable clock */
+	writel(1 << ATMEL_ID_PIODE, &pmc->pcer);
+
+	writel(1 << ATMEL_ID_LCDC, &pmc->pcer);
+	
+	udelay(5000);
+	
+	at91_set_A_periph(AT91_PIN_PE0, 0); /* LCDPWR */
+
+	gd->fb_base = CONFIG_AT91SAM9G45_LCD_BASE;
+}
+
+#ifdef CONFIG_LCD_INFO
+#include <nand.h>
+#include <version.h>
+
+void lcd_show_board_info(void)
+{
+	ulong dram_size, nand_size;
+	int i;
+	char temp[32];
+
+	lcd_printf ("%s\n", U_BOOT_VERSION);
+	lcd_printf ("(C) 2014 Axent Global\n");
+	lcd_printf ("info@axent.com.au\n");
+	lcd_printf ("%s CPU at %s MHz\n",
+		ATMEL_CPU_NAME,
+		strmhz(temp, get_cpu_clk_rate()));
+
+	dram_size = 0;
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		dram_size += gd->bd->bi_dram[i].size;
+	nand_size = 0;
+	for (i = 0; i < CONFIG_SYS_MAX_NAND_DEVICE; i++)
+		nand_size += nand_info[i].size;
+	lcd_printf ("  %ld MB SDRAM, %ld MB NAND\n",
+		dram_size >> 20,
+		nand_size >> 20 );
+}
+#endif /* CONFIG_LCD_INFO */
+#endif
+
+int board_early_init_f(void)
+{
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+
+	/* Enable clocks for all PIOs */
+	writel((1 << ATMEL_ID_PIOA) |
+	    (1 << ATMEL_ID_PIOB) |
+	    (1 << ATMEL_ID_PIOC) |
+		(1 << ATMEL_ID_PIODE),
+		&pmc->pcer);
+
+	at91_seriald_hw_init();
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Enable Ctrlc */
+	console_init_f();
+
+	/* arch number of AG11005-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_AG11005;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_SYS_SDRAM_BASE + 0x100;
+
+#ifdef CONFIG_CMD_NAND
+	ag11005_nand_hw_init();
+#endif
+#ifdef CONFIG_CMD_USB
+	ag11005_usb_hw_init();
+#endif
+#ifdef CONFIG_HAS_DATAFLASH
+	at91_spi0_hw_init(1 << 0);
+#endif
+#ifdef CONFIG_ATMEL_SPI
+	at91_spi1_hw_init(0);
+#endif
+
+#ifdef CONFIG_MACB
+	ag11005_macb_hw_init();
+#endif
+
+#ifdef CONFIG_SOFT_I2C
+	ag11005_soft_i2c_init();
+#endif
+
+#ifdef CONFIG_LCD
+	ag11005_lcd_hw_init();
+#endif
+
+#ifdef CONFIG_FPGA
+	at91_set_pio_output(AT91_PIO_PORTD, 28, 1);		/* PROGRAM_B */
+
+	at91_set_pio_output(AT91_PIO_PORTD, 29, 1);		/* INIT_B */
+	at91_set_pio_multi_drive(AT91_PIO_PORTD, 29, 1);
+	
+	at91_set_pio_output(AT91_PIO_PORTD, 30, 1);		/* DONE */
+	at91_set_pio_multi_drive(AT91_PIO_PORTD, 30, 1);
+
+    ag11005_fpga_init();
+#endif
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->ram_size = get_ram_size((void *) CONFIG_SYS_SDRAM_BASE,
+				    CONFIG_SYS_SDRAM_SIZE);
+	return 0;
+}
+
+#ifdef CONFIG_RESET_PHY_R
+void reset_phy(void)
+{
+}
+#endif
+
+int board_eth_init(bd_t *bis)
+{
+	int i;
+	ulong reg;
+	char tmp[64];
+	uchar s[6];
+	const uchar hex_array[16] = {'0', '1', '2', '3', '4', '5', '6', '7',
+								 '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
+	int rc = 0;
+
+	// Get ethernet address from EEPROM if it hasn't been done already.
+	i = getenv_f("eth_good", tmp, sizeof (tmp));
+
+	if(!(i > 0)) {
+		i2c_read(0x50, 0xfa, 1, s, 6);
+
+		setenv("eth_good", "1");
+
+		i = 0;
+		for(reg = 0; reg < 6; ++reg) {
+			tmp[i++] = hex_array[(s[reg]>>4)&0x0f];
+			tmp[i++] = hex_array[s[reg]&0x0f];
+			tmp[i++] = ':';
+		}
+		tmp[17] = '\0';
+
+		setenv("ethaddr", tmp);
+
+		saveenv();
+	}
+
+#ifdef CONFIG_MACB
+	rc = macb_eth_initialize(0, (void *)ATMEL_BASE_EMAC, 0x00);
+#endif
+	return rc;
+}
+
+/* SPI chip select control */
+#ifdef CONFIG_ATMEL_SPI
+#include <spi.h>
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return 1;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+    // Dummy function; the FPGA has its very own SPI port with no chip select, so just ignore requests to activate it
+
+	return;
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+    // Dummy function; the FPGA has its very own SPI port with no chip select, so just ignore requests to activate it
+
+	return;
+}
+#endif /* CONFIG_ATMEL_SPI */
diff --git a/board/axent/ag11005/fpga.c b/board/axent/ag11005/fpga.c
new file mode 100644
index 0000000..68cd435
--- /dev/null
+++ b/board/axent/ag11005/fpga.c
@@ -0,0 +1,158 @@
+/*
+ * (C) Copyright 2011-2014
+ * Daniel Dyer, Axent Global, daniel_dyer@axent.com.au
+ *
+ * based on the files by
+ * Heiko Schocher, DENX Software Engineering, hs@denx.de
+ * and
+ * Rich Ireland, Enterasys Networks, rireland@enterasys.com.
+ * Keith Outwater, keith_outwater@mvis.com.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ */
+
+/* Xilinx FPGA configuration support for the AG11005 board */
+
+#include <common.h>
+#include <spartan6.h>
+#include <command.h>
+#include <asm/arch/at91sam9g45.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/at91_pio.h>
+#include <spi.h>
+
+#include "fpga.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static struct spi_slave *slave;
+
+Xilinx_Spartan6_Slave_Serial_fns ag11005_fpga_fns = {
+	fpga_pre_config_fn,
+	fpga_pgm_fn,
+	0,
+	fpga_init_fn,
+	fpga_done_fn,
+	0,
+	fpga_post_config_fn,
+	fpga_fastwr_fn
+};
+
+Xilinx_desc fpga[CONFIG_FPGA_COUNT] = {
+	XILINX_XC6SLX45_DESC(
+		slave_serial,
+		(void *)&ag11005_fpga_fns,
+		0)
+};
+
+/* Set the FPGA's PROGRAM_B line to the specified level */
+int fpga_pgm_fn(int assert, int flush, int cookie)
+{
+	debug("%s:%d: FPGA PROGRAM ",
+	      __FUNCTION__, __LINE__);
+
+	if (assert) {
+		at91_set_pio_value(AT91_PIO_PORTD, 28, 0);
+		debug("asserted\n");
+	} else {
+		at91_set_pio_value(AT91_PIO_PORTD, 28, 1);
+		debug("deasserted\n");
+	}
+	return assert;
+}
+
+/*
+ * Test the state of the active-low FPGA INIT line.  Return 1 on INIT
+ * asserted (low).
+ */
+int fpga_init_fn(int cookie)
+{
+	if (at91_get_pio_value(AT91_PIO_PORTD, 29))
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * Test the state of the active-high FPGA DONE pin
+ */
+int fpga_done_fn(int cookie)
+{
+	if (at91_get_pio_value(AT91_PIO_PORTD, 30))
+		return 1;
+	else
+		return 0;
+}
+
+/*
+ * FPGA pre-configuration function. Just make sure that
+ * FPGA reset is asserted to keep the FPGA from starting up after
+ * configuration.
+ */
+int fpga_pre_config_fn(int cookie)
+{
+	debug("%s:%d: FPGA pre-configuration\n", __FUNCTION__, __LINE__);
+
+	/* release INIT_B */
+	at91_set_pio_value(AT91_PIO_PORTD, 29, 1);
+	/* release DONE */
+	at91_set_pio_value(AT91_PIO_PORTD, 30, 1);
+	return 0;
+}
+
+/*
+ * FPGA post configuration function. Blip the FPGA reset line and then see if
+ * the FPGA appears to be running.
+ */
+int fpga_post_config_fn(int cookie)
+{
+	int rc=0;
+
+	debug("%s:%d: FPGA post configuration\n", __FUNCTION__, __LINE__);
+
+    // Here is where we should do some I/O on the FPGA bus to see if it's working
+
+	return rc;
+}
+
+int fpga_fastwr_fn(void *buf, size_t len, int flush, int cookie)
+{
+	int ret;
+
+	slave = spi_setup_slave(1, 1, 2000000, SPI_MODE_0);
+	if(!slave)
+	{
+		debug("%s:%d: Unable to initialise SPI slave\n", __FUNCTION__, __LINE__);
+		return -1;
+	}
+	
+	spi_claim_bus(slave);
+	
+	ret = spi_xfer(slave, len*8, buf, 0, SPI_XFER_BEGIN | SPI_XFER_END);
+	
+    if (ret == -1)
+    {
+    	debug("%s:%d: Write failed\n", __FUNCTION__, __LINE__);
+    	spi_release_bus(slave);
+        return FPGA_FAIL;
+    }
+    else
+    	debug("%s:%d: Write sucessful\n", __FUNCTION__, __LINE__);
+    
+    spi_release_bus(slave);
+	
+	return FPGA_SUCCESS;
+}
+
+/* Initialize the fpga.  Return 1 on success, 0 on failure. */
+int ag11005_fpga_init(void)
+{
+	debug("%s:%d: Initialize FPGA interface\n", __FUNCTION__, __LINE__);
+	fpga_init();
+
+	debug("%s:%d: Adding fpga 0\n", __FUNCTION__, __LINE__);
+	fpga_add(fpga_xilinx, &fpga[0]);
+
+	return 0;
+}
diff --git a/board/axent/ag11005/fpga.h b/board/axent/ag11005/fpga.h
new file mode 100644
index 0000000..4aeb60b
--- /dev/null
+++ b/board/axent/ag11005/fpga.h
@@ -0,0 +1,19 @@
+/*
+ * (C) Copyright 2011-2014
+ * Daniel Dyer, Axent Global, daniel_dyer@axent.com.au
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+extern int ag11005_fpga_init(void);
+
+extern int fpga_pgm_fn(int assert, int flush, int cookie);
+extern int fpga_init_fn(int cookie);
+extern int fpga_done_fn(int cookie);
+extern int fpga_pre_config_fn(int cookie);
+extern int fpga_post_config_fn(int cookie);
+extern int fpga_fastwr_fn(void *buf, size_t len, int flush, int cookie);
+
diff --git a/board/axent/ag11005/led.c b/board/axent/ag11005/led.c
new file mode 100644
index 0000000..fe98723
--- /dev/null
+++ b/board/axent/ag11005/led.c
@@ -0,0 +1,27 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian@popies.net>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/at91sam9g45.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/gpio.h>
+
+void coloured_LED_init(void)
+{
+	struct at91_pmc *pmc = (struct at91_pmc *)ATMEL_BASE_PMC;
+
+	/* Enable clock */
+	writel(1 << ATMEL_ID_PIODE, &pmc->pcer);
+
+	at91_set_gpio_output(CONFIG_RED_LED, 1);
+	at91_set_gpio_output(CONFIG_GREEN_LED, 1);
+
+	at91_set_gpio_value(CONFIG_RED_LED, 0);
+	at91_set_gpio_value(CONFIG_GREEN_LED, 1);
+}
diff --git a/board/axent/ag13008/1066mhz_4x256mx16.cfg b/board/axent/ag13008/1066mhz_4x256mx16.cfg
new file mode 100644
index 0000000..8b58622
--- /dev/null
+++ b/board/axent/ag13008/1066mhz_4x256mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x898E79A5
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x008E1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
+DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x09408030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x43200330
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x031C030C
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x43340344
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x03200268
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x362C2226
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x2E262638
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x34343E36
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x442C423C
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001F001F
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000000
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/axent/ag13008/1066mhz_4x64mx16.cfg b/board/axent/ag13008/1066mhz_4x64mx16.cfg
new file mode 100644
index 0000000..08596e5
--- /dev/null
+++ b/board/axent/ag13008/1066mhz_4x64mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00020036
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x3A3F79A5
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xDB538F64
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x003F1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x09444040
+DATA 4, MX6_MMDC_P0_MDPDC, 0x00025576
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000017
+DATA 4, MX6_MMDC_P0_MDCTL, 0x821A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04088032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x09408030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x43200330
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x031C030C
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x43340344
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x03200268
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x362C2226
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x2E262638
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x34343E36
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x442C423C
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001F001F
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000000
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/axent/ag13008/800mhz_4x256mx16.cfg b/board/axent/ag13008/800mhz_4x256mx16.cfg
new file mode 100644
index 0000000..5829140
--- /dev/null
+++ b/board/axent/ag13008/800mhz_4x256mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x696C5323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x006C1023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000047
+DATA 4, MX6_MMDC_P0_MDCTL, 0x841A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00007800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x4234023C
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x023C0230
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42400244
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02300218
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x3E363638
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x3A343640
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x3A3C403C
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x42344442
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x001F001F
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x001F001F
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x001F001F
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/axent/ag13008/800mhz_4x64mx16.cfg b/board/axent/ag13008/800mhz_4x64mx16.cfg
new file mode 100644
index 0000000..e35d3d9
--- /dev/null
+++ b/board/axent/ag13008/800mhz_4x64mx16.cfg
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002002D
+DATA 4, MX6_MMDC_P0_MDCFG0, 0x40435323
+DATA 4, MX6_MMDC_P0_MDCFG1, 0xB66E8D63
+DATA 4, MX6_MMDC_P0_MDCFG2, 0x01FF00DB
+DATA 4, MX6_MMDC_P0_MDRWD, 0x000026D2
+DATA 4, MX6_MMDC_P0_MDOR, 0x00431023
+DATA 4, MX6_MMDC_P0_MDOTC, 0x00333030
+DATA 4, MX6_MMDC_P0_MDPDC, 0x0002556D
+DATA 4, MX6_MMDC_P0_MDASP, 0x00000017
+DATA 4, MX6_MMDC_P0_MDCTL, 0x821A0000
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008032
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008033
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00048031
+DATA 4, MX6_MMDC_P0_MDSCR, 0x13208030
+DATA 4, MX6_MMDC_P0_MDSCR, 0x04008040
+DATA 4, MX6_MMDC_P0_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P1_MPZQHWCTRL, 0xA1390003
+DATA 4, MX6_MMDC_P0_MDREF, 0x00005800
+DATA 4, MX6_MMDC_P0_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P1_MPODTCTRL, 0x00022227
+DATA 4, MX6_MMDC_P0_MPDGCTRL0, 0x42440254
+DATA 4, MX6_MMDC_P0_MPDGCTRL1, 0x024C0240
+DATA 4, MX6_MMDC_P1_MPDGCTRL0, 0x42500254
+DATA 4, MX6_MMDC_P1_MPDGCTRL1, 0x02480234
+DATA 4, MX6_MMDC_P0_MPRDDLCTL, 0x3A323036
+DATA 4, MX6_MMDC_P1_MPRDDLCTL, 0x3634323E
+DATA 4, MX6_MMDC_P0_MPWRDLCTL, 0x363A403C
+DATA 4, MX6_MMDC_P1_MPWRDLCTL, 0x4436403E
+DATA 4, MX6_MMDC_P0_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P0_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P1_MPWLDECTRL0, 0x0040003C
+DATA 4, MX6_MMDC_P1_MPWLDECTRL1, 0x0032003E
+DATA 4, MX6_MMDC_P0_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P1_MPMUR0, 0x00000800
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00000000
+DATA 4, MX6_MMDC_P0_MAPSR, 0x00011006
diff --git a/board/axent/ag13008/Makefile b/board/axent/ag13008/Makefile
new file mode 100644
index 0000000..93640f6
--- /dev/null
+++ b/board/axent/ag13008/Makefile
@@ -0,0 +1,9 @@
+#
+# Copyright (C) 2014 Axent Global
+#
+# (C) Copyright 2011 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y	:= ag13008.o
diff --git a/board/axent/ag13008/ag13008.c b/board/axent/ag13008/ag13008.c
new file mode 100644
index 0000000..874ac7a
--- /dev/null
+++ b/board/axent/ag13008/ag13008.c
@@ -0,0 +1,747 @@
+/*
+ * Copyright (C) 2014 Axent Global
+ * Daniel Dyer <daniel_dyer@axent.com.au>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <asm/io.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/clock.h>
+#include <asm/errno.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/mxc_i2c.h>
+#include <asm/imx-common/sata.h>
+#include <asm/imx-common/boot_mode.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <micrel.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <usb.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+	
+#define BUTTON_PAD_CTRL (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define I2C_PAD_CTRL	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+	
+#define WEAK_PULLUP	(PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_SRE_SLOW)
+
+#define WEAK_PULLDOWN	(PAD_CTL_PUS_100K_DOWN |		\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_HYS | PAD_CTL_SRE_SLOW)
+
+#define OUTPUT_40OHM (PAD_CTL_SPEED_MED|PAD_CTL_DSE_40ohm)
+
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+int dram_init(void)
+{
+	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
+
+	return 0;
+}
+
+iomux_v3_cfg_t const uart1_pads[] = {
+	MX6_PAD_SD3_DAT6__UART1_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6_PAD_SD3_DAT7__UART1_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const i2c0_pads[] = {
+	MX6_PAD_GPIO_7__GPIO1_IO07 | PC,
+	MX6_PAD_GPIO_8__GPIO1_IO08 | PC,
+};
+
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_EIM_EB2__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_EIM_EB2__GPIO2_IO30 | PC,
+		.gp = IMX_GPIO_NR(2, 30)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_EIM_D16__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_EIM_D16__GPIO3_IO16 | PC,
+		.gp = IMX_GPIO_NR(3, 16)
+	}
+};
+
+iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6_PAD_SD1_CLK__SD1_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__SD1_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT0__SD1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT1__SD1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT2__SD1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT3__SD1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_GPIO_1__GPIO1_IO01  | MUX_PAD_CTRL(NO_PAD_CTRL), /* CD */
+};
+
+iomux_v3_cfg_t const enet_pads1[] = {
+	MX6_PAD_ENET_MDIO__ENET_MDIO		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_MDC__ENET_MDC		| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TXC__RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD0__RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD1__RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD2__RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TD3__RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_TX_CTL__RGMII_TX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_ENET_REF_CLK__ENET_TX_CLK	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	/* pin 35 - 1 (PHY_AD2) on reset */
+	MX6_PAD_RGMII_RXC__GPIO6_IO30		| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* pin 32 - 1 - (MODE0) all */
+	MX6_PAD_RGMII_RD0__GPIO6_IO25		| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* pin 31 - 1 - (MODE1) all */
+	MX6_PAD_RGMII_RD1__GPIO6_IO27		| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* pin 28 - 1 - (MODE2) all */
+	MX6_PAD_RGMII_RD2__GPIO6_IO28		| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* pin 27 - 1 - (MODE3) all */
+	MX6_PAD_RGMII_RD3__GPIO6_IO29		| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* pin 33 - 1 - (CLK125_EN) 125Mhz clockout enabled */
+	MX6_PAD_RGMII_RX_CTL__GPIO6_IO24	| MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* pin 42 PHY nRST */
+	MX6_PAD_ENET_RX_ER__GPIO1_IO24		| MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const enet_pads2[] = {
+	MX6_PAD_RGMII_RXC__RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD0__RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD1__RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const button_pads[] = {
+	/* Reset button */
+	MX6_PAD_GPIO_19__GPIO4_IO05		| MUX_PAD_CTRL(BUTTON_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const misc_pads[] = {
+	/* PCIe PERST */
+	MX6_PAD_GPIO_2__GPIO1_IO02		| MUX_PAD_CTRL(OUTPUT_40OHM),
+};
+
+iomux_v3_cfg_t const usb_pads[] = {
+	/* USB hub RESET# signal */
+	MX6_PAD_KEY_COL4__GPIO4_IO14	| MUX_PAD_CTRL(WEAK_PULLUP),
+};
+
+#ifdef CONFIG_SYS_I2C
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0 ;
+	i2c_set_bus_num(CONFIG_SYS_I2C_EEPROM_BUS_NUM);
+	if (!i2c_probe(0x8)) {
+		if (i2c_read(0x8, 0, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(0x8, 3, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE100! deviceid=%x,revid=%x\n", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/* enable LICELL charger */
+		value = 0xd;
+		if (i2c_write(0x8, 0x1a, 1, &value, 1)) {
+		    printf("LICELL enable error!\n");
+		    return -1;
+		}
+		
+		/* set SWBST to APS mode for stability */
+		value = 0x6c;
+		if (i2c_write(0x8, 0x66, 1, &value, 1)) {
+		    printf("Set SWBST1CTL error!\n");
+		    return -1;
+		}
+		
+		/* set SW1AB staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x21, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x21, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x24, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x24, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x2f, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x2f, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x32, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x32, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+
+	/* swith to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		/* decrease VDDARM to 1.1V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x20;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.3V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x28;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		is_400M = set_anatop_bypass(0);
+
+		/*
+		 * MX6SL: VDDARM:1.175V@800M; VDDSOC:1.175V@800M
+		 *        VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		if (is_400M)
+			value |= 0x1b;
+		else
+			value |= 0x23;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		/* decrease VDDSOC to 1.175V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x23;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+static void setup_iomux_enet(void)
+{
+	imx_iomux_v3_setup_multiple_pads(enet_pads1, ARRAY_SIZE(enet_pads1));
+	gpio_direction_output(IMX_GPIO_NR(1, 24), 0); /* PHY reset */
+	gpio_direction_output(IMX_GPIO_NR(6, 30), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 25), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 27), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 28), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 29), 1);
+	gpio_direction_output(IMX_GPIO_NR(6, 24), 1);
+
+	/* Need delay 10ms according to KSZ9021 spec */
+	udelay(1000 * 10);
+	gpio_set_value(IMX_GPIO_NR(1, 24), 1); /* PHY reset */
+
+	imx_iomux_v3_setup_multiple_pads(enet_pads2, ARRAY_SIZE(enet_pads2));
+	udelay(1000);    /* Wait 1ms before using mii interface */
+}
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+int board_ehci_hcd_init(int port)
+{
+	imx_iomux_v3_setup_multiple_pads(usb_pads, ARRAY_SIZE(usb_pads));
+
+	/* Reset USB hub */
+	gpio_direction_output(IMX_GPIO_NR(4, 14), 0);
+	mdelay(2);
+	gpio_set_value(IMX_GPIO_NR(4, 14), 1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[1] = {
+	{USDHC1_BASE_ADDR}
+};
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret;
+
+	if (cfg->esdhc_base == USDHC1_BASE_ADDR) {
+		gpio_direction_input(IMX_GPIO_NR(1, 1));
+		ret = !gpio_get_value(IMX_GPIO_NR(1, 1));
+	} else /* Don't have the CD GPIO pin on board */
+		ret = 1;
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	s32 status = 0;
+	u32 index = 0;
+
+	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+	
+	usdhc_cfg[0].max_bus_width = 4;
+
+	for (index = 0; index < CONFIG_SYS_FSL_USDHC_NUM; ++index) {
+		switch (index) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) then supported by the board (%d)\n",
+				index + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return status;
+		}
+
+		status |= fsl_esdhc_initialize(bis, &usdhc_cfg[index]);
+	}
+
+	return status;
+}
+#endif
+
+#ifdef CONFIG_MXC_SPI
+#ifdef CONFIG_AG13008A
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	/* SS1 */
+	MX6_PAD_KEY_ROW1__GPIO4_IO09	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_ROW0__ECSPI1_MOSI	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_COL1__ECSPI1_MISO	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_KEY_COL0__ECSPI1_SCLK	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+};
+
+void setup_spi(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+}
+#else
+iomux_v3_cfg_t const ecspi4_pads[] = {
+	MX6_PAD_EIM_D20__GPIO3_IO20		| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D28__ECSPI4_MOSI	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D22__ECSPI4_MISO	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D21__ECSPI4_SCLK	| MUX_PAD_CTRL(SPI_PAD_CTRL),
+};
+
+void setup_spi(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi4_pads,
+					 ARRAY_SIZE(ecspi4_pads));
+}
+#endif
+#endif
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* min rx data delay */
+	ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_RX_DATA_SKEW, 0x0);
+	/* min tx data delay */
+	ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_TX_DATA_SKEW, 0x0);
+	/* max rx/tx clock delay, min rx/tx control */
+	ksz9021_phy_extended_write(phydev,
+			MII_KSZ9021_EXT_RGMII_CLOCK_SKEW, 0xf0f0);
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	uint32_t base = IMX_FEC_BASE;
+	struct mii_dev *bus = NULL;
+	struct phy_device *phydev = NULL;
+	int ret;
+	uchar enetaddr[6];
+
+	// Get ethernet address from EEPROM if it hasn't been done already.
+	if (!eth_getenv_enetaddr("ethaddr", enetaddr)) {
+		i2c_set_bus_num(CONFIG_SYS_I2C_EEPROM_BUS_NUM);
+		i2c_read(0x50, 0xfa, 1, enetaddr, 6);
+
+		if (is_valid_ether_addr(enetaddr))
+			eth_setenv_enetaddr("ethaddr", enetaddr);
+	}
+
+	setup_iomux_enet();
+
+#ifdef CONFIG_FEC_MXC
+	bus = fec_get_miibus(base, -1);
+	if (!bus)
+		return 0;
+	/* scan phy */
+	phydev = phy_find_by_mask(bus, 0xff, PHY_INTERFACE_MODE_RGMII);
+	if (!phydev) {
+		free(bus);
+		return 0;
+	}
+	printf("using phy at %d\n", phydev->addr);
+	ret  = fec_probe(bis, -1, base, bus, phydev);
+	if (ret) {
+		printf("FEC MXC: %s:failed\n", __func__);
+		free(phydev);
+		free(bus);
+	}
+#endif
+	return 0;
+}
+
+static void setup_buttons(void)
+{
+	imx_iomux_v3_setup_multiple_pads(button_pads,
+					 ARRAY_SIZE(button_pads));
+}
+
+#if defined(CONFIG_VIDEO_IPUV3)
+struct display_info_t {
+	int	bus;
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev);
+	struct	fb_videomode mode;
+};
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	imx_enable_hdmi_phy();
+}
+
+static int detect_i2c(struct display_info_t const *dev)
+{
+	return ((0 == i2c_set_bus_num(dev->bus))
+		&&
+		(0 == i2c_probe(dev->addr)));
+}
+
+static struct display_info_t const displays[] = {{
+	.bus    = 1,
+	.addr   = 0x50,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect = detect_i2c,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 24,
+		.right_margin   = 160,
+		.upper_margin   = 3,
+		.lower_margin   = 29,
+		.hsync_len      = 136,
+		.vsync_len      = 6,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			struct display_info_t const *dev = displays+i;
+			if (dev->detect(dev)) {
+				panel = dev->mode.name;
+				printf("auto-detected panel %s\n", panel);
+				break;
+			}
+		}
+		if (!panel) {
+			panel = displays[0].mode.name;
+			printf("No panel detected: default to %s\n", panel);
+			i = 0;
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = ipuv3_fb_init(&displays[i].mode, 0,
+				    displays[i].pixfmt);
+		if (!ret) {
+			displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else {
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+		}
+	} else {
+		printf("unsupported panel %s\n", panel);
+		ret = -EINVAL;
+	}
+	return (0 != ret);
+}
+
+#ifdef CONFIG_PCI
+int imx6_pcie_toggle_reset(void) {
+    gpio_set_value(IMX_GPIO_NR(1, 2), 0);
+	mdelay(20);
+    gpio_direction_output(IMX_GPIO_NR(1, 2), 1);
+	mdelay(100);
+	gpio_set_value(IMX_GPIO_NR(1, 2), 0);
+	mdelay(20);
+
+	return 0;
+}
+#endif
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB0, LDB1, IPU,IPU DI0 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |=  MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* set LDB0, LDB1 clk select to 011/011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK
+		 | MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET)
+	      | (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0
+		<< MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_BGREF_RRMODE_EXTERNAL_RES
+	     | IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW
+	     | IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT
+	     | IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG
+	     | IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT
+	     | IOMUXC_GPR2_LVDS_CH0_MODE_DISABLED
+	     | IOMUXC_GPR2_LVDS_CH1_MODE_ENABLED_DI0;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg = (reg & ~(IOMUXC_GPR3_LVDS1_MUX_CTL_MASK
+			| IOMUXC_GPR3_HDMI_MUX_CTL_MASK))
+	    | (IOMUXC_GPR3_MUX_SRC_IPU1_DI0
+	       << IOMUXC_GPR3_LVDS1_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	setup_buttons();
+    imx_iomux_v3_setup_multiple_pads(i2c0_pads, ARRAY_SIZE(i2c0_pads));
+    setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+	return 0;
+}
+
+int board_init(void)
+{
+    imx_iomux_v3_setup_multiple_pads(misc_pads, ARRAY_SIZE(misc_pads));
+
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_MXC_SPI
+	setup_spi();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
+	return 0;
+}
+
+static char const *board_type = "uninitialized";
+
+int checkboard(void)
+{
+	puts("Board: Axent AG13008\n");
+	board_type = "ag13008";
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	int ret, cpurev = get_cpu_rev();
+	setenv("cpu",get_imx_type((cpurev & 0xFF000) >> 12));
+	setenv("board",board_type);
+
+#if defined(CONFIG_CMD_USB) && defined(CONFIG_USB_KEYBOARD)
+	usb_stop();
+	if (usb_init() >= 0) {
+		drv_usb_kbd_init();
+	}
+#endif
+
+#ifdef CONFIG_SYS_I2C
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+	return 0;
+}
+
+
diff --git a/board/axent/ag13008/ag13008a.cfg b/board/axent/ag13008/ag13008a.cfg
new file mode 100644
index 0000000..5c7c6e9
--- /dev/null
+++ b/board/axent/ag13008/ag13008a.cfg
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Axent Global
+ * Daniel Dyer <daniel_dyer@axent.com.au>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+IMAGE_VERSION 2
+
+BOOT_FROM sd
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#include "ddr-setup.cfg"
+#include "1066mhz_4x64mx16.cfg"
+#include "clocks.cfg"
diff --git a/board/axent/ag13008/ag13008b.cfg b/board/axent/ag13008/ag13008b.cfg
new file mode 100644
index 0000000..6c27208
--- /dev/null
+++ b/board/axent/ag13008/ag13008b.cfg
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Axent Global
+ * Daniel Dyer <daniel_dyer@axent.com.au>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+IMAGE_VERSION 2
+
+BOOT_FROM spi
+
+#define __ASSEMBLY__
+#include <config.h>
+#include "asm/arch/mx6-ddr.h"
+#include "asm/arch/iomux.h"
+#include "asm/arch/crm_regs.h"
+
+#include "ddr-setup.cfg"
+#include "1066mhz_4x256mx16.cfg"
+#include "clocks.cfg"
diff --git a/board/axent/ag13008/clocks.cfg b/board/axent/ag13008/clocks.cfg
new file mode 100644
index 0000000..30ff759
--- /dev/null
+++ b/board/axent/ag13008/clocks.cfg
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/* set the default clock gate to save power */
+DATA 4, CCM_CCGR0, 0x00C03F3F
+DATA 4, CCM_CCGR1, 0x0030FCC3
+DATA 4, CCM_CCGR2, 0x0FFFC000
+DATA 4, CCM_CCGR3, 0x3FF00000
+DATA 4, CCM_CCGR4, 0x00FFF300
+DATA 4, CCM_CCGR5, 0x0F0000C3
+DATA 4, CCM_CCGR6, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, MX6_IOMUXC_GPR4, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, MX6_IOMUXC_GPR6, 0x007F007F
+DATA 4, MX6_IOMUXC_GPR7, 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4, CCM_CCOSR, 0x000000fb
diff --git a/board/axent/ag13008/ddr-setup.cfg b/board/axent/ag13008/ddr-setup.cfg
new file mode 100644
index 0000000..0aa30b7
--- /dev/null
+++ b/board/axent/ag13008/ddr-setup.cfg
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2013 Boundary Devices
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+
+/*
+ * DDR3 settings
+ * MX6Q    ddr is limited to 1066 Mhz	currently 1056 MHz(528 MHz clock),
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6DL   ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 64 bits	x16/x32/x64
+ * MX6SOLO ddr is limited to 800 MHz(400 MHz clock)
+ *	   memory bus width: 32 bits	x16/x32
+ */
+DATA 4, MX6_IOM_DRAM_SDQS0, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS1, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS2, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS3, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS4, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS5, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS6, 0x00000030
+DATA 4, MX6_IOM_DRAM_SDQS7, 0x00000030
+
+DATA 4, MX6_IOM_GRP_B0DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B1DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B2DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B3DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B4DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B5DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B6DS, 0x00000030
+DATA 4, MX6_IOM_GRP_B7DS, 0x00000030
+DATA 4, MX6_IOM_GRP_ADDDS, 0x00000030
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_CTLDS, 0x00000030
+
+DATA 4, MX6_IOM_DRAM_DQM0, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM1, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM2, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM3, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM4, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM5, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM6, 0x00020030
+DATA 4, MX6_IOM_DRAM_DQM7, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_CAS, 0x00020030
+DATA 4, MX6_IOM_DRAM_RAS, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_0, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCLK_1, 0x00020030
+
+DATA 4, MX6_IOM_DRAM_RESET, 0x00020030
+DATA 4, MX6_IOM_DRAM_SDCKE0, 0x00003000
+DATA 4, MX6_IOM_DRAM_SDCKE1, 0x00003000
+
+DATA 4, MX6_IOM_DRAM_SDODT0, 0x00003030
+DATA 4, MX6_IOM_DRAM_SDODT1, 0x00003030
+
+/* (differential input) */
+DATA 4, MX6_IOM_DDRMODE_CTL, 0x00020000
+/* (differential input) */
+DATA 4, MX6_IOM_GRP_DDRMODE, 0x00020000
+/* disable ddr pullups */
+DATA 4, MX6_IOM_GRP_DDRPKE, 0x00000000
+DATA 4, MX6_IOM_DRAM_SDBA2, 0x00000000
+/* 40 Ohm drive strength for cs0/1,sdba2,cke0/1,sdwe */
+DATA 4, MX6_IOM_GRP_DDR_TYPE, 0x000C0000
+
+/* Read data DQ Byte0-3 delay */
+DATA 4, MX6_MMDC_P0_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P0_MPRDDQBY3DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY0DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY1DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY2DL, 0x33333333
+DATA 4, MX6_MMDC_P1_MPRDDQBY3DL, 0x33333333
+
+/*
+ * MDMISC	mirroring	interleaved (row/bank/col)
+ */
+DATA 4, MX6_MMDC_P0_MDMISC, 0x00001740
+
+/*
+ * MDSCR	con_req
+ */
+DATA 4, MX6_MMDC_P0_MDSCR, 0x00008000
diff --git a/board/freescale/common/Makefile b/board/freescale/common/Makefile
index f6a0879..b32c29f 100644
--- a/board/freescale/common/Makefile
+++ b/board/freescale/common/Makefile
@@ -48,6 +48,9 @@ obj-$(CONFIG_P5020DS)		+= ics307_clk.o
 obj-$(CONFIG_P5040DS)		+= ics307_clk.o
 obj-$(CONFIG_VSC_CROSSBAR)    += vsc3316_3308.o
 obj-$(CONFIG_IDT8T49N222A)	+= idt8t49n222a_serdes_clk.o
+ifdef CONFIG_FASTBOOT
+obj-${CONFIG_ANDROID_RECOVERY} += recovery.o
+endif
 
 # deal with common files for P-series corenet based devices
 obj-$(CONFIG_P2041RDB)	+= p_corenet/
diff --git a/board/freescale/common/recovery.c b/board/freescale/common/recovery.c
new file mode 100644
index 0000000..b9fe687
--- /dev/null
+++ b/board/freescale/common/recovery.c
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#include <common.h>
+#include <malloc.h>
+#include <recovery.h>
+#ifdef CONFIG_MXC_KPD
+#include <mxc_keyb.h>
+#endif
+#include <asm/imx-common/boot_mode.h>
+
+#ifdef CONFIG_MXC_KPD
+#define PRESSED_VOL_DOWN	0x01
+#define PRESSED_POWER	    0x02
+#define RECOVERY_KEY_MASK (PRESSED_VOL_DOWN | PRESSED_POWER)
+
+inline int test_key(int value, struct kpp_key_info *ki)
+{
+	return (ki->val == value) && (ki->evt == KDepress);
+}
+
+int check_key_pressing(void)
+{
+	struct kpp_key_info *key_info = NULL;
+	int state = 0, keys, i;
+
+	int ret = 0;
+
+	mxc_kpp_init();
+	/* due to glitch suppression circuit,
+	   wait sometime to let all keys scanned. */
+	udelay(1000);
+	keys = mxc_kpp_getc(&key_info);
+
+	printf("Detecting VOL_DOWN+POWER key for recovery(%d:%d) ...\n",
+		keys, keys ? key_info->val : 0);
+	if (keys > 1) {
+		for (i = 0; i < keys; i++) {
+			if (test_key(CONFIG_POWER_KEY, &key_info[i]))
+				state |= PRESSED_POWER;
+			else if (test_key(CONFIG_VOL_DOWN_KEY, &key_info[i]))
+				state |= PRESSED_VOL_DOWN;
+		}
+	}
+	if ((state & RECOVERY_KEY_MASK) == RECOVERY_KEY_MASK)
+		ret = 1;
+	if (key_info)
+		free(key_info);
+	return ret;
+}
+#else
+/* If not using mxc keypad, currently we will detect power key on board */
+int check_key_pressing(void)
+{
+	return 0;
+}
+#endif
+
+void setup_recovery_env(void)
+{
+	board_recovery_setup();
+}
+
+/* export to lib_arm/board.c */
+void check_recovery_mode(void)
+{
+	if (check_key_pressing()) {
+		puts("Fastboot: Recovery key pressing got!\n");
+		setup_recovery_env();
+	} else if (check_recovery_cmd_file()) {
+		puts("Fastboot: Recovery command file founded!\n");
+		setup_recovery_env();
+	} else {
+		puts("Fastboot: Normal\n");
+	}
+}
diff --git a/board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg b/board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg
index bb6c60b..aa897e9 100644
--- a/board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg
+++ b/board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
  * Jason Liu <r64343@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -10,15 +10,31 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
 /* image version */
 IMAGE_VERSION 2
 
 /*
- * Boot Device : one of
- * spi, sd (the board has no nand neither onenand)
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
  */
+
+/* the same flash_offset as sd */
 BOOT_FROM      sd
 
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
 /*
  * Device Configuration Data (DCD)
  *
@@ -30,132 +46,104 @@ BOOT_FROM      sd
  *      Address   absolute address of the register
  *      value     value to be stored in the register
  */
-DATA 4 0x020e05a8 0x00000030
-DATA 4 0x020e05b0 0x00000030
-DATA 4 0x020e0524 0x00000030
-DATA 4 0x020e051c 0x00000030
-
-DATA 4 0x020e0518 0x00000030
-DATA 4 0x020e050c 0x00000030
-DATA 4 0x020e05b8 0x00000030
-DATA 4 0x020e05c0 0x00000030
-
-DATA 4 0x020e05ac 0x00020030
-DATA 4 0x020e05b4 0x00020030
-DATA 4 0x020e0528 0x00020030
-DATA 4 0x020e0520 0x00020030
-
-DATA 4 0x020e0514 0x00020030
-DATA 4 0x020e0510 0x00020030
-DATA 4 0x020e05bc 0x00020030
-DATA 4 0x020e05c4 0x00020030
-
-DATA 4 0x020e056c 0x00020030
-DATA 4 0x020e0578 0x00020030
-DATA 4 0x020e0588 0x00020030
-DATA 4 0x020e0594 0x00020030
-
-DATA 4 0x020e057c 0x00020030
-DATA 4 0x020e0590 0x00003000
-DATA 4 0x020e0598 0x00003000
-DATA 4 0x020e058c 0x00000000
-
-DATA 4 0x020e059c 0x00003030
-DATA 4 0x020e05a0 0x00003030
-DATA 4 0x020e0784 0x00000030
-DATA 4 0x020e0788 0x00000030
-
-DATA 4 0x020e0794 0x00000030
-DATA 4 0x020e079c 0x00000030
-DATA 4 0x020e07a0 0x00000030
-DATA 4 0x020e07a4 0x00000030
-
-DATA 4 0x020e07a8 0x00000030
-DATA 4 0x020e0748 0x00000030
-DATA 4 0x020e074c 0x00000030
-DATA 4 0x020e0750 0x00020000
-
-DATA 4 0x020e0758 0x00000000
-DATA 4 0x020e0774 0x00020000
-DATA 4 0x020e078c 0x00000030
-DATA 4 0x020e0798 0x000C0000
-
-DATA 4 0x021b081c 0x33333333
-DATA 4 0x021b0820 0x33333333
-DATA 4 0x021b0824 0x33333333
-DATA 4 0x021b0828 0x33333333
-
-DATA 4 0x021b481c 0x33333333
-DATA 4 0x021b4820 0x33333333
-DATA 4 0x021b4824 0x33333333
-DATA 4 0x021b4828 0x33333333
-
-DATA 4 0x021b0018 0x00081740
-
-DATA 4 0x021b001c 0x00008000
-DATA 4 0x021b000c 0x555A7974
-DATA 4 0x021b0010 0xDB538F64
-DATA 4 0x021b0014 0x01FF00DB
-DATA 4 0x021b002c 0x000026D2
-
-DATA 4 0x021b0030 0x005A1023
-DATA 4 0x021b0008 0x09444040
-DATA 4 0x021b0004 0x00025576
-DATA 4 0x021b0040 0x00000027
-DATA 4 0x021b0000 0x831A0000
-
-DATA 4 0x021b001c 0x04088032
-DATA 4 0x021b001c 0x0408803A
-DATA 4 0x021b001c 0x00008033
-DATA 4 0x021b001c 0x0000803B
-DATA 4 0x021b001c 0x00428031
-DATA 4 0x021b001c 0x00428039
-DATA 4 0x021b001c 0x19308030
-DATA 4 0x021b001c 0x19308038
-
-DATA 4 0x021b001c 0x04008040
-DATA 4 0x021b001c 0x04008048
-DATA 4 0x021b0800 0xA1380003
-DATA 4 0x021b4800 0xA1380003
-DATA 4 0x021b0020 0x00005800
-DATA 4 0x021b0818 0x00022227
-DATA 4 0x021b4818 0x00022227
-
-DATA 4 0x021b083c 0x434B0350
-DATA 4 0x021b0840 0x034C0359
-DATA 4 0x021b483c 0x434B0350
-DATA 4 0x021b4840 0x03650348
-DATA 4 0x021b0848 0x4436383B
-DATA 4 0x021b4848 0x39393341
-DATA 4 0x021b0850 0x35373933
-DATA 4 0x021b4850 0x48254A36
-
-DATA 4 0x021b080c 0x001F001F
-DATA 4 0x021b0810 0x001F001F
-
-DATA 4 0x021b480c 0x00440044
-DATA 4 0x021b4810 0x00440044
-
-DATA 4 0x021b08b8 0x00000800
-DATA 4 0x021b48b8 0x00000800
-
-DATA 4 0x021b001c 0x00000000
-DATA 4 0x021b0404 0x00011006
+DATA 4, 0x020e0798, 0x000C0000
+DATA 4, 0x020e0758, 0x00000000
+DATA 4, 0x020e0588, 0x00000030
+DATA 4, 0x020e0594, 0x00000030
+DATA 4, 0x020e056c, 0x00000030
+DATA 4, 0x020e0578, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e057c, 0x00000030
+DATA 4, 0x020e058c, 0x00000000
+DATA 4, 0x020e059c, 0x00000030
+DATA 4, 0x020e05a0, 0x00000030
+DATA 4, 0x020e078c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e05a8, 0x00000030
+DATA 4, 0x020e05b0, 0x00000030
+DATA 4, 0x020e0524, 0x00000030
+DATA 4, 0x020e051c, 0x00000030
+DATA 4, 0x020e0518, 0x00000030
+DATA 4, 0x020e050c, 0x00000030
+DATA 4, 0x020e05b8, 0x00000030
+DATA 4, 0x020e05c0, 0x00000030
+DATA 4, 0x020e0774, 0x00020000
+DATA 4, 0x020e0784, 0x00000030
+DATA 4, 0x020e0788, 0x00000030
+DATA 4, 0x020e0794, 0x00000030
+DATA 4, 0x020e079c, 0x00000030
+DATA 4, 0x020e07a0, 0x00000030
+DATA 4, 0x020e07a4, 0x00000030
+DATA 4, 0x020e07a8, 0x00000030
+DATA 4, 0x020e0748, 0x00000030
+DATA 4, 0x020e05ac, 0x00000030
+DATA 4, 0x020e05b4, 0x00000030
+DATA 4, 0x020e0528, 0x00000030
+DATA 4, 0x020e0520, 0x00000030
+DATA 4, 0x020e0514, 0x00000030
+DATA 4, 0x020e0510, 0x00000030
+DATA 4, 0x020e05bc, 0x00000030
+DATA 4, 0x020e05c4, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x43270338
+DATA 4, 0x021b0840, 0x03200314
+DATA 4, 0x021b483c, 0x431A032F
+DATA 4, 0x021b4840, 0x03200263
+DATA 4, 0x021b0848, 0x4B434748
+DATA 4, 0x021b4848, 0x4445404C
+DATA 4, 0x021b0850, 0x38444542
+DATA 4, 0x021b4850, 0x4935493A
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020036
+DATA 4, 0x021b0008, 0x09444040
+DATA 4, 0x021b000c, 0x555A7975
+DATA 4, 0x021b0010, 0xFF538F64
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x005A1023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0000, 0x831A0000
+DATA 4, 0x021b001c, 0x04088032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x09408030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025576
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
 
 /* set the default clock gate to save power */
-DATA 4 0x020c4068 0x00C03F3F
-DATA 4 0x020c406c 0x0030FC03
-DATA 4 0x020c4070 0x0FFFC000
-DATA 4 0x020c4074 0x3FF00000
-DATA 4 0x020c4078 0x00FFF300
-DATA 4 0x020c407c 0x0F0000C3
-DATA 4 0x020c4080 0x000003FF
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x000003FF
 
 /* enable AXI cache for VDOA/VPU/IPU */
-DATA 4 0x020e0010 0xF00000CF
+DATA 4, 0x020e0010, 0xF00000CF
 /* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
-DATA 4 0x020e0018 0x007F007F
-DATA 4 0x020e001c 0x007F007F
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
 
 /*
  * Setup CCM_CCOSR register as follows:
@@ -166,4 +154,5 @@ DATA 4 0x020e001c 0x007F007F
  *
  * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
  */
-DATA 4 0x020c4060 0x000000fb
+DATA 4, 0x020c4060, 0x000000fb
+#endif
diff --git a/board/freescale/mx6qarm2/Makefile b/board/freescale/mx6qarm2/Makefile
index 79401f4..4d51a6e 100644
--- a/board/freescale/mx6qarm2/Makefile
+++ b/board/freescale/mx6qarm2/Makefile
@@ -1,9 +1,13 @@
 #
 # Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
 #
-# (C) Copyright 2011 Freescale Semiconductor, Inc.
+# (C) Copyright 2011-2014 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y	:= mx6qarm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6qarm2/imximage.cfg b/board/freescale/mx6qarm2/imximage.cfg
index 710f34d..38c674b 100644
--- a/board/freescale/mx6qarm2/imximage.cfg
+++ b/board/freescale/mx6qarm2/imximage.cfg
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2011-2014 Freescale Semiconductor, Inc.
  * Jason Liu <r64343@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -10,15 +10,29 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
+
 /* image version */
+
 IMAGE_VERSION 2
 
 /*
  * Boot Device : one of
  * spi, sd (the board has no nand neither onenand)
  */
+
 BOOT_FROM	sd
 
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qarm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
 /*
  * Device Configuration Data (DCD)
  *
@@ -30,6 +44,185 @@ BOOT_FROM	sd
  *	Address	  absolute address of the register
  *	value	  value to be stored in the register
  */
+#ifdef CONFIG_MX6DQ_LPDDR2
+/* DCD */
+DATA 4 0x020C4018 0x60324
+
+DATA 4 0x020E05a8 0x00003038
+DATA 4 0x020E05b0 0x00003038
+DATA 4 0x020E0524 0x00003038
+DATA 4 0x020E051c 0x00003038
+
+DATA 4 0x020E0518 0x00003038
+DATA 4 0x020E050c 0x00003038
+DATA 4 0x020E05b8 0x00003038
+DATA 4 0x020E05c0 0x00003038
+
+DATA 4 0x020E05ac 0x00000038
+DATA 4 0x020E05b4 0x00000038
+DATA 4 0x020E0528 0x00000038
+DATA 4 0x020E0520 0x00000038
+
+DATA 4 0x020E0514 0x00000038
+DATA 4 0x020E0510 0x00000038
+DATA 4 0x020E05bc 0x00000038
+DATA 4 0x020E05c4 0x00000038
+
+DATA 4 0x020E056c 0x00000038
+DATA 4 0x020E0578 0x00000038
+DATA 4 0x020E0588 0x00000038
+DATA 4 0x020E0594 0x00000038
+
+DATA 4 0x020E057c 0x00000038
+DATA 4 0x020E0590 0x00000038
+DATA 4 0x020E0598 0x00000038
+DATA 4 0x020E058c 0x00000000
+
+DATA 4 0x020E059c 0x00000038
+DATA 4 0x020E05a0 0x00000038
+DATA 4 0x020E0784 0x00000038
+DATA 4 0x020E0788 0x00000038
+
+DATA 4 0x020E0794 0x00000038
+DATA 4 0x020E079c 0x00000038
+DATA 4 0x020E07a0 0x00000038
+DATA 4 0x020E07a4 0x00000038
+
+DATA 4 0x020E07a8 0x00000038
+DATA 4 0x020E0748 0x00000038
+DATA 4 0x020E074c 0x00000038
+DATA 4 0x020E0750 0x00020000
+
+DATA 4 0x020E0758 0x00000000
+DATA 4 0x020E0774 0x00020000
+DATA 4 0x020E078c 0x00000038
+DATA 4 0x020E0798 0x00080000
+
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b401c 0x00008000
+
+DATA 4 0x021b085c 0x1b5f01ff
+DATA 4 0x021b485c 0x1b5f01ff
+
+DATA 4 0x021b0800 0xa1390000
+DATA 4 0x021b4800 0xa1390000
+
+DATA 4 0x021b0890 0x00400000
+DATA 4 0x021b4890 0x00400000
+
+DATA 4 0x021b48bc 0x00055555
+
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b481c 0x33333333
+DATA 4 0x021b4820 0x33333333
+DATA 4 0x021b4824 0x33333333
+DATA 4 0x021b4828 0x33333333
+
+DATA 4 0x021b082c 0xf3333333
+DATA 4 0x021b0830 0xf3333333
+DATA 4 0x021b0834 0xf3333333
+DATA 4 0x021b0838 0xf3333333
+DATA 4 0x021b482c 0xf3333333
+DATA 4 0x021b4830 0xf3333333
+DATA 4 0x021b4834 0xf3333333
+DATA 4 0x021b4838 0xf3333333
+
+DATA 4 0x021b0848 0x49383b39
+DATA 4 0x021b0850 0x30364738
+DATA 4 0x021b4848 0x3e3c3846
+DATA 4 0x021b4850 0x4c294b35
+
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x0
+DATA 4 0x021b483c 0x20000000
+DATA 4 0x021b4840 0x0
+
+DATA 4 0x021b0858 0xf00
+DATA 4 0x021b4858 0xf00
+
+DATA 4 0x021b08b8 0x800
+DATA 4 0x021b48b8 0x800
+
+DATA 4 0x021b000c 0x555a61a5
+DATA 4 0x021b0004 0x20036
+DATA 4 0x021b0010 0x160e83
+DATA 4 0x021b0014 0xdd
+DATA 4 0x021b0018 0x8174c
+DATA 4 0x021b002c 0xf9f26d2
+DATA 4 0x021b0030 0x20e
+DATA 4 0x021b0038 0x200aac
+DATA 4 0x021b0008 0x0
+
+DATA 4 0x021b0040 0x5f
+
+DATA 4 0x021b0000 0xc3010000
+
+DATA 4 0x021b400c 0x555a61a5
+DATA 4 0x021b4004 0x20036
+DATA 4 0x021b4010 0x160e83
+DATA 4 0x021b4014 0xdd
+DATA 4 0x021b4018 0x8174c
+DATA 4 0x021b402c 0xf9f26d2
+DATA 4 0x021b4030 0x20e
+DATA 4 0x021b4038 0x200aac
+DATA 4 0x021b4008 0x0
+
+DATA 4 0x021b4040 0x3f
+DATA 4 0x021b4000 0xc3010000
+
+DATA 4 0x021b001c 0x3f8030
+DATA 4 0x021b001c 0xff0a8030
+DATA 4 0x021b001c 0xc2018030
+DATA 4 0x021b001c 0x6028030
+DATA 4 0x021b001c 0x2038030
+
+DATA 4 0x021b401c 0x3f8030
+DATA 4 0x021b401c 0xff0a8030
+DATA 4 0x021b401c 0xc2018030
+DATA 4 0x021b401c 0x6028030
+DATA 4 0x021b401c 0x2038030
+
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b4800 0xa1390003
+
+DATA 4 0x021b0020 0x7800
+DATA 4 0x021b4020 0x7800
+
+DATA 4 0x021b0818 0x0
+DATA 4 0x021b4818 0x0
+
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b4800 0xa1390003
+
+DATA 4 0x021b08b8 0x800
+DATA 4 0x021b48b8 0x800
+
+DATA 4 0x021b001c 0x0
+DATA 4 0x021b401c 0x0
+
+DATA 4 0x021b0404 0x00011006
+
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0x00FFF300
+DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c4080 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+
+#else
 DATA 4 0x020e05a8 0x00000030
 DATA 4 0x020e05b0 0x00000030
 DATA 4 0x020e0524 0x00000030
@@ -142,12 +335,8 @@ DATA 4 0x021b48b8 0x00000800
 DATA 4 0x021b001c 0x00000000
 DATA 4 0x021b0404 0x00011006
 
-DATA 4 0x020e0010 0xF00000FF
-DATA 4 0x020e0018 0x00070007
-DATA 4 0x020e001c 0x00070007
-
 DATA 4 0x020c4068 0x00C03F3F
-DATA 4 0x020c406c 0x0030FC00
+DATA 4 0x020c406c 0x0030FC03
 DATA 4 0x020c4070 0x0FFFC000
 DATA 4 0x020c4074 0x3FF00000
 DATA 4 0x020c4078 0x00FFF300
@@ -159,3 +348,6 @@ DATA 4 0x020e0010 0xF00000CF
 /* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
 DATA 4 0x020e0018 0x007F007F
 DATA 4 0x020e001c 0x007F007F
+
+#endif /* CONFIG_MX6DQ_LPDDR2 */
+#endif
diff --git a/board/freescale/mx6qarm2/imximage_mx6dl.cfg b/board/freescale/mx6qarm2/imximage_mx6dl.cfg
new file mode 100644
index 0000000..0e15da4
--- /dev/null
+++ b/board/freescale/mx6qarm2/imximage_mx6dl.cfg
@@ -0,0 +1,493 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License or DATA 4.at your option any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not write to the Free Software
+ * Foundation Inc. 51 Franklin Street Fifth Floor Boston,
+ * MA 02110-1301 USA
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi, sd DATA 4.the board has no nand neither onenand
+ */
+
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qarm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data DATA 4.DCD
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length DATA 4.1,2 or 4 bytes
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+
+
+#ifdef CONFIG_MX6DL_LPDDR2
+
+/* IOMUX SETTINGS */
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0 */
+DATA 4 0x020E04bc 0x00003028
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1 */
+DATA 4 0x020E04c0 0x00003028
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS2 */
+DATA 4 0x020E04c4 0x00003028
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS3 */
+DATA 4 0x020E04c8 0x00003028
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS4 */
+DATA 4 0x020E04cc 0x00003028
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS5 */
+DATA 4 0x020E04d0 0x00003028
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS6 */
+DATA 4 0x020E04d4 0x00003028
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS7 */
+DATA 4 0x020E04d8 0x00003028
+
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0 */
+DATA 4 0x020E0470 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1 */
+DATA 4 0x020E0474 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM2 */
+DATA 4 0x020E0478 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM3 */
+DATA 4 0x020E047c 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM4 */
+DATA 4 0x020E0480 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM5 */
+DATA 4 0x020E0484 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM6 */
+DATA 4 0x020E0488 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM7 */
+DATA 4 0x020E048c 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS */
+DATA 4 0x020E0464 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS */
+DATA 4 0x020E0490 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_0 */
+DATA 4 0x020E04ac 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK_1 */
+DATA 4 0x020E04b0 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET */
+DATA 4 0x020E0494 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0 */
+DATA 4 0x020E04a4 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1 */
+DATA 4 0x020E04a8 0x00000038
+/*
+ * IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2
+ * DSE can be configured using Group Control Register:
+ * IOMUXC_SW_PAD_CTL_GRP_CTLDS
+ */
+DATA 4 0x020E04a0 0x00000000
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT0 */
+DATA 4 0x020E04b4 0x00000038
+/* IOMUXC_SW_PAD_CTL_PAD_DRAM_SDODT1 */
+DATA 4 0x020E04b8 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_B0DS */
+DATA 4 0x020E0764 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_B1DS */
+DATA 4 0x020E0770 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_B2DS */
+DATA 4 0x020E0778 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_B3DS */
+DATA 4 0x020E077c 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_B4DS */
+DATA 4 0x020E0780 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_B5DS */
+DATA 4 0x020E0784 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_B6DS */
+DATA 4 0x020E078c 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_B7DS */
+DATA 4 0x020E0748 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_ADDDS */
+DATA 4 0x020E074c 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_CTLDS */
+DATA 4 0x020E076c 0x00000038
+/* IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL */
+DATA 4 0x020E0750 0x00020000
+/* IOMUXC_SW_PAD_CTL_GRP_DDRPKE */
+DATA 4 0x020E0754 0x00000000
+/* IOMUXC_SW_PAD_CTL_GRP_DDRMODE */
+DATA 4 0x020E0760 0x00020000
+/* IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE */
+DATA 4 0x020E0774 0x00080000
+
+/*
+ * DDR Controller Registers
+ *
+ * Manufacturer:	Mocron
+ * Device Part Number:	MT42L64M64D2KH-18
+ * Clock Freq.: 	528MHz
+ * MMDC channels: Both MMDC0, MMDC1
+ *Density per CS in Gb: 	256M
+ * Chip Selects used:	2
+ * Number of Banks:	8
+ * Row address:    	14
+ * Column address: 	9
+ * Data bus width	32
+ */
+
+/* MMDC_P0_BASE_ADDR = 0x021b0000 */
+/* MMDC_P1_BASE_ADDR = 0x021b4000 */
+
+/* MMDC0_MDSCR, set the Configuration request bit during MMDC set up */
+DATA 4 0x021b001c 0x00008000
+
+/* MMDC0_MDSCR, set the Configuration request bit during MMDC set up */
+DATA 4 0x021b401c 0x00008000
+
+/*LPDDR2 ZQ params */
+DATA 4 0x021b085c 0x1b5f01ff
+DATA 4 0x021b485c 0x1b5f01ff
+
+/* Calibration setup. */
+/* DDR_PHY_P0_MPZQHWCTRL, enable on time ZQ calibration */
+DATA 4 0x021b0800 0xa1390003
+
+/*ca bus abs delay */
+DATA 4 0x021b0890 0x00400000
+/*ca bus abs delay */
+DATA 4 0x021b4890 0x00400000
+/* values of 20,40,50,60,7f tried. no difference seen */
+
+/* DDR_PHY_P1_MPWRCADL */
+DATA 4 0x021b48bc 0x00055555
+
+/*frc_msr.*/
+DATA 4 0x021b08b8 0x00000800
+/*frc_msr.*/
+DATA 4 0x021b48b8 0x00000800
+
+/* DDR_PHY_P0_MPREDQBY0DL3 */
+DATA 4 0x021b081c 0x33333333
+/* DDR_PHY_P0_MPREDQBY1DL3 */
+DATA 4 0x021b0820 0x33333333
+/* DDR_PHY_P0_MPREDQBY2DL3 */
+DATA 4 0x021b0824 0x33333333
+/* DDR_PHY_P0_MPREDQBY3DL3 */
+DATA 4 0x021b0828 0x33333333
+/* DDR_PHY_P1_MPREDQBY0DL3 */
+DATA 4 0x021b481c 0x33333333
+/* DDR_PHY_P1_MPREDQBY1DL3 */
+DATA 4 0x021b4820 0x33333333
+/* DDR_PHY_P1_MPREDQBY2DL3 */
+DATA 4 0x021b4824 0x33333333
+/* DDR_PHY_P1_MPREDQBY3DL3 */
+DATA 4 0x021b4828 0x33333333
+
+/*
+ * Read and write data delay, per byte.
+ * For optimized DDR operation it is recommended to run mmdc_calibration
+ * on your board, and replace 4 delay register assigns with resulted values
+ * Note:
+ * a. DQS gating is not relevant for LPDDR2. DSQ gating calibration section
+ *    should be skipped, or the write/read calibration comming after that
+ *    will stall
+ * b. The calibration code that runs for both MMDC0 & MMDC1 should be used.
+ */
+
+DATA 4 0x021b0848 0x4b4b524f
+DATA 4 0x021b4848 0x494f4c44
+
+DATA 4 0x021b0850 0x3c3d303c
+DATA 4 0x021b4850 0x3c343d38
+
+/*dqs gating dis */
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x0
+DATA 4 0x021b483c 0x20000000
+DATA 4 0x021b4840 0x0
+
+/*clk delay */
+DATA 4 0x021b0858 0xa00
+/*clk delay */
+DATA 4 0x021b4858 0xa00
+
+/*frc_msr */
+DATA 4 0x021b08b8 0x00000800
+/*frc_msr */
+DATA 4 0x021b48b8 0x00000800
+/* Calibration setup end */
+
+/* Channel0 - startng address 0x80000000 */
+/* MMDC0_MDCFG0 */
+DATA 4 0x021b000c 0x34386145
+
+/* MMDC0_MDPDC */
+DATA 4 0x021b0004 0x00020036
+/* MMDC0_MDCFG1 */
+DATA 4 0x021b0010 0x00100c83
+/* MMDC0_MDCFG2 */
+DATA 4 0x021b0014 0x000000Dc
+/* MMDC0_MDMISC */
+DATA 4 0x021b0018 0x0000174C
+/* MMDC0_MDRWD;*/
+DATA 4 0x021b002c 0x0f9f26d2
+/* MMDC0_MDOR */
+DATA 4 0x021b0030 0x0000020e
+/* MMDC0_MDCFG3LP */
+DATA 4 0x021b0038 0x00190778
+/* MMDC0_MDOTC */
+DATA 4 0x021b0008 0x00000000
+
+/* CS0_END */
+DATA 4 0x021b0040 0x0000005f
+/* ROC */
+DATA 4 0x021b0404 0x0000000f
+
+/* MMDC0_MDCTL */
+DATA 4 0x021b0000 0xc3010000
+
+/* Channel1 - starting address 0x10000000 */
+/* MMDC1_MDCFG0 */
+DATA 4 0x021b400c 0x34386145
+
+/* MMDC1_MDPDC */
+DATA 4 0x021b4004 0x00020036
+/* MMDC1_MDCFG1 */
+DATA 4 0x021b4010 0x00100c83
+/* MMDC1_MDCFG2 */
+DATA 4 0x021b4014 0x000000Dc
+/* MMDC1_MDMISC */
+DATA 4 0x021b4018 0x0000174C
+/* MMDC1_MDRWD;*/
+DATA 4 0x021b402c 0x0f9f26d2
+/* MMDC1_MDOR */
+DATA 4 0x021b4030 0x0000020e
+/* MMDC1_MDCFG3LP */
+DATA 4 0x021b4038 0x00190778
+/* MMDC1_MDOTC */
+DATA 4 0x021b4008 0x00000000
+
+/* CS0_END */
+DATA 4 0x021b4040 0x0000003f
+
+/* MMDC1_MDCTL */
+DATA 4 0x021b4000 0xc3010000
+
+/* Channel0 : Configure DDR device:*/
+/* MRW: BA=0 CS=0 MR_ADDR=63 MR_OP=0 */
+DATA 4 0x021b001c 0x003f8030
+/* MRW: BA=0 CS=0 MR_ADDR=10 MR_OP=ff */
+DATA 4 0x021b001c 0xff0a8030
+/* MRW: BA=0 CS=0 MR_ADDR=1  MR_OP=a2 */
+DATA 4 0x021b001c 0xa2018030
+/* MRW: BA=0 CS=0 MR_ADDR=2  MR_OP=6. tcl=8, tcwl=4 */
+DATA 4 0x021b001c 0x06028030
+/* MRW: BA=0 CS=0 MR_ADDR=3  MR_OP=2.drive=240/6 */
+DATA 4 0x021b001c 0x01038030
+
+/* Channel1 : Configure DDR device:*/
+/* MRW: BA=0 CS=0 MR_ADDR=63 MR_OP=0 */
+DATA 4 0x021b401c 0x003f8030
+/* MRW: BA=0 CS=0 MR_ADDR=10 MR_OP=ff */
+DATA 4 0x021b401c 0xff0a8030
+/* MRW: BA=0 CS=0 MR_ADDR=1  MR_OP=a2 */
+DATA 4 0x021b401c 0xa2018030
+/* MRW: BA=0 CS=0 MR_ADDR=2  MR_OP=6. tcl=8, tcwl=4 */
+DATA 4 0x021b401c 0x06028030
+/* MRW: BA=0 CS=0 MR_ADDR=3  MR_OP=2.drive=240/6 */
+DATA 4 0x021b401c 0x01038030
+
+/* MMDC0_MDREF */
+DATA 4 0x021b0020 0x00005800
+/* MMDC1_MDREF */
+DATA 4 0x021b4020 0x00005800
+
+/* DDR_PHY_P0_MPODTCTRL */
+DATA 4 0x021b0818 0x0
+/* DDR_PHY_P1_MPODTCTRL */
+DATA 4 0x021b4818 0x0
+
+/*
+ * calibration values based on calibration compare of 0x00ffff00:
+ * Note, these calibration values are based on Freescale's board
+ * May need to run calibration on target board to fine tune these
+ */
+
+/* DDR_PHY_P0_MPZQHWCTRL, enable automatic ZQ calibration */
+DATA 4 0x021b0800 0xa1310003
+
+/* DDR_PHY_P0_MPMUR0, frc_msr */
+DATA 4 0x021b08b8 0x00000800
+/* DDR_PHY_P1_MPMUR0, frc_msr */
+DATA 4 0x021b48b8 0x00000800
+
+/*
+ * MMDC0_MDSCR, clear this register
+ * (especially the configuration bit as initialization is complete)
+ */
+DATA 4 0x021b001c 0x00000000
+/*
+ * MMDC0_MDSCR, clear this register
+ * (especially the configuration bit as initialization is complete)
+ */
+DATA 4 0x021b401c 0x00000000
+
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0x00FFF300
+DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c4080 0x000003FF
+
+DATA 4 0x020e0010 0xF00000CF
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+
+#else /* CONFIG_MX6DL_LPDDR2 */
+
+DATA 4 0x020e0798 0x000c0000
+DATA 4 0x020e0758 0x00000000
+DATA 4 0x020e0588 0x00000030
+DATA 4 0x020e0594 0x00000030
+DATA 4 0x020e056c 0x00000030
+DATA 4 0x020e0578 0x00000030
+DATA 4 0x020e074c 0x00000030
+DATA 4 0x020e057c 0x00000030
+DATA 4 0x020e0590 0x00003000
+DATA 4 0x020e0598 0x00003000
+DATA 4 0x020e058c 0x00000000
+DATA 4 0x020e059c 0x00003030
+DATA 4 0x020e05a0 0x00003030
+DATA 4 0x020e078c 0x00000030
+DATA 4 0x020e0750 0x00020000
+DATA 4 0x020e05a8 0x00000030
+DATA 4 0x020e05b0 0x00000030
+DATA 4 0x020e0524 0x00000030
+DATA 4 0x020e051c 0x00000030
+DATA 4 0x020e0518 0x00000030
+DATA 4 0x020e050c 0x00000030
+DATA 4 0x020e05b8 0x00000030
+DATA 4 0x020e05c0 0x00000030
+DATA 4 0x020e0774 0x00020000
+DATA 4 0x020e0784 0x00000030
+DATA 4 0x020e0788 0x00000030
+DATA 4 0x020e0794 0x00000030
+DATA 4 0x020e079c 0x00000030
+DATA 4 0x020e07a0 0x00000030
+DATA 4 0x020e07a4 0x00000030
+DATA 4 0x020e07a8 0x00000030
+DATA 4 0x020e0748 0x00000030
+DATA 4 0x020e05ac 0x00000030
+DATA 4 0x020e05b4 0x00000030
+DATA 4 0x020e0528 0x00000030
+DATA 4 0x020e0520 0x00000030
+DATA 4 0x020e0514 0x00000030
+DATA 4 0x020e0510 0x00000030
+DATA 4 0x020e05bc 0x00000030
+DATA 4 0x020e05c4 0x00000030
+
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b4800 0xa1390003
+DATA 4 0x021b080c 0x001F001F
+DATA 4 0x021b0810 0x001F001F
+DATA 4 0x021b480c 0x00370037
+DATA 4 0x021b4810 0x00370037
+DATA 4 0x021b083c 0x422f0220
+DATA 4 0x021b0840 0x021f0219
+DATA 4 0x021b483C 0x422f0220
+DATA 4 0x021b4840 0x022d022f
+DATA 4 0x021b0848 0x47494b49
+DATA 4 0x021b4848 0x48484c47
+DATA 4 0x021b0850 0x39382b2f
+DATA 4 0x021b4850 0x2f35312c
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b481c 0x33333333
+DATA 4 0x021b4820 0x33333333
+DATA 4 0x021b4824 0x33333333
+DATA 4 0x021b4828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+
+DATA 4 0x021b000c 0x40445323
+DATA 4 0x021b0010 0xb66e8c63
+
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00081740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x00440e21
+#ifdef CONFIG_DDR_32BIT
+DATA 4 0x021b0040 0x00000017
+DATA 4 0x021b0000 0xc3190000
+#else
+DATA 4 0x021b0040 0x00000027
+DATA 4 0x021b0000 0xc31a0000
+#endif
+DATA 4 0x021b001c 0x04008032
+DATA 4 0x021b001c 0x0400803a
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x0000803b
+DATA 4 0x021b001c 0x00428031
+DATA 4 0x021b001c 0x00428039
+DATA 4 0x021b001c 0x07208030
+DATA 4 0x021b001c 0x07208038
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b001c 0x04008048
+DATA 4 0x021b0020 0x00005800
+DATA 4 0x021b0818 0x00000007
+DATA 4 0x021b4818 0x00000007
+DATA 4 0x021b0004 0x0002556d
+DATA 4 0x021b4004 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0x00FFF300
+DATA 4 0x020c407c 0x0F0000C3
+DATA 4 0x020c4080 0x000003FF
+
+DATA 4 0x020e0010 0xF00000CF
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+#endif /* CONFIG_MX6DL_LPDDR2 */
+#endif
diff --git a/board/freescale/mx6qarm2/mx6qarm2.c b/board/freescale/mx6qarm2/mx6qarm2.c
index 6c51f3a..e1294bf 100644
--- a/board/freescale/mx6qarm2/mx6qarm2.c
+++ b/board/freescale/mx6qarm2/mx6qarm2.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -32,7 +32,12 @@ DECLARE_GLOBAL_DATA_PTR;
 
 int dram_init(void)
 {
-	gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
+#if defined(CONFIG_MX6DL) && !defined(CONFIG_MX6DL_LPDDR2) && \
+	defined(CONFIG_DDR_32BIT)
+	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024)/2;
+#else
+	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
+#endif
 
 	return 0;
 }
@@ -104,6 +109,35 @@ struct fsl_esdhc_cfg usdhc_cfg[2] = {
 	{USDHC4_BASE_ADDR},
 };
 
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no -= 2;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 2;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
 	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
@@ -148,6 +182,39 @@ int board_mmc_init(bd_t *bis)
 
 	return status;
 }
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
 #endif
 
 #define MII_MMD_ACCESS_CTRL_REG		0xd
@@ -222,9 +289,54 @@ int board_init(void)
 	return 0;
 }
 
+int board_late_init(void)
+{
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
 int checkboard(void)
 {
+#ifdef CONFIG_MX6DL
+	puts("Board: MX6DL-Armadillo2\n");
+#else
 	puts("Board: MX6Q-Armadillo2\n");
+#endif
 
 	return 0;
 }
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+/* no external pmic, always ldo_enable */
+void ldo_mode_set(int ldo_bypass)
+{
+	return;
+}
+#endif
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_GPIO_1__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+			ARRAY_SIZE(usb_otg_pads));
+
+		/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+		mxc_iomux_set_gpr_register(1, 13, 1, 1);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/board/freescale/mx6qarm2/plugin.S b/board/freescale/mx6qarm2/plugin.S
new file mode 100644
index 0000000..dded80a
--- /dev/null
+++ b/board/freescale/mx6qarm2/plugin.S
@@ -0,0 +1,943 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * Author: Fabio Estevam <fabio.estevam@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+.macro imx6dlarm2_ddr_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00003000
+	str r1, [r0, #0x590]
+	str r1, [r0, #0x598]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00003030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	str r2, [r1, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x00370037
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x422f0220
+	str r2, [r0, #0x83c]
+	ldr r2, =0x021f0219
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x422f0220
+	str r2, [r1, #0x83c]
+	ldr r2, =0x022d022f
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x47494b49
+	str r2, [r0, #0x848]
+	ldr r2, =0x48484c47
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x39382b2f
+	str r2, [r0, #0x850]
+	ldr r2, =0x2f35312c
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x00000800
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x40445323
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66e8c63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00081740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00440e21
+	str r2, [r0, #0x030]
+
+#ifdef CONFIG_DDR_32BIT
+	ldr r2, =0x00000017
+	str r2, [r0, #0x040]
+	ldr r2, =0xc3190000
+	str r2, [r0, #0x000]
+#else
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+	ldr r2, =0xc31a0000
+	str r2, [r0, #0x000]
+#endif
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x0400803a
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x0000803b
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00428031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00428039
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x07208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x07208038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008048
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+
+	ldr r2, =0x00000007
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0x0002556d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r1, #0x004]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dqarm2_ddr_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x594]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x56c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x578]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x74c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a0]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5a8]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5b0]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x524]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x51c]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x518]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x50c]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5b8]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x788]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x794]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x79c]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x7a0]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x7a4]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x7a8]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x748]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5ac]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5b4]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x528]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x520]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x514]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x510]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5bc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x810]
+
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x00440044
+	str r2, [r1, #0x80c]
+	ldr r2, =0x00440044
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x4333033F
+	str r2, [r0, #0x83c]
+	ldr r2, =0x0339033E
+	str r2, [r0, #0x840]
+	ldr r2, =0x433F0343
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03490320
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x42363838
+	str r2, [r0, #0x848]
+	ldr r2, =0x3F343242
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x37424844
+	str r2, [r0, #0x850]
+	ldr r2, =0x48264731
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	ldr r2, =0x33333333
+	str r2, [r0, #0x820]
+	ldr r2, =0x33333333
+	str r2, [r0, #0x824]
+	ldr r2, =0x33333333
+	str r2, [r0, #0x828]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x81c]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x820]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x824]
+	ldr r2, =0x33333333
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x00000800
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+	ldr r2, =0x555A7975
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF538F64
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00081740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x005a1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x11420000
+	str r2, [r0, #0x400]
+	ldr r2, =0x11420000
+	str r2, [r1, #0x400]
+
+	ldr r2, =0xc31a0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x0408803a
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x0000803b
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048039
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008048
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dlarm2_lpddr2_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00003028
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00000038
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x494]
+	str r1, [r0, #0x4a4]
+	str r1, [r0, #0x4a8]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x76c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+	ldr r1, =0x00080000
+	str r1, [r0, #0x774]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+	ldr r2, =0x1b5f01ff
+	str r2, [r0, #0x85c]
+	str r2, [r1, #0x85c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00400000
+	str r2, [r0, #0x890]
+	str r2, [r1, #0x890]
+	ldr r2, =0x00055555
+	str r2, [r1, #0x8bc]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x4b4b524f
+	str r2, [r0, #0x848]
+	ldr r2, =0x494f4c44
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x3c3d303c
+	str r2, [r0, #0x850]
+	ldr r2, =0x3c343d38
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	str r2, [r1, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x00000a00
+	str r2, [r0, #0x858]
+	str r2, [r1, #0x858]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x34386145
+	str r2, [r0, #0xc]
+	ldr r2, =0x00020036
+	str r2, [r0, #0x4]
+	ldr r2, =0x00100c83
+	str r2, [r0, #0x10]
+	ldr r2, =0x000000Dc
+	str r2, [r0, #0x14]
+	ldr r2, =0x0000174C
+	str r2, [r0, #0x18]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x2c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x30]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x38]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x8]
+
+	ldr r2, =0x0000005f
+	str r2, [r0, #0x40]
+	ldr r2, =0x0000000f
+	str r2, [r0, #0x404]
+
+	ldr r2, =0xc3010000
+	str r2, [r0, #0x0]
+
+	ldr r2, =0x34386145
+	str r2, [r1, #0xc]
+
+	ldr r2, =0x00020036
+	str r2, [r1, #0x4]
+	ldr r2, =0x00100c83
+	str r2, [r1, #0x10]
+	ldr r2, =0x000000Dc
+	str r2, [r1, #0x14]
+	ldr r2, =0x0000174C
+	str r2, [r1, #0x18]
+	ldr r2, =0x0f9f26d2
+	str r2, [r1, #0x2c]
+	ldr r2, =0x0000020e
+	str r2, [r1, #0x30]
+	ldr r2, =0x00190778
+	str r2, [r1, #0x38]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x8]
+
+	ldr r2, =0x0000003f
+	str r2, [r1, #0x40]
+
+	ldr r2, =0xc3010000
+	str r2, [r1, #0x0]
+
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xa2018030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x01038030
+	str r2, [r0, #0x1c]
+
+	ldr r2, =0x003f8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xff0a8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xa2018030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x01038030
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x20]
+	str r2, [r1, #0x20]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6dqarm2_lpddr2_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x60324
+	str r1, [r0, #0x18]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x06c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x070]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x074]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x078]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x07c]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x080]
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x084]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00003038
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00000038
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x57c]
+	str r1, [r0, #0x590]
+	str r1, [r0, #0x598]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x74c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000038
+	str r1, [r0, #0x78c]
+	ldr r1, =0x00080000
+	str r1, [r0, #0x798]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+	ldr r2, =0x1b5f01ff
+	str r2, [r0, #0x85c]
+	str r2, [r1, #0x85c]
+	ldr r2, =0xa1390000
+	str r2, [r0, #0x800]
+	str r2, [r1, #0x800]
+	ldr r2, =0x00400000
+	str r2, [r0, #0x890]
+	str r2, [r1, #0x890]
+	ldr r2, =0x00055555
+	str r2, [r1, #0x8bc]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0xf3333333
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+	str r2, [r1, #0x82c]
+	str r2, [r1, #0x830]
+	str r2, [r1, #0x834]
+	str r2, [r1, #0x838]
+
+	ldr r2, =0x49383b39
+	str r2, [r0, #0x848]
+	ldr r2, =0x30364738
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x3e3c3846
+	str r2, [r1, #0x848]
+	ldr r2, =0x4c294b35
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	str r2, [r1, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x00000f00
+	str r2, [r0, #0x858]
+	str r2, [r1, #0x858]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x555a61a5
+	str r2, [r0, #0xc]
+	ldr r2, =0x00020036
+	str r2, [r0, #0x4]
+	ldr r2, =0x00160e83
+	str r2, [r0, #0x10]
+	ldr r2, =0x000000dd
+	str r2, [r0, #0x14]
+	ldr r2, =0x0008174C
+	str r2, [r0, #0x18]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x2c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x30]
+	ldr r2, =0x200aac
+	str r2, [r0, #0x38]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x8]
+
+	ldr r2, =0x0000005f
+	str r2, [r0, #0x40]
+
+	ldr r2, =0xc3010000
+	str r2, [r0, #0x0]
+
+	ldr r2, =0x555a61a5
+	str r2, [r1, #0xc]
+	ldr r2, =0x00020036
+	str r2, [r1, #0x4]
+	ldr r2, =0x00160e83
+	str r2, [r1, #0x10]
+	ldr r2, =0x000000dd
+	str r2, [r1, #0x14]
+	ldr r2, =0x0008174C
+	str r2, [r1, #0x18]
+	ldr r2, =0x0f9f26d2
+	str r2, [r1, #0x2c]
+	ldr r2, =0x0000020e
+	str r2, [r1, #0x30]
+	ldr r2, =0x00200aac
+	str r2, [r1, #0x38]
+	ldr r2, =0x00000000
+	str r2, [r1, #0x8]
+
+	ldr r2, =0x0000003f
+	str r2, [r1, #0x40]
+
+	ldr r2, =0xc3010000
+	str r2, [r1, #0x0]
+
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x1c]
+	ldr r2, =0xc2018030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r0, #0x1c]
+	ldr r2, =0x02038030
+	str r2, [r0, #0x1c]
+
+	ldr r2, =0x003f8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xff0a8030
+	str r2, [r1, #0x1c]
+	ldr r2, =0xc2018030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x06028030
+	str r2, [r1, #0x1c]
+	ldr r2, =0x02038030
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	str r2, [r1, #0x800]
+
+	ldr r2, =0x00007800
+	str r2, [r0, #0x20]
+	str r2, [r1, #0x20]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+	str r2, [r1, #0x800]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x1c]
+	str r2, [r1, #0x1c]
+
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6_ddr_setting
+	#if defined (CONFIG_MX6DQ_LPDDR2)
+	imx6dqarm2_lpddr2_setting
+	#elif defined (CONFIG_MX6Q)
+	imx6dqarm2_ddr_setting
+	#elif defined (CONFIG_MX6DL_LPDDR2)
+	imx6dlarm2_lpddr2_setting
+	#elif defined (CONFIG_MX6DL)
+	imx6dlarm2_ddr_setting
+	#else
+	#error "SOC not configured"
+	#endif
+.endm
+
+.macro imx6_clock_gating
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6qsabreauto/Makefile b/board/freescale/mx6qsabreauto/Makefile
index ac5bc81..89e6cae 100644
--- a/board/freescale/mx6qsabreauto/Makefile
+++ b/board/freescale/mx6qsabreauto/Makefile
@@ -1,9 +1,13 @@
 #
 # Copyright (C) 2007, Guennadi Liakhovetski <lg@denx.de>
 #
-# (C) Copyright 2011 Freescale Semiconductor, Inc.
+# (C) Copyright 2011-2014 Freescale Semiconductor, Inc.
 #
 # SPDX-License-Identifier:	GPL-2.0+
 #
 
 obj-y  := mx6qsabreauto.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6qsabreauto/imximage.cfg b/board/freescale/mx6qsabreauto/imximage.cfg
deleted file mode 100644
index 16bf473..0000000
--- a/board/freescale/mx6qsabreauto/imximage.cfg
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
- *
- * SPDX-License-Identifier:	GPL-2.0+
- *
- * Refer doc/README.imximage for more details about how-to configure
- * and create imximage boot image
- *
- * The syntax is taken as close as possible with the kwbimage
- */
-/* image version */
-
-IMAGE_VERSION 2
-
-/*
- * Boot Device : one of
- * spi, sd (the board has no nand neither onenand)
- */
-BOOT_FROM	sd
-
-/*
- * Device Configuration Data (DCD)
- *
- * Each entry must have the format:
- * Addr-type           Address        Value
- *
- * where:
- *	Addr-type register length (1,2 or 4 bytes)
- *	Address	  absolute address of the register
- *	value	  value to be stored in the register
- */
-DATA 4 0x020e0798 0x000C0000
-DATA 4 0x020e0758 0x00000000
-DATA 4 0x020e0588 0x00000030
-DATA 4 0x020e0594 0x00000030
-DATA 4 0x020e056c 0x00000030
-DATA 4 0x020e0578 0x00000030
-DATA 4 0x020e074c 0x00000030
-DATA 4 0x020e057c 0x00000030
-DATA 4 0x020e058c 0x00000000
-DATA 4 0x020e059c 0x00000030
-DATA 4 0x020e05a0 0x00000030
-DATA 4 0x020e078c 0x00000030
-DATA 4 0x020e0750 0x00020000
-DATA 4 0x020e05a8 0x00000028
-DATA 4 0x020e05b0 0x00000028
-DATA 4 0x020e0524 0x00000028
-DATA 4 0x020e051c 0x00000028
-DATA 4 0x020e0518 0x00000028
-DATA 4 0x020e050c 0x00000028
-DATA 4 0x020e05b8 0x00000028
-DATA 4 0x020e05c0 0x00000028
-DATA 4 0x020e0774 0x00020000
-DATA 4 0x020e0784 0x00000028
-DATA 4 0x020e0788 0x00000028
-DATA 4 0x020e0794 0x00000028
-DATA 4 0x020e079c 0x00000028
-DATA 4 0x020e07a0 0x00000028
-DATA 4 0x020e07a4 0x00000028
-DATA 4 0x020e07a8 0x00000028
-DATA 4 0x020e0748 0x00000028
-DATA 4 0x020e05ac 0x00000028
-DATA 4 0x020e05b4 0x00000028
-DATA 4 0x020e0528 0x00000028
-DATA 4 0x020e0520 0x00000028
-DATA 4 0x020e0514 0x00000028
-DATA 4 0x020e0510 0x00000028
-DATA 4 0x020e05bc 0x00000028
-DATA 4 0x020e05c4 0x00000028
-DATA 4 0x021b0800 0xa1390003
-DATA 4 0x021b080c 0x001F001F
-DATA 4 0x021b0810 0x001F001F
-DATA 4 0x021b480c 0x001F001F
-DATA 4 0x021b4810 0x001F001F
-DATA 4 0x021b083c 0x43260335
-DATA 4 0x021b0840 0x031A030B
-DATA 4 0x021b483c 0x4323033B
-DATA 4 0x021b4840 0x0323026F
-DATA 4 0x021b0848 0x483D4545
-DATA 4 0x021b4848 0x44433E48
-DATA 4 0x021b0850 0x41444840
-DATA 4 0x021b4850 0x4835483E
-DATA 4 0x021b081c 0x33333333
-DATA 4 0x021b0820 0x33333333
-DATA 4 0x021b0824 0x33333333
-DATA 4 0x021b0828 0x33333333
-DATA 4 0x021b481c 0x33333333
-DATA 4 0x021b4820 0x33333333
-DATA 4 0x021b4824 0x33333333
-DATA 4 0x021b4828 0x33333333
-DATA 4 0x021b08b8 0x00000800
-DATA 4 0x021b48b8 0x00000800
-DATA 4 0x021b0004 0x00020036
-DATA 4 0x021b0008 0x09444040
-DATA 4 0x021b000c 0x8A8F7955
-DATA 4 0x021b0010 0xFF328F64
-DATA 4 0x021b0014 0x01FF00DB
-DATA 4 0x021b0018 0x00001740
-DATA 4 0x021b001c 0x00008000
-DATA 4 0x021b002c 0x000026d2
-DATA 4 0x021b0030 0x008F1023
-DATA 4 0x021b0040 0x00000047
-DATA 4 0x021b0000 0x841A0000
-DATA 4 0x021b001c 0x04088032
-DATA 4 0x021b001c 0x00008033
-DATA 4 0x021b001c 0x00048031
-DATA 4 0x021b001c 0x09408030
-DATA 4 0x021b001c 0x04008040
-DATA 4 0x021b0020 0x00005800
-DATA 4 0x021b0818 0x00011117
-DATA 4 0x021b4818 0x00011117
-DATA 4 0x021b0004 0x00025576
-DATA 4 0x021b0404 0x00011006
-DATA 4 0x021b001c 0x00000000
-
-/* set the default clock gate to save power */
-DATA 4 0x020c4068 0x00C03F3F
-DATA 4 0x020c406c 0x0030FC03
-DATA 4 0x020c4070 0x0FFFC000
-DATA 4 0x020c4074 0x3FF00000
-DATA 4 0x020c4078 0xFFFFF300
-DATA 4 0x020c407c 0x0F0000F3
-DATA 4 0x020c4080 0x00000FFF
-
-/* enable AXI cache for VDOA/VPU/IPU */
-DATA 4 0x020e0010 0xF00000CF
-/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
-DATA 4 0x020e0018 0x007F007F
-DATA 4 0x020e001c 0x007F007F
diff --git a/board/freescale/mx6qsabreauto/mx6dl.cfg b/board/freescale/mx6qsabreauto/mx6dl.cfg
new file mode 100644
index 0000000..e491c63
--- /dev/null
+++ b/board/freescale/mx6qsabreauto/mx6dl.cfg
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
+ */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4, 0x020e0774, 0x000C0000
+DATA 4, 0x020e0754, 0x00000000
+DATA 4, 0x020e04ac, 0x00000030
+DATA 4, 0x020e04b0, 0x00000030
+DATA 4, 0x020e0464, 0x00000030
+DATA 4, 0x020e0490, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e0494, 0x00000030
+DATA 4, 0x020e04a0, 0x00000000
+DATA 4, 0x020e04b4, 0x00000030
+DATA 4, 0x020e04b8, 0x00000030
+DATA 4, 0x020e076c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e04bc, 0x00000028
+DATA 4, 0x020e04c0, 0x00000028
+DATA 4, 0x020e04c4, 0x00000028
+DATA 4, 0x020e04c8, 0x00000028
+DATA 4, 0x020e04cc, 0x00000028
+DATA 4, 0x020e04d0, 0x00000028
+DATA 4, 0x020e04d4, 0x00000028
+DATA 4, 0x020e04d8, 0x00000028
+DATA 4, 0x020e0760, 0x00020000
+DATA 4, 0x020e0764, 0x00000028
+DATA 4, 0x020e0770, 0x00000028
+DATA 4, 0x020e0778, 0x00000028
+DATA 4, 0x020e077c, 0x00000028
+DATA 4, 0x020e0780, 0x00000028
+DATA 4, 0x020e0784, 0x00000028
+DATA 4, 0x020e078c, 0x00000028
+DATA 4, 0x020e0748, 0x00000028
+DATA 4, 0x020e0470, 0x00000028
+DATA 4, 0x020e0474, 0x00000028
+DATA 4, 0x020e0478, 0x00000028
+DATA 4, 0x020e047c, 0x00000028
+DATA 4, 0x020e0480, 0x00000028
+DATA 4, 0x020e0484, 0x00000028
+DATA 4, 0x020e0488, 0x00000028
+DATA 4, 0x020e048c, 0x00000028
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b480c, 0x001F001F
+DATA 4, 0x021b4810, 0x001F001F
+DATA 4, 0x021b083c, 0x42190217
+DATA 4, 0x021b0840, 0x017B017B
+DATA 4, 0x021b483c, 0x4176017B
+DATA 4, 0x021b4840, 0x015F016C
+DATA 4, 0x021b0848, 0x4C4C4D4C
+DATA 4, 0x021b4848, 0x4A4D4C48
+DATA 4, 0x021b0850, 0x3F3F3F40
+DATA 4, 0x021b4850, 0x3538382E
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b481c, 0x33333333
+DATA 4, 0x021b4820, 0x33333333
+DATA 4, 0x021b4824, 0x33333333
+DATA 4, 0x021b4828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b48b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020025
+DATA 4, 0x021b0008, 0x00333030
+DATA 4, 0x021b000c, 0x676B5313
+DATA 4, 0x021b0010, 0xB66E8B63
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x006B1023
+DATA 4, 0x021b0040, 0x00000047
+DATA 4, 0x021b0000, 0x841A0000
+DATA 4, 0x021b001c, 0x04008032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x05208030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b4818, 0x00011117
+DATA 4, 0x021b0004, 0x00025565
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0xFFFFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
diff --git a/board/freescale/mx6qsabreauto/mx6q.cfg b/board/freescale/mx6qsabreauto/mx6q.cfg
new file mode 100644
index 0000000..d3c249b
--- /dev/null
+++ b/board/freescale/mx6qsabreauto/mx6q.cfg
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer doc/README.imximage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
+ */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4 0x020e0798 0x000C0000
+DATA 4 0x020e0758 0x00000000
+DATA 4 0x020e0588 0x00000030
+DATA 4 0x020e0594 0x00000030
+DATA 4 0x020e056c 0x00000030
+DATA 4 0x020e0578 0x00000030
+DATA 4 0x020e074c 0x00000030
+DATA 4 0x020e057c 0x00000030
+DATA 4 0x020e058c 0x00000000
+DATA 4 0x020e059c 0x00000030
+DATA 4 0x020e05a0 0x00000030
+DATA 4 0x020e078c 0x00000030
+DATA 4 0x020e0750 0x00020000
+DATA 4 0x020e05a8 0x00000028
+DATA 4 0x020e05b0 0x00000028
+DATA 4 0x020e0524 0x00000028
+DATA 4 0x020e051c 0x00000028
+DATA 4 0x020e0518 0x00000028
+DATA 4 0x020e050c 0x00000028
+DATA 4 0x020e05b8 0x00000028
+DATA 4 0x020e05c0 0x00000028
+DATA 4 0x020e0774 0x00020000
+DATA 4 0x020e0784 0x00000028
+DATA 4 0x020e0788 0x00000028
+DATA 4 0x020e0794 0x00000028
+DATA 4 0x020e079c 0x00000028
+DATA 4 0x020e07a0 0x00000028
+DATA 4 0x020e07a4 0x00000028
+DATA 4 0x020e07a8 0x00000028
+DATA 4 0x020e0748 0x00000028
+DATA 4 0x020e05ac 0x00000028
+DATA 4 0x020e05b4 0x00000028
+DATA 4 0x020e0528 0x00000028
+DATA 4 0x020e0520 0x00000028
+DATA 4 0x020e0514 0x00000028
+DATA 4 0x020e0510 0x00000028
+DATA 4 0x020e05bc 0x00000028
+DATA 4 0x020e05c4 0x00000028
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b080c 0x001F001F
+DATA 4 0x021b0810 0x001F001F
+DATA 4 0x021b480c 0x001F001F
+DATA 4 0x021b4810 0x001F001F
+DATA 4 0x021b083c 0x43260335
+DATA 4 0x021b0840 0x031A030B
+DATA 4 0x021b483c 0x4323033B
+DATA 4 0x021b4840 0x0323026F
+DATA 4 0x021b0848 0x483D4545
+DATA 4 0x021b4848 0x44433E48
+DATA 4 0x021b0850 0x41444840
+DATA 4 0x021b4850 0x4835483E
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b481c 0x33333333
+DATA 4 0x021b4820 0x33333333
+DATA 4 0x021b4824 0x33333333
+DATA 4 0x021b4828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+DATA 4 0x021b0004 0x00020036
+DATA 4 0x021b0008 0x09444040
+DATA 4 0x021b000c 0x8A8F7955
+DATA 4 0x021b0010 0xFF328F64
+DATA 4 0x021b0014 0x01FF00DB
+DATA 4 0x021b0018 0x00001740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x008F1023
+DATA 4 0x021b0040 0x00000047
+DATA 4 0x021b0000 0x841A0000
+DATA 4 0x021b001c 0x04088032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00048031
+DATA 4 0x021b001c 0x09408030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00005800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b4818 0x00011117
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0xFFFFF300
+DATA 4, 0x020c407c, 0x0F0000F3
+DATA 4, 0x020c4080, 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
diff --git a/board/freescale/mx6qsabreauto/mx6qsabreauto.c b/board/freescale/mx6qsabreauto/mx6qsabreauto.c
index 928dadf..e12c5bc 100644
--- a/board/freescale/mx6qsabreauto/mx6qsabreauto.c
+++ b/board/freescale/mx6qsabreauto/mx6qsabreauto.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2015 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -12,6 +12,7 @@
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/iomux.h>
 #include <asm/arch/mx6-pins.h>
+#include <asm/arch/crm_regs.h>
 #include <asm/errno.h>
 #include <asm/gpio.h>
 #include <asm/imx-common/iomux-v3.h>
@@ -22,10 +23,30 @@
 #include <miiphy.h>
 #include <netdev.h>
 #include <asm/arch/sys_proto.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <linux/fb.h>
+#include <ipu_pixfmt.h>
+
 #include <i2c.h>
 
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FASTBOOT*/
+
+#ifdef CONFIG_MAX7310_IOEXP
+#include <gpio_exp.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
+#define I2C_EXP_RST IMX_GPIO_NR(1, 15)
+#define I2C3_STEER  IMX_GPIO_NR(5, 4)
 #define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
 	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
@@ -34,6 +55,11 @@ DECLARE_GLOBAL_DATA_PTR;
 	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
 	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
 
+/*Need more drive strength for SD1 slot on base board*/
+#define USDHC1_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |               \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
 #define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
 	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
 
@@ -43,9 +69,23 @@ DECLARE_GLOBAL_DATA_PTR;
 
 #define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
 
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_PUS_100K_DOWN | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm     | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
 int dram_init(void)
 {
-	gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
+	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
 
 	return 0;
 }
@@ -71,6 +111,7 @@ iomux_v3_cfg_t const enet_pads[] = {
 	MX6_PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL),
 	MX6_PAD_RGMII_RX_CTL__RGMII_RX_CTL	| MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6_PAD_GPIO_16__ENET_REF_CLK		| MUX_PAD_CTRL(ENET_PAD_CTRL),
 };
 
 /* I2C2 PMIC, iPod, Tuner, Codec, Touch, HDMI EDID, MIPI CSI2 card */
@@ -117,6 +158,19 @@ static void setup_iomux_enet(void)
 	imx_iomux_v3_setup_multiple_pads(enet_pads, ARRAY_SIZE(enet_pads));
 }
 
+iomux_v3_cfg_t const usdhc1_pads[] = {
+	/*To avoid pin conflict with NAND, set usdhc1 to 4 pins*/
+	MX6_PAD_SD1_CLK__SD1_CLK	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_CMD__SD1_CMD	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_DAT0__SD1_DATA0	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_DAT1__SD1_DATA1	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_DAT2__SD1_DATA2	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+	MX6_PAD_SD1_DAT3__SD1_DATA3	| MUX_PAD_CTRL(USDHC1_PAD_CTRL),
+
+	/*CD pin*/
+	MX6_PAD_GPIO_1__GPIO1_IO01 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
 iomux_v3_cfg_t const usdhc3_pads[] = {
 	MX6_PAD_SD3_CLK__SD3_CLK	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
 	MX6_PAD_SD3_CMD__SD3_CMD	| MUX_PAD_CTRL(USDHC_PAD_CTRL),
@@ -132,31 +186,452 @@ iomux_v3_cfg_t const usdhc3_pads[] = {
 	MX6_PAD_NANDF_CS2__GPIO6_IO15   | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
+#ifdef CONFIG_SYS_I2C_MXC
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0 ;
+	i2c_set_bus_num(1);
+	if (!i2c_probe(0x8)) {
+		if (i2c_read(0x8, 0, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(0x8, 3, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE100! deviceid=%x,revid=%x\n", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/* set SW1AB staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x21, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x21, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x24, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x24, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x2f, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x2f, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x32, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x32, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		/* increase VDDARM to 1.425V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.425V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+	}
+}
+#endif
+#endif
+
 static void setup_iomux_uart(void)
 {
 	imx_iomux_v3_setup_multiple_pads(uart4_pads, ARRAY_SIZE(uart4_pads));
 }
 
 #ifdef CONFIG_FSL_ESDHC
-struct fsl_esdhc_cfg usdhc_cfg[1] = {
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(1, 1)
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(6, 15)
+
+struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC1_BASE_ADDR, 0, 4},
 	{USDHC3_BASE_ADDR},
 };
 
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc3 device id
+	 * see the comments in board_mmc_init function
+	 */
+	if (2 == dev_no)
+		dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	if (1 == dev_no)
+		dev_no = 2;
+
+	return dev_no;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
-	gpio_direction_input(IMX_GPIO_NR(6, 15));
-	return !gpio_get_value(IMX_GPIO_NR(6, 15));
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
 }
 
 int board_mmc_init(bd_t *bis)
 {
-	imx_iomux_v3_setup_multiple_pads(usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+	int i;
+
+	/*
+	* According to the board_mmc_init() the following map is done:
+	* (U-boot device node)    (Physical Port)
+	* mmc0				USDHC1
+	* mmc1				USDHC3
+	*/
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
 
-	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
-	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_EIM_D19__GPIO3_IO19  | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* Steer logic */
+	MX6_PAD_EIM_A24__GPIO5_IO04  | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+	gpio_direction_output(IMX_GPIO_NR(3, 19), 0);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+iomux_v3_cfg_t eimnor_pads[] = {
+	MX6_PAD_EIM_D16__EIM_DATA16      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D17__EIM_DATA17      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D18__EIM_DATA18      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D19__EIM_DATA19      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D20__EIM_DATA20      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D21__EIM_DATA21      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D22__EIM_DATA22      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D23__EIM_DATA23      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D24__EIM_DATA24      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D25__EIM_DATA25      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D26__EIM_DATA26      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D27__EIM_DATA27      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D28__EIM_DATA28      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D29__EIM_DATA29      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D30__EIM_DATA30      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_D31__EIM_DATA31      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA0__EIM_AD00    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA1__EIM_AD01    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA2__EIM_AD02    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA3__EIM_AD03    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA4__EIM_AD04    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA5__EIM_AD05    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA6__EIM_AD06    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA7__EIM_AD07    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA8__EIM_AD08    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA9__EIM_AD09    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA10__EIM_AD10   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA11__EIM_AD11   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL) ,
+	MX6_PAD_EIM_DA12__EIM_AD12   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA13__EIM_AD13   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA14__EIM_AD14   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_DA15__EIM_AD15   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A16__EIM_ADDR16      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A17__EIM_ADDR17      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A18__EIM_ADDR18      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A19__EIM_ADDR19      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A20__EIM_ADDR20      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A21__EIM_ADDR21      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A22__EIM_ADDR22      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_A23__EIM_ADDR23      | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6_PAD_EIM_OE__EIM_OE_B         | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EIM_RW__EIM_RW           | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EIM_CS0__EIM_CS0_B       | MUX_PAD_CTRL(NO_PAD_CTRL),
+	/* Steer logic */
+	MX6_PAD_EIM_A24__GPIO5_IO04      | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
+	writel(0x00020181, WEIM_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
+	writel(0x0a020000, WEIM_BASE_ADDR + 0x008);
+	writel(0x0000c000, WEIM_BASE_ADDR + 0x00c);
+	writel(0x0804a240, WEIM_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads,
+			ARRAY_SIZE(eimnor_pads));
+
+	gpio_direction_output(IMX_GPIO_NR(5, 4), 0);
+
+	eimnor_cs_setup();
 }
 #endif
 
+#ifdef CONFIG_SYS_USE_NAND
+iomux_v3_cfg_t gpmi_pads[] = {
+	MX6_PAD_NANDF_CLE__NAND_CLE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_ALE__NAND_ALE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_WP_B__NAND_WP_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_RB0__NAND_READY_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL0),
+	MX6_PAD_NANDF_CS0__NAND_CE0_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_SD4_CMD__NAND_RE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_SD4_CLK__NAND_WE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D0__NAND_DATA00	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D1__NAND_DATA01	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D2__NAND_DATA02	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D3__NAND_DATA03	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D4__NAND_DATA04	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D5__NAND_DATA05	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D6__NAND_DATA06	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_NANDF_D7__NAND_DATA07	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6_PAD_SD4_DAT0__NAND_DQS		| MUX_PAD_CTRL(GPMI_PAD_CTRL1),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	/* gate ENFC_CLK_ROOT clock first,before clk source switch */
+	clrbits_le32(&mxc_ccm->CCGR2, MXC_CCM_CCGR2_IOMUX_IPT_CLK_IO_MASK);
+
+	/* config gpmi and bch clock to 100 MHz */
+	clrsetbits_le32(&mxc_ccm->cs2cdr,
+			MXC_CCM_CS2CDR_ENFC_CLK_PODF_MASK |
+			MXC_CCM_CS2CDR_ENFC_CLK_PRED_MASK |
+			MXC_CCM_CS2CDR_ENFC_CLK_SEL_MASK,
+			MXC_CCM_CS2CDR_ENFC_CLK_PODF(0) |
+			MXC_CCM_CS2CDR_ENFC_CLK_PRED(3) |
+			MXC_CCM_CS2CDR_ENFC_CLK_SEL(3));
+
+	/* enable ENFC_CLK_ROOT clock */
+	setbits_le32(&mxc_ccm->CCGR2, MXC_CCM_CCGR2_IOMUX_IPT_CLK_IO_MASK);
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_OFFSET);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_MAX7310_IOEXP
+void reset_max7310(void)
+{
+	gpio_direction_output(I2C_EXP_RST, 1);
+	imx_iomux_v3_setup_multiple_pads(port_exp,
+					ARRAY_SIZE(port_exp));
+}
+
+int setup_max7310(void)
+{
+#ifdef CONFIG_SYS_I2C_MXC
+	/* set steering config to i2c,
+	  * note: this causes pin conflicts with eimnor and spinor
+	  */
+    gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
+	imx_iomux_v3_setup_multiple_pads(i2c3_pads,
+					ARRAY_SIZE(i2c3_pads));
+
+	/*setup i2c info 2*/
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+
+	gpio_exp_setup_port(1, 2, 0x30);
+	gpio_exp_setup_port(2, 2, 0x32);
+	gpio_exp_setup_port(3, 2, 0x34);
+
+	return 0;
+#else
+	return -EPERM;
+#endif
+}
+#endif
 int mx6_rgmii_rework(struct phy_device *phydev)
 {
 	unsigned short val;
@@ -190,6 +665,200 @@ int board_phy_config(struct phy_device *phydev)
 	return 0;
 }
 
+#if defined(CONFIG_VIDEO_IPUV3)
+struct display_info_t {
+	int	bus;
+	int	addr;
+	int	pixfmt;
+	int	(*detect)(struct display_info_t const *dev);
+	void	(*enable)(struct display_info_t const *dev);
+	struct	fb_videomode mode;
+};
+
+static void disable_lvds(struct display_info_t const *dev)
+{
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+
+	int reg = readl(&iomux->gpr[2]);
+
+	reg &= ~(IOMUXC_GPR2_LVDS_CH0_MODE_MASK |
+		 IOMUXC_GPR2_LVDS_CH1_MODE_MASK);
+
+	writel(reg, &iomux->gpr[2]);
+}
+
+static void do_enable_hdmi(struct display_info_t const *dev)
+{
+	disable_lvds(dev);
+	imx_enable_hdmi_phy();
+}
+
+static struct display_info_t const displays[] = {{
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB666,
+	.detect	= NULL,
+	.enable	= NULL,
+	.mode	= {
+		.name           = "Hannstar-XGA",
+		.refresh        = 60,
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = FB_SYNC_EXT,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.bus	= -1,
+	.addr	= 0,
+	.pixfmt	= IPU_PIX_FMT_RGB24,
+	.detect	= NULL,
+	.enable	= do_enable_hdmi,
+	.mode	= {
+		.name           = "HDMI",
+		.refresh        = 60,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+
+	if (!panel) {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			struct display_info_t const *dev = displays+i;
+			if (dev->detect && dev->detect(dev)) {
+				panel = dev->mode.name;
+				printf("auto-detected panel %s\n", panel);
+				break;
+			}
+		}
+		if (!panel) {
+			panel = displays[0].mode.name;
+			printf("No panel detected: default to %s\n", panel);
+			i = 0;
+		}
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+
+	if (i < ARRAY_SIZE(displays)) {
+		ret = ipuv3_fb_init(&displays[i].mode, 0,
+				    displays[i].pixfmt);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+iomux_v3_cfg_t const backlight_pads[] = {
+	MX6_PAD_SD4_DAT1__GPIO2_IO09 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_backlight(void)
+{
+	gpio_direction_output(IMX_GPIO_NR(2, 9), 1);
+	imx_iomux_v3_setup_multiple_pads(backlight_pads,
+					 ARRAY_SIZE(backlight_pads));
+}
+
+static void setup_display(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
+	int reg;
+
+	setup_iomux_backlight();
+	enable_ipu_clock();
+	imx_setup_hdmi();
+
+	/* Turn on LDB_DI0 and LDB_DI1 clocks */
+	reg = readl(&mxc_ccm->CCGR3);
+	reg |= MXC_CCM_CCGR3_LDB_DI0_MASK | MXC_CCM_CCGR3_LDB_DI1_MASK;
+	writel(reg, &mxc_ccm->CCGR3);
+
+	/* Set LDB_DI0 and LDB_DI1 clk select to 3b'011 */
+	reg = readl(&mxc_ccm->cs2cdr);
+	reg &= ~(MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_MASK |
+		 MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_MASK);
+	reg |= (3 << MXC_CCM_CS2CDR_LDB_DI0_CLK_SEL_OFFSET) |
+	       (3 << MXC_CCM_CS2CDR_LDB_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->cs2cdr);
+
+	reg = readl(&mxc_ccm->cscmr2);
+	reg |= MXC_CCM_CSCMR2_LDB_DI0_IPU_DIV | MXC_CCM_CSCMR2_LDB_DI1_IPU_DIV;
+	writel(reg, &mxc_ccm->cscmr2);
+
+	reg = readl(&mxc_ccm->chsccdr);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0 <<
+		MXC_CCM_CHSCCDR_IPU1_DI0_CLK_SEL_OFFSET);
+	reg |= (CHSCCDR_CLK_SEL_LDB_DI0 <<
+		MXC_CCM_CHSCCDR_IPU1_DI1_CLK_SEL_OFFSET);
+	writel(reg, &mxc_ccm->chsccdr);
+
+	reg = IOMUXC_GPR2_DI1_VS_POLARITY_ACTIVE_LOW |
+	      IOMUXC_GPR2_DI0_VS_POLARITY_ACTIVE_LOW |
+	      IOMUXC_GPR2_BIT_MAPPING_CH1_SPWG |
+	      IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT |
+	      IOMUXC_GPR2_BIT_MAPPING_CH0_SPWG |
+	      IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT |
+	      IOMUXC_GPR2_LVDS_CH0_MODE_ENABLED_DI0 |
+	      IOMUXC_GPR2_LVDS_CH1_MODE_DISABLED;
+	writel(reg, &iomux->gpr[2]);
+
+	reg = readl(&iomux->gpr[3]);
+	reg &= ~(IOMUXC_GPR3_LVDS0_MUX_CTL_MASK |
+		 IOMUXC_GPR3_HDMI_MUX_CTL_MASK);
+	reg |= (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
+		IOMUXC_GPR3_LVDS0_MUX_CTL_OFFSET) |
+	       (IOMUXC_GPR3_MUX_SRC_IPU1_DI0 <<
+		IOMUXC_GPR3_HDMI_MUX_CTL_OFFSET);
+	writel(reg, &iomux->gpr[3]);
+}
+#endif /* CONFIG_VIDEO_IPUV3 */
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+#ifdef CONFIG_FEC_MXC
 int board_eth_init(bd_t *bis)
 {
 	setup_iomux_enet();
@@ -197,6 +866,19 @@ int board_eth_init(bd_t *bis)
 	return cpu_eth_init(bis);
 }
 
+static int setup_fec(void)
+{
+	int ret;
+
+	mxc_iomux_set_gpr_register(1, 21, 1, 1);
+	ret = enable_fec_anatop_clock(0, ENET_125MHz);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+#endif
+
 #define BOARD_REV_B  0x200
 #define BOARD_REV_A  0x100
 
@@ -238,6 +920,30 @@ int board_early_init_f(void)
 {
 	setup_iomux_uart();
 
+#ifdef CONFIG_MAX7310_IOEXP
+	/*Reset gpio expander at early stage*/
+	reset_max7310();
+#endif
+
+#if defined(CONFIG_VIDEO_IPUV3)
+	setup_display();
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
 	return 0;
 }
 
@@ -246,16 +952,6 @@ int board_init(void)
 	/* address of boot parameters */
 	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
 
-	/* I2C 2 and 3 setup - I2C 3 hw mux with EIM */
-	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
-	/* I2C 3 Steer */
-	gpio_direction_output(IMX_GPIO_NR(5, 4), 1);
-	imx_iomux_v3_setup_multiple_pads(i2c3_pads, ARRAY_SIZE(i2c3_pads));
-	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
-
-	gpio_direction_output(IMX_GPIO_NR(1, 15), 1);
-	imx_iomux_v3_setup_multiple_pads(port_exp, ARRAY_SIZE(port_exp));
-
 	return 0;
 }
 
@@ -269,13 +965,152 @@ static const struct boot_mode board_boot_modes[] = {
 
 int board_late_init(void)
 {
+	int ret;
 #ifdef CONFIG_CMD_BMODE
 	add_board_boot_modes(board_boot_modes);
 #endif
 
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_MAX7310_IOEXP
+	setup_max7310();
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
 	return 0;
 }
 
+#ifdef CONFIG_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "sata");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti sata");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};booti ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(5, 14)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_DISP0_DAT20__GPIO5_IO14 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti sata recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};booti ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
 int checkboard(void)
 {
 	int rev = mx6sabre_rev();
@@ -291,7 +1126,72 @@ int checkboard(void)
 		break;
 	}
 
-	printf("Board: MX6Q-Sabreauto rev%s\n", revname);
+	printf("Board: MX6-Sabreauto rev%s\n", revname);
+
+	return 0;
+}
+
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const otg_udc_pads[] = {
+	(MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+		ARRAY_SIZE(otg_udc_pads));
+
+	/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+    mxc_iomux_set_gpr_register(1, 13, 1, 0);
+}
+
+#endif /*CONFIG_IMX_UDC*/
+
+#ifdef CONFIG_USB_EHCI_MX6
+#define USB_HOST1_PWR     IOEXP_GPIO_NR(2, 7)
+#define USB_OTG_PWR       IOEXP_GPIO_NR(3, 1)
+
+iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+			ARRAY_SIZE(usb_otg_pads));
+
+		/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+		mxc_iomux_set_gpr_register(1, 13, 1, 0);
+		break;
+	case 1:
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
 
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		if (on)
+			gpio_exp_direction_output(USB_OTG_PWR, 1);
+		else
+			gpio_exp_direction_output(USB_OTG_PWR, 0);
+		break;
+	case 1:
+		if (on)
+			gpio_exp_direction_output(USB_HOST1_PWR, 1);
+		else
+			gpio_exp_direction_output(USB_HOST1_PWR, 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
 	return 0;
 }
+#endif
diff --git a/board/freescale/mx6qsabreauto/mx6solo.cfg b/board/freescale/mx6qsabreauto/mx6solo.cfg
new file mode 100644
index 0000000..011042b
--- /dev/null
+++ b/board/freescale/mx6qsabreauto/mx6solo.cfg
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, eimnor, nand, sata:
+ * spinor: flash_offset: 0x0400
+ * nand:   flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ * eimnor: flash_offset: 0x1000
+ */
+
+#if defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else /* others has the same flash_offset as sd */
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6qsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+DATA 4, 0x020e0774, 0x000C0000
+DATA 4, 0x020e0754, 0x00000000
+DATA 4, 0x020e04ac, 0x00000030
+DATA 4, 0x020e04b0, 0x00000030
+DATA 4, 0x020e0464, 0x00000030
+DATA 4, 0x020e0490, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e0494, 0x00000030
+DATA 4, 0x020e04a0, 0x00000000
+DATA 4, 0x020e04b4, 0x00000030
+DATA 4, 0x020e04b8, 0x00000030
+DATA 4, 0x020e076c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e04bc, 0x00000028
+DATA 4, 0x020e04c0, 0x00000028
+DATA 4, 0x020e04c4, 0x00000028
+DATA 4, 0x020e04c8, 0x00000028
+DATA 4, 0x020e0760, 0x00020000
+DATA 4, 0x020e0764, 0x00000028
+DATA 4, 0x020e0770, 0x00000028
+DATA 4, 0x020e0778, 0x00000028
+DATA 4, 0x020e077c, 0x00000028
+DATA 4, 0x020e0470, 0x00000028
+DATA 4, 0x020e0474, 0x00000028
+DATA 4, 0x020e0478, 0x00000028
+DATA 4, 0x020e047c, 0x00000028
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b083c, 0x421C0216
+DATA 4, 0x021b0840, 0x017B017A
+DATA 4, 0x021b0848, 0x4B4A4E4C
+DATA 4, 0x021b0850, 0x3F3F3334
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b0004, 0x00020025
+DATA 4, 0x021b0008, 0x00333030
+DATA 4, 0x021b000c, 0x676B5313
+DATA 4, 0x021b0010, 0xB66E8B63
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x006B1023
+DATA 4, 0x021b0040, 0x00000027
+DATA 4, 0x021b0000, 0x84190000
+DATA 4, 0x021b001c, 0x04008032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x05208030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b0004, 0x00025565
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0xFFFFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x00000FFF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
diff --git a/board/freescale/mx6qsabreauto/plugin.S b/board/freescale/mx6qsabreauto/plugin.S
new file mode 100644
index 0000000..eeecac1
--- /dev/null
+++ b/board/freescale/mx6qsabreauto/plugin.S
@@ -0,0 +1,480 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6dqsabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x43260335
+	str r2, [r0, #0x83c]
+	ldr r2, =0x031A030B
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4323033B
+	str r2, [r1, #0x83c]
+	ldr r2, =0x0323026F
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x483D4545
+	str r2, [r0, #0x848]
+	ldr r2, =0x44433E48
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x41444840
+	str r2, [r0, #0x850]
+	ldr r2, =0x4835483E
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x8A8F7955
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF328F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x008F1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000047
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x841A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dlsabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001f001f
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x42190217
+	str r2, [r0, #0x83c]
+	ldr r2, =0x017b017b
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4176017b
+	str r2, [r1, #0x83c]
+	ldr r2, =0x015f016c
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4c4c4d4c
+	str r2, [r0, #0x848]
+	ldr r2, =0x4a4d4c48
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x3f3f3f40
+	str r2, [r0, #0x850]
+	ldr r2, =0x3538382e
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020025
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x676b5313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66e8b63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000047
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x841a0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025565
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6solosabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x421C0216
+	str r2, [r0, #0x83c]
+	ldr r2, =0x017B017A
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4B4A4E4C
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x3F3F3334
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x00020025
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x676B5313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006B1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x84190000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x00025565
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00C03F3F
+	str r1, [r0, #0x068]
+	ldr r1, =0x0030FC03
+	str r1, [r0, #0x06c]
+	ldr r1, =0x0FFFC000
+	str r1, [r0, #0x070]
+	ldr r1, =0x3FF00000
+	str r1, [r0, #0x074]
+	ldr r1, =0xFFFFF300
+	str r1, [r0, #0x078]
+	ldr r1, =0x0F0000C3
+	str r1, [r0, #0x07c]
+	ldr r1, =0x00000FFF
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_MX6SOLO)
+	imx6solosabreauto_ddr_setting
+#elif defined (CONFIG_MX6DL)
+	imx6dlsabreauto_ddr_setting
+#elif defined (CONFIG_MX6Q)
+	imx6dqsabreauto_ddr_setting
+#else
+	#error "SOC not configured"
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6sabresd/Makefile b/board/freescale/mx6sabresd/Makefile
index cfca2ef..c5446c9 100644
--- a/board/freescale/mx6sabresd/Makefile
+++ b/board/freescale/mx6sabresd/Makefile
@@ -7,3 +7,7 @@
 #
 
 obj-y  := mx6sabresd.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6sabresd/mx6dl_4x_mt41j128.cfg b/board/freescale/mx6sabresd/mx6dl_4x_mt41j128.cfg
new file mode 100644
index 0000000..0b32482
--- /dev/null
+++ b/board/freescale/mx6sabresd/mx6dl_4x_mt41j128.cfg
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4,	0x020e0774, 0x000C0000
+DATA 4,	0x020e0754, 0x00000000
+DATA 4,	0x020e04ac, 0x00000030
+DATA 4,	0x020e04b0, 0x00000030
+DATA 4,	0x020e0464, 0x00000030
+DATA 4,	0x020e0490, 0x00000030
+DATA 4,	0x020e074c, 0x00000030
+DATA 4,	0x020e0494, 0x00000030
+DATA 4,	0x020e04a0, 0x00000000
+DATA 4,	0x020e04b4, 0x00000030
+DATA 4,	0x020e04b8, 0x00000030
+DATA 4,	0x020e076c, 0x00000030
+DATA 4,	0x020e0750, 0x00020000
+DATA 4,	0x020e04bc, 0x00000030
+DATA 4,	0x020e04c0, 0x00000030
+DATA 4,	0x020e04c4, 0x00000030
+DATA 4,	0x020e04c8, 0x00000030
+DATA 4,	0x020e04cc, 0x00000030
+DATA 4,	0x020e04d0, 0x00000030
+DATA 4,	0x020e04d4, 0x00000030
+DATA 4,	0x020e04d8, 0x00000030
+DATA 4,	0x020e0760, 0x00020000
+DATA 4,	0x020e0764, 0x00000030
+DATA 4,	0x020e0770, 0x00000030
+DATA 4,	0x020e0778, 0x00000030
+DATA 4,	0x020e077c, 0x00000030
+DATA 4,	0x020e0780, 0x00000030
+DATA 4,	0x020e0784, 0x00000030
+DATA 4,	0x020e078c, 0x00000030
+DATA 4,	0x020e0748, 0x00000030
+DATA 4,	0x020e0470, 0x00000030
+DATA 4,	0x020e0474, 0x00000030
+DATA 4,	0x020e0478, 0x00000030
+DATA 4,	0x020e047c, 0x00000030
+DATA 4,	0x020e0480, 0x00000030
+DATA 4,	0x020e0484, 0x00000030
+DATA 4,	0x020e0488, 0x00000030
+DATA 4,	0x020e048c, 0x00000030
+DATA 4,	0x021b0800, 0xa1390003
+DATA 4,	0x021b080c, 0x001F001F
+DATA 4,	0x021b0810, 0x001F001F
+DATA 4,	0x021b480c, 0x001F001F
+DATA 4,	0x021b4810, 0x001F001F
+DATA 4,	0x021b083c, 0x4220021F
+DATA 4,	0x021b0840, 0x0207017E
+DATA 4,	0x021b483c, 0x4201020C
+DATA 4,	0x021b4840, 0x01660172
+DATA 4,	0x021b0848, 0x4A4D4E4D
+DATA 4,	0x021b4848, 0x4A4F5049
+DATA 4,	0x021b0850, 0x3F3C3D31
+DATA 4,	0x021b4850, 0x3238372B
+DATA 4,	0x021b081c, 0x33333333
+DATA 4,	0x021b0820, 0x33333333
+DATA 4,	0x021b0824, 0x33333333
+DATA 4,	0x021b0828, 0x33333333
+DATA 4,	0x021b481c, 0x33333333
+DATA 4,	0x021b4820, 0x33333333
+DATA 4,	0x021b4824, 0x33333333
+DATA 4,	0x021b4828, 0x33333333
+DATA 4,	0x021b08b8, 0x00000800
+DATA 4,	0x021b48b8, 0x00000800
+DATA 4,	0x021b0004, 0x0002002D
+DATA 4,	0x021b0008, 0x00333030
+DATA 4,	0x021b000c, 0x3F435313
+DATA 4,	0x021b0010, 0xB66E8B63
+DATA 4,	0x021b0014, 0x01FF00DB
+DATA 4,	0x021b0018, 0x00001740
+DATA 4,	0x021b001c, 0x00008000
+DATA 4,	0x021b002c, 0x000026d2
+DATA 4,	0x021b0030, 0x00431023
+DATA 4,	0x021b0040, 0x00000027
+DATA 4,	0x021b0000, 0x831A0000
+DATA 4,	0x021b001c, 0x04008032
+DATA 4,	0x021b001c, 0x00008033
+DATA 4,	0x021b001c, 0x00048031
+DATA 4,	0x021b001c, 0x05208030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4,	0x021b0020, 0x00005800
+DATA 4,	0x021b0818, 0x00011117
+DATA 4,	0x021b4818, 0x00011117
+DATA 4,	0x021b0004, 0x0002556D
+DATA 4,	0x021b0404, 0x00011006
+DATA 4,	0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
diff --git a/board/freescale/mx6sabresd/mx6sabresd.c b/board/freescale/mx6sabresd/mx6sabresd.c
index d7d932e..d24eea1 100644
--- a/board/freescale/mx6sabresd/mx6sabresd.c
+++ b/board/freescale/mx6sabresd/mx6sabresd.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -8,6 +8,7 @@
 
 #include <asm/arch/clock.h>
 #include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
 #include <asm/arch/iomux.h>
 #include <asm/arch/mx6-pins.h>
 #include <asm/errno.h>
@@ -18,12 +19,31 @@
 #include <fsl_esdhc.h>
 #include <miiphy.h>
 #include <netdev.h>
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
 #include <asm/arch/mxc_hdmi.h>
 #include <asm/arch/crm_regs.h>
 #include <linux/fb.h>
 #include <ipu_pixfmt.h>
 #include <asm/io.h>
 #include <asm/arch/sys_proto.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#ifdef CONFIG_CMD_SATA
+#include <asm/imx-common/sata.h>
+#endif
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FASTBOOT*/
+
 DECLARE_GLOBAL_DATA_PTR;
 
 #define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
@@ -40,9 +60,34 @@ DECLARE_GLOBAL_DATA_PTR;
 #define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
 		      PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
 
+#define I2C_PAD_CTRL	(PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C2 Camera, MIPI, pfuze */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6_PAD_KEY_COL3__I2C2_SCL | PC,
+		.gpio_mode = MX6_PAD_KEY_COL3__GPIO4_IO12 | PC,
+		.gp = IMX_GPIO_NR(4, 12)
+	},
+	.sda = {
+		.i2c_mode = MX6_PAD_KEY_ROW3__I2C2_SDA | PC,
+		.gpio_mode = MX6_PAD_KEY_ROW3__GPIO4_IO13 | PC,
+		.gp = IMX_GPIO_NR(4, 13)
+	}
+};
+#endif
+
 int dram_init(void)
 {
-	gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
+	gd->ram_size = ((ulong)CONFIG_DDR_MB * 1024 * 1024);
 
 	return 0;
 }
@@ -123,6 +168,7 @@ iomux_v3_cfg_t const usdhc4_pads[] = {
 	MX6_PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 };
 
+#ifdef CONFIG_SYS_USE_SPINOR
 iomux_v3_cfg_t const ecspi1_pads[] = {
 	MX6_PAD_KEY_COL0__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
 	MX6_PAD_KEY_COL1__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
@@ -130,10 +176,12 @@ iomux_v3_cfg_t const ecspi1_pads[] = {
 	MX6_PAD_KEY_ROW1__GPIO4_IO09 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
-static void setup_spi(void)
+static void setup_spinor(void)
 {
 	imx_iomux_v3_setup_multiple_pads(ecspi1_pads, ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 9), 0);
 }
+#endif
 
 iomux_v3_cfg_t const pcie_pads[] = {
 	MX6_PAD_EIM_D19__GPIO3_IO19 | MUX_PAD_CTRL(NO_PAD_CTRL),	/* POWER */
@@ -151,11 +199,307 @@ iomux_v3_cfg_t const di0_pads[] = {
 	MX6_PAD_DI0_PIN3__IPU1_DI0_PIN03,		/* DISP0_VSYNC */
 };
 
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EIM_A16__EPDC_DATA00	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA10__EPDC_DATA01	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA12__EPDC_DATA02	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA11__EPDC_DATA03	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_LBA__EPDC_DATA04	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB2__EPDC_DATA05	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_CS0__EPDC_DATA06	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_RW__EPDC_DATA07	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A21__EPDC_GDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A22__EPDC_GDSP	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A23__EPDC_GDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_A24__EPDC_GDRL	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D31__EPDC_SDCLK_P	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_D27__EPDC_SDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA1__EPDC_SDLE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_EB1__EPDC_SDSHR	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA2__EPDC_BDR0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA4__EPDC_SDCE0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA5__EPDC_SDCE1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EIM_DA6__EPDC_SDCE2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EIM_A16__GPIO2_IO22,
+	MX6_PAD_EIM_DA10__GPIO3_IO10,
+	MX6_PAD_EIM_DA12__GPIO3_IO12,
+	MX6_PAD_EIM_DA11__GPIO3_IO11,
+	MX6_PAD_EIM_LBA__GPIO2_IO27,
+	MX6_PAD_EIM_EB2__GPIO2_IO30,
+	MX6_PAD_EIM_CS0__GPIO2_IO23,
+	MX6_PAD_EIM_RW__GPIO2_IO26,
+	MX6_PAD_EIM_A21__GPIO2_IO17,
+	MX6_PAD_EIM_A22__GPIO2_IO16,
+	MX6_PAD_EIM_A23__GPIO6_IO06,
+	MX6_PAD_EIM_A24__GPIO5_IO04,
+	MX6_PAD_EIM_D31__GPIO3_IO31,
+	MX6_PAD_EIM_D27__GPIO3_IO27,
+	MX6_PAD_EIM_DA1__GPIO3_IO01,
+	MX6_PAD_EIM_EB1__GPIO2_IO29,
+	MX6_PAD_EIM_DA2__GPIO3_IO02,
+	MX6_PAD_EIM_DA4__GPIO3_IO04,
+	MX6_PAD_EIM_DA5__GPIO3_IO05,
+	MX6_PAD_EIM_DA6__GPIO3_IO06,
+};
+#endif
+
 static void setup_iomux_uart(void)
 {
 	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
 }
 
+#ifdef CONFIG_SYS_I2C_MXC
+
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0 ;
+
+	i2c_set_bus_num(1);
+	if (!i2c_probe(0x8)) {
+		if (i2c_read(0x8, 0, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(0x8, 3, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE%s deviceid=%x,revid=%x\n",
+			((value & 0xf) == 0) ? "100" : "200", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/*For camera streaks issue,swap VGEN5 and VGEN3 to power camera.
+		*sperate VDDHIGH_IN and camera 2.8V power supply, after switch:
+		*VGEN5 for VDDHIGH_IN and increase to 3V to align with datasheet
+		*VGEN3 for camera 2.8V power supply
+		*/
+		/*increase VGEN3 from 2.5 to 2.8V*/
+		if (i2c_read(0x8, 0x6e, 1, &value, 1)) {
+			printf("Read VGEN3 error!\n");
+			return -1;
+		}
+		value &= ~0xf;
+		value |= 0xa;
+		if (i2c_write(0x8, 0x6e, 1, &value, 1)) {
+			printf("Set VGEN3 error!\n");
+			return -1;
+		}
+		/*increase VGEN5 from 2.8 to 3V*/
+		if (i2c_read(0x8, 0x70, 1, &value, 1)) {
+			printf("Read VGEN5 error!\n");
+			return -1;
+		}
+		value &= ~0xf;
+		value |= 0xc;
+		if (i2c_write(0x8, 0x70, 1, &value, 1)) {
+			printf("Set VGEN5 error!\n");
+			return -1;
+		}
+		/* set SW1AB staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x21, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x21, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x24, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x24, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V*/
+		if (i2c_read(0x8, 0x2f, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x2f, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x32, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x32, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+	unsigned char vddarm;
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		/* increase VDDARM to 1.425V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.425V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x2d;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+	}
+	/* switch to ldo_bypass mode , boot on 800Mhz */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		/* decrease VDDARM for 400Mhz DQ:1.1V, DL:1.275V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+#if defined(CONFIG_MX6DL)
+		value |= 0x27;
+#else
+		value |= 0x20;
+#endif
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.3V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x28;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		/*
+		 * MX6Q:
+		 * VDDARM:1.15V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 * MX6DL:
+		 * VDDARM:1.175V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:1.075V@400M; VDDSOC:1.175V@400M
+		 */
+		is_400M = set_anatop_bypass(2);
+		if (is_400M)
+#if defined(CONFIG_MX6DL)
+			vddarm = 0x1f;
+#else
+			vddarm = 0x1b;
+#endif
+		else
+#if defined(CONFIG_MX6DL)
+			vddarm = 0x23;
+#else
+			vddarm = 0x22;
+#endif
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= vddarm;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		/* decrease VDDSOC to 1.175V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x23;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
 #ifdef CONFIG_FSL_ESDHC
 struct fsl_esdhc_cfg usdhc_cfg[3] = {
 	{USDHC2_BASE_ADDR},
@@ -163,6 +507,35 @@ struct fsl_esdhc_cfg usdhc_cfg[3] = {
 	{USDHC4_BASE_ADDR},
 };
 
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
 #define USDHC2_CD_GPIO	IMX_GPIO_NR(2, 2)
 #define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 0)
 
@@ -229,6 +602,306 @@ int board_mmc_init(bd_t *bis)
 
 	return status;
 }
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+#ifdef CONFIG_SPLASH_SCREEN
+extern int mmc_get_env_devno(void);
+int setup_splash_img(void)
+{
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_SPLASH_IMG_OFFSET;
+	ulong size = CONFIG_SPLASH_IMG_SIZE;
+	ulong addr = 0;
+	char *s = NULL;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	s = getenv("splashimage");
+
+	if (NULL == s) {
+		puts("env splashimage not found!\n");
+		return -1;
+	}
+	addr = simple_strtoul(s, NULL, 16);
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+					blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#endif
+
+	return 0;
+}
+#endif
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 800,
+	.vl_row = 600,
+	.vl_pixclock = 26666667,
+	.vl_left_margin = 8,
+	.vl_right_margin = 100,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 8,
+	.vl_hsync = 4,
+	.vl_vsync = 1,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 419,
+	.gdsp_offs = 20,
+	.gdoe_offs = 0,
+	.gdclk_offs = 5,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EIM_A17 - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO2_IO21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as input */
+	gpio_direction_input(IMX_GPIO_NR(2, 21));
+
+	/* EIM_D17 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 17), 1);
+
+	/* EIM_D20 - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO3_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(3, 20), 1);
+
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO2_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 20), 1);
+}
+
+int setup_waveform_file(void)
+{
+#ifdef CONFIG_WAVEFORM_FILE_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_WAVEFORM_FILE_OFFSET;
+	ulong size = CONFIG_WAVEFORM_FILE_SIZE;
+	ulong addr = CONFIG_WAVEFORM_BUF_ADDR;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt   = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+				      blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#else
+	return -1;
+#endif
+}
+
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	unsigned int reg;
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC PWRSTAT - GPIO2[21] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A17__GPIO2_IO21 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC VCOM0 - GPIO3[17] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D17__GPIO3_IO17 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* UART4 TXD - GPIO3[20] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_D20__GPIO3_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EIM_A18 - GPIO2[20] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EIM_A18__GPIO2_IO20 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/*** Set pixel clock rates for EPDC ***/
+
+	/* EPDC AXI clk (IPU2_CLK) from PFD_400M, set to 396/2 = 198MHz */
+	reg = readl(&ccm_regs->cscdr3);
+	reg &= ~0x7C000;
+	reg |= (1 << 16) | (1 << 14);
+	writel(reg, &ccm_regs->cscdr3);
+
+	/* EPDC AXI clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x00C0;
+	writel(reg, &ccm_regs->CCGR3);
+
+	/* EPDC PIX clk (IPU2_DI1_CLK) from PLL5, set to 650/4/6 = ~27MHz */
+	reg = readl(&ccm_regs->cscdr2);
+	reg &= ~0x3FE00;
+	reg |= (2 << 15) | (5 << 12);
+	writel(reg, &ccm_regs->cscdr2);
+
+	/* PLL5 enable (defaults to 650) */
+	reg = readl(&ccm_regs->analog_pll_video);
+	reg &= ~((1 << 16) | (1 << 12));
+	reg |= (1 << 13);
+	writel(reg, &ccm_regs->analog_pll_video);
+
+	/* EPDC PIX clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x0C00;
+	writel(reg, &ccm_regs->CCGR3);
+
+	panel_info.epdc_data.working_buf_addr = CONFIG_WORKING_BUF_ADDR;
+	panel_info.epdc_data.waveform_buf_addr = CONFIG_WAVEFORM_BUF_ADDR;
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+
+	/* Assign fb_base */
+	gd->fb_base = CONFIG_FB_BASE;
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 20), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 20), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 21)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(3, 20), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(3, 17), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 20), 0);
+}
 #endif
 
 int mx6_rgmii_rework(struct phy_device *phydev)
@@ -274,13 +947,6 @@ struct display_info_t {
 	struct	fb_videomode mode;
 };
 
-static int detect_hdmi(struct display_info_t const *dev)
-{
-	struct hdmi_regs *hdmi	= (struct hdmi_regs *)HDMI_ARB_BASE_ADDR;
-	return readb(&hdmi->phy_stat0) & HDMI_DVI_STAT;
-}
-
-
 static void disable_lvds(struct display_info_t const *dev)
 {
 	struct iomuxc *iomux = (struct iomuxc *)IOMUXC_BASE_ADDR;
@@ -299,22 +965,12 @@ static void do_enable_hdmi(struct display_info_t const *dev)
 	imx_enable_hdmi_phy();
 }
 
-static void enable_lvds(struct display_info_t const *dev)
-{
-	struct iomuxc *iomux = (struct iomuxc *)
-				IOMUXC_BASE_ADDR;
-	u32 reg = readl(&iomux->gpr[2]);
-	reg |= IOMUXC_GPR2_DATA_WIDTH_CH0_18BIT |
-	       IOMUXC_GPR2_DATA_WIDTH_CH1_18BIT;
-	writel(reg, &iomux->gpr[2]);
-}
-
 static struct display_info_t const displays[] = {{
 	.bus	= -1,
 	.addr	= 0,
 	.pixfmt	= IPU_PIX_FMT_RGB666,
 	.detect	= NULL,
-	.enable	= enable_lvds,
+	.enable	= NULL,
 	.mode	= {
 		.name           = "Hannstar-XGA",
 		.refresh        = 60,
@@ -333,21 +989,21 @@ static struct display_info_t const displays[] = {{
 	.bus	= -1,
 	.addr	= 0,
 	.pixfmt	= IPU_PIX_FMT_RGB24,
-	.detect	= detect_hdmi,
+	.detect	= NULL,
 	.enable	= do_enable_hdmi,
 	.mode	= {
 		.name           = "HDMI",
 		.refresh        = 60,
-		.xres           = 1024,
-		.yres           = 768,
-		.pixclock       = 15385,
-		.left_margin    = 220,
-		.right_margin   = 40,
-		.upper_margin   = 21,
-		.lower_margin   = 7,
-		.hsync_len      = 60,
-		.vsync_len      = 10,
-		.sync           = FB_SYNC_EXT,
+		.xres           = 640,
+		.yres           = 480,
+		.pixclock       = 39721,
+		.left_margin    = 48,
+		.right_margin   = 16,
+		.upper_margin   = 33,
+		.lower_margin   = 10,
+		.hsync_len      = 96,
+		.vsync_len      = 2,
+		.sync           = 0,
 		.vmode          = FB_VMODE_NONINTERLACED
 } } };
 
@@ -380,7 +1036,8 @@ int board_video_skip(void)
 		ret = ipuv3_fb_init(&displays[i].mode, 0,
 				    displays[i].pixfmt);
 		if (!ret) {
-			displays[i].enable(displays+i);
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
 			printf("Display: %s (%ux%u)\n",
 			       displays[i].mode.name,
 			       displays[i].mode.xres,
@@ -476,6 +1133,14 @@ int board_early_init_f(void)
 	setup_display();
 #endif
 
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_CMD_SATA
+	setup_sata();
+#endif
+
 	return 0;
 }
 
@@ -484,8 +1149,8 @@ int board_init(void)
 	/* address of boot parameters */
 	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
 
-#ifdef CONFIG_MXC_SPI
-	setup_spi();
+#if defined(CONFIG_MX6DL) && defined(CONFIG_MXC_EPDC)
+	setup_epdc();
 #endif
 
 	return 0;
@@ -497,17 +1162,30 @@ static const struct boot_mode board_boot_modes[] = {
 	{"sd2",	 MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
 	{"sd3",	 MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
 	/* 8 bit bus width */
-	{"emmc", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{"emmc", MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
 	{NULL,	 0},
 };
 #endif
 
 int board_late_init(void)
 {
+	int ret = 0;
 #ifdef CONFIG_CMD_BMODE
 	add_board_boot_modes(board_boot_modes);
 #endif
 
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED,
+			0x7f, &i2c_pad_info1);
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
 	return 0;
 }
 
@@ -516,3 +1194,182 @@ int checkboard(void)
 	puts("Board: MX6-SabreSD\n");
 	return 0;
 }
+
+#ifdef CONFIG_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "sata");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti sata");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc0");
+	    break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc1");
+	    break;
+	case MMC4_BOOT:
+	    if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+	    if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc2");
+	    break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 5)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6_PAD_GPIO_5__GPIO1_IO05 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+    int button_pressed = 0;
+    int recovery_mode = 0;
+
+    recovery_mode = recovery_check_and_clean_flag();
+
+    /* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+			ARRAY_SIZE(recovery_key_pads));
+
+    gpio_direction_input(GPIO_VOL_DN_KEY);
+
+    if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+    }
+
+    return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case SATA_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti sata recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA*/
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc1 recovery");
+		break;
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"booti mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const otg_udc_pads[] = {
+	(MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+			ARRAY_SIZE(otg_udc_pads));
+
+	/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+    mxc_iomux_set_gpr_register(1, 13, 1, 0);
+}
+#endif /*CONFIG_IMX_UDC*/
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const usb_otg_pads[] = {
+	MX6_PAD_EIM_D22__USB_OTG_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_ENET_RX_ER__USB_OTG_ID | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+iomux_v3_cfg_t const usb_hc1_pads[] = {
+	MX6_PAD_ENET_TXD1__GPIO1_IO29 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg_pads,
+			ARRAY_SIZE(usb_otg_pads));
+
+		/*set daisy chain for otg_pin_id on 6q. for 6dl, this bit is reserved*/
+		mxc_iomux_set_gpr_register(1, 13, 1, 0);
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_hc1_pads,
+			ARRAY_SIZE(usb_hc1_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+
+int board_ehci_power(int port, int on)
+{
+	switch (port) {
+	case 0:
+		break;
+	case 1:
+		if (on)
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 1);
+		else
+			gpio_direction_output(IMX_GPIO_NR(1, 29), 0);
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg b/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg
new file mode 100644
index 0000000..6526db4
--- /dev/null
+++ b/board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ * Jason Liu <r64343@freescale.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM      sd
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN board/freescale/mx6sabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *      Addr-type register length (1,2 or 4 bytes)
+ *      Address   absolute address of the register
+ *      value     value to be stored in the register
+ */
+DATA 4, 0x020e0774, 0x000C0000
+DATA 4, 0x020e0754, 0x00000000
+DATA 4, 0x020e04ac, 0x00000030
+DATA 4, 0x020e04b0, 0x00000030
+DATA 4, 0x020e0464, 0x00000030
+DATA 4, 0x020e0490, 0x00000030
+DATA 4, 0x020e074c, 0x00000030
+DATA 4, 0x020e0494, 0x00000030
+DATA 4, 0x020e04a0, 0x00000000
+DATA 4, 0x020e04b4, 0x00000030
+DATA 4, 0x020e04b8, 0x00000030
+DATA 4, 0x020e076c, 0x00000030
+DATA 4, 0x020e0750, 0x00020000
+DATA 4, 0x020e04bc, 0x00000030
+DATA 4, 0x020e04c0, 0x00000030
+DATA 4, 0x020e04c4, 0x00000030
+DATA 4, 0x020e04c8, 0x00000030
+DATA 4, 0x020e0760, 0x00020000
+DATA 4, 0x020e0764, 0x00000030
+DATA 4, 0x020e0770, 0x00000030
+DATA 4, 0x020e0778, 0x00000030
+DATA 4, 0x020e077c, 0x00000030
+DATA 4, 0x020e0470, 0x00000030
+DATA 4, 0x020e0474, 0x00000030
+DATA 4, 0x020e0478, 0x00000030
+DATA 4, 0x020e047c, 0x00000030
+DATA 4, 0x021b0800, 0xa1390003
+DATA 4, 0x021b080c, 0x001F001F
+DATA 4, 0x021b0810, 0x001F001F
+DATA 4, 0x021b083c, 0x42190219
+DATA 4, 0x021b0840, 0x017B0177
+DATA 4, 0x021b0848, 0x4B4D4E4D
+DATA 4, 0x021b0850, 0x3F3E2D36
+DATA 4, 0x021b081c, 0x33333333
+DATA 4, 0x021b0820, 0x33333333
+DATA 4, 0x021b0824, 0x33333333
+DATA 4, 0x021b0828, 0x33333333
+DATA 4, 0x021b08b8, 0x00000800
+DATA 4, 0x021b0004, 0x0002002D
+DATA 4, 0x021b0008, 0x00333030
+DATA 4, 0x021b000c, 0x3F435313
+DATA 4, 0x021b0010, 0xB66E8B63
+DATA 4, 0x021b0014, 0x01FF00DB
+DATA 4, 0x021b0018, 0x00001740
+DATA 4, 0x021b001c, 0x00008000
+DATA 4, 0x021b002c, 0x000026d2
+DATA 4, 0x021b0030, 0x00431023
+DATA 4, 0x021b0040, 0x00000017
+DATA 4, 0x021b0000, 0x83190000
+DATA 4, 0x021b001c, 0x04008032
+DATA 4, 0x021b001c, 0x00008033
+DATA 4, 0x021b001c, 0x00048031
+DATA 4, 0x021b001c, 0x05208030
+DATA 4, 0x021b001c, 0x04008040
+DATA 4, 0x021b0020, 0x00005800
+DATA 4, 0x021b0818, 0x00011117
+DATA 4, 0x021b0004, 0x0002556D
+DATA 4, 0x021b0404, 0x00011006
+DATA 4, 0x021b001c, 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4, 0x020c4068, 0x00C03F3F
+DATA 4, 0x020c406c, 0x0030FC03
+DATA 4, 0x020c4070, 0x0FFFC000
+DATA 4, 0x020c4074, 0x3FF00000
+DATA 4, 0x020c4078, 0x00FFF300
+DATA 4, 0x020c407c, 0x0F0000C3
+DATA 4, 0x020c4080, 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4, 0x020e0010, 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4, 0x020e0018, 0x007F007F
+DATA 4, 0x020e001c, 0x007F007F
+#endif
diff --git a/board/freescale/mx6sabresd/plugin.S b/board/freescale/mx6sabresd/plugin.S
new file mode 100644
index 0000000..6e2a72a
--- /dev/null
+++ b/board/freescale/mx6sabresd/plugin.S
@@ -0,0 +1,480 @@
+/*
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6dqsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x43270338
+	str r2, [r0, #0x83c]
+	ldr r2, =0x03200314
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x431A032F
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03200263
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4B434748
+	str r2, [r0, #0x848]
+	ldr r2, =0x4445404C
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x38444542
+	str r2, [r0, #0x850]
+	ldr r2, =0x4935493A
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x555A7975
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF538F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x005A1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x09408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dlsabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001f001f
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	str r2, [r1, #0x80c]
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x4220021F
+	str r2, [r0, #0x83c]
+	ldr r2, =0x0207017E
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4201020C
+	str r2, [r1, #0x83c]
+	ldr r2, =0x01660172
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x4A4D4E4D
+	str r2, [r0, #0x848]
+	ldr r2, =0x4A4F5049
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x3F3C3D31
+	str r2, [r0, #0x850]
+	ldr r2, =0x3238372B
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F435313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6solosabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x001F001F
+	str r2, [r0, #0x80c]
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x42190219
+	str r2, [r0, #0x83c]
+	ldr r2, =0x017B0177
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x4B4D4E4D
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x3F3E2D36
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F435313
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66E8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000017
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x83190000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00005800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00C03F3F
+	str r1, [r0, #0x068]
+	ldr r1, =0x0030FC03
+	str r1, [r0, #0x06c]
+	ldr r1, =0x0FFFC000
+	str r1, [r0, #0x070]
+	ldr r1, =0x3FF00000
+	str r1, [r0, #0x074]
+	ldr r1, =0x00FFF300
+	str r1, [r0, #0x078]
+	ldr r1, =0x0F0000C3
+	str r1, [r0, #0x07c]
+	ldr r1, =0x000003FF
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_MX6SOLO)
+	imx6solosabresd_ddr_setting
+#elif defined (CONFIG_MX6DL)
+	imx6dlsabresd_ddr_setting
+#elif defined (CONFIG_MX6Q)
+	imx6dqsabresd_ddr_setting
+#else
+	#error "SOC not configured"
+#endif
+
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6slevk/Makefile b/board/freescale/mx6slevk/Makefile
index 6e1971e..fb44826 100644
--- a/board/freescale/mx6slevk/Makefile
+++ b/board/freescale/mx6slevk/Makefile
@@ -4,3 +4,7 @@
 #
 
 obj-y  := mx6slevk.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6slevk/imximage.cfg b/board/freescale/mx6slevk/imximage.cfg
index 16ea597..96e6961 100644
--- a/board/freescale/mx6slevk/imximage.cfg
+++ b/board/freescale/mx6slevk/imximage.cfg
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  *
@@ -9,6 +9,9 @@
  * The syntax is taken as close as possible with the kwbimage
  */
 
+#define __ASSEMBLY__
+#include <config.h>
+
 /* image version */
 
 IMAGE_VERSION 2
@@ -20,6 +23,15 @@ IMAGE_VERSION 2
 
 BOOT_FROM	sd
 
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6slevk/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
 /*
  * Device Configuration Data (DCD)
  *
@@ -113,3 +125,4 @@ DATA 4 0x021b08b8 0x00000800
 DATA 4 0x021b0004 0x00025564
 DATA 4 0x021b0404 0x00011006
 DATA 4 0x021b001c 0x00000000
+#endif
diff --git a/board/freescale/mx6slevk/mx6slevk.c b/board/freescale/mx6slevk/mx6slevk.c
index aadad32..9ff49b4 100644
--- a/board/freescale/mx6slevk/mx6slevk.c
+++ b/board/freescale/mx6slevk/mx6slevk.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
  *
  * Author: Fabio Estevam <fabio.estevam@freescale.com>
  *
@@ -9,16 +9,33 @@
 #include <asm/arch/clock.h>
 #include <asm/arch/iomux.h>
 #include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
 #include <asm/arch/mx6-pins.h>
 #include <asm/arch/sys_proto.h>
 #include <asm/gpio.h>
 #include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
 #include <asm/io.h>
 #include <linux/sizes.h>
 #include <common.h>
 #include <fsl_esdhc.h>
 #include <mmc.h>
 #include <netdev.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#if defined(CONFIG_MXC_EPDC)
+#include <lcd.h>
+#include <mxc_epdc_fb.h>
+#endif
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FASTBOOT*/
+
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -34,8 +51,37 @@ DECLARE_GLOBAL_DATA_PTR;
 	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED   |             \
 	PAD_CTL_DSE_40ohm   | PAD_CTL_HYS)
 
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
 #define ETH_PHY_RESET	IMX_GPIO_NR(4, 21)
 
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info0 = {
+	.sda = {
+		.i2c_mode = MX6_PAD_I2C1_SDA__I2C1_SDA | PC,
+		.gpio_mode = MX6_PAD_I2C1_SDA__GPIO_3_13 | PC,
+		.gp = IMX_GPIO_NR(3, 13),
+	},
+	.scl = {
+		.i2c_mode = MX6_PAD_I2C1_SCL__I2C1_SCL | PC,
+		.gpio_mode = MX6_PAD_I2C1_SCL__GPIO_3_12 | PC,
+		.gp = IMX_GPIO_NR(3, 12),
+	},
+};
+#endif
+
 int dram_init(void)
 {
 	gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
@@ -48,6 +94,23 @@ static iomux_v3_cfg_t const uart1_pads[] = {
 	MX6_PAD_UART1_RXD__UART1_RXD | MUX_PAD_CTRL(UART_PAD_CTRL),
 };
 
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	/* 8 bit SD */
+	MX6_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT0__USDHC1_DAT0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT1__USDHC1_DAT1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT2__USDHC1_DAT2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT3__USDHC1_DAT3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT4__USDHC1_DAT4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT5__USDHC1_DAT5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT6__USDHC1_DAT6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD1_DAT7__USDHC1_DAT7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*CD pin*/
+	MX6_PAD_KEY_ROW7__GPIO_4_7 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
 static iomux_v3_cfg_t const usdhc2_pads[] = {
 	MX6_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 	MX6_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
@@ -55,6 +118,21 @@ static iomux_v3_cfg_t const usdhc2_pads[] = {
 	MX6_PAD_SD2_DAT1__USDHC2_DAT1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 	MX6_PAD_SD2_DAT2__USDHC2_DAT2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
 	MX6_PAD_SD2_DAT3__USDHC2_DAT3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*CD pin*/
+	MX6_PAD_SD2_DAT7__GPIO_5_0 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT0__USDHC3_DAT0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT1__USDHC3_DAT1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT2__USDHC3_DAT2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6_PAD_SD3_DAT3__USDHC3_DAT3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*CD pin*/
+	MX6_PAD_REF_CLK_32K__GPIO_3_22 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
 static iomux_v3_cfg_t const fec_pads[] = {
@@ -71,6 +149,52 @@ static iomux_v3_cfg_t const fec_pads[] = {
 	MX6_PAD_FEC_TX_CLK__GPIO_4_21 | MUX_PAD_CTRL(NO_PAD_CTRL),
 };
 
+static iomux_v3_cfg_t const epdc_enable_pads[] = {
+	MX6_PAD_EPDC_D0__EPDC_SDDO_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D1__EPDC_SDDO_1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D2__EPDC_SDDO_2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D3__EPDC_SDDO_3	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D4__EPDC_SDDO_4	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D5__EPDC_SDDO_5	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D6__EPDC_SDDO_6	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_D7__EPDC_SDDO_7	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDCLK__EPDC_GDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDSP__EPDC_GDSP	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDOE__EPDC_GDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_GDRL__EPDC_GDRL	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCLK__EPDC_SDCLK	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDOE__EPDC_SDOE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDLE__EPDC_SDLE	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDSHR__EPDC_SDSHR	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_BDR0__EPDC_BDR_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE0__EPDC_SDCE_0	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE1__EPDC_SDCE_1	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+	MX6_PAD_EPDC_SDCE2__EPDC_SDCE_2	| MUX_PAD_CTRL(EPDC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const epdc_disable_pads[] = {
+	MX6_PAD_EPDC_D0__GPIO_1_7,
+	MX6_PAD_EPDC_D1__GPIO_1_8,
+	MX6_PAD_EPDC_D2__GPIO_1_9,
+	MX6_PAD_EPDC_D3__GPIO_1_10,
+	MX6_PAD_EPDC_D4__GPIO_1_11,
+	MX6_PAD_EPDC_D5__GPIO_1_12,
+	MX6_PAD_EPDC_D6__GPIO_1_13,
+	MX6_PAD_EPDC_D7__GPIO_1_14,
+	MX6_PAD_EPDC_GDCLK__GPIO_1_31,
+	MX6_PAD_EPDC_GDSP__GPIO_2_2,
+	MX6_PAD_EPDC_GDOE__GPIO_2_0,
+	MX6_PAD_EPDC_GDRL__GPIO_2_1,
+	MX6_PAD_EPDC_SDCLK__GPIO_1_23,
+	MX6_PAD_EPDC_SDOE__GPIO_1_25,
+	MX6_PAD_EPDC_SDLE__GPIO_1_24,
+	MX6_PAD_EPDC_SDSHR__GPIO_1_26,
+	MX6_PAD_EPDC_BDR0__GPIO_2_5,
+	MX6_PAD_EPDC_SDCE0__GPIO_1_27,
+	MX6_PAD_EPDC_SDCE1__GPIO_1_28,
+	MX6_PAD_EPDC_SDCE2__GPIO_1_29,
+};
+
 static void setup_iomux_uart(void)
 {
 	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
@@ -86,23 +210,420 @@ static void setup_iomux_fec(void)
 	gpio_set_value(ETH_PHY_RESET, 1);
 }
 
-static struct fsl_esdhc_cfg usdhc_cfg[1] = {
-	{USDHC2_BASE_ADDR},
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi1_pads[] = {
+	MX6_PAD_ECSPI1_SCLK__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_ECSPI1_MISO__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_ECSPI1_MOSI__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6_PAD_ECSPI1_SS0__GPIO_4_11    | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi1_pads,
+					 ARRAY_SIZE(ecspi1_pads));
+	gpio_direction_output(IMX_GPIO_NR(4, 11), 0);
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+
+#define USDHC1_CD_GPIO	IMX_GPIO_NR(4, 7)
+#define USDHC2_CD_GPIO	IMX_GPIO_NR(5, 0)
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(3, 22)
+
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC1_BASE_ADDR},
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR, 0, 4},
 };
 
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
 int board_mmc_getcd(struct mmc *mmc)
 {
-	return 1;	/* Assume boot SD always present */
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC1_BASE_ADDR:
+		ret = !gpio_get_value(USDHC1_CD_GPIO);
+		break;
+	case USDHC2_BASE_ADDR:
+		ret = !gpio_get_value(USDHC2_CD_GPIO);
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	}
+
+	return ret;
 }
 
 int board_mmc_init(bd_t *bis)
 {
-	imx_iomux_v3_setup_multiple_pads(usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1
+	 * mmc1                    USDHC2
+	 * mmc2                    USDHC3
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+			gpio_direction_input(USDHC1_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			gpio_direction_input(USDHC2_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_env_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
 
-	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
-	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+#endif
+
+#ifdef CONFIG_MXC_EPDC
+#ifdef CONFIG_SPLASH_SCREEN
+extern int mmc_get_env_devno(void);
+int setup_splash_img(void)
+{
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_SPLASH_IMG_OFFSET;
+	ulong size = CONFIG_SPLASH_IMG_SIZE;
+	ulong addr = 0;
+	char *s = NULL;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	s = getenv("splashimage");
+
+	if (NULL == s) {
+		puts("env splashimage not found!\n");
+		return -1;
+	}
+	addr = simple_strtoul(s, NULL, 16);
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+				      blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#endif
+
+	return 0;
+}
+#endif
+
+vidinfo_t panel_info = {
+	.vl_refresh = 85,
+	.vl_col = 800,
+	.vl_row = 600,
+	.vl_pixclock = 26666667,
+	.vl_left_margin = 8,
+	.vl_right_margin = 100,
+	.vl_upper_margin = 4,
+	.vl_lower_margin = 8,
+	.vl_hsync = 4,
+	.vl_vsync = 1,
+	.vl_sync = 0,
+	.vl_mode = 0,
+	.vl_flag = 0,
+	.vl_bpix = 3,
+	.cmap = 0,
+};
+
+struct epdc_timing_params panel_timings = {
+	.vscan_holdoff = 4,
+	.sdoed_width = 10,
+	.sdoed_delay = 20,
+	.sdoez_width = 10,
+	.sdoez_delay = 20,
+	.gdclk_hp_offs = 419,
+	.gdsp_offs = 20,
+	.gdoe_offs = 0,
+	.gdclk_offs = 5,
+	.num_ce = 1,
+};
+
+static void setup_epdc_power(void)
+{
+	/* Setup epdc voltage */
+
+	/* EPDC_PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRSTAT__GPIO_2_13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	gpio_direction_input(IMX_GPIO_NR(2, 13));
+
+	/* EPDC_VCOM0 - GPIO2[3] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO_2_3 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 3), 1);
+
+	/* EPDC_PWRWAKEUP - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRWAKEUP__GPIO_2_14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 14), 1);
+
+	/* EPDC_PWRCTRL0 - GPIO2[7] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRCTRL0__GPIO_2_7 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+	/* Set as output */
+	gpio_direction_output(IMX_GPIO_NR(2, 7), 1);
+}
+
+int setup_waveform_file(void)
+{
+#ifdef CONFIG_WAVEFORM_FILE_IN_MMC
+	int mmc_dev = mmc_get_env_devno();
+	ulong offset = CONFIG_WAVEFORM_FILE_OFFSET;
+	ulong size = CONFIG_WAVEFORM_FILE_SIZE;
+	ulong addr = CONFIG_WAVEFORM_BUF_ADDR;
+	struct mmc *mmc = find_mmc_device(mmc_dev);
+	uint blk_start, blk_cnt, n;
+
+	if (!mmc) {
+		printf("MMC Device %d not found\n", mmc_dev);
+		return -1;
+	}
+
+	if (mmc_init(mmc)) {
+		puts("MMC init failed\n");
+		return -1;
+	}
+
+	blk_start = ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
+	blk_cnt = ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
+	n = mmc->block_dev.block_read(mmc_dev, blk_start,
+				      blk_cnt, (u_char *)addr);
+	flush_cache((ulong)addr, blk_cnt * mmc->read_bl_len);
+
+	return (n == blk_cnt) ? 0 : -1;
+#else
+	return -1;
+#endif
 }
 
+static void epdc_enable_pins(void)
+{
+	/* epdc iomux settings */
+	imx_iomux_v3_setup_multiple_pads(epdc_enable_pads,
+				ARRAY_SIZE(epdc_enable_pads));
+}
+
+static void epdc_disable_pins(void)
+{
+	/* Configure MUX settings for EPDC pins to GPIO  and drive to 0 */
+	imx_iomux_v3_setup_multiple_pads(epdc_disable_pads,
+				ARRAY_SIZE(epdc_disable_pads));
+}
+
+static void setup_epdc(void)
+{
+	unsigned int reg;
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/*** epdc Maxim PMIC settings ***/
+
+	/* EPDC PWRSTAT - GPIO2[13] for PWR_GOOD status */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRSTAT__GPIO_2_13 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EPDC VCOM0 - GPIO2[3] for VCOM control */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_VCOM0__GPIO_2_3 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* UART4 TXD - GPIO2[14] for EPD PMIC WAKEUP */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRWAKEUP__GPIO_2_14 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/* EIM_A18 - GPIO2[7] for EPD PWR CTL0 */
+	imx_iomux_v3_setup_pad(MX6_PAD_EPDC_PWRCTRL0__GPIO_2_7 |
+				MUX_PAD_CTRL(EPDC_PAD_CTRL));
+
+	/*** Set pixel clock rates for EPDC ***/
+
+	/* EPDC AXI clk from PFD_400M, set to 396/2 = 198MHz */
+	reg = readl(&ccm_regs->chsccdr);
+	reg &= ~0x3F000;
+	reg |= (0x4 << 15) | (1 << 12);
+	writel(reg, &ccm_regs->chsccdr);
+
+	/* EPDC AXI clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x0030;
+	writel(reg, &ccm_regs->CCGR3);
+
+	/* EPDC PIX clk from PFD_540M, set to 540/4/5 = 27MHz */
+	reg = readl(&ccm_regs->cscdr2);
+	reg &= ~0x03F000;
+	reg |= (0x5 << 15) | (4 << 12);
+	writel(reg, &ccm_regs->cscdr2);
+
+	reg = readl(&ccm_regs->cbcmr);
+	reg &= ~0x03800000;
+	reg |= (0x3 << 23);
+	writel(reg, &ccm_regs->cbcmr);
+
+	/* EPDC PIX clk enable */
+	reg = readl(&ccm_regs->CCGR3);
+	reg |= 0x0C00;
+	writel(reg, &ccm_regs->CCGR3);
+
+	panel_info.epdc_data.working_buf_addr = CONFIG_WORKING_BUF_ADDR;
+	panel_info.epdc_data.waveform_buf_addr = CONFIG_WAVEFORM_BUF_ADDR;
+
+	panel_info.epdc_data.wv_modes.mode_init = 0;
+	panel_info.epdc_data.wv_modes.mode_du = 1;
+	panel_info.epdc_data.wv_modes.mode_gc4 = 3;
+	panel_info.epdc_data.wv_modes.mode_gc8 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc16 = 2;
+	panel_info.epdc_data.wv_modes.mode_gc32 = 2;
+
+	panel_info.epdc_data.epdc_timings = panel_timings;
+
+	setup_epdc_power();
+
+	/* Assign fb_base */
+	gd->fb_base = CONFIG_FB_BASE;
+}
+
+void epdc_power_on(void)
+{
+	unsigned int reg;
+	struct gpio_regs *gpio_regs = (struct gpio_regs *)GPIO2_BASE_ADDR;
+
+	/* Set EPD_PWR_CTL0 to high - enable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 1);
+	udelay(1000);
+
+	/* Enable epdc signal pin */
+	epdc_enable_pins();
+
+	/* Set PMIC Wakeup to high - enable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 1);
+
+	/* Wait for PWRGOOD == 1 */
+	while (1) {
+		reg = readl(&gpio_regs->gpio_psr);
+		if (!(reg & (1 << 13)))
+			break;
+
+		udelay(100);
+	}
+
+	/* Enable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 1);
+
+	udelay(500);
+}
+
+void epdc_power_off(void)
+{
+	/* Set PMIC Wakeup to low - disable Display power */
+	gpio_set_value(IMX_GPIO_NR(2, 14), 0);
+
+	/* Disable VCOM */
+	gpio_set_value(IMX_GPIO_NR(2, 3), 0);
+
+	epdc_disable_pins();
+
+	/* Set EPD_PWR_CTL0 to low - disable EINK_VDD (3.15) */
+	gpio_set_value(IMX_GPIO_NR(2, 7), 0);
+}
+#endif
+
 #ifdef CONFIG_FEC_MXC
 int board_eth_init(bd_t *bis)
 {
@@ -120,7 +641,7 @@ static int setup_fec(void)
 	/* clear gpr1[14], gpr1[18:17] to select anatop clock */
 	clrsetbits_le32(&iomuxc_regs->gpr[1], IOMUX_GPR1_FEC_MASK, 0);
 
-	ret = enable_fec_anatop_clock(ENET_50MHz);
+	ret = enable_fec_anatop_clock(0, ENET_50MHz);
 	if (ret)
 		return ret;
 
@@ -128,10 +649,192 @@ static int setup_fec(void)
 }
 #endif
 
+#ifdef CONFIG_SYS_I2C_MXC
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0;
+
+	i2c_set_bus_num(0);
+	if (!i2c_probe(0x8)) {
+		if (i2c_read(0x8, 0, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(0x8, 3, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE%s deviceid=%x,revid=%x\n",
+			((value & 0xf) == 0) ? "100" : "200", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/* set SW1AB staby volatage 0.975V */
+		if (i2c_read(0x8, 0x21, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x21, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x24, 1, &value, 1)) {
+			printf("Read SW1ABCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x24, 1, &value, 1)) {
+			printf("Set SW1ABCONFIG error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V */
+		if (i2c_read(0x8, 0x2f, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= 0x1b;
+		if (i2c_write(0x8, 0x2f, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(0x8, 0x32, 1, &value, 1)) {
+			printf("Read SW1CCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(0x8, 0x32, 1, &value, 1)) {
+			printf("Set SW1CCONFIG error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+
+	/* swith to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+
+		/* decrease VDDARM to 1.1V */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x20;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.3V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x28;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		is_400M = set_anatop_bypass(0);
+
+		/*
+		 * MX6SL: VDDARM:1.175V@800M; VDDSOC:1.175V@800M
+		 *        VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 */
+		if (i2c_read(0x8, 0x20, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		if (is_400M)
+			value |= 0x1b;
+		else
+			value |= 0x23;
+		if (i2c_write(0x8, 0x20, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		/* decrease VDDSOC to 1.175V */
+		if (i2c_read(0x8, 0x2e, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= 0x23;
+		if (i2c_write(0x8, 0x2e, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
 
 int board_early_init_f(void)
 {
 	setup_iomux_uart();
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
 	return 0;
 }
 
@@ -143,6 +846,29 @@ int board_init(void)
 #ifdef	CONFIG_FEC_MXC
 	setup_fec();
 #endif
+
+#ifdef	CONFIG_MXC_EPDC
+	setup_epdc();
+#endif
+	return 0;
+}
+
+int board_late_init(void)
+{
+	int ret = 0;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED,
+			0x7f, &i2c_pad_info0);
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
 	return 0;
 }
 
@@ -151,9 +877,155 @@ u32 get_board_rev(void)
 	return get_cpu_rev();
 }
 
+#ifdef CONFIG_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc0");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc1");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc2");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+    return recovery_check_and_clean_flag();
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	/*current uboot BSP only supports USDHC2*/
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD1_BOOT:
+	case MMC1_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+					"booti mmc0 recovery");
+		break;
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+					"booti mmc1 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+					"booti mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
+
+#ifdef CONFIG_MXC_KPD
+#define MX6SL_KEYPAD_CTRL	(PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE | \
+				PAD_CTL_PUS_100K_UP | PAD_CTL_DSE_120ohm)
+
+iomux_v3_cfg_t const mxc_kpd_pads[] = {
+	(MX6_PAD_KEY_COL0__KPP_COL_0 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	(MX6_PAD_KEY_COL1__KPP_COL_1 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	(MX6_PAD_KEY_COL2__KPP_COL_2 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+	(MX6_PAD_KEY_COL3__KPP_COL_3 | MUX_PAD_CTRL(NO_PAD_CTRL)),
+
+	(MX6_PAD_KEY_ROW0__KPP_ROW_0 | MUX_PAD_CTRL(MX6SL_KEYPAD_CTRL)),
+	(MX6_PAD_KEY_ROW1__KPP_ROW_1 | MUX_PAD_CTRL(MX6SL_KEYPAD_CTRL)),
+	(MX6_PAD_KEY_ROW2__KPP_ROW_2 | MUX_PAD_CTRL(MX6SL_KEYPAD_CTRL)),
+	(MX6_PAD_KEY_ROW3__KPP_ROW_3 | MUX_PAD_CTRL(MX6SL_KEYPAD_CTRL)),
+};
+int setup_mxc_kpd(void)
+{
+	imx_iomux_v3_setup_multiple_pads(mxc_kpd_pads,
+			ARRAY_SIZE(mxc_kpd_pads));
+
+	return 0;
+}
+#endif /*CONFIG_MXC_KPD*/
+
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const otg_udc_pads[] = {
+	(MX6_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+			ARRAY_SIZE(otg_udc_pads));
+}
+#endif /*CONFIG_IMX_UDC*/
+
 int checkboard(void)
 {
 	puts("Board: MX6SLEVK\n");
 
 	return 0;
 }
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6_PAD_KEY_COL4__USB_USBOTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6_PAD_EPDC_PWRCOM__ANATOP_USBOTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX6_PAD_KEY_COL5__USB_USBOTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+			ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+			ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/board/freescale/mx6slevk/plugin.S b/board/freescale/mx6slevk/plugin.S
new file mode 100644
index 0000000..287dfed
--- /dev/null
+++ b/board/freescale/mx6slevk/plugin.S
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6slevk_ddr_setting
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00260324
+	str r1, [r0, #0x018]
+
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5c0]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5b4]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x338]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x31c]
+	str r1, [r0, #0x320]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5b0]
+
+	ldr r1, =0x00003030
+	str r1, [r0, #0x344]
+	str r1, [r0, #0x348]
+	str r1, [r0, #0x34c]
+	str r1, [r0, #0x350]
+
+	ldr r1, =0x00080000
+	str r1, [r0, #0x5d0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5c4]
+	str r1, [r0, #0x5cc]
+	str r1, [r0, #0x5d4]
+	str r1, [r0, #0x5d8]
+
+	str r1, [r0, #0x30c]
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x318]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x1b4700c7
+	str r2, [r0, #0x85c]
+
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00300000
+	str r2, [r0, #0x890]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+
+	ldr r2, =0x4241444a
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x3030312b
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33374133
+	str r2, [r0, #0x00c]
+
+	ldr r2, =0x00020024
+	str r2, [r0, #0x004]
+
+	ldr r2, =0x00100A82
+	str r2, [r0, #0x010]
+	ldr r2, =0x00000093
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001688
+	str r2, [r0, #0x018]
+	ldr r2, =0x0F9F26D2
+	str r2, [r0, #0x02c]
+
+	ldr r2, =0x0000020E
+	str r2, [r0, #0x030]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x038]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x008]
+	ldr r2, =0x0000004F
+	str r2, [r0, #0x040]
+	ldr r2, =0xC3110000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x003F8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xFF0A8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x02038030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xFF0A8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x02038038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x020]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x00025564
+	str r2, [r0, #0x004]
+
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6slevk_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6sx_17x17_arm2/Makefile b/board/freescale/mx6sx_17x17_arm2/Makefile
new file mode 100644
index 0000000..2ee8078b
--- /dev/null
+++ b/board/freescale/mx6sx_17x17_arm2/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sx_17x17_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6sx_17x17_arm2/imximage.cfg b/board/freescale/mx6sx_17x17_arm2/imximage.cfg
new file mode 100644
index 0000000..f98acb0
--- /dev/null
+++ b/board/freescale/mx6sx_17x17_arm2/imximage.cfg
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sx_17x17_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+DATA 4 0x020e032c 0x00000030
+
+DATA 4 0x020e0300 0x00000030
+DATA 4 0x020e02fc 0x00000030
+DATA 4 0x020e05f4 0x00000030
+DATA 4 0x020e0340 0x00000030
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000030
+DATA 4 0x020e0314 0x00000030
+DATA 4 0x020e0614 0x00000030
+
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000030
+DATA 4 0x020e0334 0x00000030
+DATA 4 0x020e0338 0x00000030
+DATA 4 0x020e033c 0x00000030
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000030
+DATA 4 0x020e0610 0x00000030
+DATA 4 0x020e061c 0x00000030
+DATA 4 0x020e0620 0x00000030
+DATA 4 0x020e02ec 0x00000030
+DATA 4 0x020e02f0 0x00000030
+DATA 4 0x020e02f4 0x00000030
+DATA 4 0x020e02f8 0x00000030
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b080c 0x00270025
+DATA 4 0x021b0810 0x001B001E
+DATA 4 0x021b083c 0x4144013C
+DATA 4 0x021b0840 0x01300128
+DATA 4 0x021b0848 0x4044464A
+DATA 4 0x021b0850 0x3A383C34
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000005f
+DATA 4 0x021b0000 0x84190000
+DATA 4 0x021b001c 0x04008032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00068031
+DATA 4 0x021b001c 0x05208030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff --git a/board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg b/board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg
new file mode 100644
index 0000000..e7379b0
--- /dev/null
+++ b/board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sx_17x17_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020c4018 0x00260324
+
+DATA 4 0x020e0618 0x00080000
+DATA 4 0x020e05fc 0x00000000
+DATA 4 0x020e032c 0x00000030
+
+DATA 4 0x020e0300 0x00000028
+DATA 4 0x020e02fc 0x00000028
+DATA 4 0x020e05f4 0x00000028
+DATA 4 0x020e0340 0x00000028
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000000
+DATA 4 0x020e0314 0x00000000
+DATA 4 0x020e0614 0x00000028
+
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00003028
+DATA 4 0x020e0334 0x00003028
+DATA 4 0x020e0338 0x00003028
+DATA 4 0x020e033c 0x00003028
+
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b085c 0x1b4700c7
+
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b0890 0x00380000
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+DATA 4 0x021b082c 0x51111111
+DATA 4 0x021b0830 0x51111111
+DATA 4 0x021b0834 0x51111111
+DATA 4 0x021b0838 0x51111111
+
+DATA 4 0x021b0848 0x42424244
+
+DATA 4 0x021b0850 0x2E30322E
+DATA 4 0x021b08c0 0x2492244A
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x0
+
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b000c 0x33374133
+DATA 4 0x021b0004 0x00020024
+DATA 4 0x021b0010 0x00100A42
+DATA 4 0x021b0014 0x00000093
+DATA 4 0x021b0018 0x00001748
+DATA 4 0x021b002c 0x0f9f26d2
+DATA 4 0x021b0030 0x0000020e
+DATA 4 0x021b0038 0x00190778
+DATA 4 0x021b0008 0x00000000
+DATA 4 0x021b0040 0x0000004f
+DATA 4 0x021b0000 0xc3110000
+
+DATA 4 0x021b001c 0x003f8030
+DATA 4 0x021b001c 0xff0a8030
+DATA 4 0x021b001c 0x82018030
+DATA 4 0x021b001c 0x04028030
+DATA 4 0x021b001c 0x01038030
+
+DATA 4 0x021b001c 0x003f8038
+DATA 4 0x021b001c 0xff0a8038
+DATA 4 0x021b001c 0x82018038
+DATA 4 0x021b001c 0x04028038
+DATA 4 0x021b001c 0x01038038
+
+DATA 4 0x021b0020 0x00001800
+DATA 4 0x021b0818 0x00000000
+
+DATA 4 0x021b0800 0xa1310003
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff --git a/board/freescale/mx6sx_17x17_arm2/mx6sx_17x17_arm2.c b/board/freescale/mx6sx_17x17_arm2/mx6sx_17x17_arm2.c
new file mode 100644
index 0000000..612bda8
--- /dev/null
+++ b/board/freescale/mx6sx_17x17_arm2/mx6sx_17x17_arm2.c
@@ -0,0 +1,903 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <asm/arch/crm_regs.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_47K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_MED   |                                   \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_MED   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define EPDC_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL2 (PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm)
+
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6SX_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6SX_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6SX_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA0__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA1__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA2__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA3__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6SX_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA0__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA1__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA2__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA3__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA4__USDHC3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA5__USDHC3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA6__USDHC3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA7__USDHC3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/*CD pin*/
+	MX6SX_PAD_KEY_COL0__GPIO2_IO_10 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6SX_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA4__USDHC4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA5__USDHC4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA6__USDHC4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA7__USDHC4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6SX_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	/* AR8031 PHY Reset. For arm2 board, silder the resistance */
+	MX6SX_PAD_QSPI1A_SS0_B__GPIO4_IO_22 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec1(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(4, 22) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(4, 22), 1);
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_QSPI
+
+#define QSPI_PAD_CTRL1  \
+		(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+		PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+#define QSPI_PAD_CTRL2 (QSPI_PAD_CTRL1 | PAD_CTL_DSE_34ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6SX_PAD_NAND_WP_B__QSPI2_A_DATA_0 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_READY_B__QSPI2_A_DATA_1 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CE0_B__QSPI2_A_DATA_2 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CE1_B__QSPI2_A_DATA_3 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CLE__QSPI2_A_SCLK | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_ALE__QSPI2_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA01__QSPI2_B_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA00__QSPI2_B_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_WE_B__QSPI2_B_DATA_2		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_RE_B__QSPI2_B_DATA_3		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA03__QSPI2_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA02__QSPI2_B_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 10)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 2 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	dev_no -= 2;
+#else
+	dev_no--;
+#endif
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+#ifdef CONFIG_SYS_USE_SPINOR
+	return dev_no + 2;
+#else
+	return dev_no + 1;
+#endif
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = 1; /*always present */
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1; /*always present */
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_SYS_USE_SPINOR
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD3 (SDB)
+	 * mmc1                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+		}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+#else
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD2 (SDA)
+	 * mmc1                    SD3 (SDB)
+	 * mmc2                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+		}
+
+		if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+			printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+#endif
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi4_pads[] = {
+	MX6SX_PAD_SD2_CLK__ECSPI4_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA3__ECSPI4_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6SX_PAD_SD2_CMD__ECSPI4_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA2__GPIO6_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi4_pads,
+					 ARRAY_SIZE(ecspi4_pads));
+	gpio_direction_output(IMX_GPIO_NR(6, 10), 0);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+iomux_v3_cfg_t eimnor_pads[] = {
+	MX6SX_PAD_NAND_DATA00__WEIM_AD_0     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA01__WEIM_AD_1     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA02__WEIM_AD_2     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA03__WEIM_AD_3     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA04__WEIM_AD_4     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA05__WEIM_AD_5     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA06__WEIM_AD_6     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA07__WEIM_AD_7     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA08__WEIM_AD_8     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA09__WEIM_AD_9     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA10__WEIM_AD_10    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA11__WEIM_AD_11    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL) ,
+	MX6SX_PAD_LCD1_DATA12__WEIM_AD_12    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA13__WEIM_AD_13    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA14__WEIM_AD_14    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA15__WEIM_AD_15    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA16__WEIM_ADDR_16  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA17__WEIM_ADDR_17  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA18__WEIM_ADDR_18  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA19__WEIM_ADDR_19  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA20__WEIM_ADDR_20  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA21__WEIM_ADDR_21  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA22__WEIM_ADDR_22  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA23__WEIM_ADDR_23  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA03__WEIM_ADDR_24  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA04__WEIM_ADDR_25  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6SX_PAD_NAND_CE0_B__WEIM_LBA_B     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_CE1_B__WEIM_OE        | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_RE_B__WEIM_RW         | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_WE_B__WEIM_WAIT       | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	MX6SX_PAD_NAND_ALE__WEIM_CS0_B       | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+};
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
+	writel(0x00610089, WEIM_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
+	writel(0x1c022000, WEIM_BASE_ADDR + 0x008);
+	writel(0x00000000, WEIM_BASE_ADDR + 0x00c);
+	writel(0x1404a38e, WEIM_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads,
+			ARRAY_SIZE(eimnor_pads));
+
+	eimnor_cs_setup();
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+iomux_v3_cfg_t gpmi_pads[] = {
+	MX6SX_PAD_NAND_CLE__RAWNAND_CLE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_ALE__RAWNAND_ALE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_WP_B__RAWNAND_WP_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_READY_B__RAWNAND_READY_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL0),
+	MX6SX_PAD_NAND_CE0_B__RAWNAND_CE0_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_RE_B__RAWNAND_RE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_WE_B__RAWNAND_WE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA00__RAWNAND_DATA00	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA01__RAWNAND_DATA01	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA02__RAWNAND_DATA02	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA03__RAWNAND_DATA03	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA04__RAWNAND_DATA04	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA05__RAWNAND_DATA05	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA06__RAWNAND_DATA06	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA07__RAWNAND_DATA07	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	/* Disable the QSPI2 root clock */
+	clrbits_le32(&mxc_ccm->CCGR4, MXC_CCM_CCGR4_QSPI2_ENFC_MASK
+				| MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK);
+
+	/* config gpmi and bch clock to 100 MHz */
+	clrsetbits_le32(&mxc_ccm->cs2cdr,
+			MXC_CCM_CS2CDR_QSPI2_CLK_PODF_MASK |
+			MXC_CCM_CS2CDR_QSPI2_CLK_PRED_MASK |
+			MXC_CCM_CS2CDR_QSPI2_CLK_SEL_MASK,
+			MXC_CCM_CS2CDR_QSPI2_CLK_PODF(0) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_PRED(3) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_SEL(3));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK |
+		     MXC_CCM_CCGR4_QSPI2_ENFC_MASK);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec1();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+	unsigned char value = 1;
+
+	/* clear gpr1[13], gpr1[17] to select anatop clock */
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+
+	ret = enable_fec_anatop_clock(0, ENET_125MHz);
+	if (ret)
+		return ret;
+
+	enable_enet_clock();
+
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+	/* release max7322 from reset */
+	gpio_direction_output(IMX_GPIO_NR(4, 22) , 1);
+
+	/* This is needed to drive the pads to 1.8V instead of 1.5V */
+	i2c_set_bus_num(CONFIG_MAX7322_I2C_BUS);
+
+	if (!i2c_probe(CONFIG_MAX7322_I2C_ADDR)) {
+		/* Write 0x1 to enable O0 output, this device has no addr */
+		/* hence addr length is 0 */
+		value = 0x1;
+		if (i2c_write(CONFIG_MAX7322_I2C_ADDR, 0, 0, &value, 1))
+			printf("MAX7322 write failed\n");
+	} else {
+		printf("MAX7322 Not found\n");
+	}
+#endif
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+#endif
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define PFUZE100_DEVICEID	0x0
+#define PFUZE100_REVID		0x3
+#define PFUZE100_FABID		0x4
+
+#define PFUZE100_SW1ABVOL	0x20
+#define PFUZE100_SW1ABSTBY	0x21
+#define PFUZE100_SW1ABCONF	0x24
+#define PFUZE100_SW1CVOL	0x2e
+#define PFUZE100_SW1CSTBY	0x2f
+#define PFUZE100_SW1CCONF	0x32
+#define PFUZE100_SW1ABC_SETP(x)	((x-3000)/250)
+
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0;
+
+	i2c_set_bus_num(CONFIG_PMIC_I2C_BUS);
+
+	if (!i2c_probe(CONFIG_PMIC_I2C_SLAVE)) {
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_DEVICEID, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_REVID, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE100! deviceid 0x%x, revid 0x%x\n", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/* set SW1AB staby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Read SW1ABCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Set SW1ABCONFIG error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Read SW1CCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Set SW1CCONFIG error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+	u32 vddarm;
+	/* swith to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* decrease VDDSOC to 1.3V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(13000);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= vddarm;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd2", MAKE_CFGVAL(0x40, 0x28, 0x00, 0x00)},
+	{"sd3", MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"emmc", MAKE_CFGVAL(0x60, 0x38, 0x00, 0x00)},
+	{"qspi2", MAKE_CFGVAL(0x18, 0x00, 0x00, 0x00)},
+	{"spinor", MAKE_CFGVAL(0x30, 0x00, 0x00, 0x0B)},
+	{"nand", MAKE_CFGVAL(0x80, 0x00, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+	int ret = 0;
+
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+#ifdef CONFIG_MX6SX_14x14
+	puts("Board: MX6SX 14x14 ARM2\n");
+#else
+	puts("Board: MX6SX 17x17 ARM2\n");
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6SX_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX6SX_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+			ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+			ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/board/freescale/mx6sx_17x17_arm2/plugin.S b/board/freescale/mx6sx_17x17_arm2/plugin.S
new file mode 100644
index 0000000..bce001e
--- /dev/null
+++ b/board/freescale/mx6sx_17x17_arm2/plugin.S
@@ -0,0 +1,277 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sx_17x17_ddr3_evk_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00270025
+	str r2, [r0, #0x80c]
+	ldr r2, =0x001B001E
+	str r2, [r0, #0x810]
+	ldr r2, =0x4144013C
+	str r2, [r0, #0x83c]
+	ldr r2, =0x01300128
+	str r2, [r0, #0x840]
+	ldr r2, =0x4044464A
+	str r2, [r0, #0x848]
+	ldr r2, =0x3A383C34
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x676b52f3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66d8b63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x0000005f
+	str r2, [r0, #0x040]
+	ldr r2, =0x84190000
+	str r2, [r0, #0x000]
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00068031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6sx_14x14_lpddr2_arm2_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00003028
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x1b4700c7
+	str r2, [r0, #0x85c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00380000
+	str r2, [r0, #0x890]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x51111111
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+
+	ldr r2, =0x42424244
+	str r2, [r0, #0x848]
+	ldr r2, =0x2E30322E
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33374133
+	str r2, [r0, #0x00c]
+	ldr r2, =0x00020024
+	str r2, [r0, #0x004]
+	ldr r2, =0x00100A42
+	str r2, [r0, #0x010]
+	ldr r2, =0x00000093
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001748
+	str r2, [r0, #0x018]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x030]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x038]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x008]
+	ldr r2, =0x0000004f
+	str r2, [r0, #0x040]
+	ldr r2, =0xc3110000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038030
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x003f8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6_ddr_setting
+#if defined(CONFIG_MX6SX_14x14) && defined (CONFIG_LPDDR)
+	imx6sx_14x14_lpddr2_arm2_ddr_setting
+#else
+	imx6sx_17x17_ddr3_evk_ddr_setting
+#endif
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6sx_19x19_arm2/Makefile b/board/freescale/mx6sx_19x19_arm2/Makefile
new file mode 100644
index 0000000..a9f17ae
--- /dev/null
+++ b/board/freescale/mx6sx_19x19_arm2/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sx_19x19_arm2.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6sx_19x19_arm2/imximage.cfg b/board/freescale/mx6sx_19x19_arm2/imximage.cfg
new file mode 100644
index 0000000..475127c
--- /dev/null
+++ b/board/freescale/mx6sx_19x19_arm2/imximage.cfg
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sx_19x19_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX */
+/* DDR IO TYPE */
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+
+/* CLOCK */
+DATA 4 0x020e032c 0x00000030
+
+/* ADDRESS */
+DATA 4 0x020e0300 0x00000030
+DATA 4 0x020e02fc 0x00000030
+DATA 4 0x020e05f4 0x00000030
+
+/* CONTROL */
+DATA 4 0x020e0340 0x00000030
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000030
+DATA 4 0x020e0314 0x00000030
+DATA 4 0x020e0614 0x00000030
+
+/* DATA STROBE */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000030
+DATA 4 0x020e0334 0x00000030
+DATA 4 0x020e0338 0x00000030
+DATA 4 0x020e033c 0x00000030
+
+/* DATA */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000030
+DATA 4 0x020e0610 0x00000030
+DATA 4 0x020e061c 0x00000030
+DATA 4 0x020e0620 0x00000030
+DATA 4 0x020e02ec 0x00000030
+DATA 4 0x020e02f0 0x00000030
+DATA 4 0x020e02f4 0x00000030
+DATA 4 0x020e02f8 0x00000030
+
+/* Calibrations */
+/* ZQ */
+DATA 4 0x021b0800 0xa1390003
+/* write leveling */
+DATA 4 0x021b080c 0x002C003D
+DATA 4 0x021b0810 0x00110046
+
+/* DQS Read Gate */
+DATA 4 0x021b083c 0x4160016C
+DATA 4 0x021b0840 0x013C016C
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x46424446
+DATA 4 0x021b0850 0x3A3C3C3A
+
+DATA 4 0x021b08c0 0x2492244A
+
+/* read data bit delay */
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+/* Complete calibration by forced measurment */
+DATA 4 0x021b08b8 0x00000800
+
+/* MMDC init */
+/* in DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000007f
+DATA 4 0x021b0000 0x85190000
+
+/* Initialize CS0: MT41K256M16HA-125 */
+/* MR2 */
+DATA 4 0x021b001c 0x04008032
+/* MR3 */
+DATA 4 0x021b001c 0x00008033
+/* MR1 */
+DATA 4 0x021b001c 0x00068031
+/* MR0 */
+DATA 4 0x021b001c 0x05208030
+/* DDR device ZQ calibration */
+DATA 4 0x021b001c 0x04008040
+
+/* final DDR setup, before operation start */
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00022227
+DATA 4 0x021b0004 0x0002556d
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff --git a/board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg b/board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg
new file mode 100644
index 0000000..c8ab483
--- /dev/null
+++ b/board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sx_19x19_arm2/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+DATA 4 0x020e0618 0x00080000
+DATA 4 0x020e05fc 0x00000000
+DATA 4 0x020e032c 0x00000030
+
+DATA 4 0x020e0300 0x00000028
+DATA 4 0x020e02fc 0x00000028
+DATA 4 0x020e05f4 0x00000028
+DATA 4 0x020e0340 0x00000028
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000000
+DATA 4 0x020e0314 0x00000000
+DATA 4 0x020e0614 0x00000028
+
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00003028
+DATA 4 0x020e0334 0x00003028
+DATA 4 0x020e0338 0x00003028
+DATA 4 0x020e033c 0x00003028
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b085c 0x1b4700c7
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b0890 0x00380000
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b082c 0x51111111
+DATA 4 0x021b0830 0x51111111
+DATA 4 0x021b0834 0x51111111
+DATA 4 0x021b0838 0x51111111
+DATA 4 0x021b0848 0x42424244
+DATA 4 0x021b0850 0x2E30322E
+DATA 4 0x021b08c0 0x2492244A
+DATA 4 0x021b083c 0x20000000
+DATA 4 0x021b0840 0x00000000
+DATA 4 0x021b08b8 0x00000800
+
+DATA 4 0x021b000c 0x33374133
+DATA 4 0x021b0004 0x00020024
+DATA 4 0x021b0010 0x00100A42
+DATA 4 0x021b0014 0x00000093
+DATA 4 0x021b0018 0x00001748
+DATA 4 0x021b002c 0x0f9f26d2
+DATA 4 0x021b0030 0x0000020e
+DATA 4 0x021b0038 0x00190778
+DATA 4 0x021b0008 0x00000000
+DATA 4 0x021b0040 0x0000004f
+DATA 4 0x021b0000 0xc3110000
+
+DATA 4 0x021b001c 0x003f8030
+DATA 4 0x021b001c 0xff0a8030
+DATA 4 0x021b001c 0x82018030
+DATA 4 0x021b001c 0x04028030
+DATA 4 0x021b001c 0x01038030
+
+DATA 4 0x021b001c 0x003f8038
+DATA 4 0x021b001c 0xff0a8038
+DATA 4 0x021b001c 0x82018038
+DATA 4 0x021b001c 0x04028038
+DATA 4 0x021b001c 0x01038038
+
+DATA 4 0x021b0020 0x00001800
+DATA 4 0x021b0818 0x00000000
+DATA 4 0x021b0800 0xa1310003
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff --git a/board/freescale/mx6sx_19x19_arm2/mx6sx_19x19_arm2.c b/board/freescale/mx6sx_19x19_arm2/mx6sx_19x19_arm2.c
new file mode 100644
index 0000000..c704a8e
--- /dev/null
+++ b/board/freescale/mx6sx_19x19_arm2/mx6sx_19x19_arm2.c
@@ -0,0 +1,941 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#include <asm/arch/crm_regs.h>
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_MED   |                                   \
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_MED   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS |				\
+	PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST)
+
+#define WEIM_NOR_PAD_CTRL2 (PAD_CTL_HYS | PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm)
+
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6SX_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6SX_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc1_pads[] = {
+	MX6SX_PAD_SD1_CLK__USDHC1_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD1_CMD__USDHC1_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD1_DATA0__USDHC1_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD1_DATA1__USDHC1_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD1_DATA2__USDHC1_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD1_DATA3__USDHC1_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* CABC enable */
+	MX6SX_PAD_KEY_ROW1__GPIO2_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6SX_PAD_GPIO1_IO12__GPIO1_IO_12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6SX_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA18__LCDIF1_DATA_18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA19__LCDIF1_DATA_19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA20__LCDIF1_DATA_20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA21__LCDIF1_DATA_21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA22__LCDIF1_DATA_22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA23__LCDIF1_DATA_23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6SX_PAD_GPIO1_IO12__GPIO1_IO_12 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_lvds(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+	enable_lvds(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* Enable CABC */
+	gpio_direction_output(IMX_GPIO_NR(2, 16) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 12) , 1);
+}
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 27) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(1, 12) , 1);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF2_BASE_ADDR,
+	.depth = 18,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6SX_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_ENET1_TX_CLK__ENET1_TX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL),
+
+	/* AR8031 PHY Reset. For arm2 board, silder the resistance */
+	MX6SX_PAD_SD4_DATA4__GPIO6_IO_18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec1(void)
+{
+	imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_QSPI
+
+#define QSPI_PAD_CTRL1	\
+		(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+		PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+#define QSPI_PAD_CTRL2 (QSPI_PAD_CTRL1 | PAD_CTL_DSE_34ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6SX_PAD_NAND_WP_B__QSPI2_A_DATA_0 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_READY_B__QSPI2_A_DATA_1 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CE0_B__QSPI2_A_DATA_2 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CE1_B__QSPI2_A_DATA_3 | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CLE__QSPI2_A_SCLK | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_ALE__QSPI2_A_SS0_B | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA01__QSPI2_B_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA00__QSPI2_B_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_WE_B__QSPI2_B_DATA_2		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_RE_B__QSPI2_B_DATA_3		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA03__QSPI2_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA02__QSPI2_B_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[1] = {
+	{USDHC1_BASE_ADDR, 0, 4},
+};
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	u32 dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	return 1;	/* Assume boot SD always present */
+}
+int board_mmc_init(bd_t *bis)
+{
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC1 (SDA)
+	 */
+	imx_iomux_v3_setup_multiple_pads(usdhc1_pads, ARRAY_SIZE(usdhc1_pads));
+
+	usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC_CLK);
+	return fsl_esdhc_initialize(bis, &usdhc_cfg[0]);
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+iomux_v3_cfg_t const ecspi4_pads[] = {
+	MX6SX_PAD_SD2_CLK__ECSPI4_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA3__ECSPI4_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6SX_PAD_SD2_CMD__ECSPI4_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA2__GPIO6_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+void setup_spinor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(ecspi4_pads,
+					 ARRAY_SIZE(ecspi4_pads));
+	gpio_direction_output(IMX_GPIO_NR(6, 10), 0);
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+iomux_v3_cfg_t eimnor_pads[] = {
+	MX6SX_PAD_QSPI1A_SCLK__WEIM_DATA_0   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1A_SS0_B__WEIM_DATA_1  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1A_SS1_B__WEIM_DATA_2  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1A_DATA3__WEIM_DATA_3  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1A_DATA2__WEIM_DATA_4  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1A_DATA1__WEIM_DATA_5  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1A_DATA0__WEIM_DATA_6  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1A_DQS__WEIM_DATA_7    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1B_SCLK__WEIM_DATA_8   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1B_SS0_B__WEIM_DATA_9  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1B_SS1_B__WEIM_DATA_10 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1B_DATA3__WEIM_DATA_11 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1B_DATA2__WEIM_DATA_12 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1B_DATA1__WEIM_DATA_13 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1B_DATA0__WEIM_DATA_14 | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+	MX6SX_PAD_QSPI1B_DQS__WEIM_DATA_15   | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL2),
+
+	MX6SX_PAD_NAND_DATA00__WEIM_AD_0     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA01__WEIM_AD_1     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA02__WEIM_AD_2     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA03__WEIM_AD_3     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA04__WEIM_AD_4     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA05__WEIM_AD_5     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA06__WEIM_AD_6     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_DATA07__WEIM_AD_7     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA08__WEIM_AD_8     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA09__WEIM_AD_9     | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA10__WEIM_AD_10    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA11__WEIM_AD_11    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL) ,
+	MX6SX_PAD_LCD1_DATA12__WEIM_AD_12    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA13__WEIM_AD_13    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA14__WEIM_AD_14    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA15__WEIM_AD_15    | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA16__WEIM_ADDR_16  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA17__WEIM_ADDR_17  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA18__WEIM_ADDR_18  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA19__WEIM_ADDR_19  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA20__WEIM_ADDR_20  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA21__WEIM_ADDR_21  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA22__WEIM_ADDR_22  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA23__WEIM_ADDR_23  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA03__WEIM_ADDR_24  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA04__WEIM_ADDR_25  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA05__WEIM_ADDR_26  | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+
+	MX6SX_PAD_NAND_CE1_B__WEIM_OE        | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_RE_B__WEIM_RW         | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+	MX6SX_PAD_NAND_WE_B__WEIM_WAIT       | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	MX6SX_PAD_NAND_ALE__WEIM_CS0_B       | MUX_PAD_CTRL(WEIM_NOR_PAD_CTRL),
+};
+static void eimnor_cs_setup(void)
+{
+	writel(0x00000120, WEIM_BASE_ADDR + 0x090);
+	writel(0x00010181, WEIM_BASE_ADDR + 0x000);
+	writel(0x00000001, WEIM_BASE_ADDR + 0x004);
+	writel(0x0a020000, WEIM_BASE_ADDR + 0x008);
+	writel(0x0000c000, WEIM_BASE_ADDR + 0x00c);
+	writel(0x0804a240, WEIM_BASE_ADDR + 0x010);
+}
+
+static void setup_eimnor(void)
+{
+	imx_iomux_v3_setup_multiple_pads(eimnor_pads,
+			ARRAY_SIZE(eimnor_pads));
+
+	eimnor_cs_setup();
+}
+#endif
+
+
+#ifdef CONFIG_SYS_USE_NAND
+iomux_v3_cfg_t gpmi_pads[] = {
+	MX6SX_PAD_NAND_CLE__RAWNAND_CLE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_ALE__RAWNAND_ALE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_WP_B__RAWNAND_WP_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_READY_B__RAWNAND_READY_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL0),
+	MX6SX_PAD_NAND_CE0_B__RAWNAND_CE0_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_RE_B__RAWNAND_RE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_WE_B__RAWNAND_WE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA00__RAWNAND_DATA00	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA01__RAWNAND_DATA01	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA02__RAWNAND_DATA02	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA03__RAWNAND_DATA03	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA04__RAWNAND_DATA04	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA05__RAWNAND_DATA05	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA06__RAWNAND_DATA06	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA07__RAWNAND_DATA07	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	/* Disable the QSPI2 root clock */
+	clrbits_le32(&mxc_ccm->CCGR4, MXC_CCM_CCGR4_QSPI2_ENFC_MASK
+				| MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK);
+
+	/* config gpmi and bch clock to 100 MHz */
+	clrsetbits_le32(&mxc_ccm->cs2cdr,
+			MXC_CCM_CS2CDR_QSPI2_CLK_PODF_MASK |
+			MXC_CCM_CS2CDR_QSPI2_CLK_PRED_MASK |
+			MXC_CCM_CS2CDR_QSPI2_CLK_SEL_MASK,
+			MXC_CCM_CS2CDR_QSPI2_CLK_PODF(0) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_PRED(3) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_SEL(3));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK |
+		     MXC_CCM_CCGR4_QSPI2_ENFC_MASK);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec1();
+
+	ret = fecmxc_initialize_multi(bis, 0,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC1 MXC: %s:failed\n", __func__);
+
+	return 0;
+}
+
+static int setup_fec(void)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+	unsigned char value = 1;
+
+	/* clear gpr1[13], gpr1[17] to select anatop clock */
+	clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+
+	ret = enable_fec_anatop_clock(0, ENET_125MHz);
+	if (ret)
+		return ret;
+
+	enable_enet_clock();
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(6, 18) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(6, 18), 1);
+
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+	/* This is needed to drive the pads to 1.8V instead of 1.5V */
+	i2c_set_bus_num(CONFIG_MAX7322_I2C_BUS);
+
+	if (!i2c_probe(CONFIG_MAX7322_I2C_ADDR)) {
+		/* Write 0x1 to enable O0 output, this device has no addr */
+		/* hence addr length is 0 */
+		value = 0x1;
+		if (i2c_write(CONFIG_MAX7322_I2C_ADDR, 0, 0, &value, 1))
+			printf("MAX7322 write failed\n");
+	} else {
+		printf("MAX7322 Not found\n");
+	}
+#endif
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+#endif
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define PFUZE100_DEVICEID	0x0
+#define PFUZE100_REVID		0x3
+#define PFUZE100_FABID		0x4
+
+#define PFUZE100_SW1ABVOL	0x20
+#define PFUZE100_SW1ABSTBY	0x21
+#define PFUZE100_SW1ABCONF	0x24
+#define PFUZE100_SW1CVOL	0x2e
+#define PFUZE100_SW1CSTBY	0x2f
+#define PFUZE100_SW1CCONF	0x32
+#define PFUZE100_SW1ABC_SETP(x)	((x-3000)/250)
+
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0;
+
+	i2c_set_bus_num(CONFIG_PMIC_I2C_BUS);
+
+	if (!i2c_probe(CONFIG_PMIC_I2C_SLAVE)) {
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_DEVICEID, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_REVID, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE%s deviceid=%x,revid=%x\n",
+			((value & 0xf) == 0) ? "100" : "200", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/* set SW1AB staby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Read SW1ABCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Set SW1ABCONFIG error!\n");
+			return -1;
+		}
+
+		/* set SW1C staby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Read SW1CCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Set SW1CCONFIG error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+	u32 vddarm;
+	/* swith to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* decrease VDDSOC to 1.3V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(13000);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= vddarm;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef CONFIG_FEC_MXC
+	setup_fec();
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+	setup_spinor();
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+	setup_eimnor();
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd1", MAKE_CFGVAL(0x40, 0x20, 0x00, 0x00)},
+	{"qspi2", MAKE_CFGVAL(0x18, 0x00, 0x00, 0x00)},
+	{"spinor", MAKE_CFGVAL(0x30, 0x00, 0x00, 0x0B)},
+	{"eimnor", MAKE_CFGVAL(0x00, 0x80, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+	int ret = 0;
+
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6SX 19x19 ARM2\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6SX_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX6SX_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+			ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+			ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
diff --git a/board/freescale/mx6sx_19x19_arm2/plugin.S b/board/freescale/mx6sx_19x19_arm2/plugin.S
new file mode 100644
index 0000000..b5387a1
--- /dev/null
+++ b/board/freescale/mx6sx_19x19_arm2/plugin.S
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sx_19x19_ddr3_arm2_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x002C003D
+	str r2, [r0, #0x80c]
+	ldr r2, =0x00110046
+	str r2, [r0, #0x810]
+	ldr r2, =0x4160016C
+	str r2, [r0, #0x83c]
+	ldr r2, =0x013C016C
+	str r2, [r0, #0x840]
+	ldr r2, =0x46424446
+	str r2, [r0, #0x848]
+	ldr r2, =0x3A3C3C3A
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x676b52f3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66d8b63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x0000007f
+	str r2, [r0, #0x040]
+	ldr r2, =0x85190000
+	str r2, [r0, #0x000]
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00068031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00022227
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+
+.macro imx6sx_19x19_lpddr2_arm2_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x00080000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000028
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00003028
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x1c]
+	ldr r2, =0x1b4700c7
+	str r2, [r0, #0x85c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00380000
+	str r2, [r0, #0x890]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x51111111
+	str r2, [r0, #0x82c]
+	str r2, [r0, #0x830]
+	str r2, [r0, #0x834]
+	str r2, [r0, #0x838]
+
+	ldr r2, =0x42424244
+	str r2, [r0, #0x848]
+	ldr r2, =0x2E30322E
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+	ldr r2, =0x20000000
+	str r2, [r0, #0x83c]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x840]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x33374133
+	str r2, [r0, #0x00c]
+	ldr r2, =0x00020024
+	str r2, [r0, #0x004]
+	ldr r2, =0x00100A42
+	str r2, [r0, #0x010]
+	ldr r2, =0x00000093
+	str r2, [r0, #0x014]
+	ldr r2, =0x00001748
+	str r2, [r0, #0x018]
+	ldr r2, =0x0f9f26d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x0000020e
+	str r2, [r0, #0x030]
+	ldr r2, =0x00190778
+	str r2, [r0, #0x038]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x008]
+	ldr r2, =0x0000004f
+	str r2, [r0, #0x040]
+	ldr r2, =0xc3110000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x003f8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038030
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x003f8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0xff0a8038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x82018038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04028038
+	str r2, [r0, #0x01c]
+	ldr r2, =0x01038038
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00001800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x818]
+	ldr r2, =0xa1310003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+#if defined (CONFIG_LPDDR2)
+	imx6sx_19x19_lpddr2_arm2_ddr_setting
+#else
+	imx6sx_19x19_ddr3_arm2_ddr_setting
+#endif
+
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6sxsabreauto/Makefile b/board/freescale/mx6sxsabreauto/Makefile
new file mode 100644
index 0000000..db01364
--- /dev/null
+++ b/board/freescale/mx6sxsabreauto/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sxsabreauto.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6sxsabreauto/imximage.cfg b/board/freescale/mx6sxsabreauto/imximage.cfg
new file mode 100644
index 0000000..d431a2d
--- /dev/null
+++ b/board/freescale/mx6sxsabreauto/imximage.cfg
@@ -0,0 +1,161 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#elif defined(CONFIG_SYS_BOOT_EIMNOR)
+BOOT_FROM	nor
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sxsabreauto/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX */
+/* DDR IO TYPE */
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+
+/* CLOCK */
+DATA 4 0x020e032c 0x00000030
+
+/* ADDRESS */
+DATA 4 0x020e0300 0x00000030
+DATA 4 0x020e02fc 0x00000030
+DATA 4 0x020e05f4 0x00000030
+
+/* CONTROL */
+DATA 4 0x020e0340 0x00000030
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000030
+DATA 4 0x020e0314 0x00000030
+DATA 4 0x020e0614 0x00000030
+
+/* DATA STROBE */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000030
+DATA 4 0x020e0334 0x00000030
+DATA 4 0x020e0338 0x00000030
+DATA 4 0x020e033c 0x00000030
+
+/* DATA */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000030
+DATA 4 0x020e0610 0x00000030
+DATA 4 0x020e061c 0x00000030
+DATA 4 0x020e0620 0x00000030
+DATA 4 0x020e02ec 0x00000030
+DATA 4 0x020e02f0 0x00000030
+DATA 4 0x020e02f4 0x00000030
+DATA 4 0x020e02f8 0x00000030
+
+/* Calibrations */
+/* ZQ */
+DATA 4 0x021b0800 0xa1390003
+/* write leveling */
+DATA 4 0x021b080c 0x002C003D
+DATA 4 0x021b0810 0x00110046
+
+/* DQS Read Gate */
+DATA 4 0x021b083c 0x4160016C
+DATA 4 0x021b0840 0x013C016C
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x46424446
+DATA 4 0x021b0850 0x3A3C3C3A
+
+DATA 4 0x021b08c0 0x2492244A
+
+/* read data bit delay */
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+/* Complete calibration by forced measurment */
+DATA 4 0x021b08b8 0x00000800
+
+/* MMDC init */
+/* in DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000007f
+DATA 4 0x021b0000 0x85190000
+
+/* Initialize CS0: MT41K256M16HA-125 */
+/* MR2 */
+DATA 4 0x021b001c 0x04008032
+/* MR3 */
+DATA 4 0x021b001c 0x00008033
+/* MR1 */
+DATA 4 0x021b001c 0x00068031
+/* MR0 */
+DATA 4 0x021b001c 0x05208030
+/* DDR device ZQ calibration */
+DATA 4 0x021b001c 0x04008040
+
+/* final DDR setup, before operation start */
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00022227
+DATA 4 0x021b0004 0x0002556d
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+#endif
diff --git a/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c b/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
new file mode 100644
index 0000000..6c93845
--- /dev/null
+++ b/board/freescale/mx6sxsabreauto/mx6sxsabreauto.c
@@ -0,0 +1,1041 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/crm_regs.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#ifdef CONFIG_MXC_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+#ifdef CONFIG_MAX7310_IOEXP
+#include <gpio_exp.h>
+#endif
+
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FASTBOOT*/
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_40ohm)
+
+#define GPMI_PAD_CTRL0 (PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_100K_UP)
+#define GPMI_PAD_CTRL1 (PAD_CTL_DSE_40ohm | PAD_CTL_SPEED_MED | \
+			PAD_CTL_SRE_FAST)
+#define GPMI_PAD_CTRL2 (GPMI_PAD_CTRL0 | GPMI_PAD_CTRL1)
+
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C2 for PMIC */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+
+/* I2C3 */
+struct i2c_pads_info i2c_pad_info3 = {
+	.scl = {
+		.i2c_mode = MX6SX_PAD_KEY_COL4__I2C3_SCL | PC,
+		.gpio_mode = MX6SX_PAD_KEY_COL4__GPIO2_IO_14 | PC,
+		.gp = IMX_GPIO_NR(2, 14),
+	},
+	.sda = {
+		.i2c_mode = MX6SX_PAD_KEY_ROW4__I2C3_SDA | PC,
+		.gpio_mode = MX6SX_PAD_KEY_ROW4__GPIO2_IO_19 | PC,
+		.gp = IMX_GPIO_NR(2, 19),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6SX_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6SX_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6SX_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA0__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA1__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA2__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA3__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA4__USDHC3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA5__USDHC3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA6__USDHC3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA7__USDHC3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6SX_PAD_USB_H_DATA__GPIO7_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* RST_B, used for power reset cycle */
+	MX6SX_PAD_KEY_COL1__GPIO2_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6SX_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA4__USDHC4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA5__USDHC4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA6__USDHC4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA7__USDHC4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6SX_PAD_USB_H_STROBE__GPIO7_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6SX_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6SX_PAD_ENET1_MDC__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_ENET1_MDIO__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RX_CTL__ENET2_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RD0__ENET2_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RD1__ENET2_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RD2__ENET2_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RD3__ENET2_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RXC__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TX_CTL__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TD0__ENET2_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TD1__ENET2_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TD2__ENET2_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TD3__ENET2_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TXC__ENET2_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (0 == fec_id)
+		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+}
+#endif
+
+#ifdef CONFIG_MAX7310_IOEXP
+
+#define CPU_PER_RST_B	IOEXP_GPIO_NR(1, 4)
+#define LVDS_EN_PIN		IOEXP_GPIO_NR(1, 7)
+#define STEER_ENET		IOEXP_GPIO_NR(2, 2)
+
+int setup_max7310(void)
+{
+	/* Must call this function after i2c has setup */
+#ifdef CONFIG_SYS_I2C_MXC
+	gpio_exp_setup_port(1, 2, 0x30);
+	gpio_exp_setup_port(2, 2, 0x32);
+
+	return 0;
+#else
+	return -EPERM;
+#endif
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_QSPI
+
+#define QSPI_PAD_CTRL1	\
+		(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+		 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6SX_PAD_QSPI1A_SS0_B__QSPI1_A_SS0_B   | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1A_SCLK__QSPI1_A_SCLK     | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1A_DATA0__QSPI1_A_DATA_0  | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1A_DATA1__QSPI1_A_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1A_DATA2__QSPI1_A_DATA_2  | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1A_DATA3__QSPI1_A_DATA_3  | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1B_SS0_B__QSPI1_B_SS0_B   | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1B_SCLK__QSPI1_B_SCLK     | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1B_DATA0__QSPI1_B_DATA_0  | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1B_DATA1__QSPI1_B_DATA_1  | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1B_DATA2__QSPI1_B_DATA_2  | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_QSPI1B_DATA3__QSPI1_B_DATA_3  | MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(0);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+iomux_v3_cfg_t gpmi_pads[] = {
+	MX6SX_PAD_NAND_CLE__RAWNAND_CLE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_ALE__RAWNAND_ALE		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_WP_B__RAWNAND_WP_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_READY_B__RAWNAND_READY_B	| MUX_PAD_CTRL(GPMI_PAD_CTRL0),
+	MX6SX_PAD_NAND_CE0_B__RAWNAND_CE0_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_RE_B__RAWNAND_RE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_WE_B__RAWNAND_WE_B		| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA00__RAWNAND_DATA00	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA01__RAWNAND_DATA01	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA02__RAWNAND_DATA02	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA03__RAWNAND_DATA03	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA04__RAWNAND_DATA04	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA05__RAWNAND_DATA05	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA06__RAWNAND_DATA06	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+	MX6SX_PAD_NAND_DATA07__RAWNAND_DATA07	| MUX_PAD_CTRL(GPMI_PAD_CTRL2),
+};
+
+static void setup_gpmi_nand(void)
+{
+	struct mxc_ccm_reg *mxc_ccm = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+
+	/* config gpmi nand iomux */
+	imx_iomux_v3_setup_multiple_pads(gpmi_pads, ARRAY_SIZE(gpmi_pads));
+
+	/* Disable the QSPI2 root clock */
+	clrbits_le32(&mxc_ccm->CCGR4, MXC_CCM_CCGR4_QSPI2_ENFC_MASK
+				| MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK);
+
+	/* config gpmi and bch clock to 100 MHz */
+	clrsetbits_le32(&mxc_ccm->cs2cdr,
+			MXC_CCM_CS2CDR_QSPI2_CLK_PODF_MASK |
+			MXC_CCM_CS2CDR_QSPI2_CLK_PRED_MASK |
+			MXC_CCM_CS2CDR_QSPI2_CLK_SEL_MASK,
+			MXC_CCM_CS2CDR_QSPI2_CLK_PODF(0) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_PRED(3) |
+			MXC_CCM_CS2CDR_QSPI2_CLK_SEL(3));
+
+	/* enable gpmi and bch clock gating */
+	setbits_le32(&mxc_ccm->CCGR4,
+		     MXC_CCM_CCGR4_RAWNAND_U_BCH_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_BCH_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_BCH_INPUT_GPMI_IO_MASK |
+		     MXC_CCM_CCGR4_RAWNAND_U_GPMI_INPUT_APB_MASK |
+		     MXC_CCM_CCGR4_PL301_MX6QPER1_BCH_MASK |
+		     MXC_CCM_CCGR4_QSPI2_ENFC_MASK);
+
+	/* enable apbh clock gating */
+	setbits_le32(&mxc_ccm->CCGR0, MXC_CCM_CCGR0_APBHDMA_MASK);
+}
+#endif
+
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(7, 10)
+#define USDHC3_RST_GPIO	IMX_GPIO_NR(2, 11)
+#define USDHC4_CD_GPIO	IMX_GPIO_NR(7, 11)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no -= 2;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 2;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = !gpio_get_value(USDHC4_CD_GPIO);
+		break;
+	}
+
+	return ret;
+
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC3
+	 * mmc1                    USDHC4
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+
+			/* Need to set steer to B0 to A*/
+			gpio_direction_output(USDHC3_RST_GPIO, 1);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			gpio_direction_input(USDHC4_CD_GPIO);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6SX_PAD_SD1_DATA1__GPIO6_IO_3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6SX_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_lvds(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+	enable_lvds(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+#ifdef CONFIG_MAX7310_IOEXP
+	/* LVDS Enable pin */
+	gpio_exp_direction_output(LVDS_EN_PIN , 1);
+#endif
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(6, 3) , 1);
+}
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 27) , 1);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF2_BASE_ADDR,
+	.depth = 18,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 18,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "Boundary-LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id)
+		/* Use 125M anatop REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+	else
+		/* Use 125M anatop REF_CLK1 for ENET2, clear gpr1[14], gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK, 0);
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_125MHz);
+	if (ret)
+		return ret;
+
+	enable_enet_clock();
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define PFUZE100_DEVICEID	0x0
+#define PFUZE100_REVID		0x3
+#define PFUZE100_FABID		0x4
+
+#define PFUZE100_SW1ABVOL	0x20
+#define PFUZE100_SW1ABSTBY	0x21
+#define PFUZE100_SW1ABCONF	0x24
+#define PFUZE100_SW1CVOL	0x2e
+#define PFUZE100_SW1CSTBY	0x2f
+#define PFUZE100_SW1CCONF	0x32
+#define PFUZE100_SW1ABC_SETP(x)	((x - 3000) / 250)
+#define PFUZE100_VGEN5CTL	0x70
+
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0;
+
+	i2c_set_bus_num(CONFIG_PMIC_I2C_BUS);
+
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_PMIC_I2C_SLAVE);
+	if (!i2c_probe(CONFIG_PMIC_I2C_SLAVE)) {
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_DEVICEID, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_REVID, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		printf("Found PFUZE100! deviceid 0x%x, revid 0x%x\n", value, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/* set SW1AB standby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Read SW1ABCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Set SW1ABCONFIG error!\n");
+			return -1;
+		}
+
+		/* set SW1C standby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Read SW1CCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Set SW1CCONFIG error!\n");
+			return -1;
+		}
+
+		/* Enable power of VGEN5 3V3, needed for SD3 */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_VGEN5CTL, 1, &value, 1)) {
+			printf("Read VGEN5CTL error!\n");
+			return -1;
+		}
+		value &= ~0x1F;
+		value |= 0x1F;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_VGEN5CTL, 1, &value, 1)) {
+			printf("Set VGEN5CTL error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		/* decrease VDDARM to 1.15V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11500);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* increase VDDSOC to 1.15V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11500);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		set_anatop_bypass(1);
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+#ifdef CONFIG_MXC_RDC
+static rdc_peri_cfg_t const shared_resources[] = {
+	(RDC_PER_GPIO1 | RDC_DOMAIN(0) | RDC_DOMAIN(1)),
+};
+#endif
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_MXC_RDC
+	imx_rdc_setup_peripherals(shared_resources, ARRAY_SIZE(shared_resources));
+#endif
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+	arch_auxiliary_core_up(0, CONFIG_SYS_AUXCORE_BOOTDATA);
+#endif
+
+	setup_iomux_uart();
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+	setup_i2c(2, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info3);
+#endif
+
+#ifdef CONFIG_MAX7310_IOEXP
+	setup_max7310();
+
+	/* Reset CPU_PER_RST_B signal for enet phy and PCIE */
+	gpio_exp_direction_output(CPU_PER_RST_B, 0);
+	udelay(500);
+	gpio_exp_direction_output(CPU_PER_RST_B, 1);
+
+	/* Set steering signal to L for selecting B0 */
+	gpio_exp_direction_output(STEER_ENET, 0);
+#endif
+
+#ifdef	CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+	setup_gpmi_nand();
+#endif
+
+#ifdef CONFIG_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	{"sda", MAKE_CFGVAL(0x42, 0x30, 0x00, 0x00)},
+	{"sdb", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{"qspi1", MAKE_CFGVAL(0x10, 0x00, 0x00, 0x00)},
+	{"nand", MAKE_CFGVAL(0x82, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+	int ret = 0;
+
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+	/* set WDOG_B to reset whole system */
+	set_wdog_reset((struct wdog_regs *)WDOG1_BASE_ADDR);
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6SX SABRE AUTO\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6SX_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+iomux_v3_cfg_t const usb_host2_pads[] = {
+	MX6SX_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+			ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_host2_pads,
+			ARRAY_SIZE(usb_host2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc0");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc1");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "nand");
+		if (!getenv("fbparts"))
+			setenv("fbparts", ANDROID_FASTBOOT_NAND_PARTS);
+		if (!getenv("bootcmd"))
+			setenv("bootcmd",
+				"nand read ${loadaddr} ${boot_nand_offset} "
+				"${boot_nand_size};booti ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+int check_recovery_cmd_file(void)
+{
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	return recovery_mode;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc0 recovery");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc1 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case NAND_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery",
+				"nand read ${loadaddr} ${recovery_nand_offset} "
+				"${recovery_nand_size};booti ${loadaddr}");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const otg_udc_pads[] = {
+	(MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+		ARRAY_SIZE(otg_udc_pads));
+}
+
+#endif /*CONFIG_IMX_UDC*/
diff --git a/board/freescale/mx6sxsabreauto/plugin.S b/board/freescale/mx6sxsabreauto/plugin.S
new file mode 100644
index 0000000..169a852
--- /dev/null
+++ b/board/freescale/mx6sxsabreauto/plugin.S
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sx_sabreauto_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x002C003D
+	str r2, [r0, #0x80c]
+	ldr r2, =0x00110046
+	str r2, [r0, #0x810]
+	ldr r2, =0x4160016C
+	str r2, [r0, #0x83c]
+	ldr r2, =0x013C016C
+	str r2, [r0, #0x840]
+	ldr r2, =0x46424446
+	str r2, [r0, #0x848]
+	ldr r2, =0x3A3C3C3A
+	str r2, [r0, #0x850]
+	ldr r2, =0x2492244A
+	str r2, [r0, #0x8c0]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x676b52f3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66d8b63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x0000007f
+	str r2, [r0, #0x040]
+	ldr r2, =0x85190000
+	str r2, [r0, #0x000]
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00068031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00022227
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+
+.endm
+
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6sx_sabreauto_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/board/freescale/mx6sxsabresd/Makefile b/board/freescale/mx6sxsabresd/Makefile
new file mode 100644
index 0000000..bd9ac6f
--- /dev/null
+++ b/board/freescale/mx6sxsabresd/Makefile
@@ -0,0 +1,10 @@
+# (C) Copyright 2014 Freescale Semiconductor, Inc.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6sxsabresd.o
+
+extra-$(CONFIG_USE_PLUGIN) :=  plugin.bin
+$(obj)/plugin.bin: $(obj)/plugin.o
+	$(OBJCOPY) -O binary --gap-fill 0xff $< $@
diff --git a/board/freescale/mx6sxsabresd/imximage.cfg b/board/freescale/mx6sxsabresd/imximage.cfg
new file mode 100644
index 0000000..5456155
--- /dev/null
+++ b/board/freescale/mx6sxsabresd/imximage.cfg
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ *
+ * Refer docs/README.imxmage for more details about how-to configure
+ * and create imximage boot image
+ *
+ * The syntax is taken as close as possible with the kwbimage
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of
+ * spi/sd/nand/onenand, qspi/nor
+ */
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+BOOT_FROM	qspi
+#else
+BOOT_FROM	sd
+#endif
+
+#ifdef CONFIG_USE_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6sxsabresd/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF 0x2000
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address	  absolute address of the register
+ *	value	  value to be stored in the register
+ */
+
+/* Enable all clocks */
+DATA 4 0x020c4068 0xffffffff
+DATA 4 0x020c406c 0xffffffff
+DATA 4 0x020c4070 0xffffffff
+DATA 4 0x020c4074 0xffffffff
+DATA 4 0x020c4078 0xffffffff
+DATA 4 0x020c407c 0xffffffff
+DATA 4 0x020c4080 0xffffffff
+DATA 4 0x020c4084 0xffffffff
+
+/* IOMUX */
+/* DDR IO TYPE */
+DATA 4 0x020e0618 0x000c0000
+DATA 4 0x020e05fc 0x00000000
+
+/* CLOCK */
+DATA 4 0x020e032c 0x00000030
+
+/* ADDRESS */
+DATA 4 0x020e0300 0x00000020
+DATA 4 0x020e02fc 0x00000020
+DATA 4 0x020e05f4 0x00000020
+
+/* CONTROL */
+DATA 4 0x020e0340 0x00000020
+
+DATA 4 0x020e0320 0x00000000
+DATA 4 0x020e0310 0x00000020
+DATA 4 0x020e0314 0x00000020
+DATA 4 0x020e0614 0x00000020
+
+/* DATA STROBE */
+DATA 4 0x020e05f8 0x00020000
+DATA 4 0x020e0330 0x00000028
+DATA 4 0x020e0334 0x00000028
+DATA 4 0x020e0338 0x00000028
+DATA 4 0x020e033c 0x00000028
+
+/* DATA */
+DATA 4 0x020e0608 0x00020000
+DATA 4 0x020e060c 0x00000028
+DATA 4 0x020e0610 0x00000028
+DATA 4 0x020e061c 0x00000028
+DATA 4 0x020e0620 0x00000028
+DATA 4 0x020e02ec 0x00000028
+DATA 4 0x020e02f0 0x00000028
+DATA 4 0x020e02f4 0x00000028
+DATA 4 0x020e02f8 0x00000028
+
+/* Calibrations */
+/* ZQ */
+DATA 4 0x021b0800 0xa1390003
+
+/* write leveling */
+DATA 4 0x021b080c 0x00290025
+DATA 4 0x021b0810 0x00220022
+
+/* DQS Read Gate */
+DATA 4 0x021b083c 0x41480144
+DATA 4 0x021b0840 0x01340130
+
+/* Read/Write Delay */
+DATA 4 0x021b0848 0x3C3E4244
+DATA 4 0x021b0850 0x34363638
+
+/* read data bit delay */
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+
+/* Complete calibration by forced measurment */
+DATA 4 0x021b08b8 0x00000800
+
+/* MMDC init */
+/* in DDR3, 64-bit mode, only MMDC0 is initiated */
+DATA 4 0x021b0004 0x0002002d
+DATA 4 0x021b0008 0x00333030
+DATA 4 0x021b000c 0x676b52f3
+DATA 4 0x021b0010 0xb66d8b63
+DATA 4 0x021b0014 0x01ff00db
+DATA 4 0x021b0018 0x00011740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x006b1023
+DATA 4 0x021b0040 0x0000005f
+DATA 4 0x021b0000 0x84190000
+
+/* Initialize MT41K256M16HA-125 */
+/* MR2 */
+DATA 4 0x021b001c 0x04008032
+/* MR3 */
+DATA 4 0x021b001c 0x00008033
+/* MR1 */
+DATA 4 0x021b001c 0x00048031
+/* MR0 */
+DATA 4 0x021b001c 0x05208030
+/* DDR device ZQ calibration */
+DATA 4 0x021b001c 0x04008040
+
+/* final DDR setup, before operation start */
+DATA 4 0x021b0020 0x00000800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b001c 0x00000000
+#endif
diff --git a/board/freescale/mx6sxsabresd/mx6sxsabresd.c b/board/freescale/mx6sxsabresd/mx6sxsabresd.c
new file mode 100644
index 0000000..0d033f3
--- /dev/null
+++ b/board/freescale/mx6sxsabresd/mx6sxsabresd.c
@@ -0,0 +1,1089 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/gpio.h>
+#include <asm/imx-common/iomux-v3.h>
+#include <asm/imx-common/boot_mode.h>
+#include <asm/io.h>
+#include <linux/sizes.h>
+#include <common.h>
+#include <fsl_esdhc.h>
+#include <mmc.h>
+#include <miiphy.h>
+#include <netdev.h>
+#ifdef CONFIG_SYS_I2C_MXC
+#include <i2c.h>
+#include <asm/imx-common/mxc_i2c.h>
+#endif
+#ifdef CONFIG_MXC_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+#include <linux/fb.h>
+#include <mxsfb.h>
+#endif
+
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+#endif /*CONFIG_FASTBOOT*/
+
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |		\
+	PAD_CTL_DSE_40ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PKE | PAD_CTL_PUE |		\
+	PAD_CTL_PUS_22K_UP  | PAD_CTL_SPEED_LOW |		\
+	PAD_CTL_DSE_80ohm   | PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP | PAD_CTL_PUE |     \
+	PAD_CTL_SPEED_HIGH   |                                   \
+	PAD_CTL_DSE_48ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_CLK_PAD_CTRL  (PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_120ohm   | PAD_CTL_SRE_FAST)
+
+#define ENET_RX_PAD_CTRL  (PAD_CTL_PKE | PAD_CTL_PUE |          \
+	PAD_CTL_SPEED_HIGH   | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE |            \
+	PAD_CTL_PUS_100K_UP | PAD_CTL_SPEED_MED |               \
+	PAD_CTL_DSE_40ohm | PAD_CTL_HYS |			\
+	PAD_CTL_ODE)
+
+#define LCD_PAD_CTRL    (PAD_CTL_HYS | PAD_CTL_PUS_100K_UP | PAD_CTL_PUE | \
+	PAD_CTL_PKE | PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm)
+
+#define BUTTON_PAD_CTRL    (PAD_CTL_PKE | PAD_CTL_PUE | \
+	PAD_CTL_PUS_22K_UP | PAD_CTL_DSE_40ohm)
+
+#define WDOG_PAD_CTRL (PAD_CTL_PUE | PAD_CTL_PKE | PAD_CTL_SPEED_MED |	\
+	PAD_CTL_DSE_40ohm)
+
+#ifdef CONFIG_SYS_I2C_MXC
+#define PC MUX_PAD_CTRL(I2C_PAD_CTRL)
+/* I2C1 for PMIC */
+struct i2c_pads_info i2c_pad_info1 = {
+	.scl = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO00__I2C1_SCL | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO00__GPIO1_IO_0 | PC,
+		.gp = IMX_GPIO_NR(1, 0),
+	},
+	.sda = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO01__I2C1_SDA | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO01__GPIO1_IO_1 | PC,
+		.gp = IMX_GPIO_NR(1, 1),
+	},
+};
+
+/* I2C2 */
+struct i2c_pads_info i2c_pad_info2 = {
+	.scl = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO02__I2C2_SCL | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO02__GPIO1_IO_2 | PC,
+		.gp = IMX_GPIO_NR(1, 2),
+	},
+	.sda = {
+		.i2c_mode = MX6SX_PAD_GPIO1_IO03__I2C2_SDA | PC,
+		.gpio_mode = MX6SX_PAD_GPIO1_IO03__GPIO1_IO_3 | PC,
+		.gp = IMX_GPIO_NR(1, 3),
+	},
+};
+#endif
+
+int dram_init(void)
+{
+	gd->ram_size = PHYS_SDRAM_SIZE;
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart1_pads[] = {
+	MX6SX_PAD_GPIO1_IO04__UART1_TX | MUX_PAD_CTRL(UART_PAD_CTRL),
+	MX6SX_PAD_GPIO1_IO05__UART1_RX | MUX_PAD_CTRL(UART_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc2_pads[] = {
+	MX6SX_PAD_SD2_CLK__USDHC2_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_CMD__USDHC2_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA0__USDHC2_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA1__USDHC2_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA2__USDHC2_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD2_DATA3__USDHC2_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	MX6SX_PAD_SD3_CLK__USDHC3_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_CMD__USDHC3_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA0__USDHC3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA1__USDHC3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA2__USDHC3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA3__USDHC3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA4__USDHC3_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA5__USDHC3_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA6__USDHC3_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD3_DATA7__USDHC3_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6SX_PAD_KEY_COL0__GPIO2_IO_10 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* RST_B, used for power reset cycle */
+	MX6SX_PAD_KEY_COL1__GPIO2_IO_11 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	MX6SX_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+
+	/* CD pin */
+	MX6SX_PAD_SD4_DATA7__GPIO6_IO_21 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const usdhc4_emmc_pads[] = {
+	MX6SX_PAD_SD4_CLK__USDHC4_CLK | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_CMD__USDHC4_CMD | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA0__USDHC4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA1__USDHC4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA2__USDHC4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA3__USDHC4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA4__USDHC4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA5__USDHC4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA6__USDHC4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_DATA7__USDHC4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL),
+	MX6SX_PAD_SD4_RESET_B__USDHC4_RESET_B | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+static iomux_v3_cfg_t const peri_3v3_pads[] = {
+	MX6SX_PAD_QSPI1A_DATA0__GPIO4_IO_16 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const wdog_b_pad = {
+	MX6SX_PAD_GPIO1_IO13__GPIO1_IO_13 | MUX_PAD_CTRL(WDOG_PAD_CTRL),
+};
+
+#ifdef CONFIG_FEC_MXC
+static iomux_v3_cfg_t const fec1_pads[] = {
+	MX6SX_PAD_ENET1_MDC__ENET1_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_ENET1_MDIO__ENET1_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RX_CTL__ENET1_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD0__ENET1_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD1__ENET1_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD2__ENET1_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RD3__ENET1_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_RXC__ENET1_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TX_CTL__ENET1_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD0__ENET1_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD1__ENET1_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD2__ENET1_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TD3__ENET1_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII1_TXC__ENET1_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const fec2_pads[] = {
+	MX6SX_PAD_ENET1_MDC__ENET2_MDC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_ENET1_MDIO__ENET2_MDIO | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RX_CTL__ENET2_RX_EN | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RD0__ENET2_RX_DATA_0 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RD1__ENET2_RX_DATA_1 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RD2__ENET2_RX_DATA_2 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RD3__ENET2_RX_DATA_3 | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_RXC__ENET2_RX_CLK | MUX_PAD_CTRL(ENET_RX_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TX_CTL__ENET2_TX_EN | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TD0__ENET2_TX_DATA_0 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TD1__ENET2_TX_DATA_1 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TD2__ENET2_TX_DATA_2 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TD3__ENET2_TX_DATA_3 | MUX_PAD_CTRL(ENET_PAD_CTRL),
+	MX6SX_PAD_RGMII2_TXC__ENET2_RGMII_TXC | MUX_PAD_CTRL(ENET_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const phy_control_pads[] = {
+	/* Phy 25M Clock */
+	MX6SX_PAD_ENET2_RX_CLK__ENET2_REF_CLK_25M | MUX_PAD_CTRL(ENET_CLK_PAD_CTRL),
+
+	/* ENET PHY Power */
+	MX6SX_PAD_ENET2_COL__GPIO2_IO_6 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* AR8031 PHY Reset. */
+	MX6SX_PAD_ENET2_CRS__GPIO2_IO_7 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static void setup_iomux_fec(int fec_id)
+{
+	if (0 == fec_id)
+		imx_iomux_v3_setup_multiple_pads(fec1_pads, ARRAY_SIZE(fec1_pads));
+	else
+		imx_iomux_v3_setup_multiple_pads(fec2_pads, ARRAY_SIZE(fec2_pads));
+}
+#endif
+
+static void setup_iomux_uart(void)
+{
+	imx_iomux_v3_setup_multiple_pads(uart1_pads, ARRAY_SIZE(uart1_pads));
+}
+
+#ifdef CONFIG_QSPI
+
+#define QSPI_PAD_CTRL1	\
+		(PAD_CTL_SRE_FAST | PAD_CTL_SPEED_MED | \
+		 PAD_CTL_PKE | PAD_CTL_PUE | PAD_CTL_PUS_47K_UP | PAD_CTL_DSE_60ohm)
+
+static iomux_v3_cfg_t const quadspi_pads[] = {
+	MX6SX_PAD_NAND_WP_B__QSPI2_A_DATA_0		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_READY_B__QSPI2_A_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CE0_B__QSPI2_A_DATA_2	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CE1_B__QSPI2_A_DATA_3	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_ALE__QSPI2_A_SS0_B		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_CLE__QSPI2_A_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA07__QSPI2_A_DQS		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA01__QSPI2_B_DATA_0	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA00__QSPI2_B_DATA_1	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_WE_B__QSPI2_B_DATA_2		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_RE_B__QSPI2_B_DATA_3		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA03__QSPI2_B_SS0_B	| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA02__QSPI2_B_SCLK		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+	MX6SX_PAD_NAND_DATA05__QSPI2_B_DQS		| MUX_PAD_CTRL(QSPI_PAD_CTRL1),
+};
+
+int board_qspi_init(void)
+{
+	/* Set the iomux */
+	imx_iomux_v3_setup_multiple_pads(quadspi_pads, ARRAY_SIZE(quadspi_pads));
+
+	/* Set the clock */
+	enable_qspi_clk(1);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FSL_ESDHC
+static struct fsl_esdhc_cfg usdhc_cfg[3] = {
+	{USDHC2_BASE_ADDR, 0, 4},
+	{USDHC3_BASE_ADDR},
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+	{USDHC4_BASE_ADDR, 0, 8},
+#else
+	{USDHC4_BASE_ADDR, 0, 4},
+#endif
+};
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(2, 10)
+#define USDHC3_PWR_GPIO	IMX_GPIO_NR(2, 11)
+#define USDHC4_CD_GPIO	IMX_GPIO_NR(6, 21)
+
+int mmc_get_env_devno(void)
+{
+	u32 soc_sbmr = readl(SRC_BASE_ADDR + 0x4);
+	int dev_no;
+	u32 bootsel;
+
+	bootsel = (soc_sbmr & 0x000000FF) >> 6 ;
+
+	/* If not boot from sd/mmc, use default value */
+	if (bootsel != 1)
+		return CONFIG_SYS_MMC_ENV_DEV;
+
+	/* BOOT_CFG2[3] and BOOT_CFG2[4] */
+	dev_no = (soc_sbmr & 0x00001800) >> 11;
+
+	/* need ubstract 1 to map to the mmc device id
+	 * see the comments in board_mmc_init function
+	 */
+
+	dev_no--;
+
+	return dev_no;
+}
+
+int mmc_map_to_kernel_blk(int dev_no)
+{
+	return dev_no + 1;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC2_BASE_ADDR:
+		ret = 1; /* Assume uSDHC2 is always present */
+		break;
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+		ret = 1;
+#else
+		ret = !gpio_get_value(USDHC4_CD_GPIO);
+#endif
+		break;
+	}
+
+	return ret;
+
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    USDHC2
+	 * mmc1                    USDHC3
+	 * mmc2                    USDHC4
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc2_pads, ARRAY_SIZE(usdhc2_pads));
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC2_CLK);
+			break;
+		case 1:
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc3_pads, ARRAY_SIZE(usdhc3_pads));
+			gpio_direction_input(USDHC3_CD_GPIO);
+			gpio_direction_output(USDHC3_PWR_GPIO, 1);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 2:
+#ifdef CONFIG_MX6SXSABRESD_EMMC_REWORK
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_emmc_pads, ARRAY_SIZE(usdhc4_emmc_pads));
+#else
+			imx_iomux_v3_setup_multiple_pads(
+				usdhc4_pads, ARRAY_SIZE(usdhc4_pads));
+			gpio_direction_input(USDHC4_CD_GPIO);
+#endif
+			usdhc_cfg[2].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) than supported by the board\n", i + 1);
+			return 0;
+			}
+
+			if (fsl_esdhc_initialize(bis, &usdhc_cfg[i]))
+				printf("Warning: failed to initialize mmc dev %d\n", i);
+	}
+
+	return 0;
+}
+
+int check_mmc_autodetect(void)
+{
+	char *autodetect_str = getenv("mmcautodetect");
+
+	if ((autodetect_str != NULL) &&
+		(strcmp(autodetect_str, "yes") == 0)) {
+		return 1;
+	}
+
+	return 0;
+}
+
+void board_late_mmc_init(void)
+{
+	char cmd[32];
+	char mmcblk[32];
+	u32 dev_no = mmc_get_env_devno();
+
+	if (!check_mmc_autodetect())
+		return;
+
+	setenv_ulong("mmcdev", dev_no);
+
+	/* Set mmcblk env */
+	sprintf(mmcblk, "/dev/mmcblk%dp2 rootwait rw",
+		mmc_map_to_kernel_blk(dev_no));
+	setenv("mmcroot", mmcblk);
+
+	sprintf(cmd, "mmc dev %d", dev_no);
+	run_command(cmd, 0);
+}
+
+#endif
+
+#ifdef CONFIG_VIDEO_MXS
+static iomux_v3_cfg_t const lvds_ctrl_pads[] = {
+	/* CABC enable */
+	MX6SX_PAD_QSPI1A_DATA2__GPIO4_IO_18 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6SX_PAD_SD1_DATA1__GPIO6_IO_3 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+static iomux_v3_cfg_t const lcd_pads[] = {
+	MX6SX_PAD_LCD1_CLK__LCDIF1_CLK | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_ENABLE__LCDIF1_ENABLE | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_HSYNC__LCDIF1_HSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_VSYNC__LCDIF1_VSYNC | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA00__LCDIF1_DATA_0 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA01__LCDIF1_DATA_1 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA02__LCDIF1_DATA_2 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA03__LCDIF1_DATA_3 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA04__LCDIF1_DATA_4 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA05__LCDIF1_DATA_5 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA06__LCDIF1_DATA_6 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA07__LCDIF1_DATA_7 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA08__LCDIF1_DATA_8 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA09__LCDIF1_DATA_9 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA10__LCDIF1_DATA_10 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA11__LCDIF1_DATA_11 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA12__LCDIF1_DATA_12 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA13__LCDIF1_DATA_13 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA14__LCDIF1_DATA_14 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA15__LCDIF1_DATA_15 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA16__LCDIF1_DATA_16 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA17__LCDIF1_DATA_17 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA18__LCDIF1_DATA_18 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA19__LCDIF1_DATA_19 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA20__LCDIF1_DATA_20 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA21__LCDIF1_DATA_21 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA22__LCDIF1_DATA_22 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_DATA23__LCDIF1_DATA_23 | MUX_PAD_CTRL(LCD_PAD_CTRL),
+	MX6SX_PAD_LCD1_RESET__GPIO3_IO_27 | MUX_PAD_CTRL(NO_PAD_CTRL),
+
+	/* Use GPIO for Brightness adjustment, duty cycle = period */
+	MX6SX_PAD_SD1_DATA2__GPIO6_IO_4 | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+
+struct lcd_panel_info_t {
+	unsigned int lcdif_base_addr;
+	int depth;
+	void	(*enable)(struct lcd_panel_info_t const *dev);
+	struct fb_videomode mode;
+};
+
+void do_enable_lvds(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+	enable_lvds(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lvds_ctrl_pads,
+							ARRAY_SIZE(lvds_ctrl_pads));
+
+	/* Enable CABC */
+	gpio_direction_output(IMX_GPIO_NR(4, 18) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(6, 3) , 1);
+}
+
+void do_enable_parallel_lcd(struct lcd_panel_info_t const *dev)
+{
+	enable_lcdif_clock(dev->lcdif_base_addr);
+
+	imx_iomux_v3_setup_multiple_pads(lcd_pads, ARRAY_SIZE(lcd_pads));
+
+	/* Power up the LCD */
+	gpio_direction_output(IMX_GPIO_NR(3, 27) , 1);
+
+	/* Set Brightness to high */
+	gpio_direction_output(IMX_GPIO_NR(6, 4) , 1);
+}
+
+static struct lcd_panel_info_t const displays[] = {{
+	.lcdif_base_addr = LCDIF2_BASE_ADDR,
+	.depth = 18,
+	.enable	= do_enable_lvds,
+	.mode	= {
+		.name			= "Hannstar-XGA",
+		.xres           = 1024,
+		.yres           = 768,
+		.pixclock       = 15385,
+		.left_margin    = 220,
+		.right_margin   = 40,
+		.upper_margin   = 21,
+		.lower_margin   = 7,
+		.hsync_len      = 60,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} }, {
+	.lcdif_base_addr = LCDIF1_BASE_ADDR,
+	.depth = 24,
+	.enable	= do_enable_parallel_lcd,
+	.mode	= {
+		.name			= "MCIMX28LCD",
+		.xres           = 800,
+		.yres           = 480,
+		.pixclock       = 29850,
+		.left_margin    = 89,
+		.right_margin   = 164,
+		.upper_margin   = 23,
+		.lower_margin   = 10,
+		.hsync_len      = 10,
+		.vsync_len      = 10,
+		.sync           = 0,
+		.vmode          = FB_VMODE_NONINTERLACED
+} } };
+
+int board_video_skip(void)
+{
+	int i;
+	int ret;
+	char const *panel = getenv("panel");
+	if (!panel) {
+		panel = displays[0].mode.name;
+		printf("No panel detected: default to %s\n", panel);
+		i = 0;
+	} else {
+		for (i = 0; i < ARRAY_SIZE(displays); i++) {
+			if (!strcmp(panel, displays[i].mode.name))
+				break;
+		}
+	}
+	if (i < ARRAY_SIZE(displays)) {
+		ret = mxs_lcd_panel_setup(displays[i].mode, displays[i].depth,
+				    displays[i].lcdif_base_addr);
+		if (!ret) {
+			if (displays[i].enable)
+				displays[i].enable(displays+i);
+			printf("Display: %s (%ux%u)\n",
+			       displays[i].mode.name,
+			       displays[i].mode.xres,
+			       displays[i].mode.yres);
+		} else
+			printf("LCD %s cannot be configured: %d\n",
+			       displays[i].mode.name, ret);
+	} else {
+		printf("unsupported panel %s\n", panel);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FEC_MXC
+int board_eth_init(bd_t *bis)
+{
+	int ret;
+
+	setup_iomux_fec(CONFIG_FEC_ENET_DEV);
+
+	ret = fecmxc_initialize_multi(bis, CONFIG_FEC_ENET_DEV,
+		CONFIG_FEC_MXC_PHYADDR, IMX_FEC_BASE);
+	if (ret)
+		printf("FEC%d MXC: %s:failed\n", CONFIG_FEC_ENET_DEV, __func__);
+
+	return 0;
+}
+
+static int setup_fec(int fec_id)
+{
+	struct iomuxc_gpr_base_regs *const iomuxc_gpr_regs
+		= (struct iomuxc_gpr_base_regs *) IOMUXC_GPR_BASE_ADDR;
+	int ret;
+
+	if (0 == fec_id)
+		/* Use 125M anatop loopback REF_CLK1 for ENET1, clear gpr1[13], gpr1[17]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC1_MASK, 0);
+	else
+		/* Use 125M anatop loopback REF_CLK1 for ENET2, clear gpr1[14], gpr1[18]*/
+		clrsetbits_le32(&iomuxc_gpr_regs->gpr[1], IOMUX_GPR1_FEC2_MASK, 0);
+
+	imx_iomux_v3_setup_multiple_pads(phy_control_pads,
+		ARRAY_SIZE(phy_control_pads));
+
+	/* Enable the ENET power, active low */
+	gpio_direction_output(IMX_GPIO_NR(2, 6) , 0);
+
+	/* Reset AR8031 PHY */
+	gpio_direction_output(IMX_GPIO_NR(2, 7) , 0);
+	udelay(500);
+	gpio_set_value(IMX_GPIO_NR(2, 7), 1);
+
+	ret = enable_fec_anatop_clock(fec_id, ENET_125MHz);
+	if (ret)
+		return ret;
+
+	enable_enet_clock();
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	/* Enable 1.8V(SEL_1P5_1P8_POS_REG) on
+	   Phy control debug reg 0 */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x1f);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x8);
+
+	/* rgmii tx clock delay enable */
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1d, 0x05);
+	phy_write(phydev, MDIO_DEVAD_NONE, 0x1e, 0x100);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define PFUZE100_DEVICEID	0x0
+#define PFUZE100_REVID		0x3
+#define PFUZE100_FABID		0x4
+
+#define PFUZE100_SW1ABVOL	0x20
+#define PFUZE100_SW1ABSTBY	0x21
+#define PFUZE100_SW1ABCONF	0x24
+#define PFUZE100_SW1CVOL	0x2e
+#define PFUZE100_SW1CSTBY	0x2f
+#define PFUZE100_SW1CCONF	0x32
+#define PFUZE100_SW1ABC_SETP(x)	((x - 3000) / 250)
+#define PFUZE100_VGEN5CTL	0x70
+
+/* set all switches APS in normal and PFM mode in standby */
+static int setup_pmic_mode(int chip)
+{
+	unsigned char offset, i, switch_num, value;
+
+	if (!chip) {
+		/* pfuze100 */
+		switch_num = 6;
+		offset = 0x31;
+	} else {
+		/* pfuze200 */
+		switch_num = 4;
+		offset = 0x38;
+	}
+
+	value = 0xc;
+	if (i2c_write(0x8, 0x23, 1, &value, 1)) {
+		printf("Set SW1AB mode error!\n");
+		return -1;
+	}
+
+	for (i = 0; i < switch_num - 1; i++) {
+		if (i2c_write(0x8, offset + i * 7, 1, &value, 1)) {
+			printf("Set switch%x mode error!\n", offset);
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+static int setup_pmic_voltages(void)
+{
+	unsigned char value, rev_id = 0;
+
+	i2c_set_bus_num(CONFIG_PMIC_I2C_BUS);
+
+	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_PMIC_I2C_SLAVE);
+	if (!i2c_probe(CONFIG_PMIC_I2C_SLAVE)) {
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_DEVICEID, 1, &value, 1)) {
+			printf("Read device ID error!\n");
+			return -1;
+		}
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_REVID, 1, &rev_id, 1)) {
+			printf("Read Rev ID error!\n");
+			return -1;
+		}
+		/*
+		 * PFUZE200: Die version 0001 = PF0200
+		 * PFUZE100: Die version 0000 = PF0100
+		 */
+		printf("Found %s! deviceid 0x%x, revid 0x%x\n", (value & 0xf) ?
+		       "PFUZE200" : "PFUZE100", value & 0xf, rev_id);
+
+		if (setup_pmic_mode(value & 0xf)) {
+			printf("setup pmic mode error!\n");
+			return -1;
+		}
+		/* set SW1AB standby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Read SW1ABSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABSTBY, 1, &value, 1)) {
+			printf("Set SW1ABSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Read SW1ABCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABCONF, 1, &value, 1)) {
+			printf("Set SW1ABCONFIG error!\n");
+			return -1;
+		}
+
+		/* set SW1C standby volatage 0.975V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Read SW1CSTBY error!\n");
+			return -1;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(9750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CSTBY, 1, &value, 1)) {
+			printf("Set SW1CSTBY error!\n");
+			return -1;
+		}
+
+		/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Read SW1CCONFIG error!\n");
+			return -1;
+		}
+		value &= ~0xc0;
+		value |= 0x40;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CCONF, 1, &value, 1)) {
+			printf("Set SW1CCONFIG error!\n");
+			return -1;
+		}
+
+		/* Enable power of VGEN5 3V3, needed for SD3 */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_VGEN5CTL, 1, &value, 1)) {
+			printf("Read VGEN5CTL error!\n");
+			return -1;
+		}
+		value &= ~0x1F;
+		value |= 0x1F;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_VGEN5CTL, 1, &value, 1)) {
+			printf("Set VGEN5CTL error!\n");
+			return -1;
+		}
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned char value;
+	int is_400M;
+	u32 vddarm;
+	/* switch to ldo_bypass mode */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM to 1.275V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(12750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+		/* decrease VDDSOC to 1.3V */
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(13000);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		is_400M = set_anatop_bypass(1);
+		if (is_400M)
+			vddarm = PFUZE100_SW1ABC_SETP(10750);
+		else
+			vddarm = PFUZE100_SW1ABC_SETP(11750);
+
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Read SW1AB error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= vddarm;
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1ABVOL, 1, &value, 1)) {
+			printf("Set SW1AB error!\n");
+			return;
+		}
+
+		if (i2c_read(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Read SW1C error!\n");
+			return;
+		}
+		value &= ~0x3f;
+		value |= PFUZE100_SW1ABC_SETP(11750);
+		if (i2c_write(CONFIG_PMIC_I2C_SLAVE, PFUZE100_SW1CVOL, 1, &value, 1)) {
+			printf("Set SW1C error!\n");
+			return;
+		}
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+
+}
+#endif
+#endif
+
+#ifdef CONFIG_MXC_RDC
+static rdc_peri_cfg_t const shared_resources[] = {
+	(RDC_PER_GPIO1 | RDC_DOMAIN(0) | RDC_DOMAIN(1)),
+};
+#endif
+
+int board_early_init_f(void)
+{
+#ifdef CONFIG_MXC_RDC
+	imx_rdc_setup_peripherals(shared_resources, ARRAY_SIZE(shared_resources));
+#endif
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+	arch_auxiliary_core_up(0, CONFIG_SYS_AUXCORE_BOOTDATA);
+#endif
+
+	setup_iomux_uart();
+	return 0;
+}
+
+int board_init(void)
+{
+	/* Address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	/*
+	 * Because kernel set WDOG_B mux before pad with the commone pinctrl
+	 * framwork now and wdog reset will be triggered once set WDOG_B mux
+	 * with default pad setting, we set pad setting here to workaround this.
+	 * Since imx_iomux_v3_setup_pad also set mux before pad setting, we set
+	 * as GPIO mux firstly here to workaround it.
+	 */
+	imx_iomux_v3_setup_pad(wdog_b_pad);
+
+	/* Enable PERI_3V3, which is used by SD2, ENET, LVDS, BT */
+	imx_iomux_v3_setup_multiple_pads(peri_3v3_pads, ARRAY_SIZE(peri_3v3_pads));
+
+	/* Active high for ncp692 */
+	gpio_direction_output(IMX_GPIO_NR(4, 16) , 1);
+
+#ifdef CONFIG_SYS_I2C_MXC
+	setup_i2c(0, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info1);
+	setup_i2c(1, CONFIG_SYS_I2C_SPEED, 0x7f, &i2c_pad_info2);
+#endif
+
+#ifdef	CONFIG_FEC_MXC
+	setup_fec(CONFIG_FEC_ENET_DEV);
+#endif
+
+#ifdef CONFIG_QSPI
+	board_qspi_init();
+#endif
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 4 bit bus width */
+	{"sd3", MAKE_CFGVAL(0x42, 0x30, 0x00, 0x00)},
+	{"sd4", MAKE_CFGVAL(0x40, 0x38, 0x00, 0x00)},
+	{"qspi2", MAKE_CFGVAL(0x18, 0x00, 0x00, 0x00)},
+	{NULL,	 0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+	int ret = 0;
+
+	ret = setup_pmic_voltages();
+	if (ret)
+		return -1;
+#endif
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_init();
+#endif
+
+	return 0;
+}
+
+u32 get_board_rev(void)
+{
+	return get_cpu_rev();
+}
+
+int checkboard(void)
+{
+	puts("Board: MX6SX SABRE SDB\n");
+
+	return 0;
+}
+
+#ifdef CONFIG_USB_EHCI_MX6
+iomux_v3_cfg_t const usb_otg1_pads[] = {
+	MX6SX_PAD_GPIO1_IO09__USB_OTG1_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+	MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)
+};
+
+iomux_v3_cfg_t const usb_otg2_pads[] = {
+	MX6SX_PAD_GPIO1_IO12__USB_OTG2_PWR | MUX_PAD_CTRL(NO_PAD_CTRL),
+};
+
+int board_ehci_hcd_init(int port)
+{
+	switch (port) {
+	case 0:
+		imx_iomux_v3_setup_multiple_pads(usb_otg1_pads,
+			ARRAY_SIZE(usb_otg1_pads));
+		break;
+	case 1:
+		imx_iomux_v3_setup_multiple_pads(usb_otg2_pads,
+			ARRAY_SIZE(usb_otg2_pads));
+		break;
+	default:
+		printf("MXC USB port %d not yet supported\n", port);
+		return 1;
+	}
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_FASTBOOT
+
+void board_fastboot_setup(void)
+{
+	switch (get_boot_device()) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc0");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc0");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc1");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc1");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("fastboot_dev"))
+			setenv("fastboot_dev", "mmc2");
+		if (!getenv("bootcmd"))
+			setenv("bootcmd", "booti mmc2");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("unsupported boot devices\n");
+		break;
+	}
+}
+
+#ifdef CONFIG_ANDROID_RECOVERY
+
+#define GPIO_VOL_DN_KEY IMX_GPIO_NR(1, 19)
+iomux_v3_cfg_t const recovery_key_pads[] = {
+	(MX6SX_PAD_CSI_DATA05__GPIO1_IO_19 | MUX_PAD_CTRL(BUTTON_PAD_CTRL)),
+};
+
+int check_recovery_cmd_file(void)
+{
+	int button_pressed = 0;
+	int recovery_mode = 0;
+
+	recovery_mode = recovery_check_and_clean_flag();
+
+	/* Check Recovery Combo Button press or not. */
+	imx_iomux_v3_setup_multiple_pads(recovery_key_pads,
+		ARRAY_SIZE(recovery_key_pads));
+
+	gpio_direction_input(GPIO_VOL_DN_KEY);
+
+	if (gpio_get_value(GPIO_VOL_DN_KEY) == 0) { /* VOL_DN key is low assert */
+		button_pressed = 1;
+		printf("Recovery key pressed\n");
+	}
+
+	return recovery_mode || button_pressed;
+}
+
+void board_recovery_setup(void)
+{
+	int bootdev = get_boot_device();
+
+	switch (bootdev) {
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case SD2_BOOT:
+	case MMC2_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc0 recovery");
+		break;
+	case SD3_BOOT:
+	case MMC3_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc1 recovery");
+		break;
+	case SD4_BOOT:
+	case MMC4_BOOT:
+		if (!getenv("bootcmd_android_recovery"))
+			setenv("bootcmd_android_recovery", "booti mmc2 recovery");
+		break;
+#endif /*CONFIG_FASTBOOT_STORAGE_MMC*/
+	default:
+		printf("Unsupported bootup device for recovery: dev: %d\n",
+			bootdev);
+		return;
+	}
+
+	printf("setup env for recovery..\n");
+	setenv("bootcmd", "run bootcmd_android_recovery");
+}
+#endif /*CONFIG_ANDROID_RECOVERY*/
+
+#endif /*CONFIG_FASTBOOT*/
+
+#ifdef CONFIG_IMX_UDC
+iomux_v3_cfg_t const otg_udc_pads[] = {
+	(MX6SX_PAD_GPIO1_IO10__ANATOP_OTG1_ID | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+void udc_pins_setting(void)
+{
+	imx_iomux_v3_setup_multiple_pads(otg_udc_pads,
+		ARRAY_SIZE(otg_udc_pads));
+}
+
+#endif /*CONFIG_IMX_UDC*/
diff --git a/board/freescale/mx6sxsabresd/plugin.S b/board/freescale/mx6sxsabresd/plugin.S
new file mode 100644
index 0000000..667095f
--- /dev/null
+++ b/board/freescale/mx6sxsabresd/plugin.S
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6sx_sabresd_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x618]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x5fc]
+	ldr r1, =0x00000030
+	str r1, [r0, #0x32c]
+
+	ldr r1, =0x00000020
+	str r1, [r0, #0x300]
+	str r1, [r0, #0x2fc]
+	str r1, [r0, #0x5f4]
+	str r1, [r0, #0x340]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x320]
+	ldr r1, =0x00000020
+	str r1, [r0, #0x310]
+	str r1, [r0, #0x314]
+	str r1, [r0, #0x614]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x5f8]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x330]
+	str r1, [r0, #0x334]
+	str r1, [r0, #0x338]
+	str r1, [r0, #0x33c]
+	ldr r1, =0x00020000
+	str r1, [r0, #0x608]
+	ldr r1, =0x00000028
+	str r1, [r0, #0x60c]
+	str r1, [r0, #0x610]
+	str r1, [r0, #0x61c]
+	str r1, [r0, #0x620]
+	str r1, [r0, #0x2ec]
+	str r1, [r0, #0x2f0]
+	str r1, [r0, #0x2f4]
+	str r1, [r0, #0x2f8]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+	ldr r2, =0x00290025
+	str r2, [r0, #0x80c]
+	ldr r2, =0x00220022
+	str r2, [r0, #0x810]
+	ldr r2, =0x41480144
+	str r2, [r0, #0x83c]
+	ldr r2, =0x01340130
+	str r2, [r0, #0x840]
+	ldr r2, =0x3C3E4244
+	str r2, [r0, #0x848]
+	ldr r2, =0x34363638
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	ldr r2, =0x0002002d
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333030
+	str r2, [r0, #0x008]
+	ldr r2, =0x676b52f3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xb66d8b63
+	str r2, [r0, #0x010]
+	ldr r2, =0x01ff00db
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x006b1023
+	str r2, [r0, #0x030]
+	ldr r2, =0x0000005f
+	str r2, [r0, #0x040]
+	ldr r2, =0x84190000
+	str r2, [r0, #0x000]
+	ldr r2, =0x04008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x05208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00000800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00011117
+	str r2, [r0, #0x818]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0xffffffff
+	str r1, [r0, #0x068]
+	str r1, [r0, #0x06c]
+	str r1, [r0, #0x070]
+	str r1, [r0, #0x074]
+	str r1, [r0, #0x078]
+	str r1, [r0, #0x07c]
+	str r1, [r0, #0x080]
+	str r1, [r0, #0x084]
+.endm
+
+.macro imx6_qos_setting
+.endm
+
+.macro imx6_ddr_setting
+	imx6sx_sabresd_ddr_setting
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/boards.cfg b/boards.cfg
index b4203f1..26aedbe 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -111,6 +111,7 @@ Active  arm         arm926ejs      at91        atmel           at91sam9x5ek
 Active  arm         arm926ejs      at91        atmel           at91sam9x5ek        at91sam9x5ek_mmc                     at91sam9x5ek:AT91SAM9X5,SYS_USE_MMC                                                                                               Bo Shen <voice.shen@atmel.com>
 Active  arm         arm926ejs      at91        atmel           at91sam9x5ek        at91sam9x5ek_nandflash               at91sam9x5ek:AT91SAM9X5,SYS_USE_NANDFLASH                                                                                         Bo Shen <voice.shen@atmel.com>
 Active  arm         arm926ejs      at91        atmel           at91sam9x5ek        at91sam9x5ek_spiflash                at91sam9x5ek:AT91SAM9X5,SYS_USE_SPIFLASH                                                                                          Bo Shen <voice.shen@atmel.com>
+Active  arm         arm926ejs      at91        axent           ag11005             ag11005                              ag11005:AT91SAM9M10G45                                                                                                            Daniel Dyer <daniel_dyer@axent.com.au>
 Active  arm         arm926ejs      at91        bluewater       -                   snapper9260                          snapper9260:AT91SAM9260                                                                                                           Ryan Mallon <ryan@bluewatersys.com>
 Active  arm         arm926ejs      at91        bluewater       snapper9260         snapper9g20                          snapper9260:AT91SAM9G20                                                                                                           Ryan Mallon <ryan@bluewatersys.com>
 Active  arm         arm926ejs      at91        BuS             vl_ma2sc            vl_ma2sc                             -                                                                                                                                 Jens Scharsig <esw@bus-elektronik.de>
@@ -308,6 +309,10 @@ Active  arm         armv7          mx6         -               udoo
 Active  arm         armv7          mx6         -               wandboard           wandboard_dl                         wandboard:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl.cfg,MX6DL,DDR_MB=1024                                                  Fabio Estevam <fabio.estevam@freescale.com>
 Active  arm         armv7          mx6         -               wandboard           wandboard_quad                       wandboard:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q2g.cfg,MX6Q,DDR_MB=2048                                                  Fabio Estevam <fabio.estevam@freescale.com>
 Active  arm         armv7          mx6         -               wandboard           wandboard_solo                       wandboard:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s.cfg,MX6S,DDR_MB=512                                                     Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         axent           ag13008             ag13008a                             ag13008:IMX_CONFIG=board/axent/ag13008/ag13008a.cfg,AG13008A,DDR_MB=512                                                                      Daniel Dyer <daniel_dyer@axent.com.au>
+Active  arm         armv7          mx6         axent           ag13008             ag13008b                             ag13008:IMX_CONFIG=board/axent/ag13008/ag13008b.cfg,AG13008B,DDR_MB=2048                                                                     Daniel Dyer <daniel_dyer@axent.com.au>
+Active  arm         armv7          mx6         axent           ag13008             ag13008a_noconsole                   ag13008:IMX_CONFIG=board/axent/ag13008/ag13008a.cfg,AG13008A,DDR_MB=512,NOCONSOLE                                                            Daniel Dyer <daniel_dyer@axent.com.au>
+Active  arm         armv7          mx6         axent           ag13008             ag13008b_noconsole                   ag13008:IMX_CONFIG=board/axent/ag13008/ag13008b.cfg,AG13008B,DDR_MB=2048,NOCONSOLE                                                            Daniel Dyer <daniel_dyer@axent.com.au>
 Active  arm         armv7          mx6         barco           titanium            titanium                             titanium:IMX_CONFIG=board/barco/titanium/imximage.cfg                                                                             Stefan Roese <sr@denx.de>
 Active  arm         armv7          mx6         boundary        nitrogen6x          mx6qsabrelite                        nitrogen6x:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6q.cfg,MX6Q,DDR_MB=1024,SABRELITE                                         Eric Nelson <eric.nelson@boundarydevices.com>
 Active  arm         armv7          mx6         boundary        nitrogen6x          nitrogen6dl                          nitrogen6x:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl.cfg,MX6DL,DDR_MB=1024                                                 Eric Nelson <eric.nelson@boundarydevices.com>
@@ -317,11 +322,64 @@ Active  arm         armv7          mx6         boundary        nitrogen6x
 Active  arm         armv7          mx6         boundary        nitrogen6x          nitrogen6s                           nitrogen6x:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s.cfg,MX6S,DDR_MB=512                                                    Eric Nelson <eric.nelson@boundarydevices.com>
 Active  arm         armv7          mx6         boundary        nitrogen6x          nitrogen6s1g                         nitrogen6x:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6s1g.cfg,MX6S,DDR_MB=1024                                                 Eric Nelson <eric.nelson@boundarydevices.com>
 Active  arm         armv7          mx6         congatec        cgtqmx6eval         cgtqmx6qeval                         cgtqmx6eval:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg,MX6Q                                                          Leo Sartre <lsartre@adeneo-embedded.com>
-Active  arm         armv7          mx6         freescale       mx6qarm2            mx6qarm2                             mx6qarm2:IMX_CONFIG=board/freescale/mx6qarm2/imximage.cfg                                                                         Jason Liu <r64343@freescale.com>
-Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreauto                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/imximage.cfg,MX6Q                                                          Fabio Estevam <fabio.estevam@freescale.com>
-Active  arm         armv7          mx6         freescale       mx6sabresd          mx6dlsabresd                         mx6sabresd:IMX_CONFIG=board/boundary/nitrogen6x/nitrogen6dl.cfg,MX6DL                                                             Fabio Estevam <fabio.estevam@freescale.com>
-Active  arm         armv7          mx6         freescale       mx6sabresd          mx6qsabresd                          mx6sabresd:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg,MX6Q                                                           Fabio Estevam <fabio.estevam@freescale.com>
-Active  arm         armv7          mx6         freescale       mx6slevk            mx6slevk                             mx6slevk:IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL                                                                   Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qarm2            mx6qarm2                             mx6qarm2:IMX_CONFIG=board/freescale/mx6qarm2/imximage.cfg,MX6Q,DDR_MB=2048                                                        Jason Liu <r64343@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qarm2            mx6qarm2_lpddr2                      mx6qarm2:IMX_CONFIG=board/freescale/mx6qarm2/imximage.cfg,MX6Q,MX6DQ_LPDDR2,DDR_MB=512                                            Jason Liu <r64343@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qarm2            mx6dlarm2                            mx6qarm2:IMX_CONFIG=board/freescale/mx6qarm2/imximage_mx6dl.cfg,MX6DL,DDR_MB=2048                                                 Jason Liu <r64343@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qarm2            mx6dlarm2_lpddr2                     mx6qarm2:IMX_CONFIG=board/freescale/mx6qarm2/imximage_mx6dl.cfg,MX6DL,MX6DL_LPDDR2,DDR_MB=512                                     Jason Liu <r64343@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreauto                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6q.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabreauto.dtb",DDR_MB=2048                                                          Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6dlsabreauto                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=2048                                                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6solosabreauto                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=1024,SYS_NOSMP="nosmp"                Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreautoandroid                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6q.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabreauto.dtb",DDR_MB=2048,ANDROID_SUPPORT                                                          Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6dlsabreautoandroid                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=2048,ANDROID_SUPPORT                                                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6solosabreautoandroid                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=1024,SYS_NOSMP="nosmp",ANDROID_SUPPORT                Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreauto_spinor                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6q.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_SPINOR                                                          Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6dlsabreauto_spinor                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_SPINOR                                                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6solosabreauto_spinor                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=1024,SYS_BOOT_SPINOR,SYS_NOSMP="nosmp"                Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreauto_eimnor                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6q.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_EIMNOR                                                          Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6dlsabreauto_eimnor                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_EIMNOR                                                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6solosabreauto_eimnor                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=1024,SYS_BOOT_EIMNOR,SYS_NOSMP="nosmp"                Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreauto_nand                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6q.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_NAND                                                          Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6dlsabreauto_nand                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_NAND                                                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6solosabreauto_nand                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=1024,SYS_BOOT_NAND,SYS_NOSMP="nosmp"                Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreautoandroid_nand                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6q.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_NAND,ANDROID_SUPPORT                                                          Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6dlsabreautoandroid_nand                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6dl.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_NAND,ANDROID_SUPPORT                                                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6solosabreautoandroid_nand                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6solo.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabreauto.dtb",DDR_MB=1024,SYS_BOOT_NAND,SYS_NOSMP="nosmp",ANDROID_SUPPORT                Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6qsabreauto       mx6qsabreauto_sata                        mx6qsabreauto:IMX_CONFIG=board/freescale/mx6qsabreauto/mx6q.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabreauto.dtb",DDR_MB=2048,SYS_BOOT_SATA                                                          Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sabresd          mx6dlsabresd                         mx6sabresd:IMX_CONFIG=board/freescale/mx6sabresd/mx6dl_4x_mt41j128.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR                                                  Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sabresd          mx6dlsabresdandroid                         mx6sabresd:IMX_CONFIG=board/freescale/mx6sabresd/mx6dl_4x_mt41j128.cfg,MX6DL,DEFAULT_FDT_FILE="imx6dl-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR,ANDROID_SUPPORT                                                  Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sabresd          mx6qsabresd                          mx6sabresd:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR                                                           Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sabresd          mx6qsabresdandroid                          mx6sabresd:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR,ANDROID_SUPPORT                                                           Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sabresd          mx6qsabresd_sata                  mx6sabresd:IMX_CONFIG=board/freescale/imx/ddr/mx6q_4x_mt41j128.cfg,MX6Q,DEFAULT_FDT_FILE="imx6q-sabresd.dtb",DDR_MB=1024,SYS_USE_SPINOR,SYS_BOOT_SATA                                 Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sabresd          mx6solosabresd                         mx6sabresd:IMX_CONFIG=board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabresd.dtb",DDR_MB=512,SYS_USE_SPINOR,SYS_NOSMP="nosmp"             Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sabresd          mx6solosabresdandroid                         mx6sabresd:IMX_CONFIG=board/freescale/mx6sabresd/mx6solo_4x_mt41j128.cfg,MX6SOLO,DEFAULT_FDT_FILE="imx6dl-sabresd.dtb",DDR_MB=512,SYS_USE_SPINOR,SYS_NOSMP="nosmp",ANDROID_SUPPORT             Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6slevk            mx6slevk                             mx6slevk:IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,SYS_USE_SPINOR                                                                   Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6slevk            mx6slevkandroid                             mx6slevk:IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,SYS_USE_SPINOR,ANDROID_SUPPORT                                                                   Fabio Estevam <fabio.estevam@freescale.com>
+
+Active  arm         armv7          mx6         freescale       mx6slevk            mx6slevk_spinor                      mx6slevk:IMX_CONFIG=board/freescale/mx6slevk/imximage.cfg,MX6SL,SYS_BOOT_SPINOR                                                   Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_17x17_arm2  mx6sx_17x17_arm2               mx6sx_17x17_arm2:IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-17x17-arm2.dtb"                                                                 Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_17x17_arm2  mx6sx_14x14_lpddr2_arm2        mx6sx_17x17_arm2:IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg,MX6SX,MX6SX_14x14,LPDDR2,DEFAULT_FDT_FILE="imx6sx-17x17-arm2.dtb"                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_17x17_arm2  mx6sx_14x14_lpddr2_arm2_nand        mx6sx_17x17_arm2:IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/mx6sx_14x14_lpddr2_arm2.cfg,MX6SX,MX6SX_14x14,LPDDR2,DEFAULT_FDT_FILE="imx6sx-17x17-arm2.dtb",SYS_BOOT_NAND                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_17x17_arm2  mx6sx_17x17_arm2_spinor     mx6sx_17x17_arm2:IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-17x17-arm2.dtb",SYS_BOOT_SPINOR                                                                 Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_17x17_arm2  mx6sx_17x17_arm2_nand       mx6sx_17x17_arm2:IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-17x17-arm2.dtb",SYS_BOOT_NAND                                                                 Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_17x17_arm2  mx6sx_17x17_arm2_qspi2      mx6sx_17x17_arm2:IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-17x17-arm2.dtb",SYS_BOOT_QSPI                                                                 Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_17x17_arm2  mx6sx_17x17_arm2_eimnor      mx6sx_17x17_arm2:IMX_CONFIG=board/freescale/mx6sx_17x17_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-17x17-arm2.dtb",SYS_BOOT_EIMNOR                                                                 Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_19x19_arm2  mx6sx_19x19_ddr3_arm2       mx6sx_19x19_arm2:IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-19x19-arm2.dtb"                                                                 Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_19x19_arm2  mx6sx_19x19_ddr3_arm2_qspi2       mx6sx_19x19_arm2:IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-19x19-arm2.dtb",SYS_BOOT_QSPI
+Active  arm         armv7          mx6         freescale       mx6sx_19x19_arm2  mx6sx_19x19_ddr3_arm2_nand       mx6sx_19x19_arm2:IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-19x19-arm2.dtb",SYS_BOOT_NAND
+Active  arm         armv7          mx6         freescale       mx6sx_19x19_arm2  mx6sx_19x19_ddr3_arm2_spinor       mx6sx_19x19_arm2:IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-19x19-arm2.dtb",SYS_BOOT_SPINOR
+Active  arm         armv7          mx6         freescale       mx6sx_19x19_arm2  mx6sx_19x19_ddr3_arm2_eimnor       mx6sx_19x19_arm2:IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage.cfg,MX6SX,DEFAULT_FDT_FILE="imx6sx-19x19-arm2.dtb",SYS_BOOT_EIMNOR
+Active  arm         armv7          mx6         freescale       mx6sx_19x19_arm2  mx6sx_19x19_lpddr2_arm2       mx6sx_19x19_arm2:IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg,MX6SX,LPDDR2,DEFAULT_FDT_FILE="imx6sx-19x19-arm2.dtb"                                                                 Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sx_19x19_arm2  mx6sx_19x19_lpddr2_arm2_qspi2       mx6sx_19x19_arm2:IMX_CONFIG=board/freescale/mx6sx_19x19_arm2/imximage_lpddr2.cfg,MX6SX,LPDDR2,DEFAULT_FDT_FILE="imx6sx-19x19-arm2.dtb",SYS_BOOT_QSPI
+Active  arm         armv7          mx6         freescale       mx6sxsabresd     mx6sxsabresd                         mx6sxsabresd:IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,MX6SX                                                               Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabresd     mx6sxsabresd_qspi2                mx6sxsabresd:IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,MX6SX,SYS_BOOT_QSPI                                                               Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabresd     mx6sxsabresd_m4fastup          mx6sxsabresd:IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,MX6SX,SYS_BOOT_QSPI,SYS_AUXCORE_FASTUP                            Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabresd     mx6sxsabresd_emmc               mx6sxsabresd:IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,MX6SX,MX6SXSABRESD_EMMC_REWORK                                       Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabresd     mx6sxsabresdandroid               mx6sxsabresd:IMX_CONFIG=board/freescale/mx6sxsabresd/imximage.cfg,MX6SX,ANDROID_SUPPORT                                                          Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabreauto     mx6sxsabreauto                    mx6sxsabreauto:IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX                                                               Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabreauto     mx6sxsabreauto_qspi1           mx6sxsabreauto:IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX,SYS_BOOT_QSPI                                                               Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabreauto     mx6sxsabreauto_nand           mx6sxsabreauto:IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX,SYS_BOOT_NAND                                                               Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabreauto     mx6sxsabreautoandroid           mx6sxsabreauto:IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX,ANDROID_SUPPORT                                                               Fabio Estevam <fabio.estevam@freescale.com>
+Active  arm         armv7          mx6         freescale       mx6sxsabreauto     mx6sxsabreautoandroid_nand           mx6sxsabreauto:IMX_CONFIG=board/freescale/mx6sxsabreauto/imximage.cfg,MX6SX,SYS_BOOT_NAND,ANDROID_SUPPORT                                                               Fabio Estevam <fabio.estevam@freescale.com>
 Active  arm         armv7          mx6         gateworks       gw_ventana          gwventanadl                          gw_ventana:IMX_CONFIG=board/gateworks/gw_ventana/gw_ventana.cfg,MX6DL,DDR_MB=512                                                  Tim Harvey <tharvey@gateworks.com>
 Active  arm         armv7          mx6         gateworks       gw_ventana          gwventanadl1g                        gw_ventana:IMX_CONFIG=board/gateworks/gw_ventana/gw_ventana.cfg,MX6DL,DDR_MB=1024                                                 Tim Harvey <tharvey@gateworks.com>
 Active  arm         armv7          mx6         gateworks       gw_ventana          gwventanaq                           gw_ventana:IMX_CONFIG=board/gateworks/gw_ventana/gw_ventana.cfg,MX6Q,DDR_MB=512                                                   Tim Harvey <tharvey@gateworks.com>
diff --git a/common/Makefile b/common/Makefile
index cecd81a..bfecc68 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_ENV_IS_IN_FAT) += env_fat.o
 obj-$(CONFIG_ENV_IS_IN_NAND) += env_nand.o
 obj-$(CONFIG_ENV_IS_IN_NVRAM) += env_nvram.o
 obj-$(CONFIG_ENV_IS_IN_ONENAND) += env_onenand.o
+obj-$(CONFIG_ENV_IS_IN_SATA) += env_sata.o
 obj-$(CONFIG_ENV_IS_IN_SPI_FLASH) += env_sf.o
 obj-$(CONFIG_ENV_IS_IN_REMOTE) += env_remote.o
 obj-$(CONFIG_ENV_IS_IN_UBI) += env_ubi.o
@@ -189,8 +190,10 @@ obj-$(CONFIG_MENU) += menu.o
 obj-$(CONFIG_MODEM_SUPPORT) += modem.o
 obj-$(CONFIG_UPDATE_TFTP) += update.o
 obj-$(CONFIG_USB_KEYBOARD) += usb_kbd.o
+obj-$(CONFIG_FASTBOOT) += cmd_fastboot.o
 obj-$(CONFIG_CMD_DFU) += cmd_dfu.o
 obj-$(CONFIG_CMD_GPT) += cmd_gpt.o
+obj-$(CONFIG_CMD_BOOTAUX) += cmd_bootaux.o
 endif
 
 ifdef CONFIG_SPL_BUILD
@@ -236,6 +239,7 @@ obj-y += console.o
 obj-$(CONFIG_CROS_EC) += cros_ec.o
 obj-y += dlmalloc.o
 obj-y += image.o
+obj-$(CONFIG_ANDROID_BOOT_IMAGE) += image-android.o
 obj-$(CONFIG_OF_LIBFDT) += image-fdt.o
 obj-$(CONFIG_FIT) += image-fit.o
 obj-$(CONFIG_FIT_SIGNATURE) += image-sig.o
diff --git a/common/board_r.c b/common/board_r.c
index 8629a65..b9f8aeb 100644
--- a/common/board_r.c
+++ b/common/board_r.c
@@ -55,6 +55,9 @@
 #include <dm/root.h>
 #include <linux/compiler.h>
 #include <linux/err.h>
+#ifdef CONFIG_FASTBOOT
+#include <fastboot.h>
+#endif
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -714,6 +717,20 @@ static int initr_modem(void)
 }
 #endif
 
+#ifdef CONFIG_FASTBOOT
+static int initr_fastboot_setup(void)
+{
+	fastboot_setup();
+	return 0;
+}
+
+static int initr_check_fastboot(void)
+{
+	check_fastboot();
+	return 0;
+}
+#endif
+
 static int run_main_loop(void)
 {
 #ifdef CONFIG_SANDBOX
@@ -885,6 +902,9 @@ init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_BOARD_LATE_INIT
 	board_late_init,
 #endif
+#ifdef CONFIG_FASTBOOT
+	initr_fastboot_setup,
+#endif
 #ifdef CONFIG_CMD_SCSI
 	INIT_FUNC_WATCHDOG_RESET
 	initr_scsi,
@@ -931,6 +951,9 @@ init_fnc_t init_sequence_r[] = {
 #ifdef CONFIG_MODEM_SUPPORT
 	initr_modem,
 #endif
+#ifdef CONFIG_FASTBOOT
+	initr_check_fastboot,
+#endif
 	run_main_loop,
 };
 
diff --git a/common/cmd_bootaux.c b/common/cmd_bootaux.c
new file mode 100644
index 0000000..b15de0e
--- /dev/null
+++ b/common/cmd_bootaux.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <command.h>
+
+/* Allow for arch specific config before we boot */
+static int __arch_auxiliary_core_up(u32 core_id, u32 boot_private_data)
+{
+	/* please define platform specific arch_auxiliary_core_up() */
+	return CMD_RET_FAILURE;
+}
+int arch_auxiliary_core_up(u32 core_id, u32 boot_private_data)
+	__attribute__((weak, alias("__arch_auxiliary_core_up")));
+
+/* Allow for arch specific config before we boot */
+static int __arch_auxiliary_core_check_up(u32 core_id)
+{
+	/* please define platform specific arch_auxiliary_core_check_up() */
+	return 0;
+}
+
+int arch_auxiliary_core_check_up(u32 core_id)
+	__attribute__((weak, alias("__arch_auxiliary_core_check_up")));
+
+int do_bootaux(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	ulong addr;
+	int ret, up;
+
+	if (argc < 2)
+		return CMD_RET_USAGE;
+
+	up = arch_auxiliary_core_check_up(0);
+	if (up) {
+		printf("## Auxiliary core is already up\n");
+		return CMD_RET_SUCCESS;
+	}
+
+	addr = simple_strtoul(argv[1], NULL, 16);
+
+	printf("## Starting auxiliary core at 0x%08lX ...\n", addr);
+
+	ret = arch_auxiliary_core_up(0, addr);
+	if (ret)
+		return CMD_RET_FAILURE;
+
+	return CMD_RET_SUCCESS;
+}
+
+U_BOOT_CMD(
+	bootaux, CONFIG_SYS_MAXARGS, 1,	do_bootaux,
+	"Start auxiliary core",
+	""
+);
diff --git a/common/cmd_bootm.c b/common/cmd_bootm.c
index 9751edc..7e3558d 100644
--- a/common/cmd_bootm.c
+++ b/common/cmd_bootm.c
@@ -222,6 +222,7 @@ static int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,
 			 char * const argv[])
 {
 	const void *os_hdr;
+	bool ep_found = false;
 
 	/* get kernel image header, start address and length */
 	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
@@ -274,6 +275,18 @@ static int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,
 		}
 		break;
 #endif
+#ifdef CONFIG_ANDROID_BOOT_IMAGE
+	case IMAGE_FORMAT_ANDROID:
+		images.os.type = IH_TYPE_KERNEL;
+		images.os.comp = IH_COMP_NONE;
+		images.os.os = IH_OS_LINUX;
+		images.ep = images.os.load;
+		ep_found = true;
+
+		images.os.end = android_image_get_end(os_hdr);
+		images.os.load = android_image_get_kload(os_hdr);
+		break;
+#endif
 	default:
 		puts("ERROR: unknown image format type!\n");
 		return 1;
@@ -293,7 +306,7 @@ static int bootm_find_os(cmd_tbl_t *cmdtp, int flag, int argc,
 			return 1;
 		}
 #endif
-	} else {
+	} else if (!ep_found) {
 		puts("Could not find kernel entry point!\n");
 		return 1;
 	}
@@ -813,6 +826,16 @@ int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
 			return do_bootm_subcommand(cmdtp, flag, argc, argv);
 	}
 
+#ifdef CONFIG_SECURE_BOOT
+	extern uint32_t authenticate_image(
+			uint32_t ddr_start, uint32_t image_size);
+	if (authenticate_image(load_addr,
+		image_get_image_size((image_header_t *)load_addr)) == 0) {
+		printf("Authenticate uImage Fail, Please check\n");
+		return 1;
+	}
+#endif
+
 	return do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START |
 		BOOTM_STATE_FINDOS | BOOTM_STATE_FINDOTHER |
 		BOOTM_STATE_LOADOS |
@@ -1002,6 +1025,14 @@ static const void *boot_get_kernel(cmd_tbl_t *cmdtp, int flag, int argc,
 		images->fit_noffset_os = os_noffset;
 		break;
 #endif
+#ifdef CONFIG_ANDROID_BOOT_IMAGE
+	case IMAGE_FORMAT_ANDROID:
+		printf("## Booting Android Image at 0x%08lx ...\n", img_addr);
+		if (android_image_get_kernel((void *)img_addr, images->verify,
+					     os_data, os_len))
+			return NULL;
+		break;
+#endif
 	default:
 		printf("Wrong Image Format for %s command\n", cmdtp->name);
 		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
@@ -1879,6 +1910,15 @@ static int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc,
 		return 1;
 #endif
 
+#ifdef CONFIG_SECURE_BOOT
+	extern uint32_t authenticate_image(
+			uint32_t ddr_start, uint32_t image_size);
+	if (authenticate_image(images->ep, zi_end - zi_start) == 0) {
+		printf("Authenticate zImage Fail, Please check\n");
+		return 1;
+	}
+#endif
+
 	return 0;
 }
 
diff --git a/common/cmd_fastboot.c b/common/cmd_fastboot.c
new file mode 100644
index 0000000..d0a929d
--- /dev/null
+++ b/common/cmd_fastboot.c
@@ -0,0 +1,1827 @@
+/*
+ * Copyright 2008 - 2009 (C) Wind River Systems, Inc.
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * Part of the rx_handler were copied from the Android project.
+ * Specifically rx command parsing in the  usb_rx_data_complete
+ * function of the file bootable/bootloader/legacy/usbloader/usbloader.c
+ *
+ * The logical naming of flash comes from the Android project
+ * Thse structures and functions that look like fastboot_flash_*
+ * They come from bootable/bootloader/legacy/libboot/flash.c
+ *
+ * This is their Copyright:
+ *
+ * Copyright (C) 2008 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <asm/byteorder.h>
+#include <common.h>
+#include <command.h>
+#include <nand.h>
+#include <fastboot.h>
+#include <environment.h>
+#include <mmc.h>
+
+#if defined(CONFIG_OF_LIBFDT)
+#include <libfdt.h>
+#include <fdt_support.h>
+#endif
+#include <asm/bootm.h>
+
+#ifdef CONFIG_FASTBOOT
+
+int do_booti(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+extern int do_bootm_linux(int flag, int argc,
+	char *argv[], bootm_headers_t *images);
+
+/* Forward decl */
+static int tx_handler(void);
+static int rx_handler(const unsigned char *buffer, unsigned int buffer_size);
+static void reset_handler(void);
+
+static struct cmd_fastboot_interface interface = {
+	.rx_handler            = rx_handler,
+	.reset_handler         = reset_handler,
+	.product_name          = NULL,
+	.serial_no             = NULL,
+	.nand_block_size       = 0,
+	.transfer_buffer       = (unsigned char *)0xffffffff,
+	.transfer_buffer_size  = 0,
+};
+
+static unsigned int download_size;
+static unsigned int download_bytes;
+static unsigned int download_bytes_unpadded;
+static unsigned int download_error;
+static unsigned int continue_booting;
+static unsigned int upload_size;
+static unsigned int upload_bytes;
+static unsigned int upload_error;
+
+#define MMC_SATA_BLOCK_SIZE 512
+
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+static void save_env(struct fastboot_ptentry *ptn,
+		     char *var, char *val)
+{
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	char lock[128], unlock[128];
+#endif
+
+	setenv(var, val);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	sprintf(lock, "nand lock 0x%x 0x%x", ptn->start, ptn->length);
+	sprintf(unlock, "nand unlock 0x%x 0x%x", ptn->start, ptn->length);
+
+	/* This could be a problem is there is an outstanding lock */
+	run_command(unlock, 0);
+#endif
+	saveenv();
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	run_command(lock, 0);
+#endif
+}
+
+void save_parts_values(struct fastboot_ptentry *ptn,
+			      unsigned int offset,
+			      unsigned int size)
+{
+	char var[64], val[32];
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	char lock[128], unlock[128];
+	struct fastboot_ptentry *env_ptn;
+#endif
+
+	printf("saving it..\n");
+
+
+	sprintf(var, "%s_nand_offset", ptn->name);
+	sprintf(val, "0x%x", offset);
+
+	printf("setenv %s %s\n", var, val);
+
+	setenv(var, val);
+
+	sprintf(var, "%s_nand_size", ptn->name);
+	sprintf(val, "0x%x", size);
+
+	printf("setenv %s %s\n", var, val);
+
+	setenv(var, val);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	/* Warning :
+	   The environment is assumed to be in a partition named 'enviroment'.
+	   It is very possible that your board stores the enviroment
+	   someplace else. */
+	env_ptn = fastboot_flash_find_ptn("environment");
+
+	if (env_ptn) {
+		sprintf(lock, "nand lock 0x%x 0x%x",
+			env_ptn->start, env_ptn->length);
+		sprintf(unlock, "nand unlock 0x%x 0x%x",
+			env_ptn->start, env_ptn->length);
+
+		run_command(unlock, 0);
+	}
+#endif
+	saveenv();
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	if (env_ptn)
+		run_command(lock, 0);
+#endif
+}
+
+int check_parts_values(struct fastboot_ptentry *ptn)
+{
+	char var[64];
+
+	sprintf(var, "%s_nand_offset", ptn->name);
+	if (!getenv(var))
+		return 1;
+
+	sprintf(var, "%s_nand_size", ptn->name);
+	if (!getenv(var))
+		return 1;
+
+	return 0;
+}
+
+static int write_to_ptn(struct fastboot_ptentry *ptn)
+{
+	int ret = 1;
+	char length[32];
+	char write_type[32];
+	int repeat, repeat_max;
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+	char lock[128];
+	char unlock[128];
+#endif
+	char write[128];
+	char erase[128];
+
+	printf("flashing '%s'\n", ptn->name);
+
+	/* Which flavor of write to use */
+	if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_I)
+		sprintf(write_type, "write.i");
+#ifdef CONFIG_CMD_NAND_TRIMFFS
+	else if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS)
+		sprintf(write_type, "write.trimffs");
+#endif
+	else
+		sprintf(write_type, "write");
+
+	/* Some flashing requires writing the same data in multiple,
+	   consecutive flash partitions */
+	repeat_max = 1;
+	if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK) {
+		if (ptn->flags &
+		    FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK) {
+			printf("Warning can not do both 'contiguous block' "
+				"and 'repeat' writes for for partition '%s'\n", ptn->name);
+			printf("Ignoring repeat flag\n");
+		} else {
+			repeat_max = ptn->flags &
+				FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK;
+		}
+	}
+
+	/* Unlock the whole partition instead of trying to
+	   manage special cases */
+	sprintf(length, "0x%x", ptn->length * repeat_max);
+
+	for (repeat = 0; repeat < repeat_max; repeat++) {
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+		sprintf(lock, "nand lock 0x%x %s",
+			ptn->start + (repeat * ptn->length), length);
+		sprintf(unlock, "nand unlock 0x%x %s",
+			ptn->start + (repeat * ptn->length), length);
+#endif
+		sprintf(erase, "nand erase 0x%x %s",
+			ptn->start + (repeat * ptn->length), length);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+		run_command(unlock, 0);
+#endif
+		run_command(erase, 0);
+
+		if ((ptn->flags &
+		     FASTBOOT_PTENTRY_FLAGS_WRITE_NEXT_GOOD_BLOCK) &&
+		    (ptn->flags &
+		     FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK)) {
+			/* Both can not be true */
+			printf("Warning can not do 'next good block' and \
+				'contiguous block' for partition '%s'\n",
+				ptn->name);
+			printf("Ignoring these flags\n");
+		} else if (ptn->flags &
+			   FASTBOOT_PTENTRY_FLAGS_WRITE_NEXT_GOOD_BLOCK) {
+			/* Keep writing until you get a good block
+			   transfer_buffer should already be aligned */
+			if (interface.nand_block_size) {
+				unsigned int blocks = download_bytes /
+					interface.nand_block_size;
+				unsigned int i = 0;
+				unsigned int offset = 0;
+
+				while (i < blocks) {
+					/* Check for overflow */
+					if (offset >= ptn->length)
+						break;
+
+					/* download's address only advance
+					   if last write was successful */
+
+					/* nand's address always advances */
+					sprintf(write, "nand %s 0x%p 0x%x 0x%x", write_type,
+						interface.transfer_buffer +
+						(i * interface.nand_block_size),
+						ptn->start + (repeat * ptn->length) + offset,
+						interface.nand_block_size);
+
+					ret = run_command(write, 0);
+					if (ret)
+						break;
+					else
+						i++;
+
+					/* Go to next nand block */
+					offset += interface.nand_block_size;
+				}
+			} else {
+				printf("Warning nand block size can not be 0 \
+					when using 'next good block' for \
+					partition '%s'\n", ptn->name);
+				printf("Ignoring write request\n");
+			}
+		} else if (ptn->flags &
+			 FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK) {
+			/* Keep writing until you get a good block
+			   transfer_buffer should already be aligned */
+			if (interface.nand_block_size) {
+				if (0 == nand_curr_device) {
+					nand_info_t *nand;
+					unsigned long off;
+					unsigned int ok_start;
+
+					nand = &nand_info[nand_curr_device];
+
+					printf("\nDevice %d bad blocks:\n",
+					       nand_curr_device);
+
+					/* Initialize the ok_start to the
+					   start of the partition
+					   Then try to find a block large
+					   enough for the download */
+					ok_start = ptn->start;
+
+					/* It is assumed that the start and
+					   length are multiples of block size */
+					for (off = ptn->start;
+					     off < ptn->start + ptn->length;
+					     off += nand->erasesize) {
+						if (nand_block_isbad(nand, off)) {
+							/* Reset the ok_start
+							   to the next block */
+							ok_start = off +
+								nand->erasesize;
+						}
+
+						/* Check if we have enough
+						   blocks */
+						if ((ok_start - off) >=
+						    download_bytes)
+							break;
+					}
+
+					/* Check if there is enough space */
+					if (ok_start + download_bytes <=
+					    ptn->start + ptn->length) {
+
+						sprintf(write, "nand %s 0x%p 0x%x 0x%x", write_type,
+							interface.transfer_buffer,
+							ok_start,
+							download_bytes);
+
+						ret = run_command(write, 0);
+
+						/* Save the results into an
+						   environment variable on the
+						   format
+						   ptn_name + 'offset'
+						   ptn_name + 'size'  */
+						if (ret) {
+							/* failed */
+							save_parts_values(ptn, ptn->start, 0);
+						} else {
+							/* success */
+							save_parts_values(ptn, ok_start, download_bytes);
+						}
+					} else {
+						printf("Error could not find enough contiguous space "
+							"in partition '%s'\n", ptn->name);
+						printf("Ignoring write request\n");
+					}
+				} else {
+					/* TBD : Generalize flash handling */
+					printf("Error only handling 1 NAND per board");
+					printf("Ignoring write request\n");
+				}
+			} else {
+				printf("Warning nand block size can not be 0 \
+					when using 'continuous block' for \
+					partition '%s'\n", ptn->name);
+				printf("Ignoring write request\n");
+			}
+		} else {
+			/* Normal case */
+			sprintf(write, "nand %s 0x%p 0x%x 0x%x", write_type,
+							interface.transfer_buffer,
+							ptn->start + (repeat * ptn->length),
+							download_bytes);
+#ifdef CONFIG_CMD_NAND_TRIMFFS
+			if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS) {
+				sprintf(write, "nand %s 0x%p 0x%x 0x%x", write_type,
+							interface.transfer_buffer,
+							ptn->start + (repeat * ptn->length),
+							download_bytes_unpadded);
+			}
+#endif
+
+			ret = run_command(write, 0);
+
+			if (0 == repeat) {
+				if (ret) /* failed */
+					save_parts_values(ptn, ptn->start, 0);
+				else     /* success */
+					save_parts_values(ptn, ptn->start,
+							  download_bytes);
+			}
+		}
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+		run_command(lock, 0);
+#endif
+
+		if (ret)
+			break;
+	}
+
+	return ret;
+}
+#else
+static void save_env(struct fastboot_ptentry *ptn,
+		     char *var, char *val)
+{
+	setenv(var, val);
+	saveenv();
+}
+#endif
+
+/* When save = 0, just parse.  The input is unchanged
+   When save = 1, parse and do the save.  The input is changed */
+static int parse_env(void *ptn, char *err_string, int save, int debug)
+{
+	int ret = 1;
+	unsigned int sets = 0;
+	unsigned int comment_start = 0;
+	char *var = NULL;
+	char *var_end = NULL;
+	char *val = NULL;
+	char *val_end = NULL;
+	unsigned int i;
+
+	char *buff = (char *)interface.transfer_buffer;
+	unsigned int size = download_bytes_unpadded;
+
+	/* The input does not have to be null terminated.
+	   This will cause a problem in the corner case
+	   where the last line does not have a new line.
+	   Put a null after the end of the input.
+
+	   WARNING : Input buffer is assumed to be bigger
+	   than the size of the input */
+	if (save)
+		buff[size] = 0;
+
+	for (i = 0; i < size; i++) {
+
+		if (NULL == var) {
+
+			/*
+			 * Check for comments, comment ok only on
+			 * mostly empty lines
+			 */
+			if (buff[i] == '#')
+				comment_start = 1;
+
+			if (comment_start) {
+				if  ((buff[i] == '\r') ||
+				     (buff[i] == '\n')) {
+					comment_start = 0;
+				}
+			} else {
+				if (!((buff[i] == ' ') ||
+				      (buff[i] == '\t') ||
+				      (buff[i] == '\r') ||
+				      (buff[i] == '\n'))) {
+					/*
+					 * Normal whitespace before the
+					 * variable
+					 */
+					var = &buff[i];
+				}
+			}
+
+		} else if (((NULL == var_end) || (NULL == val)) &&
+			   ((buff[i] == '\r') || (buff[i] == '\n'))) {
+
+			/* This is the case when a variable
+			   is unset. */
+
+			if (save) {
+				/* Set the var end to null so the
+				   normal string routines will work
+
+				   WARNING : This changes the input */
+				buff[i] = '\0';
+
+				save_env(ptn, var, val);
+
+				if (debug)
+					printf("Unsetting %s\n", var);
+			}
+
+			/* Clear the variable so state is parse is back
+			   to initial. */
+			var = NULL;
+			var_end = NULL;
+			sets++;
+		} else if (NULL == var_end) {
+			if ((buff[i] == ' ') ||
+			    (buff[i] == '\t'))
+				var_end = &buff[i];
+		} else if (NULL == val) {
+			if (!((buff[i] == ' ') ||
+			      (buff[i] == '\t')))
+				val = &buff[i];
+		} else if (NULL == val_end) {
+			if ((buff[i] == '\r') ||
+			    (buff[i] == '\n')) {
+				/* look for escaped cr or ln */
+				if ('\\' == buff[i - 1]) {
+					/* check for dos */
+					if ((buff[i] == '\r') &&
+					    (buff[i+1] == '\n'))
+						buff[i + 1] = ' ';
+					buff[i - 1] = buff[i] = ' ';
+				} else {
+					val_end = &buff[i];
+				}
+			}
+		} else {
+			sprintf(err_string, "Internal Error");
+
+			if (debug)
+				printf("Internal error at %s %d\n",
+				       __FILE__, __LINE__);
+			return 1;
+		}
+		/* Check if a var / val pair is ready */
+		if (NULL != val_end) {
+			if (save) {
+				/* Set the end's with nulls so
+				   normal string routines will
+				   work.
+
+				   WARNING : This changes the input */
+				*var_end = '\0';
+				*val_end = '\0';
+
+				save_env(ptn, var, val);
+
+				if (debug)
+					printf("Setting %s %s\n", var, val);
+			}
+
+			/* Clear the variable so state is parse is back
+			   to initial. */
+			var = NULL;
+			var_end = NULL;
+			val = NULL;
+			val_end = NULL;
+
+			sets++;
+		}
+	}
+
+	/* Corner case
+	   Check for the case that no newline at end of the input */
+	if ((NULL != var) &&
+	    (NULL == val_end)) {
+		if (save) {
+			/* case of val / val pair */
+			if (var_end)
+				*var_end = '\0';
+			/* else case handled by setting 0 past
+			   the end of buffer.
+			   Similar for val_end being null */
+			save_env(ptn, var, val);
+
+			if (debug) {
+				if (var_end)
+					printf("Trailing Setting %s %s\n", var, val);
+				else
+					printf("Trailing Unsetting %s\n", var);
+			}
+		}
+		sets++;
+	}
+	/* Did we set anything ? */
+	if (0 == sets)
+		sprintf(err_string, "No variables set");
+	else
+		ret = 0;
+
+	return ret;
+}
+
+static int saveenv_to_ptn(struct fastboot_ptentry *ptn, char *err_string)
+{
+	int ret = 1;
+	int save = 0;
+	int debug = 0;
+
+	/* err_string is only 32 bytes
+	   Initialize with a generic error message. */
+	sprintf(err_string, "%s", "Unknown Error");
+
+	/* Parse the input twice.
+	   Only save to the enviroment if the entire input if correct */
+	save = 0;
+	if (0 == parse_env(ptn, err_string, save, debug)) {
+		save = 1;
+		ret = parse_env(ptn, err_string, save, debug);
+	}
+	return ret;
+}
+
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+
+static void process_flash_nand(const char *cmdbuf, char *response)
+{
+	if (download_bytes) {
+		struct fastboot_ptentry *ptn;
+
+		ptn = fastboot_flash_find_ptn(cmdbuf + 6);
+		if (ptn == 0) {
+			sprintf(response, "FAILpartition does not exist");
+		} else if ((download_bytes > ptn->length) &&
+			   !(ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV)) {
+			sprintf(response, "FAILimage too large for partition");
+			/* TODO : Improve check for yaffs write */
+		} else {
+			/* Check if this is not really a flash write
+			   but rather a saveenv */
+			if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV) {
+				/* Since the response can only be 64 bytes,
+				   there is no point in having a large error message. */
+				char err_string[32];
+				if (saveenv_to_ptn(ptn, &err_string[0])) {
+					printf("savenv '%s' failed : %s\n",
+						ptn->name, err_string);
+					sprintf(response, "FAIL%s", err_string);
+				} else {
+					printf("partition '%s' saveenv-ed\n", ptn->name);
+					sprintf(response, "OKAY");
+				}
+			} else {
+				/* Normal case */
+				if (write_to_ptn(ptn)) {
+					printf("flashing '%s' failed\n", ptn->name);
+					sprintf(response, "FAILfailed to flash partition");
+				} else {
+					printf("partition '%s' flashed\n", ptn->name);
+					sprintf(response, "OKAY");
+				}
+			}
+		}
+	} else {
+		sprintf(response, "FAILno image downloaded");
+	}
+
+}
+#endif
+
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+static void process_flash_sata(const char *cmdbuf, char *response)
+{
+	if (download_bytes) {
+		struct fastboot_ptentry *ptn;
+
+		/* Next is the partition name */
+		ptn = fastboot_flash_find_ptn(cmdbuf + 6);
+		if (ptn == 0) {
+			printf("Partition:'%s' does not exist\n", ptn->name);
+			sprintf(response, "FAILpartition does not exist");
+		} else if ((download_bytes >
+			   ptn->length * MMC_SATA_BLOCK_SIZE) &&
+				!(ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV)) {
+			printf("Image too large for the partition\n");
+			sprintf(response, "FAILimage too large for partition");
+		} else if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV) {
+			/* Since the response can only be 64 bytes,
+			   there is no point in having a large error message. */
+			char err_string[32];
+			if (saveenv_to_ptn(ptn, &err_string[0])) {
+				printf("savenv '%s' failed : %s\n", ptn->name, err_string);
+				sprintf(response, "FAIL%s", err_string);
+			} else {
+				printf("partition '%s' saveenv-ed\n", ptn->name);
+				sprintf(response, "OKAY");
+			}
+		} else {
+			unsigned int temp;
+			char sata_write[128];
+
+			/* block count */
+			temp = (download_bytes +
+				MMC_SATA_BLOCK_SIZE - 1) /
+					MMC_SATA_BLOCK_SIZE;
+
+			sprintf(sata_write, "sata write 0x%x 0x%x 0x%x",
+				(unsigned int)interface.transfer_buffer,
+				ptn->start,
+				temp)
+
+			if (run_command(sata_write, 0)) {
+				printf("Writing '%s' FAILED!\n",
+					 ptn->name);
+				sprintf(response,
+				       "FAIL: Write partition");
+			} else {
+				printf("Writing '%s' DONE!\n",
+					ptn->name);
+				sprintf(response, "OKAY");
+			}
+		}
+	} else {
+		sprintf(response, "FAILno image downloaded");
+	}
+
+}
+#endif
+
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+static void process_flash_mmc(const char *cmdbuf, char *response)
+{
+	if (download_bytes) {
+		struct fastboot_ptentry *ptn;
+
+		/* Next is the partition name */
+		ptn = fastboot_flash_find_ptn(cmdbuf + 6);
+		if (ptn == 0) {
+			printf("Partition:'%s' does not exist\n", ptn->name);
+			sprintf(response, "FAILpartition does not exist");
+		} else if ((download_bytes >
+			   ptn->length * MMC_SATA_BLOCK_SIZE) &&
+				!(ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV)) {
+			printf("Image too large for the partition\n");
+			sprintf(response, "FAILimage too large for partition");
+		} else if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_WRITE_ENV) {
+			/* Since the response can only be 64 bytes,
+			   there is no point in having a large error message. */
+			char err_string[32];
+			if (saveenv_to_ptn(ptn, &err_string[0])) {
+				printf("savenv '%s' failed : %s\n", ptn->name, err_string);
+				sprintf(response, "FAIL%s", err_string);
+			} else {
+				printf("partition '%s' saveenv-ed\n", ptn->name);
+				sprintf(response, "OKAY");
+			}
+		} else {
+			unsigned int temp;
+
+			char mmc_dev[128];
+			char mmc_write[128];
+			int mmcret;
+
+			printf("writing to partition '%s'\n", ptn->name);
+
+			if (ptn->partition_id != FASTBOOT_MMC_NONE_PARTITION_ID)
+				sprintf(mmc_dev, "mmc dev %x %x",
+					fastboot_devinfo.dev_id, /*slot no*/
+					ptn->partition_id /*part no*/);
+			else
+				sprintf(mmc_dev, "mmc dev %x",
+					fastboot_devinfo.dev_id /*slot no*/);
+
+			/* block count */
+			temp = (download_bytes +
+				    MMC_SATA_BLOCK_SIZE - 1) /
+				    MMC_SATA_BLOCK_SIZE;
+
+			sprintf(mmc_write, "mmc write 0x%x 0x%x 0x%x",
+					(unsigned int)interface.transfer_buffer, /*source*/
+					ptn->start, /*dest*/
+					temp /*length*/);
+
+			printf("Initializing '%s'\n", ptn->name);
+
+			mmcret = run_command(mmc_dev, 0);
+			if (mmcret)
+				sprintf(response, "FAIL:Init of MMC card");
+			else
+				sprintf(response, "OKAY");
+
+			printf("Writing '%s'\n", ptn->name);
+			if (run_command(mmc_write, 0)) {
+				printf("Writing '%s' FAILED!\n", ptn->name);
+				sprintf(response, "FAIL: Write partition");
+			} else {
+				printf("Writing '%s' DONE!\n", ptn->name);
+				sprintf(response, "OKAY");
+			}
+		}
+	} else {
+		sprintf(response, "FAILno image downloaded");
+	}
+}
+
+#endif
+
+static void reset_handler ()
+{
+	/* If there was a download going on, bail */
+	download_size = 0;
+	download_bytes = 0;
+	download_bytes_unpadded = 0;
+	download_error = 0;
+	continue_booting = 0;
+	upload_size = 0;
+	upload_bytes = 0;
+	upload_error = 0;
+}
+
+static void rx_process_getvar(const char *cmdbuf, char *response)
+{
+	int temp_len = 0;
+
+	strcpy(response, "OKAY");
+
+	temp_len = strlen("getvar:");
+	if (!strcmp(cmdbuf + temp_len, "version")) {
+		strcpy(response + 4, FASTBOOT_VERSION);
+	} else if (!strcmp(cmdbuf + temp_len,
+			     "product")) {
+		if (interface.product_name)
+			strcpy(response + 4, interface.product_name);
+
+	} else if (!strcmp(cmdbuf + temp_len,
+			     "serialno")) {
+		if (interface.serial_no)
+			strcpy(response + 4, interface.serial_no);
+
+	} else if (!strcmp(cmdbuf + temp_len,
+			    "downloadsize")) {
+		if (interface.transfer_buffer_size)
+			sprintf(response + 4, "0x%x",
+				interface.transfer_buffer_size);
+	} else {
+		fastboot_getvar(cmdbuf + 7, response + 4);
+	}
+}
+
+static void rx_process_reboot(const char *cmdbuf, char *response)
+{
+	sprintf(response, "OKAY");
+	fastboot_tx_status(response, strlen(response));
+	udelay(1000000); /* 1 sec */
+
+	do_reset(NULL, 0, 0, NULL);
+}
+
+static int rx_process_erase(const char *cmdbuf, char *response)
+{
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	struct fastboot_ptentry *ptn;
+
+	ptn = fastboot_flash_find_ptn(cmdbuf + 6);
+	if (ptn == 0) {
+		sprintf(response, "FAILpartition does not exist");
+	} else {
+		int status, repeat, repeat_max;
+
+		printf("erasing '%s'\n", ptn->name);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+		char lock[128];
+		char unlock[128];
+#endif
+		char erase[128];
+
+		repeat_max = 1;
+		if (ptn->flags & FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK)
+			repeat_max = ptn->flags & FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK;
+
+		for (repeat = 0; repeat < repeat_max;
+			repeat++) {
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+			sprintf(lock, "nand lock 0x%x 0x%x",
+				ptn->start + (repeat * ptn->length),
+				ptn->length);
+			sprintf(unlock, "nand unlock 0x%x 0x%x",
+				ptn->start + (repeat * ptn->length),
+				ptn->length);
+#endif
+			sprintf(erase, "nand erase 0x%x 0x%x",
+				ptn->start + (repeat * ptn->length),
+				ptn->length);
+
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+			run_command(unlock, 0);
+#endif
+			status = run_command(erase, 0);
+#ifdef CONFIG_CMD_NAND_LOCK_UNLOCK
+			run_command(lock, 0);
+#endif
+
+			if (status)
+				break;
+		}
+
+		if (status) {
+			sprintf(response,
+				   "FAILfailed to erase partition");
+		} else {
+			printf("partition '%s' erased\n", ptn->name);
+			sprintf(response, "OKAY");
+		}
+	}
+	return 0;
+#else
+	printf("Not support erase command for EMMC\n");
+	return -1;
+#endif
+
+}
+
+static void rx_process_flash(const char *cmdbuf, char *response)
+{
+	switch (fastboot_devinfo.type) {
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA)
+	case DEV_SATA:
+		process_flash_sata(cmdbuf, response);
+		break;
+#endif
+#if defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	case DEV_MMC:
+		process_flash_mmc(cmdbuf, response);
+		break;
+#endif
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	case DEV_NAND:
+		process_flash_nand(cmdbuf, response);
+		break;
+#endif
+	default:
+		printf("Not support flash command for current device %d\n",
+			fastboot_devinfo.type);
+		sprintf(response,
+			   "FAILfailed to flash device");
+		break;
+	}
+}
+
+static void rx_process_boot(const char *cmdbuf, char *response)
+{
+	if ((download_bytes) &&
+		(CFG_FASTBOOT_MKBOOTIMAGE_PAGE_SIZE <
+			download_bytes)) {
+		char start[32];
+		char *booti_args[4] = {"booti",  NULL, "boot", NULL};
+
+		/*
+		 * Use this later to determine if a command line was passed
+		 * for the kernel.
+		 */
+		/* struct fastboot_boot_img_hdr *fb_hdr = */
+		/*	(struct fastboot_boot_img_hdr *) interface.transfer_buffer; */
+
+		/* Skip the mkbootimage header */
+		/* image_header_t *hdr = */
+		/*	(image_header_t *) */
+		/*	&interface.transfer_buffer[CFG_FASTBOOT_MKBOOTIMAGE_PAGE_SIZE]; */
+
+		booti_args[1] = start;
+		sprintf(start, "0x%x", (unsigned int)interface.transfer_buffer);
+
+		/* Execution should jump to kernel so send the response
+		   now and wait a bit.	*/
+		sprintf(response, "OKAY");
+		fastboot_tx_status(response, strlen(response));
+
+		printf("Booting kernel...\n");
+
+
+		/* Reserve for further use, this can
+		 * be more convient for developer. */
+		/* if (strlen ((char *) &fb_hdr->cmdline[0])) */
+		/*	set_env("bootargs", (char *) &fb_hdr->cmdline[0]); */
+
+		/* boot the boot.img */
+		do_booti(NULL, 0, 3, booti_args);
+
+
+	}
+	sprintf(response, "FAILinvalid boot image");
+}
+
+static void rx_process_upload(const char *cmdbuf, char *response)
+{
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	unsigned int adv, delim_index, len;
+	struct fastboot_ptentry *ptn;
+	unsigned int is_raw = 0;
+
+	/* Is this a raw read ? */
+	if (memcmp(cmdbuf, "uploadraw:", 10) == 0) {
+		is_raw = 1;
+		adv = 10;
+	} else {
+		adv = 7;
+	}
+
+	/* Scan to the next ':' to find when the size starts */
+	len = strlen(cmdbuf);
+	for (delim_index = adv;
+		 delim_index < len; delim_index++) {
+		if (cmdbuf[delim_index] == ':') {
+			/* WARNING, cmdbuf is being modified. */
+			*((char *) &cmdbuf[delim_index]) = 0;
+			break;
+		}
+	}
+
+	ptn = fastboot_flash_find_ptn(cmdbuf + adv);
+	if (ptn == 0) {
+		sprintf(response,
+			"FAILpartition does not exist");
+	} else {
+		/* This is how much the user is expecting */
+		unsigned int user_size;
+		/*
+		 * This is the maximum size needed for
+		 * this partition
+		 */
+		unsigned int size;
+		/* This is the length of the data */
+		unsigned int length;
+		/*
+		 * Used to check previous write of
+		 * the parition
+		 */
+		char env_ptn_length_var[128];
+		char *env_ptn_length_val;
+
+		user_size = 0;
+		if (delim_index < len)
+			user_size =
+				simple_strtoul(cmdbuf + delim_index + 1,
+					NULL, 16);
+
+		/* Make sure output is padded to block size */
+		length = ptn->length;
+		sprintf(env_ptn_length_var,
+			"%s_nand_size", ptn->name);
+		env_ptn_length_val = getenv(env_ptn_length_var);
+		if (env_ptn_length_val) {
+			length =
+				simple_strtoul(env_ptn_length_val,
+					NULL, 16);
+			/* Catch possible problems */
+			if (!length)
+				length = ptn->length;
+		}
+
+		size = length / interface.nand_block_size;
+		size *= interface.nand_block_size;
+		if (length % interface.nand_block_size)
+			size += interface.nand_block_size;
+
+		if (is_raw)
+			size += (size /
+				 interface.nand_block_size) *
+				interface.nand_oob_size;
+
+		if (size > interface.transfer_buffer_size) {
+
+			sprintf(response, "FAILdata too large");
+
+		} else if (user_size == 0) {
+
+			/* Send the data response */
+			sprintf(response, "DATA%08x", size);
+
+		} else if (user_size != size) {
+			/* This is the wrong size */
+			sprintf(response, "FAIL");
+		} else {
+			/*
+			 * This is where the transfer
+			 * buffer is populated
+			 */
+			unsigned char *buf =
+			  interface.transfer_buffer;
+			char read[128];
+
+			/*
+			 * Setting upload_size causes
+			 * transfer to happen in main loop
+			 */
+			upload_size = size;
+			upload_bytes = 0;
+			upload_error = 0;
+
+			/*
+			 * Poison the transfer buffer, 0xff
+			 * is erase value of nand
+			 */
+			memset(buf, 0xff, upload_size);
+
+			/* Which flavor of read to use */
+			if (is_raw)
+				sprintf(read, "nand read.raw 0x%x 0x%x 0x%x",
+					(unsigned int)(interface.transfer_buffer),
+					ptn->start,
+					upload_size);
+			else
+				sprintf(read, "nand read.i 0x%x 0x%x 0x%x",
+					(unsigned int)(interface.transfer_buffer),
+					ptn->start,
+					upload_size);
+
+			run_command(read, 0);
+
+			/* Send the data response */
+			sprintf(response, "DATA%08x", size);
+		}
+	}
+#endif
+
+}
+
+static int tx_handler(void)
+{
+	if (upload_size) {
+
+		int bytes_written;
+		bytes_written = fastboot_tx(interface.transfer_buffer +
+					    upload_bytes, upload_size -
+					    upload_bytes);
+		if (bytes_written > 0) {
+
+			upload_bytes += bytes_written;
+			/* Check if this is the last */
+			if (upload_bytes == upload_size) {
+
+				/* Reset upload */
+				upload_size = 0;
+				upload_bytes = 0;
+				upload_error = 0;
+			}
+		}
+	}
+	return upload_error;
+}
+
+static int rx_handler (const unsigned char *buffer, unsigned int buffer_size)
+{
+	int ret = 1;
+
+	/*response buffer, Use 65 instead of 64
+	   null gets dropped. strcpy's need the extra byte */
+	char response[FASTBOOT_RESPONSE_SIZE];
+
+	if (download_size) {
+		/* Something to download */
+
+		if (buffer_size) {
+			/* Handle possible overflow */
+			unsigned int transfer_size =
+				download_size - download_bytes;
+
+			if (buffer_size < transfer_size)
+				transfer_size = buffer_size;
+
+			/* Save the data to the transfer buffer */
+			memcpy(interface.transfer_buffer + download_bytes,
+				buffer, transfer_size);
+
+			download_bytes += transfer_size;
+
+			/* Check if transfer is done */
+			if (download_bytes >= download_size) {
+				/* Reset global transfer variable,
+				   Keep download_bytes because it will be
+				   used in the next possible flashing command */
+				download_size = 0;
+
+				if (download_error) {
+					/* There was an earlier error */
+					sprintf(response, "ERROR");
+				} else {
+					/* Everything has transferred,
+					   send the OK response */
+					sprintf(response, "OKAY");
+				}
+				fastboot_tx_status(response, strlen(response));
+
+				printf("\ndownloading of %d bytes finished\n",
+					download_bytes);
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+				/* Pad to block length
+				   In most cases, padding the download to be
+				   block aligned is correct. The exception is
+				   when the following flash writes to the oob
+				   area.  This happens when the image is a
+				   YAFFS image.  Since we do not know what
+				   the download is until it is flashed,
+				   go ahead and pad it, but save the true
+				   size in case if should have
+				   been unpadded */
+				download_bytes_unpadded = download_bytes;
+				if (interface.nand_block_size) {
+					if (download_bytes %
+					    interface.nand_block_size) {
+						unsigned int pad =
+							interface.nand_block_size -
+							(download_bytes % interface.nand_block_size);
+						unsigned int i;
+
+						for (i = 0; i < pad; i++) {
+							if (download_bytes >=
+								interface.transfer_buffer_size)
+								break;
+
+							interface.transfer_buffer[download_bytes] = 0;
+							download_bytes++;
+						}
+					}
+				}
+#endif
+			}
+
+			/* Provide some feedback */
+			if (download_bytes &&
+			    0 == (download_bytes %
+				  (16 * interface.nand_block_size))) {
+				/* Some feeback that the
+				   download is happening */
+				if (download_error)
+					printf("X");
+				else
+					printf(".");
+				if (0 == (download_bytes %
+					  (80 * 16 *
+					   interface.nand_block_size)))
+					printf("\n");
+
+			}
+		} else {
+			/* Ignore empty buffers */
+			printf("Warning empty download buffer\n");
+			printf("Ignoring\n");
+		}
+		ret = 0;
+	} else {
+		/* A command */
+
+		/* Cast to make compiler happy with string functions */
+		const char *cmdbuf = (char *) buffer;
+		printf("cmdbuf: %s\n", cmdbuf);
+
+		/* Generic failed response */
+		sprintf(response, "FAIL");
+
+		/* reboot
+		   Reboot the board. */
+		if (memcmp(cmdbuf, "reboot", 6) == 0) {
+			rx_process_reboot(cmdbuf, response);
+			/* This code is unreachable,
+			   leave it to make the compiler happy */
+			return 0;
+		}
+
+		/* getvar
+		   Get common fastboot variables
+		   Board has a chance to handle other variables */
+		if (memcmp(cmdbuf, "getvar:", 7) == 0) {
+			rx_process_getvar(cmdbuf, response);
+			ret = 0;
+		}
+
+		/* erase
+		   Erase a register flash partition
+		   Board has to set up flash partitions */
+		if (memcmp(cmdbuf, "erase:", 6) == 0)
+			ret = rx_process_erase(cmdbuf, response);
+
+		/* download
+		   download something ..
+		   What happens to it depends on the next command after data */
+
+		if (memcmp(cmdbuf, "download:", 9) == 0) {
+
+			/* save the size */
+			download_size = simple_strtoul(cmdbuf + 9, NULL, 16);
+			/* Reset the bytes count, now it is safe */
+			download_bytes = 0;
+			/* Reset error */
+			download_error = 0;
+
+			printf("Starting download of %d bytes\n",
+				download_size);
+
+			if (0 == download_size) {
+				/* bad user input */
+				sprintf(response, "FAILdata invalid size");
+			} else if (download_size >
+				    interface.transfer_buffer_size) {
+				/* set download_size to 0 because this is an error */
+				download_size = 0;
+				sprintf(response, "FAILdata too large");
+			} else {
+				/* The default case, the transfer fits
+				   completely in the interface buffer */
+				sprintf(response, "DATA%08x", download_size);
+			}
+			ret = 0;
+		}
+
+		/* boot
+		   boot what was downloaded
+
+		   WARNING WARNING WARNING
+
+		   This is not what you expect.
+		   The fastboot client does its own packaging of the
+		   kernel.  The layout is defined in the android header
+		   file bootimage.h.  This layeout is copiedlooks like this,
+
+		   **
+		   ** +-----------------+
+		   ** | boot header     | 1 page
+		   ** +-----------------+
+		   ** | kernel          | n pages
+		   ** +-----------------+
+		   ** | ramdisk         | m pages
+		   ** +-----------------+
+		   ** | second stage    | o pages
+		   ** +-----------------+
+		   **
+
+		   We only care about the kernel.
+		   So we have to jump past a page.
+
+		   What is a page size ?
+		   The fastboot client uses 2048
+
+		   The is the default value of
+
+		   CFG_FASTBOOT_MKBOOTIMAGE_PAGE_SIZE
+
+		*/
+
+		if (memcmp(cmdbuf, "boot", 4) == 0) {
+			rx_process_boot(cmdbuf, response);
+			ret = 0;
+		}
+
+		/* flash
+		   Flash what was downloaded */
+		if (memcmp(cmdbuf, "flash:", 6) == 0) {
+			rx_process_flash(cmdbuf, response);
+			ret = 0;
+		}
+
+		/* continue
+		   Stop doing fastboot */
+		if (memcmp(cmdbuf, "continue", 8) == 0) {
+			sprintf(response, "OKAY");
+			continue_booting = 1;
+			ret = 0;
+		}
+
+		/* upload
+		   Upload just the data in a partition */
+		if ((memcmp(cmdbuf, "upload:", 7) == 0) ||
+		    (memcmp(cmdbuf, "uploadraw:", 10) == 0)) {
+			rx_process_upload(cmdbuf, response);
+			ret = 0;
+		}
+
+		fastboot_tx_status(response, strlen(response));
+
+	} /* End of command */
+
+	return ret;
+}
+
+int do_fastboot(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int ret = 1;
+	int check_timeout = 0;
+	uint64_t timeout_endtime = 0;
+	uint64_t timeout_ticks = 1000;
+	int continue_from_disconnect = 0;
+
+	do {
+		continue_from_disconnect = 0;
+
+		/* Initialize the board specific support */
+		if (0 == fastboot_init(&interface)) {
+
+			int poll_status;
+
+			/* If we got this far, we are a success */
+			ret = 0;
+			printf("fastboot initialized\n");
+
+			timeout_endtime = get_timer(0);
+			timeout_endtime += timeout_ticks;
+
+			while (1) {
+				uint64_t current_time = 0;
+				poll_status = fastboot_poll();
+
+				if (1 == check_timeout)
+					current_time = get_timer(0);
+
+				if (FASTBOOT_ERROR == poll_status) {
+					/* Error */
+					break;
+				} else if (FASTBOOT_DISCONNECT == poll_status) {
+					/* beak, cleanup and re-init */
+					printf("Fastboot disconnect detected\n");
+					continue_from_disconnect = 1;
+					break;
+				} else if ((1 == check_timeout) &&
+					   (FASTBOOT_INACTIVE == poll_status)) {
+
+					/* No activity */
+					if (current_time >= timeout_endtime) {
+						printf("Fastboot inactivity detected\n");
+						break;
+					}
+				} else {
+					/* Something happened */
+					if (1 == check_timeout) {
+						/* Update the timeout endtime */
+						timeout_endtime = current_time;
+						timeout_endtime += timeout_ticks;
+					}
+				}
+
+				/* Check if the user wanted to terminate with ^C */
+				if ((FASTBOOT_INACTIVE == poll_status) &&
+				    (ctrlc())) {
+					printf("Fastboot ended by user\n");
+					break;
+				}
+
+				/*
+				 * Check if the fastboot client wanted to
+				 * continue booting
+				 */
+				if (continue_booting) {
+					printf("Fastboot ended by client\n");
+					break;
+				}
+
+				/* Check if there is something to upload */
+				tx_handler();
+			}
+		}
+
+		/* Reset the board specific support */
+		fastboot_shutdown();
+
+		/* restart the loop if a disconnect was detected */
+	} while (continue_from_disconnect);
+
+	return ret;
+}
+
+U_BOOT_CMD(
+	fastboot,	2,	1,	do_fastboot,
+	"fastboot- use USB Fastboot protocol\n",
+	"[inactive timeout]\n"
+	"    - Run as a fastboot usb device.\n"
+	"    - The optional inactive timeout is the decimal seconds before\n"
+	"    - the normal console resumes\n"
+);
+
+
+#ifdef CONFIG_CMD_BOOTI
+  /* Section for Android bootimage format support
+   * Refer:
+   * http://android.git.kernel.org/?p=platform/system/core.git;a=blob;
+   * f=mkbootimg/bootimg.h
+   */
+
+void
+bootimg_print_image_hdr(struct fastboot_boot_img_hdr *hdr)
+{
+#ifdef DEBUG
+	int i;
+	printf("   Image magic:   %s\n", hdr->magic);
+
+	printf("   kernel_size:   0x%x\n", hdr->kernel_size);
+	printf("   kernel_addr:   0x%x\n", hdr->kernel_addr);
+
+	printf("   rdisk_size:   0x%x\n", hdr->ramdisk_size);
+	printf("   rdisk_addr:   0x%x\n", hdr->ramdisk_addr);
+
+	printf("   second_size:   0x%x\n", hdr->second_size);
+	printf("   second_addr:   0x%x\n", hdr->second_addr);
+
+	printf("   tags_addr:   0x%x\n", hdr->tags_addr);
+	printf("   page_size:   0x%x\n", hdr->page_size);
+
+	printf("   name:      %s\n", hdr->name);
+	printf("   cmdline:   %s%x\n", hdr->cmdline);
+
+	for (i = 0; i < 8; i++)
+		printf("   id[%d]:   0x%x\n", i, hdr->id[i]);
+#endif
+}
+
+static struct fastboot_boot_img_hdr boothdr __aligned(ARCH_DMA_MINALIGN);
+
+#define ALIGN_SECTOR(n, pagesz) ((n + (pagesz - 1)) & (~(pagesz - 1)))
+
+#ifdef CONFIG_LMB
+static void boot_start_lmb(bootm_headers_t *images)
+{
+	ulong		mem_start;
+	phys_size_t	mem_size;
+
+	lmb_init(&images->lmb);
+
+	mem_start = getenv_bootm_low();
+	mem_size = getenv_bootm_size();
+
+	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
+
+	arch_lmb_reserve(&images->lmb);
+	board_lmb_reserve(&images->lmb);
+}
+#else
+#define lmb_reserve(lmb, base, size)
+static inline void boot_start_lmb(bootm_headers_t *images) { }
+#endif
+
+/* Allow for arch specific config before we boot */
+static void __arch_preboot_os(void)
+{
+	/* please define platform specific arch_preboot_os() */
+}
+void arch_preboot_os(void) __attribute__((weak, alias("__arch_preboot_os")));
+
+/* booti <addr> [ mmc0 | mmc1 [ <partition> ] ] */
+int do_booti(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	unsigned addr = 0;
+	char *ptn = "boot";
+	int mmcc = -1;
+	struct fastboot_boot_img_hdr *hdr = &boothdr;
+#ifdef CONFIG_SECURE_BOOT
+    u_int32_t load_addr;
+    uint32_t image_size;
+#endif
+	int i = 0;
+	bootm_headers_t images;
+
+	for (i = 0; i < argc; i++)
+		printf("%s ", argv[i]);
+	printf("\n");
+
+	if (argc < 2)
+		return -1;
+
+	if (!strncmp(argv[1], "mmc", 3))
+		mmcc = simple_strtoul(argv[1]+3, NULL, 10);
+	else
+		addr = simple_strtoul(argv[1], NULL, 16);
+
+	if (argc > 2)
+		ptn = argv[2];
+
+	if (mmcc != -1) {
+#ifdef CONFIG_MMC
+		struct fastboot_ptentry *pte;
+		struct mmc *mmc;
+		disk_partition_t info;
+		block_dev_desc_t *dev_desc = NULL;
+		unsigned sector;
+
+		memset((void *)&info, 0 , sizeof(disk_partition_t));
+		/* i.MX use MBR as partition table, so this will have
+		   to find the start block and length for the
+		   partition name and register the fastboot pte we
+		   define the partition number of each partition in
+		   config file
+		 */
+		mmc = find_mmc_device(mmcc);
+		if (!mmc) {
+			printf("booti: cannot find '%d' mmc device\n", mmcc);
+			goto fail;
+		}
+		dev_desc = get_dev("mmc", mmcc);
+		if (NULL == dev_desc) {
+			printf("** Block device MMC %d not supported\n", mmcc);
+			goto fail;
+		}
+
+		/* below was i.MX mmc operation code */
+		if (mmc_init(mmc)) {
+			printf("mmc%d init failed\n", mmcc);
+			goto fail;
+		}
+
+		pte = fastboot_flash_find_ptn(ptn);
+		if (!pte) {
+			printf("booti: cannot find '%s' partition\n", ptn);
+			goto fail;
+		}
+
+		if (mmc->block_dev.block_read(mmcc, pte->start,
+					      1, (void *)hdr) < 0) {
+			printf("booti: mmc failed to read bootimg header\n");
+			goto fail;
+		}
+
+		if (memcmp(hdr->magic, FASTBOOT_BOOT_MAGIC, 8)) {
+			printf("booti: bad boot image magic\n");
+			goto fail;
+		}
+
+		sector = pte->start + (hdr->page_size / 512);
+
+		if (mmc->block_dev.block_read(mmcc, sector,
+						(hdr->kernel_size / 512) + 1,
+						(void *)hdr->kernel_addr) < 0) {
+			printf("booti: mmc failed to read kernel\n");
+			goto fail;
+		}
+		/* flush cache after read */
+		flush_cache((ulong)hdr->kernel_addr, hdr->kernel_size); /* FIXME */
+		sector += ALIGN_SECTOR(hdr->kernel_size, hdr->page_size) / 512;
+		if (mmc->block_dev.block_read(mmcc, sector,
+						(hdr->ramdisk_size / 512) + 1,
+						(void *)hdr->ramdisk_addr) < 0) {
+			printf("booti: mmc failed to read ramdisk\n");
+			goto fail;
+		}
+		/* flush cache after read */
+		flush_cache((ulong)hdr->ramdisk_addr, hdr->ramdisk_size); /* FIXME */
+
+#ifdef CONFIG_OF_LIBFDT
+		/* load the dtb file */
+		if (hdr->second_size && hdr->second_addr) {
+			sector += ALIGN_SECTOR(hdr->ramdisk_size, hdr->page_size) / 512;
+			if (mmc->block_dev.block_read(mmcc, sector,
+						(hdr->second_size / 512) + 1,
+						(void *)hdr->second_addr) < 0) {
+				printf("booti: mmc failed to dtb\n");
+				goto fail;
+			}
+			/* flush cache after read */
+			flush_cache((ulong)hdr->second_addr, hdr->second_size); /* FIXME */
+		}
+#endif /*CONFIG_OF_LIBFDT*/
+
+#else /*! CONFIG_MMC*/
+		return -1;
+#endif /*! CONFIG_MMC*/
+	} else {
+		unsigned kaddr, raddr, end;
+#ifdef CONFIG_OF_LIBFDT
+		unsigned fdtaddr = 0;
+#endif
+
+		/* set this aside somewhere safe */
+		memcpy(hdr, (void *) addr, sizeof(*hdr));
+
+		if (memcmp(hdr->magic, FASTBOOT_BOOT_MAGIC, 8)) {
+			printf("booti: bad boot image magic\n");
+			return 1;
+		}
+
+		bootimg_print_image_hdr(hdr);
+
+		kaddr = addr + hdr->page_size;
+		raddr = kaddr + ALIGN_SECTOR(hdr->kernel_size, hdr->page_size);
+		end = raddr + hdr->ramdisk_size;
+#ifdef CONFIG_OF_LIBFDT
+		if (hdr->second_size) {
+			fdtaddr = raddr + ALIGN_SECTOR(hdr->ramdisk_size, hdr->page_size);
+			end = fdtaddr + hdr->second_size;
+		}
+#endif /*CONFIG_OF_LIBFDT*/
+		if (kaddr != hdr->kernel_addr) {
+			/*check overlap*/
+			if (((hdr->kernel_addr >= addr) &&
+					(hdr->kernel_addr <= end)) ||
+				((addr >= hdr->kernel_addr) &&
+					(addr <= hdr->kernel_addr + hdr->kernel_size))) {
+				printf("Fail: booti address overlap with kernel address\n");
+				return 1;
+			}
+			memmove((void *) hdr->kernel_addr,
+				(void *)kaddr, hdr->kernel_size);
+		}
+		if (raddr != hdr->ramdisk_addr) {
+			/*check overlap*/
+			if (((hdr->ramdisk_addr >= addr) &&
+					(hdr->ramdisk_addr <= end)) ||
+				((addr >= hdr->ramdisk_addr) &&
+					(addr <= hdr->ramdisk_addr + hdr->ramdisk_size))) {
+				printf("Fail: booti address overlap with ramdisk address\n");
+				return 1;
+			}
+			memmove((void *) hdr->ramdisk_addr,
+				(void *)raddr, hdr->ramdisk_size);
+		}
+
+#ifdef CONFIG_OF_LIBFDT
+		if (hdr->second_size && fdtaddr != hdr->second_addr) {
+			/*check overlap*/
+			if (((hdr->second_addr >= addr) &&
+					(hdr->second_addr <= end)) ||
+				((addr >= hdr->second_addr) &&
+					(addr <= hdr->second_addr + hdr->second_size))) {
+				printf("Fail: booti address overlap with FDT address\n");
+				return 1;
+			}
+			memmove((void *) hdr->second_addr,
+				(void *)fdtaddr, hdr->second_size);
+		}
+#endif /*CONFIG_OF_LIBFDT*/
+	}
+
+	printf("kernel   @ %08x (%d)\n", hdr->kernel_addr, hdr->kernel_size);
+	printf("ramdisk  @ %08x (%d)\n", hdr->ramdisk_addr, hdr->ramdisk_size);
+#ifdef CONFIG_OF_LIBFDT
+	if (hdr->second_size)
+		printf("fdt      @ %08x (%d)\n", hdr->second_addr, hdr->second_size);
+#endif /*CONFIG_OF_LIBFDT*/
+
+#ifdef CONFIG_SECURE_BOOT
+#define IVT_SIZE 0x20
+#define CSF_PAD_SIZE 0x2000
+	extern uint32_t authenticate_image(uint32_t ddr_start,
+					   uint32_t image_size);
+
+	image_size = hdr->ramdisk_addr + hdr->ramdisk_size - hdr->kernel_addr -
+		IVT_SIZE - CSF_PAD_SIZE;
+
+	if (authenticate_image(hdr->kernel_addr, image_size)) {
+		printf("Authenticate OK\n");
+	} else {
+		printf("Authenticate image Fail, Please check\n\n");
+		return 1;
+	}
+#endif /*CONFIG_SECURE_BOOT*/
+
+#ifdef CONFIG_CMDLINE_TAG
+	char *commandline = getenv("bootargs");
+
+	/* If no bootargs env, just use hdr command line */
+	if (!commandline) {
+		commandline = (char *)hdr->cmdline;
+#ifdef CONFIG_SERIAL_TAG
+		char appended_cmd_line[FASTBOOT_BOOT_ARGS_SIZE];
+		struct tag_serialnr serialnr;
+		get_board_serial(&serialnr);
+		if (strlen((char *)hdr->cmdline) +
+			strlen("androidboot.serialno") + 17 < FASTBOOT_BOOT_ARGS_SIZE) {
+			sprintf(appended_cmd_line,
+							"%s androidboot.serialno=%08x%08x",
+							(char *)hdr->cmdline,
+							serialnr.high,
+							serialnr.low);
+			commandline = appended_cmd_line;
+		} else {
+			printf("Cannot append androidboot.serialno\n");
+		}
+
+		setenv("bootargs", commandline);
+#endif
+	}
+
+	/* XXX: in production, you should always use boot.img 's cmdline !!! */
+	printf("kernel cmdline:\n");
+	printf("\tuse boot.img ");
+	printf("command line:\n\t%s\n", commandline);
+#endif /*CONFIG_CMDLINE_TAG*/
+
+	memset(&images, 0, sizeof(images));
+
+	/*Setup lmb for memory reserve*/
+	boot_start_lmb(&images);
+
+	images.ep = hdr->kernel_addr;
+	images.rd_start = hdr->ramdisk_addr;
+	images.rd_end = hdr->ramdisk_addr + hdr->ramdisk_size;
+
+	/*Reserve memory for kernel image*/
+	lmb_reserve(&images.lmb, images.ep, hdr->kernel_size);
+
+#ifdef CONFIG_OF_LIBFDT
+	/*use secondary fields for fdt, second_size= fdt size, second_addr= fdt addr*/
+	images.ft_addr = (char *)(hdr->second_addr);
+	images.ft_len = (ulong)(hdr->second_size);
+	set_working_fdt_addr(images.ft_addr);
+#endif /*CONFIG_OF_LIBFDT*/
+
+	arch_preboot_os();
+
+	do_bootm_linux(0, 0, NULL, &images);
+
+	puts("booti: Control returned to monitor - resetting...\n");
+	do_reset(cmdtp, flag, argc, argv);
+	return 1;
+
+fail:
+#ifdef CONFIG_FASTBOOT
+	return do_fastboot(NULL, 0, 0, NULL);
+#else /*! CONFIG_FASTBOOT*/
+	return -1;
+#endif /*! CONFIG_FASTBOOT*/
+}
+
+U_BOOT_CMD(
+	booti,	3,	1,	do_booti,
+	"booti   - boot android bootimg from memory\n",
+	"[<addr> | mmc0 | mmc1 | mmc2 | mmcX] [<partition>]\n    "
+	"- boot application image stored in memory or mmc\n"
+	"\t'addr' should be the address of boot image "
+	"which is zImage+ramdisk.img\n"
+	"\t'mmcX' is the mmc device you store your boot.img, "
+	"which will read the boot.img from 1M offset('/boot' partition)\n"
+	"\t 'partition' (optional) is the partition id of your device, "
+	"if no partition give, will going to 'boot' partition\n"
+);
+#endif	/* CONFIG_CMD_BOOTI */
+
+#endif	/* CONFIG_FASTBOOT */
diff --git a/common/cmd_nvedit.c b/common/cmd_nvedit.c
index c53601c..1b06bf2 100644
--- a/common/cmd_nvedit.c
+++ b/common/cmd_nvedit.c
@@ -5,7 +5,7 @@
  * (C) Copyright 2001 Sysgo Real-Time Solutions, GmbH <www.elinos.com>
  * Andreas Heppel <aheppel@sysgo.de>
  *
- * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -47,9 +47,10 @@ DECLARE_GLOBAL_DATA_PTR;
 	!defined(CONFIG_ENV_IS_IN_SPI_FLASH)	&& \
 	!defined(CONFIG_ENV_IS_IN_REMOTE)	&& \
 	!defined(CONFIG_ENV_IS_IN_UBI)		&& \
+	!defined(CONFIG_ENV_IS_IN_SATA)		&& \
 	!defined(CONFIG_ENV_IS_NOWHERE)
 # error Define one of CONFIG_ENV_IS_IN_{EEPROM|FLASH|DATAFLASH|ONENAND|\
-SPI_FLASH|NVRAM|MMC|FAT|REMOTE|UBI} or CONFIG_ENV_IS_NOWHERE
+SPI_FLASH|NVRAM|MMC|FAT|REMOTE|UBI|SATA} or CONFIG_ENV_IS_NOWHERE
 #endif
 
 /*
diff --git a/common/cmd_sata.c b/common/cmd_sata.c
index fc92131..a359c71 100644
--- a/common/cmd_sata.c
+++ b/common/cmd_sata.c
@@ -4,7 +4,7 @@
  * Copyright (C) Procsys. All rights reserved.
  *		Mushtaq Khan <mushtaq_k@procsys.com>
  *			<mushtaqk_921@yahoo.co.in>
- * Copyright (C) 2008 Freescale Semiconductor, Inc.
+ * Copyright (C) 2008-2014 Freescale Semiconductor, Inc.
  *		Dave Liu <daveliu@freescale.com>
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -15,7 +15,7 @@
 #include <part.h>
 #include <sata.h>
 
-static int sata_curr_device = -1;
+int sata_curr_device = -1;
 block_dev_desc_t sata_dev_desc[CONFIG_SYS_SATA_MAX_DEVICE];
 
 int __sata_initialize(void)
diff --git a/common/env_mmc.c b/common/env_mmc.c
index 045428c..0d4e8a2 100644
--- a/common/env_mmc.c
+++ b/common/env_mmc.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2008-2011 Freescale Semiconductor, Inc.
+ * (C) Copyright 2008-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -53,6 +53,11 @@ __weak int mmc_get_env_addr(struct mmc *mmc, int copy, u32 *env_addr)
 	return 0;
 }
 
+__weak int mmc_get_env_devno(void)
+{
+	return CONFIG_SYS_MMC_ENV_DEV;
+}
+
 int env_init(void)
 {
 	/* use default */
@@ -76,7 +81,9 @@ static int init_mmc_for_env(struct mmc *mmc)
 
 #ifdef CONFIG_SYS_MMC_ENV_PART
 	if (CONFIG_SYS_MMC_ENV_PART != mmc->part_num) {
-		if (mmc_switch_part(CONFIG_SYS_MMC_ENV_DEV,
+		int mmc_env_devno = mmc_get_env_devno();
+
+		if (mmc_switch_part(mmc_env_devno,
 				    CONFIG_SYS_MMC_ENV_PART)) {
 			puts("MMC partition switch failed\n");
 			return -1;
@@ -90,8 +97,10 @@ static int init_mmc_for_env(struct mmc *mmc)
 static void fini_mmc_for_env(struct mmc *mmc)
 {
 #ifdef CONFIG_SYS_MMC_ENV_PART
+	int mmc_env_devno = mmc_get_env_devno();
+
 	if (CONFIG_SYS_MMC_ENV_PART != mmc->part_num)
-		mmc_switch_part(CONFIG_SYS_MMC_ENV_DEV,
+		mmc_switch_part(mmc_env_devno,
 				mmc->part_num);
 #endif
 }
@@ -101,11 +110,12 @@ static inline int write_env(struct mmc *mmc, unsigned long size,
 			    unsigned long offset, const void *buffer)
 {
 	uint blk_start, blk_cnt, n;
+	int mmc_env_devno = mmc_get_env_devno();
 
 	blk_start	= ALIGN(offset, mmc->write_bl_len) / mmc->write_bl_len;
 	blk_cnt		= ALIGN(size, mmc->write_bl_len) / mmc->write_bl_len;
 
-	n = mmc->block_dev.block_write(CONFIG_SYS_MMC_ENV_DEV, blk_start,
+	n = mmc->block_dev.block_write(mmc_env_devno, blk_start,
 					blk_cnt, (u_char *)buffer);
 
 	return (n == blk_cnt) ? 0 : -1;
@@ -118,9 +128,10 @@ static unsigned char env_flags;
 int saveenv(void)
 {
 	ALLOC_CACHE_ALIGN_BUFFER(env_t, env_new, 1);
+	int mmc_env_devno = mmc_get_env_devno();
 	ssize_t	len;
 	char	*res;
-	struct mmc *mmc = find_mmc_device(CONFIG_SYS_MMC_ENV_DEV);
+	struct mmc *mmc = find_mmc_device(mmc_env_devno);
 	u32	offset;
 	int	ret, copy = 0;
 
@@ -150,7 +161,7 @@ int saveenv(void)
 	}
 
 	printf("Writing to %sMMC(%d)... ", copy ? "redundant " : "",
-	       CONFIG_SYS_MMC_ENV_DEV);
+	       mmc_env_devno);
 	if (write_env(mmc, CONFIG_ENV_SIZE, offset, (u_char *)env_new)) {
 		puts("failed\n");
 		ret = 1;
@@ -174,11 +185,12 @@ static inline int read_env(struct mmc *mmc, unsigned long size,
 			   unsigned long offset, const void *buffer)
 {
 	uint blk_start, blk_cnt, n;
+	int mmc_env_devno = mmc_get_env_devno();
 
 	blk_start	= ALIGN(offset, mmc->read_bl_len) / mmc->read_bl_len;
 	blk_cnt		= ALIGN(size, mmc->read_bl_len) / mmc->read_bl_len;
 
-	n = mmc->block_dev.block_read(CONFIG_SYS_MMC_ENV_DEV, blk_start,
+	n = mmc->block_dev.block_read(mmc_env_devno, blk_start,
 					blk_cnt, (uchar *)buffer);
 
 	return (n == blk_cnt) ? 0 : -1;
@@ -188,7 +200,8 @@ static inline int read_env(struct mmc *mmc, unsigned long size,
 void env_relocate_spec(void)
 {
 #if !defined(ENV_IS_EMBEDDED)
-	struct mmc *mmc = find_mmc_device(CONFIG_SYS_MMC_ENV_DEV);
+	int mmc_env_devno = mmc_get_env_devno();
+	struct mmc *mmc = find_mmc_device(mmc_env_devno);
 	u32 offset1, offset2;
 	int read1_fail = 0, read2_fail = 0;
 	int crc1_ok = 0, crc2_ok = 0;
@@ -274,7 +287,8 @@ void env_relocate_spec(void)
 {
 #if !defined(ENV_IS_EMBEDDED)
 	ALLOC_CACHE_ALIGN_BUFFER(char, buf, CONFIG_ENV_SIZE);
-	struct mmc *mmc = find_mmc_device(CONFIG_SYS_MMC_ENV_DEV);
+	int mmc_env_devno = mmc_get_env_devno();
+	struct mmc *mmc = find_mmc_device(mmc_env_devno);
 	u32 offset;
 	int ret;
 
diff --git a/common/env_sata.c b/common/env_sata.c
new file mode 100644
index 0000000..7dbfd89
--- /dev/null
+++ b/common/env_sata.c
@@ -0,0 +1,171 @@
+/*
+ * (C) Copyright 2010-2014 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* #define DEBUG */
+
+#include <common.h>
+
+#include <command.h>
+#include <environment.h>
+#include <linux/stddef.h>
+#include <errno.h>
+#include <sata.h>
+
+char *env_name_spec = "SATA";
+
+#ifdef ENV_IS_EMBEDDED
+extern uchar environment[];
+env_t *env_ptr = (env_t *)(&environment[0]);
+#else /* ! ENV_IS_EMBEDDED */
+env_t *env_ptr;
+#endif /* ENV_IS_EMBEDDED */
+
+extern int sata_curr_device;
+
+/* local functions */
+#if !defined(ENV_IS_EMBEDDED)
+static void use_default(void);
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+uchar env_get_char_spec(int index)
+{
+	return *((uchar *)(gd->env_addr + index));
+}
+
+int env_init(void)
+{
+	/* use default */
+	gd->env_addr = (ulong)&default_environment[0];
+	gd->env_valid = 1;
+
+	return 0;
+}
+
+#ifdef CONFIG_CMD_SAVEENV
+
+inline int write_env(block_dev_desc_t *sata, unsigned long size,
+			unsigned long offset, const void *buffer)
+{
+	uint blk_start, blk_cnt, n;
+
+	blk_start = ALIGN(offset, sata->blksz) / sata->blksz;
+	blk_cnt   = ALIGN(size, sata->blksz) / sata->blksz;
+
+	n = sata->block_write(sata_curr_device, blk_start,
+					blk_cnt, (u_char *)buffer);
+
+	return (n == blk_cnt) ? 0 : -1;
+}
+
+int saveenv(void)
+{
+	block_dev_desc_t *sata = NULL;
+	env_t	env_new;
+	ssize_t	len;
+	char *res;
+
+	if (sata_curr_device == -1) {
+		if (sata_initialize())
+			return 1;
+		sata_curr_device = CONFIG_SATA_ENV_DEV;
+	}
+
+	if (sata_curr_device >= CONFIG_SYS_SATA_MAX_DEVICE) {
+		printf("Unknown SATA(%d) device for environment!\n",
+			sata_curr_device);
+		return 1;
+	}
+
+	sata = sata_get_dev(sata_curr_device);
+
+	res = (char *)&env_new.data;
+	len = hexport_r(&env_htab, '\0', 0, &res, ENV_SIZE, 0, NULL);
+	if (len < 0) {
+		error("Cannot export environment: errno = %d\n", errno);
+		return 1;
+	}
+	env_new.crc = crc32(0, env_new.data, ENV_SIZE);
+
+	printf("Writing to SATA(%d)...", sata_curr_device);
+	if (write_env(sata, CONFIG_ENV_SIZE, CONFIG_ENV_OFFSET, &env_new)) {
+		puts("failed\n");
+		return 1;
+	}
+
+	puts("done\n");
+	return 0;
+}
+#endif /* CONFIG_CMD_SAVEENV */
+
+inline int read_env(block_dev_desc_t *sata, unsigned long size,
+			unsigned long offset, const void *buffer)
+{
+	uint blk_start, blk_cnt, n;
+
+	blk_start = ALIGN(offset, sata->blksz) / sata->blksz;
+	blk_cnt   = ALIGN(size, sata->blksz) / sata->blksz;
+
+	n = sata->block_read(sata_curr_device, blk_start,
+					blk_cnt, (uchar *)buffer);
+
+	return (n == blk_cnt) ? 0 : -1;
+}
+
+void env_relocate_spec(void)
+{
+#if !defined(ENV_IS_EMBEDDED)
+	block_dev_desc_t *sata = NULL;
+	char buf[CONFIG_ENV_SIZE];
+	int ret;
+
+	if (sata_curr_device == -1) {
+		if (sata_initialize())
+			return;
+		sata_curr_device = CONFIG_SATA_ENV_DEV;
+	}
+
+	if (sata_curr_device >= CONFIG_SYS_SATA_MAX_DEVICE) {
+		printf("Unknown SATA(%d) device for environment!\n",
+			sata_curr_device);
+		return;
+	}
+	sata = sata_get_dev(sata_curr_device);
+
+	if (read_env(sata, CONFIG_ENV_SIZE, CONFIG_ENV_OFFSET, buf))
+		return use_default();
+
+	ret = env_import(buf, 1);
+	if (ret)
+		gd->env_valid = 1;
+
+#endif
+}
+
+#if !defined(ENV_IS_EMBEDDED)
+static void use_default()
+{
+	puts("*** Warning - bad CRC or MMC, using default environment\n\n");
+	set_default_env(NULL);
+}
+#endif
diff --git a/common/image-android.c b/common/image-android.c
new file mode 100644
index 0000000..6ded7e2
--- /dev/null
+++ b/common/image-android.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2011 Sebastian Andrzej Siewior <bigeasy@linutronix.de>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <image.h>
+#include <android_image.h>
+
+static char andr_tmp_str[ANDR_BOOT_ARGS_SIZE + 1];
+
+int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
+			     ulong *os_data, ulong *os_len)
+{
+	/*
+	 * Not all Android tools use the id field for signing the image with
+	 * sha1 (or anything) so we don't check it. It is not obvious that the
+	 * string is null terminated so we take care of this.
+	 */
+	strncpy(andr_tmp_str, hdr->name, ANDR_BOOT_NAME_SIZE);
+	andr_tmp_str[ANDR_BOOT_NAME_SIZE] = '\0';
+	if (strlen(andr_tmp_str))
+		printf("Android's image name: %s\n", andr_tmp_str);
+
+	printf("Kernel load addr 0x%08x size %u KiB\n",
+	       hdr->kernel_addr, DIV_ROUND_UP(hdr->kernel_size, 1024));
+	strncpy(andr_tmp_str, hdr->cmdline, ANDR_BOOT_ARGS_SIZE);
+	andr_tmp_str[ANDR_BOOT_ARGS_SIZE] = '\0';
+	if (strlen(andr_tmp_str)) {
+		printf("Kernel command line: %s\n", andr_tmp_str);
+		setenv("bootargs", andr_tmp_str);
+	}
+	if (hdr->ramdisk_size)
+		printf("RAM disk load addr 0x%08x size %u KiB\n",
+		       hdr->ramdisk_addr,
+		       DIV_ROUND_UP(hdr->ramdisk_size, 1024));
+
+	if (os_data) {
+		*os_data = (ulong)hdr;
+		*os_data += hdr->page_size;
+	}
+	if (os_len)
+		*os_len = hdr->kernel_size;
+	return 0;
+}
+
+int android_image_check_header(const struct andr_img_hdr *hdr)
+{
+	return memcmp(ANDR_BOOT_MAGIC, hdr->magic, ANDR_BOOT_MAGIC_SIZE);
+}
+
+ulong android_image_get_end(const struct andr_img_hdr *hdr)
+{
+	u32 size = 0;
+	/*
+	 * The header takes a full page, the remaining components are aligned
+	 * on page boundary
+	 */
+	size += hdr->page_size;
+	size += ALIGN(hdr->kernel_size, hdr->page_size);
+	size += ALIGN(hdr->ramdisk_size, hdr->page_size);
+	size += ALIGN(hdr->second_size, hdr->page_size);
+
+	return size;
+}
+
+ulong android_image_get_kload(const struct andr_img_hdr *hdr)
+{
+	return hdr->kernel_addr;
+}
+
+int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
+			      ulong *rd_data, ulong *rd_len)
+{
+	if (!hdr->ramdisk_size)
+		return -1;
+	*rd_data = (unsigned long)hdr;
+	*rd_data += hdr->page_size;
+	*rd_data += ALIGN(hdr->kernel_size, hdr->page_size);
+
+	*rd_len = hdr->ramdisk_size;
+	return 0;
+}
diff --git a/common/image.c b/common/image.c
index 9c6bec5..7ff27d7 100644
--- a/common/image.c
+++ b/common/image.c
@@ -659,10 +659,12 @@ int genimg_get_format(const void *img_addr)
 	if (image_check_magic(hdr))
 		format = IMAGE_FORMAT_LEGACY;
 #if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
-	else {
-		if (fdt_check_header(img_addr) == 0)
-			format = IMAGE_FORMAT_FIT;
-	}
+	else if (fdt_check_header(img_addr) == 0)
+		format = IMAGE_FORMAT_FIT;
+#endif
+#ifdef CONFIG_ANDROID_BOOT_IMAGE
+	else if (android_image_check_header(img_addr) == 0)
+		format = IMAGE_FORMAT_ANDROID;
 #endif
 
 	return format;
@@ -932,7 +934,15 @@ int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
 				(ulong)images->legacy_hdr_os);
 
 		image_multi_getimg(images->legacy_hdr_os, 1, &rd_data, &rd_len);
-	} else {
+	}
+#ifdef CONFIG_ANDROID_BOOT_IMAGE
+	else if ((genimg_get_format(images) == IMAGE_FORMAT_ANDROID) &&
+		 (!android_image_get_ramdisk((void *)images->os.start,
+		 &rd_data, &rd_len))) {
+		/* empty */
+	}
+#endif
+	else {
 		/*
 		 * no initrd image
 		 */
diff --git a/common/lcd.c b/common/lcd.c
index 19b86b7..32242b0 100644
--- a/common/lcd.c
+++ b/common/lcd.c
@@ -60,7 +60,7 @@
 #ifdef CONFIG_LCD_LOGO
 # include <bmp_logo.h>		/* Get logo data, width and height	*/
 # include <bmp_logo_data.h>
-# if (CONSOLE_COLOR_WHITE >= BMP_LOGO_OFFSET) && (LCD_BPP != LCD_COLOR16)
+# if (CONSOLE_COLOR_WHITE >= BMP_LOGO_OFFSET) && (LCD_BPP != LCD_COLOR16) && (LCD_BPP != LCD_COLOR32)
 #  error Default Color Map overlaps with Logo Color Map
 # endif
 #endif
@@ -100,7 +100,7 @@
 #if LCD_BPP == LCD_MONOCHROME
 # define COLOR_MASK(c)		((c)	  | (c) << 1 | (c) << 2 | (c) << 3 | \
 				 (c) << 4 | (c) << 5 | (c) << 6 | (c) << 7)
-#elif (LCD_BPP == LCD_COLOR8) || (LCD_BPP == LCD_COLOR16)
+#elif (LCD_BPP == LCD_COLOR8) || (LCD_BPP == LCD_COLOR16) || (LCD_BPP == LCD_COLOR32)
 # define COLOR_MASK(c)		(c)
 #else
 # error Unsupported LCD BPP.
@@ -303,7 +303,9 @@ static void lcd_drawchars(ushort x, ushort y, uchar *str, int count)
 	for (row = 0; row < VIDEO_FONT_HEIGHT; ++row, dest += lcd_line_length) {
 		uchar *s = str;
 		int i;
-#if LCD_BPP == LCD_COLOR16
+#if LCD_BPP == LCD_COLOR32
+		u32 *d = (u32 *)dest;
+#elif LCD_BPP == LCD_COLOR16
 		ushort *d = (ushort *)dest;
 #else
 		uchar *d = dest;
@@ -337,6 +339,12 @@ static void lcd_drawchars(ushort x, ushort y, uchar *str, int count)
 						lcd_color_fg : lcd_color_bg;
 				bits <<= 1;
 			}
+#elif LCD_BPP == LCD_COLOR32
+			for (c = 0; c < 8; ++c) {
+				*d++ = (bits & 0x80) ?
+						lcd_color_fg : lcd_color_bg;
+				bits <<= 1;
+			}
 #endif
 		}
 #if LCD_BPP == LCD_MONOCHROME
@@ -625,6 +633,7 @@ void bitmap_plot(int x, int y)
 	uchar *bmap;
 	uchar *fb;
 	ushort *fb16;
+	ulong *fb32;
 #if defined(CONFIG_MPC823)
 	immap_t *immr = (immap_t *) CONFIG_SYS_IMMR;
 	cpm8xx_t *cp = &(immr->im_cpm);
@@ -659,7 +668,7 @@ void bitmap_plot(int x, int y)
 			ushort colreg = bmp_logo_palette[i];
 #ifdef CONFIG_ATMEL_LCD
 			uint lut_entry;
-#ifdef CONFIG_ATMEL_LCD_BGR555
+#ifdef CONFIG_ATMEL_LCD_RGB565
 			lut_entry = ((colreg & 0x000F) << 11) |
 					((colreg & 0x00F0) <<  2) |
 					((colreg & 0x0F00) >>  7);
@@ -687,6 +696,21 @@ void bitmap_plot(int x, int y)
 			fb += panel_info.vl_col;
 		}
 	}
+	else if (NBITS(panel_info.vl_bpix) > 16){ /* full color mode */
+		u16 col16;
+		fb32 = (ulong *)(lcd_base + y * lcd_line_length + x);
+		for (i=0; i<BMP_LOGO_HEIGHT; ++i) {
+			for (j=0; j<BMP_LOGO_WIDTH; j++) {
+				col16 = bmp_logo_palette[bmap[j]-16];
+				fb32[j] = 
+					((u32)(col16 & 0x000F) << 4) |
+					((u32)(col16 & 0x00F0) << 8) |
+					((u32)(col16 & 0x0F00) << 12);
+				}
+			bmap += BMP_LOGO_WIDTH;
+			fb32 += panel_info.vl_col;
+		}
+	}
 	else { /* true color mode */
 		u16 col16;
 		fb16 = (ushort *)fb;
diff --git a/common/main.c b/common/main.c
index 8b6f274..c709587 100644
--- a/common/main.c
+++ b/common/main.c
@@ -17,6 +17,11 @@
 #include <hush.h>
 #include <malloc.h>
 #include <menu.h>
+
+#ifdef is_boot_from_usb
+#include <environment.h>
+#endif
+
 #include <post.h>
 #include <version.h>
 #include <watchdog.h>
@@ -342,6 +347,16 @@ static void process_boot_delay(void)
 	s = getenv ("bootdelay");
 	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
 
+#ifdef is_boot_from_usb
+	if (is_boot_from_usb()) {
+		printf("Boot from USB for mfgtools\n");
+		bootdelay = 0;
+		set_default_env("Use default environment for mfgtools\n");
+	} else {
+		printf("Normal Boot\n");
+	}
+#endif
+
 #ifdef CONFIG_OF_CONTROL
 	bootdelay = fdtdec_get_config_int(gd->fdt_blob, "bootdelay",
 			bootdelay);
@@ -371,6 +386,13 @@ static void process_boot_delay(void)
 	else
 #endif /* CONFIG_BOOTCOUNT_LIMIT */
 		s = getenv ("bootcmd");
+#ifdef is_boot_from_usb
+	if (is_boot_from_usb()) {
+		s = getenv("bootcmd_mfg");
+		printf("Run bootcmd_mfg: %s\n", s);
+	}
+#endif
+
 #ifdef CONFIG_OF_CONTROL
 	/* Allow the fdt to override the boot command */
 	env = fdtdec_get_config_string(gd->fdt_blob, "bootcmd");
diff --git a/drivers/Makefile b/drivers/Makefile
index 5d03f37..e103896 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -13,4 +13,5 @@ obj-y += tpm/
 obj-y += twserial/
 obj-y += video/
 obj-y += watchdog/
+obj-y += fastboot/
 obj-$(CONFIG_QE) += qe/
diff --git a/drivers/fastboot/Makefile b/drivers/fastboot/Makefile
new file mode 100644
index 0000000..251120d
--- /dev/null
+++ b/drivers/fastboot/Makefile
@@ -0,0 +1,8 @@
+#
+# (C) Copyright 2000-2007
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-$(CONFIG_FASTBOOT) += fastboot.o
diff --git a/drivers/fastboot/fastboot.c b/drivers/fastboot/fastboot.c
new file mode 100644
index 0000000..4c911f0
--- /dev/null
+++ b/drivers/fastboot/fastboot.c
@@ -0,0 +1,1127 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <config.h>
+#include <malloc.h>
+#include <fastboot.h>
+#include <usb/imx_udc.h>
+#include <asm/io.h>
+#include <usbdevice.h>
+#include <mmc.h>
+#include <sata.h>
+#ifdef CONFIG_ANDROID_RECOVERY
+#include <recovery.h>
+#endif
+
+/*
+ * Defines
+ */
+#define NUM_ENDPOINTS  2
+
+#define CONFIG_USBD_OUT_PKTSIZE	    0x200
+#define CONFIG_USBD_IN_PKTSIZE	    0x200
+#define MAX_BUFFER_SIZE		    0x200
+
+/*
+ * imx family android layout
+ * mbr -  0 ~ 0x3FF byte
+ * bootloader - 0x400 ~ 0xFFFFF byte
+ * kernel - 0x100000 ~ 5FFFFF byte
+ * uramedisk - 0x600000 ~ 0x6FFFFF  supposing 1M temporarily
+ * SYSTEM partition - /dev/mmcblk0p2  or /dev/sda2
+ * RECOVERY parittion - dev/mmcblk0p4 or /dev/sda4
+ */
+#define ANDROID_MBR_OFFSET	    0
+#define ANDROID_MBR_SIZE	    0x200
+#define ANDROID_BOOTLOADER_OFFSET   0x400
+#define ANDROID_BOOTLOADER_SIZE	    0xFFC00
+#define ANDROID_KERNEL_OFFSET	    0x100000
+#define ANDROID_KERNEL_SIZE	    0x500000
+#define ANDROID_URAMDISK_OFFSET	    0x600000
+#define ANDROID_URAMDISK_SIZE	    0x100000
+
+#define STR_LANG_INDEX		    0x00
+#define STR_MANUFACTURER_INDEX	    0x01
+#define STR_PRODUCT_INDEX	    0x02
+#define STR_SERIAL_INDEX	    0x03
+#define STR_CONFIG_INDEX	    0x04
+#define STR_DATA_INTERFACE_INDEX    0x05
+#define STR_CTRL_INTERFACE_INDEX    0x06
+#define STR_COUNT		    0x07
+
+#define FASTBOOT_FBPARTS_ENV_MAX_LEN 1024
+/* To support the Android-style naming of flash */
+#define MAX_PTN		    16
+
+
+/*pentry index internally*/
+enum {
+    PTN_MBR_INDEX = 0,
+    PTN_BOOTLOADER_INDEX,
+    PTN_KERNEL_INDEX,
+    PTN_URAMDISK_INDEX,
+    PTN_SYSTEM_INDEX,
+    PTN_RECOVERY_INDEX
+};
+
+struct fastboot_device_info fastboot_devinfo;
+
+/* defined and used by gadget/ep0.c */
+extern struct usb_string_descriptor **usb_strings;
+
+static struct usb_device_instance device_instance[1];
+static struct usb_bus_instance bus_instance[1];
+static struct usb_configuration_instance config_instance[1];
+static struct usb_interface_instance interface_instance[1];
+static struct usb_alternate_instance alternate_instance[1];
+/* one extra for control endpoint */
+static struct usb_endpoint_instance endpoint_instance[NUM_ENDPOINTS+1];
+
+static struct cmd_fastboot_interface *fastboot_interface;
+static int fastboot_configured_flag;
+static int usb_disconnected;
+
+/* Indicies, References */
+static u8 rx_endpoint;
+static u8 tx_endpoint;
+static struct usb_string_descriptor *fastboot_string_table[STR_COUNT];
+
+/* USB Descriptor Strings */
+static u8 wstrLang[4] = {4, USB_DT_STRING, 0x9, 0x4};
+static u8 wstrManufacturer[2 * (sizeof(CONFIG_FASTBOOT_MANUFACTURER_STR))];
+static u8 wstrProduct[2 * (sizeof(CONFIG_FASTBOOT_PRODUCT_NAME_STR))];
+static u8 wstrSerial[2*(sizeof(CONFIG_FASTBOOT_SERIAL_NUM))];
+static u8 wstrConfiguration[2 * (sizeof(CONFIG_FASTBOOT_CONFIGURATION_STR))];
+static u8 wstrDataInterface[2 * (sizeof(CONFIG_FASTBOOT_INTERFACE_STR))];
+
+/* Standard USB Data Structures */
+static struct usb_interface_descriptor interface_descriptors[1];
+static struct usb_endpoint_descriptor *ep_descriptor_ptrs[NUM_ENDPOINTS];
+static struct usb_configuration_descriptor *configuration_descriptor;
+static struct usb_device_descriptor device_descriptor = {
+	.bLength = sizeof(struct usb_device_descriptor),
+	.bDescriptorType =	USB_DT_DEVICE,
+	.bcdUSB =		cpu_to_le16(USB_BCD_VERSION),
+	.bDeviceClass =		0xff,
+	.bDeviceSubClass =	0xff,
+	.bDeviceProtocol =	0xff,
+	.bMaxPacketSize0 =	0x40,
+	.idVendor =		cpu_to_le16(CONFIG_FASTBOOT_VENDOR_ID),
+	.idProduct =		cpu_to_le16(CONFIG_FASTBOOT_PRODUCT_ID),
+	.bcdDevice =		cpu_to_le16(CONFIG_FASTBOOT_BCD_DEVICE),
+	.iManufacturer =	STR_MANUFACTURER_INDEX,
+	.iProduct =		STR_PRODUCT_INDEX,
+	.iSerialNumber =	STR_SERIAL_INDEX,
+	.bNumConfigurations =	1
+};
+
+/*
+ * Static Generic Serial specific data
+ */
+
+struct fastboot_config_desc {
+	struct usb_configuration_descriptor configuration_desc;
+	struct usb_interface_descriptor	interface_desc[1];
+	struct usb_endpoint_descriptor data_endpoints[NUM_ENDPOINTS];
+};
+
+static struct fastboot_config_desc
+fastboot_configuration_descriptors[1] = {
+	{
+		.configuration_desc = {
+			.bLength = sizeof(struct usb_configuration_descriptor),
+			.bDescriptorType = USB_DT_CONFIG,
+			.wTotalLength =
+			    cpu_to_le16(sizeof(struct fastboot_config_desc)),
+			.bNumInterfaces = 1,
+			.bConfigurationValue = 1,
+			.iConfiguration = STR_CONFIG_INDEX,
+			.bmAttributes =
+				BMATTRIBUTE_SELF_POWERED|BMATTRIBUTE_RESERVED,
+			.bMaxPower = 0x32
+		},
+		.interface_desc = {
+			{
+				.bLength  =
+					sizeof(struct usb_interface_descriptor),
+				.bDescriptorType = USB_DT_INTERFACE,
+				.bInterfaceNumber = 0,
+				.bAlternateSetting = 0,
+				.bNumEndpoints = NUM_ENDPOINTS,
+				.bInterfaceClass =
+					FASTBOOT_INTERFACE_CLASS,
+				.bInterfaceSubClass =
+					FASTBOOT_INTERFACE_SUB_CLASS,
+				.bInterfaceProtocol =
+					FASTBOOT_INTERFACE_PROTOCOL,
+				.iInterface = STR_DATA_INTERFACE_INDEX
+			},
+		},
+		.data_endpoints  = {
+			{
+				.bLength =
+					sizeof(struct usb_endpoint_descriptor),
+				.bDescriptorType =  USB_DT_ENDPOINT,
+				.bEndpointAddress = UDC_OUT_ENDPOINT |
+							 USB_DIR_OUT,
+				.bmAttributes =	USB_ENDPOINT_XFER_BULK,
+				.wMaxPacketSize =
+					cpu_to_le16(CONFIG_USBD_OUT_PKTSIZE),
+				.bInterval = 0x00,
+			},
+			{
+				.bLength =
+					sizeof(struct usb_endpoint_descriptor),
+				.bDescriptorType =  USB_DT_ENDPOINT,
+				.bEndpointAddress = UDC_IN_ENDPOINT |
+							USB_DIR_IN,
+				.bmAttributes =	USB_ENDPOINT_XFER_BULK,
+				.wMaxPacketSize =
+					cpu_to_le16(CONFIG_USBD_IN_PKTSIZE),
+				.bInterval = 0x00,
+			},
+		},
+	},
+};
+
+
+
+static struct fastboot_ptentry ptable[MAX_PTN];
+static unsigned int pcount;
+
+
+/* Static Function Prototypes */
+static void _fastboot_init_strings(void);
+static void _fastboot_init_instances(void);
+static void _fastboot_init_endpoints(void);
+static void _fastboot_event_handler(struct usb_device_instance *device,
+				usb_device_event_t event, int data);
+static int _fastboot_cdc_setup(struct usb_device_request *request,
+				struct urb *urb);
+static int _fastboot_usb_configured(void);
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA) \
+	|| defined(CONFIG_FASTBOOT_STORAGE_MMC)
+static int _fastboot_parts_load_from_ptable(void);
+#endif
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+static int _fastboot_parts_load_from_env(void);
+#endif
+static int _fastboot_setup_dev(void);
+static void _fastboot_load_partitions(void);
+
+/* utility function for converting char* to wide string used by USB */
+static void str2wide(char *str, u16 * wide)
+{
+	int i;
+	for (i = 0; i < strlen(str) && str[i]; i++) {
+		#if defined(__LITTLE_ENDIAN)
+			wide[i] = (u16) str[i];
+		#elif defined(__BIG_ENDIAN)
+			wide[i] = ((u16)(str[i])<<8);
+		#else
+			#error "__LITTLE_ENDIAN or __BIG_ENDIAN undefined"
+		#endif
+	}
+}
+
+/*
+   Get mmc control number from passed string, eg, "mmc1" mean device 1. Only
+   support "mmc0" to "mmc9" currently. It will be treated as device 0 for
+   other string.
+*/
+static int _fastboot_get_mmc_no(char *env_str)
+{
+	int digit = 0;
+	unsigned char a;
+
+	if (env_str && (strlen(env_str) >= 4) &&
+	    !strncmp(env_str, "mmc", 3)) {
+		a = env_str[3];
+		if (a >= '0' && a <= '9')
+			digit = a - '0';
+	}
+
+	return digit;
+}
+
+static int _fastboot_setup_dev(void)
+{
+	char *fastboot_env;
+	fastboot_env = getenv("fastboot_dev");
+
+	if (fastboot_env) {
+		if (!strcmp(fastboot_env, "sata")) {
+			fastboot_devinfo.type = DEV_SATA;
+			fastboot_devinfo.dev_id = 0;
+		} else if (!strcmp(fastboot_env, "nand")) {
+			fastboot_devinfo.type = DEV_NAND;
+			fastboot_devinfo.dev_id = 0;
+		} else if (!strncmp(fastboot_env, "mmc", 3)) {
+			fastboot_devinfo.type = DEV_MMC;
+			fastboot_devinfo.dev_id = _fastboot_get_mmc_no(fastboot_env);
+		}
+	} else {
+		return 1;
+	}
+
+	return 0;
+}
+
+
+/*
+ * Initialize fastboot
+ */
+int fastboot_init(struct cmd_fastboot_interface *interface)
+{
+	printf("fastboot is in init......");
+
+	fastboot_interface = interface;
+	fastboot_interface->product_name = CONFIG_FASTBOOT_PRODUCT_NAME_STR;
+	fastboot_interface->serial_no = CONFIG_FASTBOOT_SERIAL_NUM;
+	fastboot_interface->nand_block_size = 4096;
+	fastboot_interface->transfer_buffer =
+				(unsigned char *)CONFIG_FASTBOOT_TRANSFER_BUF;
+	fastboot_interface->transfer_buffer_size =
+				CONFIG_FASTBOOT_TRANSFER_BUF_SIZE;
+
+	_fastboot_init_strings();
+	/* Basic USB initialization */
+	udc_init();
+
+	_fastboot_init_instances();
+
+	udc_startup_events(device_instance);
+	udc_connect();		/* Enable pullup for host detection */
+
+	return 0;
+}
+
+static void _fastboot_init_strings(void)
+{
+	struct usb_string_descriptor *string;
+
+	fastboot_string_table[STR_LANG_INDEX] =
+		(struct usb_string_descriptor *)wstrLang;
+
+	string = (struct usb_string_descriptor *)wstrManufacturer;
+	string->bLength = sizeof(wstrManufacturer);
+	string->bDescriptorType = USB_DT_STRING;
+	str2wide(CONFIG_FASTBOOT_MANUFACTURER_STR, string->wData);
+	fastboot_string_table[STR_MANUFACTURER_INDEX] = string;
+
+	string = (struct usb_string_descriptor *)wstrProduct;
+	string->bLength = sizeof(wstrProduct);
+	string->bDescriptorType = USB_DT_STRING;
+	str2wide(CONFIG_FASTBOOT_PRODUCT_NAME_STR, string->wData);
+	fastboot_string_table[STR_PRODUCT_INDEX] = string;
+
+	string = (struct usb_string_descriptor *)wstrSerial;
+	string->bLength = sizeof(wstrSerial);
+	string->bDescriptorType = USB_DT_STRING;
+	str2wide(CONFIG_FASTBOOT_SERIAL_NUM, string->wData);
+	fastboot_string_table[STR_SERIAL_INDEX] = string;
+
+	string = (struct usb_string_descriptor *)wstrConfiguration;
+	string->bLength = sizeof(wstrConfiguration);
+	string->bDescriptorType = USB_DT_STRING;
+	str2wide(CONFIG_FASTBOOT_CONFIGURATION_STR, string->wData);
+	fastboot_string_table[STR_CONFIG_INDEX] = string;
+
+	string = (struct usb_string_descriptor *) wstrDataInterface;
+	string->bLength = sizeof(wstrDataInterface);
+	string->bDescriptorType = USB_DT_STRING;
+	str2wide(CONFIG_FASTBOOT_INTERFACE_STR, string->wData);
+	fastboot_string_table[STR_DATA_INTERFACE_INDEX] = string;
+
+	/* Now, initialize the string table for ep0 handling */
+	usb_strings = fastboot_string_table;
+}
+
+static void _fastboot_init_instances(void)
+{
+	int i;
+	u16 temp;
+
+	/* Assign endpoint descriptors */
+	ep_descriptor_ptrs[0] =
+		&fastboot_configuration_descriptors[0].data_endpoints[0];
+	ep_descriptor_ptrs[1] =
+		&fastboot_configuration_descriptors[0].data_endpoints[1];
+
+	/* Configuration Descriptor */
+	configuration_descriptor =
+		(struct usb_configuration_descriptor *)
+		&fastboot_configuration_descriptors;
+
+	fastboot_configured_flag = 0;
+
+	/* initialize device instance */
+	memset(device_instance, 0, sizeof(struct usb_device_instance));
+	device_instance->device_state = STATE_INIT;
+	device_instance->device_descriptor = &device_descriptor;
+	device_instance->event = _fastboot_event_handler;
+	device_instance->cdc_recv_setup = _fastboot_cdc_setup;
+	device_instance->bus = bus_instance;
+	device_instance->configurations = 1;
+	device_instance->configuration_instance_array = config_instance;
+
+	/* initialize bus instance */
+	memset(bus_instance, 0, sizeof(struct usb_bus_instance));
+	bus_instance->device = device_instance;
+	bus_instance->endpoint_array = endpoint_instance;
+	bus_instance->max_endpoints = NUM_ENDPOINTS + 1;
+	bus_instance->maxpacketsize = 0xFF;
+	bus_instance->serial_number_str = CONFIG_FASTBOOT_SERIAL_NUM;
+
+	/* configuration instance */
+	memset(config_instance, 0,
+		sizeof(struct usb_configuration_instance));
+	config_instance->interfaces = 1;
+	config_instance->configuration_descriptor = configuration_descriptor;
+	config_instance->interface_instance_array = interface_instance;
+
+	/* interface instance */
+	memset(interface_instance, 0,
+		sizeof(struct usb_interface_instance));
+	interface_instance->alternates = 1;
+	interface_instance->alternates_instance_array = alternate_instance;
+
+	/* alternates instance */
+	memset(alternate_instance, 0,
+		sizeof(struct usb_alternate_instance));
+	alternate_instance->interface_descriptor = interface_descriptors;
+	alternate_instance->endpoints = NUM_ENDPOINTS;
+	alternate_instance->endpoints_descriptor_array = ep_descriptor_ptrs;
+
+	/* endpoint instances */
+	memset(&endpoint_instance[0], 0,
+		sizeof(struct usb_endpoint_instance));
+	endpoint_instance[0].endpoint_address = 0;
+	endpoint_instance[0].rcv_packetSize = EP0_MAX_PACKET_SIZE;
+	endpoint_instance[0].rcv_attributes = USB_ENDPOINT_XFER_CONTROL;
+	endpoint_instance[0].tx_packetSize = EP0_MAX_PACKET_SIZE;
+	endpoint_instance[0].tx_attributes = USB_ENDPOINT_XFER_CONTROL;
+	udc_setup_ep(device_instance, 0, &endpoint_instance[0]);
+
+	for (i = 1; i <= NUM_ENDPOINTS; i++) {
+		memset(&endpoint_instance[i], 0,
+			sizeof(struct usb_endpoint_instance));
+
+		endpoint_instance[i].endpoint_address =
+			ep_descriptor_ptrs[i - 1]->bEndpointAddress;
+
+		endpoint_instance[i].rcv_attributes =
+			ep_descriptor_ptrs[i - 1]->bmAttributes;
+
+		/*fix the abort caused by unalignment*/
+		temp = *(u8 *)&ep_descriptor_ptrs[i - 1]->wMaxPacketSize;
+		temp |=
+			(*(((u8 *)&ep_descriptor_ptrs[i - 1]->wMaxPacketSize) + 1) << 8);
+
+		endpoint_instance[i].rcv_packetSize =
+			le16_to_cpu(temp);
+
+		endpoint_instance[i].tx_attributes =
+			ep_descriptor_ptrs[i - 1]->bmAttributes;
+
+		endpoint_instance[i].tx_packetSize =
+			le16_to_cpu(temp);
+
+		endpoint_instance[i].tx_attributes =
+			ep_descriptor_ptrs[i - 1]->bmAttributes;
+
+		urb_link_init(&endpoint_instance[i].rcv);
+		urb_link_init(&endpoint_instance[i].rdy);
+		urb_link_init(&endpoint_instance[i].tx);
+		urb_link_init(&endpoint_instance[i].done);
+
+		if (endpoint_instance[i].endpoint_address & USB_DIR_IN) {
+			tx_endpoint = i;
+			endpoint_instance[i].tx_urb =
+				usbd_alloc_urb(device_instance,
+						&endpoint_instance[i]);
+		} else {
+			rx_endpoint = i;
+			endpoint_instance[i].rcv_urb =
+				usbd_alloc_urb(device_instance,
+						&endpoint_instance[i]);
+		}
+	}
+}
+
+static void _fastboot_init_endpoints(void)
+{
+	int i;
+
+	bus_instance->max_endpoints = NUM_ENDPOINTS + 1;
+	for (i = 1; i <= NUM_ENDPOINTS; i++)
+		udc_setup_ep(device_instance, i, &endpoint_instance[i]);
+}
+
+static void _fastboot_destroy_endpoints(void)
+{
+	int i;
+	struct urb *tx_urb;
+
+	for (i = 1; i <= NUM_ENDPOINTS; i++) {
+		/*dealloc urb*/
+		if (endpoint_instance[i].endpoint_address & USB_DIR_IN) {
+			if (endpoint_instance[i].tx_urb)
+				usbd_dealloc_urb(endpoint_instance[i].tx_urb);
+
+			while (endpoint_instance[i].tx_queue) {
+				tx_urb = first_urb_detached(&endpoint_instance[i].tx);
+				if (tx_urb) {
+					usbd_dealloc_urb(tx_urb);
+					endpoint_instance[i].tx_queue--;
+				} else {
+					break;
+				}
+			}
+			endpoint_instance[i].tx_queue = 0;
+
+			do {
+				tx_urb = first_urb_detached(&endpoint_instance[i].done);
+				if (tx_urb)
+					usbd_dealloc_urb(tx_urb);
+			} while (tx_urb);
+
+		} else {
+			if (endpoint_instance[i].rcv_urb)
+				usbd_dealloc_urb(endpoint_instance[i].rcv_urb);
+		}
+
+		udc_destroy_ep(device_instance, &endpoint_instance[i]);
+	}
+}
+
+
+static int _fill_buffer(u8 *buf)
+{
+	struct usb_endpoint_instance *endpoint =
+					&endpoint_instance[rx_endpoint];
+
+	if (endpoint->rcv_urb && endpoint->rcv_urb->actual_length) {
+		unsigned int nb = 0;
+		char *src = (char *)endpoint->rcv_urb->buffer;
+		unsigned int rx_avail = MAX_BUFFER_SIZE;
+
+		if (rx_avail >= endpoint->rcv_urb->actual_length) {
+			nb = endpoint->rcv_urb->actual_length;
+			memcpy(buf, src, nb);
+			endpoint->rcv_urb->actual_length = 0;
+		}
+		return nb;
+	}
+	return 0;
+}
+
+static struct urb *_next_urb(struct usb_device_instance *device,
+				struct usb_endpoint_instance *endpoint)
+{
+	struct urb *current_urb = NULL;
+	int space;
+
+	/* If there's a queue, then we should add to the last urb */
+	if (!endpoint->tx_queue)
+		current_urb = endpoint->tx_urb;
+	else
+		/* Last urb from tx chain */
+		current_urb =
+		    p2surround(struct urb, link, endpoint->tx.prev);
+
+	/* Make sure this one has enough room */
+	space = current_urb->buffer_length - current_urb->actual_length;
+	if (space > 0)
+		return current_urb;
+	else {    /* No space here */
+		/* First look at done list */
+		current_urb = first_urb_detached(&endpoint->done);
+		if (!current_urb)
+			current_urb = usbd_alloc_urb(device, endpoint);
+
+		urb_append(&endpoint->tx, current_urb);
+		endpoint->tx_queue++;
+	}
+	return current_urb;
+}
+
+static int _fastboot_usb_configured(void)
+{
+	return fastboot_configured_flag;
+}
+
+static void _fastboot_event_handler(struct usb_device_instance *device,
+				  usb_device_event_t event, int data)
+{
+	switch (event) {
+	case DEVICE_RESET:
+	case DEVICE_BUS_INACTIVE:
+		fastboot_configured_flag = 0;
+		break;
+	case DEVICE_CONFIGURED:
+		fastboot_configured_flag = 1;
+		_fastboot_init_endpoints();
+		break;
+	case DEVICE_ADDRESS_ASSIGNED:
+	default:
+		break;
+	}
+}
+
+static int _fastboot_cdc_setup(struct usb_device_request *request,
+	struct urb *urb)
+{
+	return 0;
+}
+
+
+/*!
+ * Function to receive data from host through channel
+ *
+ * @buf  buffer to fill in
+ * @count  read data size
+ *
+ * @return 0
+ */
+int fastboot_usb_recv(u8 *buf, int count)
+{
+	int len = 0;
+
+	while (!_fastboot_usb_configured())
+		udc_irq();
+
+	/* update rxqueue to wait new data */
+	mxc_udc_rxqueue_update(2, count);
+
+	while (!len) {
+		if (is_usb_disconnected()) {
+			/*it will not unconfigure when disconnect
+			from host, so here needs manual unconfigure
+			anyway, it's just a workaround*/
+			fastboot_configured_flag = 0;
+			usb_disconnected = 1;
+			return 0;
+		}
+		udc_irq();
+		if (_fastboot_usb_configured())
+			len = _fill_buffer(buf);
+	}
+	return len;
+}
+
+int fastboot_getvar(const char *rx_buffer, char *tx_buffer)
+{
+	/* Place board specific variables here */
+	return 0;
+}
+
+int fastboot_poll()
+{
+	u8 buffer[MAX_BUFFER_SIZE];
+	int length = 0;
+
+	memset(buffer, 0, MAX_BUFFER_SIZE);
+
+	length = fastboot_usb_recv(buffer, MAX_BUFFER_SIZE);
+
+	/* If usb disconnected, blocked here to wait */
+	if (usb_disconnected) {
+		udc_disconnect();
+		udc_connect();
+		/*the udc_connect will be blocked until connect to host
+		  so, the usb_disconnect should be 0 after udc_connect,
+		  and should be set manually. Anyway, it's just a workaround*/
+		usb_disconnected = 0;
+	}
+
+	if (!length)
+		return FASTBOOT_INACTIVE;
+
+	/* Pass this up to the interface's handler */
+	if (fastboot_interface && fastboot_interface->rx_handler) {
+		if (!fastboot_interface->rx_handler(buffer, length))
+			return FASTBOOT_OK;
+	}
+	return FASTBOOT_OK;
+}
+
+int fastboot_tx(unsigned char *buffer, unsigned int buffer_size)
+{
+	/* Not realized yet */
+	return 0;
+}
+
+static int _fastboot_write_buffer(const char *buffer,
+	unsigned int buffer_size)
+{
+	struct usb_endpoint_instance *endpoint =
+		(struct usb_endpoint_instance *)&endpoint_instance[tx_endpoint];
+	struct urb *current_urb = NULL;
+
+	if (!_fastboot_usb_configured())
+		return 0;
+
+	current_urb = _next_urb(device_instance, endpoint);
+	if (buffer_size) {
+		char *dest;
+		int space_avail, popnum, count, total = 0;
+
+		/* Break buffer into urb sized pieces,
+		 * and link each to the endpoint
+		 */
+		count = buffer_size;
+		while (count > 0) {
+			if (!current_urb) {
+				printf("current_urb is NULL, buffer_size %d\n",
+				    buffer_size);
+				return total;
+			}
+
+			dest = (char *)current_urb->buffer +
+			current_urb->actual_length;
+
+			space_avail = current_urb->buffer_length -
+					current_urb->actual_length;
+			popnum = MIN(space_avail, count);
+			if (popnum == 0)
+				break;
+
+			memcpy(dest, buffer + total, popnum);
+			printf("send: %s\n", (char *)buffer);
+
+			current_urb->actual_length += popnum;
+			total += popnum;
+
+			if (udc_endpoint_write(endpoint))
+				/* Write pre-empted by RX */
+				return 0;
+			count -= popnum;
+		} /* end while */
+		return total;
+	}
+	return 0;
+}
+
+int fastboot_tx_status(const char *buffer, unsigned int buffer_size)
+{
+	int len = 0;
+
+	while (buffer_size > 0) {
+		len = _fastboot_write_buffer(buffer + len, buffer_size);
+		buffer_size -= len;
+
+		udc_irq();
+	}
+	udc_irq();
+
+	return 0;
+}
+
+void fastboot_shutdown(void)
+{
+	usb_shutdown();
+
+	/* Reset interface*/
+	if (fastboot_interface &&
+		fastboot_interface->reset_handler) {
+		fastboot_interface->reset_handler();
+	}
+
+	/* Reset some globals */
+	_fastboot_destroy_endpoints();
+	fastboot_interface = NULL;
+	fastboot_configured_flag = 0;
+	usb_disconnected = 0;
+
+	/*free memory*/
+	udc_destroy();
+}
+
+/*
+ * CPU and board-specific fastboot initializations.  Aliased function
+ * signals caller to move on
+ */
+static void __def_fastboot_setup(void)
+{
+	/*do nothing here*/
+}
+void board_fastboot_setup(void) \
+	__attribute__((weak, alias("__def_fastboot_setup")));
+
+
+void fastboot_setup(void)
+{
+	/*execute board relevant initilizations for preparing fastboot */
+	board_fastboot_setup();
+
+	/*get the fastboot dev*/
+	_fastboot_setup_dev();
+
+	/*check if we need to setup recovery*/
+#ifdef CONFIG_ANDROID_RECOVERY
+    check_recovery_mode();
+#endif
+
+	/*load partitions information for the fastboot dev*/
+	_fastboot_load_partitions();
+}
+
+/* export to lib_arm/board.c */
+void check_fastboot(void)
+{
+	if (fastboot_check_and_clean_flag())
+		do_fastboot(NULL, 0, 0, 0);
+}
+
+#if defined(CONFIG_FASTBOOT_STORAGE_SATA) \
+	|| defined(CONFIG_FASTBOOT_STORAGE_MMC)
+/**
+   @mmc_dos_partition_index: the partition index in mbr.
+   @mmc_partition_index: the boot partition or user partition index,
+   not related to the partition table.
+ */
+static int _fastboot_parts_add_ptable_entry(int ptable_index,
+				      int mmc_dos_partition_index,
+				      int mmc_partition_index,
+				      const char *name,
+				      block_dev_desc_t *dev_desc,
+				      struct fastboot_ptentry *ptable)
+{
+	disk_partition_t info;
+	strcpy(ptable[ptable_index].name, name);
+
+	if (get_partition_info(dev_desc,
+			       mmc_dos_partition_index, &info)) {
+		printf("Bad partition index:%d for partition:%s\n",
+		       mmc_dos_partition_index, name);
+		return -1;
+	} else {
+		ptable[ptable_index].start = info.start;
+		ptable[ptable_index].length = info.size;
+		ptable[ptable_index].partition_id = mmc_partition_index;
+	}
+	return 0;
+}
+
+static int _fastboot_parts_load_from_ptable(void)
+{
+	int i;
+#ifdef CONFIG_CMD_SATA
+	int sata_device_no;
+#endif
+
+	/* mmc boot partition: -1 means no partition, 0 user part., 1 boot part.
+	 * default is no partition, for emmc default user part, except emmc*/
+	int boot_partition = FASTBOOT_MMC_NONE_PARTITION_ID;
+    int user_partition = FASTBOOT_MMC_NONE_PARTITION_ID;
+
+	struct mmc *mmc;
+	block_dev_desc_t *dev_desc;
+	struct fastboot_ptentry ptable[PTN_RECOVERY_INDEX + 1];
+
+	/* sata case in env */
+	if (fastboot_devinfo.type == DEV_SATA) {
+#ifdef CONFIG_CMD_SATA
+		puts("flash target is SATA\n");
+		if (sata_initialize())
+			return -1;
+		sata_device_no = CONFIG_FASTBOOT_SATA_NO;
+		if (sata_device_no >= CONFIG_SYS_SATA_MAX_DEVICE) {
+			printf("Unknown SATA(%d) device for fastboot\n",
+				sata_device_no);
+			return -1;
+		}
+		dev_desc = sata_get_dev(sata_device_no);
+#else /*! CONFIG_CMD_SATA*/
+		puts("SATA isn't buildin\n");
+		return -1;
+#endif /*! CONFIG_CMD_SATA*/
+	} else if (fastboot_devinfo.type == DEV_MMC) {
+		int mmc_no = 0;
+		mmc_no = fastboot_devinfo.dev_id;
+
+		printf("flash target is MMC:%d\n", mmc_no);
+		mmc = find_mmc_device(mmc_no);
+		if (mmc && mmc_init(mmc))
+			printf("MMC card init failed!\n");
+
+		dev_desc = get_dev("mmc", mmc_no);
+		if (NULL == dev_desc) {
+			printf("** Block device MMC %d not supported\n",
+				mmc_no);
+			return -1;
+		}
+
+		/* multiple boot paritions for eMMC 4.3 later */
+		if (mmc->part_config != MMCPART_NOAVAILABLE) {
+			boot_partition = FASTBOOT_MMC_BOOT_PARTITION_ID;
+			user_partition = FASTBOOT_MMC_USER_PARTITION_ID;
+		}
+	} else {
+		printf("Can't setup partition table on this device %d\n",
+			fastboot_devinfo.type);
+		return -1;
+	}
+
+	memset((char *)ptable, 0,
+		    sizeof(struct fastboot_ptentry) * (PTN_RECOVERY_INDEX + 1));
+	/* MBR */
+	strcpy(ptable[PTN_MBR_INDEX].name, "mbr");
+	ptable[PTN_MBR_INDEX].start = ANDROID_MBR_OFFSET / dev_desc->blksz;
+	ptable[PTN_MBR_INDEX].length = ANDROID_MBR_SIZE / dev_desc->blksz;
+	ptable[PTN_MBR_INDEX].partition_id = user_partition;
+	/* Bootloader */
+	strcpy(ptable[PTN_BOOTLOADER_INDEX].name, "bootloader");
+	ptable[PTN_BOOTLOADER_INDEX].start =
+				ANDROID_BOOTLOADER_OFFSET / dev_desc->blksz;
+	ptable[PTN_BOOTLOADER_INDEX].length =
+				 ANDROID_BOOTLOADER_SIZE / dev_desc->blksz;
+	ptable[PTN_BOOTLOADER_INDEX].partition_id = boot_partition;
+
+	_fastboot_parts_add_ptable_entry(PTN_KERNEL_INDEX,
+				   CONFIG_ANDROID_BOOT_PARTITION_MMC,
+				   user_partition, "boot", dev_desc, ptable);
+	_fastboot_parts_add_ptable_entry(PTN_RECOVERY_INDEX,
+				   CONFIG_ANDROID_RECOVERY_PARTITION_MMC,
+				   user_partition,
+				   "recovery", dev_desc, ptable);
+	_fastboot_parts_add_ptable_entry(PTN_SYSTEM_INDEX,
+				   CONFIG_ANDROID_SYSTEM_PARTITION_MMC,
+				   user_partition,
+				   "system", dev_desc, ptable);
+
+	for (i = 0; i <= PTN_RECOVERY_INDEX; i++)
+		fastboot_flash_add_ptn(&ptable[i]);
+
+	return 0;
+}
+#endif /*CONFIG_FASTBOOT_STORAGE_SATA || CONFIG_FASTBOOT_STORAGE_MMC*/
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+static unsigned long long _memparse(char *ptr, char **retptr)
+{
+	char *endptr;	/* local pointer to end of parsed string */
+
+	unsigned long ret = simple_strtoul(ptr, &endptr, 0);
+
+	switch (*endptr) {
+	case 'M':
+	case 'm':
+		ret <<= 10;
+	case 'K':
+	case 'k':
+		ret <<= 10;
+		endptr++;
+	default:
+		break;
+	}
+
+	if (retptr)
+		*retptr = endptr;
+
+	return ret;
+}
+
+static int _fastboot_parts_add_env_entry(char *s, char **retptr)
+{
+	unsigned long size;
+	unsigned long offset = 0;
+	char *name;
+	int name_len;
+	int delim;
+	unsigned int flags;
+	struct fastboot_ptentry part;
+
+	size = _memparse(s, &s);
+	if (0 == size) {
+		printf("Error:FASTBOOT size of parition is 0\n");
+		return 1;
+	}
+
+	/* fetch partition name and flags */
+	flags = 0; /* this is going to be a regular partition */
+	delim = 0;
+	/* check for offset */
+	if (*s == '@') {
+		s++;
+		offset = _memparse(s, &s);
+	} else {
+		printf("Error:FASTBOOT offset of parition is not given\n");
+		return 1;
+	}
+
+	/* now look for name */
+	if (*s == '(')
+		delim = ')';
+
+	if (delim) {
+		char *p;
+
+		name = ++s;
+		p = strchr((const char *)name, delim);
+		if (!p) {
+			printf("Error:FASTBOOT no closing %c found in partition name\n",
+				delim);
+			return 1;
+		}
+		name_len = p - name;
+		s = p + 1;
+	} else {
+		printf("Error:FASTBOOT no partition name for \'%s\'\n", s);
+		return 1;
+	}
+
+	/* check for options */
+	while (1) {
+		if (strncmp(s, "i", 1) == 0) {
+			flags |= FASTBOOT_PTENTRY_FLAGS_WRITE_I;
+			s += 1;
+		} else if (strncmp(s, "ubifs", 5) == 0) {
+			/* ubifs */
+			flags |= FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS;
+			s += 5;
+		} else {
+			break;
+		}
+		if (strncmp(s, "|", 1) == 0)
+			s += 1;
+	}
+
+	/* enter this partition (offset will be calculated later if it is zero at this point) */
+	part.length = size;
+	part.start = offset;
+	part.flags = flags;
+
+	if (name) {
+		if (name_len >= sizeof(part.name)) {
+			printf("Error:FASTBOOT partition name is too long\n");
+			return 1;
+		}
+		strncpy(&part.name[0], name, name_len);
+		/* name is not null terminated */
+		part.name[name_len] = '\0';
+	} else {
+		printf("Error:FASTBOOT no name\n");
+		return 1;
+	}
+
+	fastboot_flash_add_ptn(&part);
+
+	/*if the nand partitions envs are not initialized, try to init them*/
+	if (check_parts_values(&part))
+		save_parts_values(&part, part.start, part.length);
+
+	/* return (updated) pointer command line string */
+	*retptr = s;
+
+	/* return partition table */
+	return 0;
+}
+
+static int _fastboot_parts_load_from_env(void)
+{
+	char fbparts[FASTBOOT_FBPARTS_ENV_MAX_LEN], *env;
+
+	env = getenv("fbparts");
+	if (env) {
+		unsigned int len;
+		len = strlen(env);
+		if (len && len < FASTBOOT_FBPARTS_ENV_MAX_LEN) {
+			char *s, *e;
+
+			memcpy(&fbparts[0], env, len + 1);
+			printf("Fastboot: Adding partitions from environment\n");
+			s = &fbparts[0];
+			e = s + len;
+			while (s < e) {
+				if (_fastboot_parts_add_env_entry(s, &s)) {
+					printf("Error:Fastboot: Abort adding partitions\n");
+					pcount = 0;
+					return 1;
+				}
+				/* Skip a bunch of delimiters */
+				while (s < e) {
+					if ((' ' == *s) ||
+					    ('\t' == *s) ||
+					    ('\n' == *s) ||
+					    ('\r' == *s) ||
+					    (',' == *s)) {
+						s++;
+					} else {
+						break;
+					}
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+static void _fastboot_load_partitions(void)
+{
+	pcount = 0;
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+	_fastboot_parts_load_from_env();
+#elif defined(CONFIG_FASTBOOT_STORAGE_SATA) \
+	|| defined(CONFIG_FASTBOOT_STORAGE_MMC)
+	_fastboot_parts_load_from_ptable();
+#endif
+}
+
+/*
+ * Android style flash utilties */
+void fastboot_flash_add_ptn(struct fastboot_ptentry *ptn)
+{
+	if (pcount < MAX_PTN) {
+		memcpy(ptable + pcount, ptn, sizeof(struct fastboot_ptentry));
+		pcount++;
+	}
+}
+
+void fastboot_flash_dump_ptn(void)
+{
+	unsigned int n;
+	for (n = 0; n < pcount; n++) {
+		struct fastboot_ptentry *ptn = ptable + n;
+		printf("ptn %d name='%s' start=%d len=%d\n",
+			n, ptn->name, ptn->start, ptn->length);
+	}
+}
+
+
+struct fastboot_ptentry *fastboot_flash_find_ptn(const char *name)
+{
+	unsigned int n;
+
+	for (n = 0; n < pcount; n++) {
+		/* Make sure a substring is not accepted */
+		if (strlen(name) == strlen(ptable[n].name)) {
+			if (0 == strcmp(ptable[n].name, name))
+				return ptable + n;
+		}
+	}
+
+	printf("can't find partition: %s, dump the partition table\n", name);
+	fastboot_flash_dump_ptn();
+	return 0;
+}
+
+struct fastboot_ptentry *fastboot_flash_get_ptn(unsigned int n)
+{
+	if (n < pcount)
+		return ptable + n;
+	else
+		return 0;
+}
+
+unsigned int fastboot_flash_get_ptn_count(void)
+{
+	return pcount;
+}
diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
index dfb2e7f..160488a 100644
--- a/drivers/fpga/Makefile
+++ b/drivers/fpga/Makefile
@@ -8,6 +8,7 @@
 obj-y += fpga.o
 obj-$(CONFIG_FPGA_SPARTAN2) += spartan2.o
 obj-$(CONFIG_FPGA_SPARTAN3) += spartan3.o
+obj-$(CONFIG_FPGA_SPARTAN6) += spartan6.o
 obj-$(CONFIG_FPGA_VIRTEX2) += virtex2.o
 obj-$(CONFIG_FPGA_ZYNQPL) += zynqpl.o
 obj-$(CONFIG_FPGA_XILINX) += xilinx.o
diff --git a/drivers/fpga/spartan6.c b/drivers/fpga/spartan6.c
new file mode 100644
index 0000000..6cc3bbe
--- /dev/null
+++ b/drivers/fpga/spartan6.c
@@ -0,0 +1,467 @@
+/*
+ * (C) Copyright 2011
+ * Daniel Dyer, Axent Global, daniel_dyer@axent.com.au.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*
+ * Configuration suspport for Xilinx Spartan6 devices.  Based
+ * on spartan3.c (Rich Ireland, rireland@enterasys.com).
+ */
+
+#include <common.h>		/* core U-Boot definitions */
+#include <spartan6.h>		/* Spartan-II device family */
+
+/* Define FPGA_DEBUG to get debug printf's */
+#ifdef	FPGA_DEBUG
+#define PRINTF(fmt,args...)	printf (fmt ,##args)
+#else
+#define PRINTF(fmt,args...)
+#endif
+
+#undef CONFIG_SYS_FPGA_CHECK_BUSY
+
+/* Note: The assumption is that we cannot possibly run fast enough to
+ * overrun the device (the Slave Parallel mode can free run at 50MHz).
+ * If there is a need to operate slower, define CONFIG_FPGA_DELAY in
+ * the board config file to slow things down.
+ */
+#ifndef CONFIG_FPGA_DELAY
+#define CONFIG_FPGA_DELAY()
+#endif
+
+#ifndef CONFIG_SYS_FPGA_WAIT
+#define CONFIG_SYS_FPGA_WAIT CONFIG_SYS_HZ/100	/* 10 ms */
+#endif
+
+static int Spartan6_sp_load(Xilinx_desc *desc, const void *buf, size_t bsize);
+static int Spartan6_sp_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+/* static int Spartan6_sp_info(Xilinx_desc *desc ); */
+
+static int Spartan6_ss_load(Xilinx_desc *desc, const void *buf, size_t bsize);
+static int Spartan6_ss_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+/* static int Spartan6_ss_info(Xilinx_desc *desc); */
+
+/* ------------------------------------------------------------------------- */
+/* Spartan-6 Generic Implementation */
+int Spartan6_load(Xilinx_desc *desc, const void *buf, size_t bsize)
+{
+	int ret_val = FPGA_FAIL;
+
+	switch (desc->iface) {
+	case slave_serial:
+		PRINTF ("%s: Launching Slave Serial Load\n", __FUNCTION__);
+		ret_val = Spartan6_ss_load (desc, buf, bsize);
+		break;
+
+	case slave_parallel:
+		PRINTF ("%s: Launching Slave Parallel Load\n", __FUNCTION__);
+		ret_val = Spartan6_sp_load (desc, buf, bsize);
+		break;
+
+	default:
+		printf ("%s: Unsupported interface type, %d\n",
+				__FUNCTION__, desc->iface);
+	}
+
+	return ret_val;
+}
+
+int Spartan6_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
+{
+	int ret_val = FPGA_FAIL;
+
+	switch (desc->iface) {
+	case slave_serial:
+		PRINTF ("%s: Launching Slave Serial Dump\n", __FUNCTION__);
+		ret_val = Spartan6_ss_dump (desc, buf, bsize);
+		break;
+
+	case slave_parallel:
+		PRINTF ("%s: Launching Slave Parallel Dump\n", __FUNCTION__);
+		ret_val = Spartan6_sp_dump (desc, buf, bsize);
+		break;
+
+	default:
+		printf ("%s: Unsupported interface type, %d\n",
+				__FUNCTION__, desc->iface);
+	}
+
+	return ret_val;
+}
+
+int Spartan6_info( Xilinx_desc *desc )
+{
+	return FPGA_SUCCESS;
+}
+
+
+/* ------------------------------------------------------------------------- */
+/* Spartan-6 Slave Parallel Generic Implementation */
+
+static int Spartan6_sp_load(Xilinx_desc *desc, const void *buf, size_t bsize)
+{
+	int ret_val = FPGA_FAIL;	/* assume the worst */
+	Xilinx_Spartan6_Slave_Parallel_fns *fn = desc->iface_fns;
+
+	PRINTF ("%s: start with interface functions @ 0x%p\n",
+			__FUNCTION__, fn);
+
+	if (fn) {
+		size_t bytecount = 0;
+		unsigned char *data = (unsigned char *) buf;
+		int cookie = desc->cookie;	/* make a local copy */
+		unsigned long ts;		/* timestamp */
+
+		PRINTF ("%s: Function Table:\n"
+				"ptr:\t0x%p\n"
+				"struct: 0x%p\n"
+				"pre: 0x%p\n"
+				"pgm:\t0x%p\n"
+				"init:\t0x%p\n"
+				"err:\t0x%p\n"
+				"clk:\t0x%p\n"
+				"cs:\t0x%p\n"
+				"wr:\t0x%p\n"
+				"read data:\t0x%p\n"
+				"write data:\t0x%p\n"
+				"busy:\t0x%p\n"
+				"abort:\t0x%p\n",
+				"post:\t0x%p\n\n",
+				__FUNCTION__, &fn, fn, fn->pre, fn->pgm, fn->init, fn->err,
+				fn->clk, fn->cs, fn->wr, fn->rdata, fn->wdata, fn->busy,
+				fn->abort, fn->post);
+
+		/*
+		 * This code is designed to emulate the "Express Style"
+		 * Continuous Data Loading in Slave Parallel Mode for
+		 * the Spartan-6 Family.
+		 */
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		printf ("Loading FPGA Device %d...\n", cookie);
+#endif
+		/*
+		 * Run the pre configuration function if there is one.
+		 */
+		if (*fn->pre) {
+			(*fn->pre) (cookie);
+		}
+
+		/* Establish the initial state */
+		(*fn->pgm) (true, true, cookie);	/* Assert the program, commit */
+
+		/* Get ready for the burn */
+		CONFIG_FPGA_DELAY ();
+		(*fn->pgm) (false, true, cookie);	/* Deassert the program, commit */
+
+		ts = get_timer (0);		/* get current time */
+		/* Now wait for INIT and BUSY to go high */
+		do {
+			CONFIG_FPGA_DELAY ();
+			if (get_timer (ts) > CONFIG_SYS_FPGA_WAIT) {	/* check the time */
+				puts ("** Timeout waiting for INIT to clear.\n");
+				(*fn->abort) (cookie);	/* abort the burn */
+				return FPGA_FAIL;
+			}
+		} while ((*fn->init) (cookie) && (*fn->busy) (cookie));
+
+		(*fn->wr) (true, true, cookie); /* Assert write, commit */
+		(*fn->cs) (true, true, cookie); /* Assert chip select, commit */
+		(*fn->clk) (true, true, cookie);	/* Assert the clock pin */
+
+		/* Load the data */
+		while (bytecount < bsize) {
+			/* XXX - do we check for an Ctrl-C press in here ??? */
+			/* XXX - Check the error bit? */
+
+			(*fn->wdata) (data[bytecount++], true, cookie); /* write the data */
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (false, true, cookie);	/* Deassert the clock pin */
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (true, true, cookie);	/* Assert the clock pin */
+
+#ifdef CONFIG_SYS_FPGA_CHECK_BUSY
+			ts = get_timer (0);	/* get current time */
+			while ((*fn->busy) (cookie)) {
+				/* XXX - we should have a check in here somewhere to
+				 * make sure we aren't busy forever... */
+
+				CONFIG_FPGA_DELAY ();
+				(*fn->clk) (false, true, cookie);	/* Deassert the clock pin */
+				CONFIG_FPGA_DELAY ();
+				(*fn->clk) (true, true, cookie);	/* Assert the clock pin */
+
+				if (get_timer (ts) > CONFIG_SYS_FPGA_WAIT) {	/* check the time */
+					puts ("** Timeout waiting for BUSY to clear.\n");
+					(*fn->abort) (cookie);	/* abort the burn */
+					return FPGA_FAIL;
+				}
+			}
+#endif
+
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+			if (bytecount % (bsize / 40) == 0)
+				putc ('.');		/* let them know we are alive */
+#endif
+		}
+
+		CONFIG_FPGA_DELAY ();
+		(*fn->cs) (false, true, cookie);	/* Deassert the chip select */
+		(*fn->wr) (false, true, cookie);	/* Deassert the write pin */
+
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		putc ('\n');			/* terminate the dotted line */
+#endif
+
+		/* now check for done signal */
+		ts = get_timer (0);		/* get current time */
+		ret_val = FPGA_SUCCESS;
+		while ((*fn->done) (cookie) == FPGA_FAIL) {
+			/* XXX - we should have a check in here somewhere to
+			 * make sure we aren't busy forever... */
+
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (false, true, cookie);	/* Deassert the clock pin */
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (true, true, cookie);	/* Assert the clock pin */
+
+			if (get_timer (ts) > CONFIG_SYS_FPGA_WAIT) {	/* check the time */
+				puts ("** Timeout waiting for DONE to clear.\n");
+				(*fn->abort) (cookie);	/* abort the burn */
+				ret_val = FPGA_FAIL;
+				break;
+			}
+		}
+
+		/*
+		 * Run the post configuration function if there is one.
+		 */
+		if (*fn->post)
+			(*fn->post) (cookie);
+
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		if (ret_val == FPGA_SUCCESS)
+			puts ("Done.\n");
+		else
+			puts ("Fail.\n");
+#endif
+
+	} else {
+		printf ("%s: NULL Interface function table!\n", __FUNCTION__);
+	}
+
+	return ret_val;
+}
+
+static int Spartan6_sp_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
+{
+	int ret_val = FPGA_FAIL;	/* assume the worst */
+	Xilinx_Spartan6_Slave_Parallel_fns *fn = desc->iface_fns;
+
+	if (fn) {
+		unsigned char *data = (unsigned char *) buf;
+		size_t bytecount = 0;
+		int cookie = desc->cookie;	/* make a local copy */
+
+		printf ("Starting Dump of FPGA Device %d...\n", cookie);
+
+		(*fn->cs) (true, true, cookie); /* Assert chip select, commit */
+		(*fn->clk) (true, true, cookie);	/* Assert the clock pin */
+
+		/* dump the data */
+		while (bytecount < bsize) {
+			/* XXX - do we check for an Ctrl-C press in here ??? */
+
+			(*fn->clk) (false, true, cookie);	/* Deassert the clock pin */
+			(*fn->clk) (true, true, cookie);	/* Assert the clock pin */
+			(*fn->rdata) (&(data[bytecount++]), cookie);	/* read the data */
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+			if (bytecount % (bsize / 40) == 0)
+				putc ('.');		/* let them know we are alive */
+#endif
+		}
+
+		(*fn->cs) (false, false, cookie);	/* Deassert the chip select */
+		(*fn->clk) (false, true, cookie);	/* Deassert the clock pin */
+		(*fn->clk) (true, true, cookie);	/* Assert the clock pin */
+
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		putc ('\n');			/* terminate the dotted line */
+#endif
+		puts ("Done.\n");
+
+		/* XXX - checksum the data? */
+	} else {
+		printf ("%s: NULL Interface function table!\n", __FUNCTION__);
+	}
+
+	return ret_val;
+}
+
+
+/* ------------------------------------------------------------------------- */
+
+static int Spartan6_ss_load(Xilinx_desc *desc, const void *buf, size_t bsize)
+{
+	int ret_val = FPGA_FAIL;	/* assume the worst */
+	Xilinx_Spartan6_Slave_Serial_fns *fn = desc->iface_fns;
+	int i;
+	unsigned char val;
+
+	PRINTF ("%s: start with interface functions @ 0x%p\n",
+			__FUNCTION__, fn);
+
+	if (fn) {
+		size_t bytecount = 0;
+		unsigned char *data = (unsigned char *) buf;
+		int cookie = desc->cookie;	/* make a local copy */
+		unsigned long ts;		/* timestamp */
+
+		PRINTF ("%s: Function Table:\n"
+				"ptr:\t0x%p\n"
+				"struct: 0x%p\n"
+				"pgm:\t0x%p\n"
+				"init:\t0x%p\n"
+				"clk:\t0x%p\n"
+				"wr:\t0x%p\n"
+				"done:\t0x%p\n\n",
+				__FUNCTION__, &fn, fn, fn->pgm, fn->init,
+				fn->clk, fn->wr, fn->done);
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		printf ("Loading FPGA Device %d...\n", cookie);
+#endif
+
+		/*
+		 * Run the pre configuration function if there is one.
+		 */
+		if (*fn->pre) {
+			(*fn->pre) (cookie);
+		}
+
+		/* Establish the initial state */
+		(*fn->pgm) (true, true, cookie);	/* Assert the program, commit */
+
+		/* Wait for INIT state (init low)                            */
+		ts = get_timer (0);		/* get current time */
+		do {
+			CONFIG_FPGA_DELAY ();
+			if (get_timer (ts) > CONFIG_SYS_FPGA_WAIT) {	/* check the time */
+				puts ("** Timeout waiting for INIT to start.\n");
+				if (*fn->abort)
+					(*fn->abort) (cookie);
+				return FPGA_FAIL;
+			}
+		} while (!(*fn->init) (cookie));
+
+		/* Get ready for the burn */
+		CONFIG_FPGA_DELAY ();
+		(*fn->pgm) (false, true, cookie);	/* Deassert the program, commit */
+
+		ts = get_timer (0);		/* get current time */
+		/* Now wait for INIT to go high */
+		do {
+			CONFIG_FPGA_DELAY ();
+			if (get_timer (ts) > CONFIG_SYS_FPGA_WAIT) {	/* check the time */
+				puts ("** Timeout waiting for INIT to clear.\n");
+				if (*fn->abort)
+					(*fn->abort) (cookie);
+				return FPGA_FAIL;
+			}
+		} while ((*fn->init) (cookie));
+
+		/* Load the data */
+		if(*fn->bwr)
+			(*fn->bwr) (data, bsize, true, cookie);
+		else {
+			while (bytecount < bsize) {
+
+				/* Xilinx detects an error if INIT goes low (active)
+				   while DONE is low (inactive) */
+				if ((*fn->done) (cookie) == 0 && (*fn->init) (cookie)) {
+					puts ("** CRC error during FPGA load.\n");
+					if (*fn->abort)
+						(*fn->abort) (cookie);
+					return (FPGA_FAIL);
+				}
+				val = data [bytecount ++];
+				i = 8;
+				do {
+					/* Deassert the clock */
+					(*fn->clk) (false, true, cookie);
+					CONFIG_FPGA_DELAY ();
+					/* Write data */
+					(*fn->wr) ((val & 0x80), true, cookie);
+					CONFIG_FPGA_DELAY ();
+					/* Assert the clock */
+					(*fn->clk) (true, true, cookie);
+					CONFIG_FPGA_DELAY ();
+					val <<= 1;
+					i --;
+				} while (i > 0);
+
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+				if (bytecount % (bsize / 40) == 0)
+					putc ('.');		/* let them know we are alive */
+#endif
+			}
+		}
+
+		CONFIG_FPGA_DELAY ();
+
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		putc ('\n');			/* terminate the dotted line */
+#endif
+
+		/* now check for done signal */
+		ts = get_timer (0);		/* get current time */
+		ret_val = FPGA_SUCCESS;
+		(*fn->wr) (true, true, cookie);
+
+		while (! (*fn->done) (cookie)) {
+			/* XXX - we should have a check in here somewhere to
+			 * make sure we aren't busy forever... */
+
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (false, true, cookie);	/* Deassert the clock pin */
+			CONFIG_FPGA_DELAY ();
+			(*fn->clk) (true, true, cookie);	/* Assert the clock pin */
+
+			putc ('*');
+
+			if (get_timer (ts) > CONFIG_SYS_FPGA_WAIT) {	/* check the time */
+				puts ("** Timeout waiting for DONE to clear.\n");
+				ret_val = FPGA_FAIL;
+				break;
+			}
+		}
+		putc ('\n');			/* terminate the dotted line */
+
+		/*
+		 * Run the post configuration function if there is one.
+		 */
+		if (*fn->post)
+			(*fn->post) (cookie);
+
+#ifdef CONFIG_SYS_FPGA_PROG_FEEDBACK
+		if (ret_val == FPGA_SUCCESS)
+			puts ("Done.\n");
+		else
+			puts ("Fail.\n");
+#endif
+
+	} else {
+		printf ("%s: NULL Interface function table!\n", __FUNCTION__);
+	}
+
+	return ret_val;
+}
+
+static int Spartan6_ss_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
+{
+	/* Readback is only available through the Slave Parallel and         */
+	/* boundary-scan interfaces.                                         */
+	printf ("%s: Slave Serial Dumping is unavailable\n",
+			__FUNCTION__);
+	return FPGA_FAIL;
+}
diff --git a/drivers/fpga/xilinx.c b/drivers/fpga/xilinx.c
index 2e0db53..d5956d0 100644
--- a/drivers/fpga/xilinx.c
+++ b/drivers/fpga/xilinx.c
@@ -17,6 +17,7 @@
 #include <virtex2.h>
 #include <spartan2.h>
 #include <spartan3.h>
+#include <spartan6.h>
 #include <zynqpl.h>
 
 #if 0
@@ -169,6 +170,16 @@ int xilinx_load(Xilinx_desc *desc, const void *buf, size_t bsize)
 					__FUNCTION__);
 #endif
 			break;
+		case Xilinx_Spartan6:
+#if defined(CONFIG_FPGA_SPARTAN6)
+			PRINTF ("%s: Launching the Spartan-6 Loader...\n",
+					__FUNCTION__);
+			ret_val = Spartan6_load (desc, buf, bsize);
+#else
+			printf ("%s: No support for Spartan-6 devices.\n",
+					__FUNCTION__);
+#endif
+			break;
 		case Xilinx_Virtex2:
 #if defined(CONFIG_FPGA_VIRTEX2)
 			PRINTF ("%s: Launching the Virtex-II Loader...\n",
@@ -226,6 +237,16 @@ int xilinx_dump(Xilinx_desc *desc, const void *buf, size_t bsize)
 					__FUNCTION__);
 #endif
 			break;
+		case Xilinx_Spartan6:
+#if defined(CONFIG_FPGA_SPARTAN6)
+			PRINTF ("%s: Launching the Spartan-6 Reader...\n",
+					__FUNCTION__);
+			ret_val = Spartan6_dump (desc, buf, bsize);
+#else
+			printf ("%s: No support for Spartan-6 devices.\n",
+					__FUNCTION__);
+#endif
+			break;
 		case Xilinx_Virtex2:
 #if defined( CONFIG_FPGA_VIRTEX2)
 			PRINTF ("%s: Launching the Virtex-II Reader...\n",
@@ -268,6 +289,9 @@ int xilinx_info (Xilinx_desc * desc)
 		case Xilinx_Spartan3:
 			printf ("Spartan-III\n");
 			break;
+		case Xilinx_Spartan6:
+			printf ("Spartan-6\n");
+			break;
 		case Xilinx_Virtex2:
 			printf ("Virtex-II\n");
 			break;
@@ -334,6 +358,15 @@ int xilinx_info (Xilinx_desc * desc)
 						__FUNCTION__);
 #endif
 				break;
+			case Xilinx_Spartan6:
+#if defined(CONFIG_FPGA_SPARTAN6)
+				Spartan6_info (desc);
+#else
+				/* just in case */
+				printf ("%s: No support for Spartan-6 devices.\n",
+						__FUNCTION__);
+#endif
+				break;
 			case Xilinx_Virtex2:
 #if defined(CONFIG_FPGA_VIRTEX2)
 				Virtex2_info (desc);
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 4e001e1..1a06403 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -33,4 +33,5 @@ obj-$(CONFIG_S3C2440_GPIO)	+= s3c2440_gpio.o
 obj-$(CONFIG_XILINX_GPIO)	+= xilinx_gpio.o
 obj-$(CONFIG_ADI_GPIO2)	+= adi_gpio2.o
 obj-$(CONFIG_TCA642X)		+= tca642x.o
-oby-$(CONFIG_SX151X)		+= sx151x.o
+obj-$(CONFIG_SX151X)		+= sx151x.o
+obj-$(CONFIG_MAX7310_IOEXP)	+= max7310_ioexp.o
diff --git a/drivers/gpio/max7310_ioexp.c b/drivers/gpio/max7310_ioexp.c
new file mode 100644
index 0000000..34c494f
--- /dev/null
+++ b/drivers/gpio/max7310_ioexp.c
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <common.h>
+#include <asm/gpio.h>
+#include <asm/io.h>
+#include <errno.h>
+#include <i2c.h>
+#include <gpio_exp.h>
+
+#define MAX7310_REG_INPUT_PORT          0x00
+#define MAX7310_REG_OUTPUT_PORT         0x01
+#define MAX7310_REG_POLARITY            0x02
+#define MAX7310_REG_CONFIGURATION       0x03
+#define MAX7310_REG_TIMEOUT             0x04
+
+enum max7310_gpio_direction {
+	MAX7310_GPIO_DIRECTION_IN,
+	MAX7310_GPIO_DIRECTION_OUT,
+};
+
+struct max7310_config_struct {
+	int i2c_slave_addr;
+	int i2c_bus_id;
+};
+
+static struct max7310_config_struct max7310_configs[CONFIG_IOEXP_DEVICES_NUM];
+
+
+static int max7310_gpio_direction(unsigned int gpio,
+	enum max7310_gpio_direction direction)
+{
+	unsigned int dev = IOEXP_GPIO_TO_DEVICE(gpio);
+	unsigned int pin = IOEXP_GPIO_TO_PIN(gpio);
+	unsigned char value, val2, val3;
+	unsigned char chip;
+
+	if (dev >= CONFIG_IOEXP_DEVICES_NUM)
+		return -EPERM;
+
+	chip = max7310_configs[dev].i2c_slave_addr;
+
+	i2c_set_bus_num(max7310_configs[dev].i2c_bus_id);
+	if (i2c_probe(chip))
+		return -ENXIO;
+
+	i2c_read(chip, MAX7310_REG_CONFIGURATION, 1, &value, 1);
+
+	switch (direction) {
+	case MAX7310_GPIO_DIRECTION_OUT:
+		value &= ~(1 << pin);
+		i2c_write(chip, MAX7310_REG_CONFIGURATION, 1, &value, 1);
+		break;
+	case MAX7310_GPIO_DIRECTION_IN:
+
+		i2c_read(chip, MAX7310_REG_POLARITY, 1, &val2, 1);
+		i2c_read(chip, MAX7310_REG_OUTPUT_PORT, 1, &val3, 1);
+
+		value |= (1 << pin);
+		val2 &= ~(1 << pin);
+		val3 &= ~(1 << pin);
+
+		i2c_write(chip, MAX7310_REG_POLARITY, 1, &val2, 1);
+		i2c_write(chip, MAX7310_REG_CONFIGURATION, 1, &value, 1);
+		i2c_write(chip, MAX7310_REG_OUTPUT_PORT, 1, &val3, 1);
+
+		break;
+	}
+
+	return 0;
+}
+
+static int max7310_gpio_set_value(unsigned gpio, int value)
+{
+	unsigned int dev = IOEXP_GPIO_TO_DEVICE(gpio);
+	unsigned int pin = IOEXP_GPIO_TO_PIN(gpio);
+	unsigned char reg_val;
+	unsigned char chip;
+
+	if (dev >= CONFIG_IOEXP_DEVICES_NUM)
+		return -EPERM;
+
+	chip = max7310_configs[dev].i2c_slave_addr;
+
+	i2c_set_bus_num(max7310_configs[dev].i2c_bus_id);
+	if (i2c_probe(chip))
+		return -ENXIO;
+
+	i2c_read(chip, MAX7310_REG_OUTPUT_PORT, 1, &reg_val, 1);
+
+	if (value)
+		reg_val |= 1 << pin;
+	else
+		reg_val &= ~(1 << pin);
+
+	i2c_write(chip, MAX7310_REG_OUTPUT_PORT, 1, &reg_val, 1);
+
+	return 0;
+}
+
+static int max7310_gpio_get_value(unsigned gpio)
+{
+	unsigned int dev = IOEXP_GPIO_TO_DEVICE(gpio);
+	unsigned int pin = IOEXP_GPIO_TO_PIN(gpio);
+	unsigned char reg_val;
+	unsigned char chip;
+
+	if (dev >= CONFIG_IOEXP_DEVICES_NUM)
+		return -EPERM;
+
+	chip = max7310_configs[dev].i2c_slave_addr;
+
+	i2c_set_bus_num(max7310_configs[dev].i2c_bus_id);
+	if (i2c_probe(chip))
+		return -ENXIO;
+
+	i2c_read(chip, MAX7310_REG_INPUT_PORT, 1, &reg_val, 1);
+
+	reg_val = (reg_val >> pin) & 0x01;
+
+	return reg_val;
+}
+
+int gpio_exp_direction_input(unsigned gpio)
+{
+	int ret = max7310_gpio_direction(gpio, MAX7310_GPIO_DIRECTION_IN);
+
+	if (ret < 0)
+		return ret;
+
+	return max7310_gpio_get_value(gpio);
+}
+
+int gpio_exp_direction_output(unsigned gpio, int value)
+{
+	int ret = max7310_gpio_direction(gpio, MAX7310_GPIO_DIRECTION_OUT);
+
+	if (ret < 0)
+		return ret;
+
+	return max7310_gpio_set_value(gpio, value);
+}
+
+int gpio_exp_setup_port(int port, int i2c_bus_id, int i2c_slave_addr)
+{
+	if (port > CONFIG_IOEXP_DEVICES_NUM || port <= 0)
+		return -EPERM;
+
+	max7310_configs[port-1].i2c_bus_id = i2c_bus_id;
+	max7310_configs[port-1].i2c_slave_addr = i2c_slave_addr;
+
+	return 0;
+}
diff --git a/drivers/gpio/mxc_gpio.c b/drivers/gpio/mxc_gpio.c
index 6a572d5..d804eb5 100644
--- a/drivers/gpio/mxc_gpio.c
+++ b/drivers/gpio/mxc_gpio.c
@@ -12,6 +12,10 @@
 #include <asm/gpio.h>
 #include <asm/io.h>
 #include <errno.h>
+#ifdef CONFIG_MXC_RDC
+#include <asm/imx-common/rdc-sema.h>
+#include <asm/arch/imx-rdc.h>
+#endif
 
 enum mxc_gpio_direction {
 	MXC_GPIO_DIRECTION_IN,
@@ -38,6 +42,27 @@ static unsigned long gpio_ports[] = {
 #endif
 };
 
+#ifdef CONFIG_MXC_RDC
+static unsigned int gpio_rdc[] = {
+	RDC_PER_GPIO1,
+	RDC_PER_GPIO2,
+	RDC_PER_GPIO3,
+	RDC_PER_GPIO4,
+	RDC_PER_GPIO5,
+	RDC_PER_GPIO6,
+	RDC_PER_GPIO7,
+};
+
+#define RDC_CHECK(x) imx_rdc_check_permission(gpio_rdc[x])
+#define RDC_SPINLOCK_UP(x) imx_rdc_sema_lock(gpio_rdc[x])
+#define RDC_SPINLOCK_DOWN(x) imx_rdc_sema_unlock(gpio_rdc[x])
+#else
+#define RDC_CHECK(x) 0
+#define RDC_SPINLOCK_UP(x)
+#define RDC_SPINLOCK_DOWN(x)
+#endif
+
+
 static int mxc_gpio_direction(unsigned int gpio,
 	enum mxc_gpio_direction direction)
 {
@@ -48,6 +73,11 @@ static int mxc_gpio_direction(unsigned int gpio,
 	if (port >= ARRAY_SIZE(gpio_ports))
 		return -1;
 
+	if (RDC_CHECK(port))
+		return -1;
+
+	RDC_SPINLOCK_UP(port);
+
 	gpio &= 0x1f;
 
 	regs = (struct gpio_regs *)gpio_ports[port];
@@ -63,6 +93,8 @@ static int mxc_gpio_direction(unsigned int gpio,
 	}
 	writel(l, &regs->gpio_dir);
 
+	RDC_SPINLOCK_DOWN(port);
+
 	return 0;
 }
 
@@ -75,6 +107,11 @@ int gpio_set_value(unsigned gpio, int value)
 	if (port >= ARRAY_SIZE(gpio_ports))
 		return -1;
 
+	if (RDC_CHECK(port))
+		return -1;
+
+	RDC_SPINLOCK_UP(port);
+
 	gpio &= 0x1f;
 
 	regs = (struct gpio_regs *)gpio_ports[port];
@@ -86,6 +123,8 @@ int gpio_set_value(unsigned gpio, int value)
 		l &= ~(1 << gpio);
 	writel(l, &regs->gpio_dr);
 
+	RDC_SPINLOCK_DOWN(port);
+
 	return 0;
 }
 
@@ -98,12 +137,19 @@ int gpio_get_value(unsigned gpio)
 	if (port >= ARRAY_SIZE(gpio_ports))
 		return -1;
 
+	if (RDC_CHECK(port))
+		return -1;
+
+	RDC_SPINLOCK_UP(port);
+
 	gpio &= 0x1f;
 
 	regs = (struct gpio_regs *)gpio_ports[port];
 
 	val = (readl(&regs->gpio_psr) >> gpio) & 0x01;
 
+	RDC_SPINLOCK_DOWN(port);
+
 	return val;
 }
 
@@ -112,6 +158,10 @@ int gpio_request(unsigned gpio, const char *label)
 	unsigned int port = GPIO_TO_PORT(gpio);
 	if (port >= ARRAY_SIZE(gpio_ports))
 		return -1;
+
+	if (RDC_CHECK(port))
+		return -1;
+
 	return 0;
 }
 
diff --git a/drivers/input/Makefile b/drivers/input/Makefile
index a8e9be2..8b1b86c 100644
--- a/drivers/input/Makefile
+++ b/drivers/input/Makefile
@@ -14,3 +14,4 @@ obj-$(CONFIG_PS2MULT) += ps2mult.o ps2ser.o
 endif
 obj-y += input.o
 obj-$(CONFIG_OF_CONTROL) += key_matrix.o
+obj-$(CONFIG_MXC_KPD) += mxc_keyb.o
diff --git a/drivers/input/mxc_keyb.c b/drivers/input/mxc_keyb.c
new file mode 100644
index 0000000..813a073
--- /dev/null
+++ b/drivers/input/mxc_keyb.c
@@ -0,0 +1,592 @@
+/*
+ * Copyright (C) 2009-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*!
+ * @file mxc_keyb.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC keypad port.
+ *
+ * The keypad driver is designed as a standard Input driver which interacts
+ * with low level keypad port hardware. Upon opening, the Keypad driver
+ * initializes the keypad port. When the keypad interrupt happens the driver
+ * calles keypad polling timer and scans the keypad matrix for key
+ * press/release. If all key press/release happened it comes out of timer and
+ * waits for key press interrupt. The scancode for key press and release events
+ * are passed to Input subsytem.
+ *
+ * @ingroup keypad
+ */
+
+#include <asm/io.h>
+#include <common.h>
+#include <asm/errno.h>
+#include <linux/types.h>
+#include <asm/imx-common/mxc_key_defs.h>
+#include <malloc.h>
+
+/*
+ *  * Module header file
+ *   */
+#include <mxc_keyb.h>
+
+/*!
+ * Comment KPP_DEBUG to disable debug messages
+ */
+
+#undef	KPP_DEBUG
+
+#ifdef	KPP_DEBUG
+#define	KPP_PRINTF(fmt, args...)	printf(fmt , ##args)
+
+static void mxc_kpp_dump_regs()
+{
+	unsigned short t1, t2, t3;
+
+	t1 = __raw_readw(KPCR);
+	t2 = __raw_readw(KPSR);
+	t3 = __raw_readw(KDDR);
+	/*
+	KPP_PRINTF("KPCR=0x%04x, KPSR=0x%04x, KDDR=0x%04x\n",
+		t1, t2, t3);
+		*/
+}
+#else
+#define KPP_PRINTF(fmt, args...)
+#endif
+
+static u16 mxc_key_mapping[] = CONFIG_MXC_KEYMAPPING;
+
+/*!
+ * This structure holds the keypad private data structure.
+ */
+static struct keypad_priv kpp_dev;
+
+/*! Indicates if the key pad device is enabled. */
+
+/*! This static variable indicates whether a key event is pressed/released. */
+static unsigned short KPress;
+
+/*! cur_rcmap and prev_rcmap array is used to detect key press and release. */
+static unsigned short *cur_rcmap;	/* max 64 bits (8x8 matrix) */
+static unsigned short *prev_rcmap;
+
+/*!
+ * Debounce polling period(10ms) in system ticks.
+ */
+/*static unsigned short KScanRate = (10 * CONFIG_SYS_HZ) / 1000;*/
+
+/*!
+ * These arrays are used to store press and release scancodes.
+ */
+static short **press_scancode;
+static short **release_scancode;
+
+static const unsigned short *mxckpd_keycodes;
+static unsigned short mxckpd_keycodes_size;
+
+/*!
+ * This function is called to scan the keypad matrix to find out the key press
+ * and key release events. Make scancode and break scancode are generated for
+ * key press and key release events.
+ *
+ * The following scanning sequence are done for
+ * keypad row and column scanning,
+ * -# Write 1's to KPDR[15:8], setting column data to 1's
+ * -# Configure columns as totem pole outputs(for quick discharging of keypad
+ * capacitance)
+ * -# Configure columns as open-drain
+ * -# Write a single column to 0, others to 1.
+ * -# Sample row inputs and save data. Multiple key presses can be detected on
+ * a single column.
+ * -# Repeat steps the above steps for remaining columns.
+ * -# Return all columns to 0 in preparation for standby mode.
+ * -# Clear KPKD and KPKR status bit(s) by writing to a 1,
+ *    Set the KPKR synchronizer chain by writing "1" to KRSS register,
+ *    Clear the KPKD synchronizer chain by writing "1" to KDSC register
+ *
+ * @result    Number of key pressed/released.
+ */
+static int mxc_kpp_scan_matrix(void)
+{
+	unsigned short reg_val;
+	int col, row;
+	short scancode = 0;
+	int keycnt = 0;		/* How many keys are still pressed */
+
+	/*
+	 * wmb() linux kernel function which guarantees orderings in write
+	 * operations
+	 */
+	/* wmb(); */
+
+	/* save cur keypad matrix to prev */
+	memcpy(prev_rcmap, cur_rcmap, kpp_dev.kpp_rows * sizeof(prev_rcmap[0]));
+	memset(cur_rcmap, 0, kpp_dev.kpp_rows * sizeof(cur_rcmap[0]));
+
+	/*1. Disable both (depress and release) keypad interrupts.*/
+
+	/* KDIE has been disabled in mxc_kpp_getc before calling scan matrix.
+	  * KRIE is always disabled in this driver.
+	  */
+
+	for (col = 0; col < kpp_dev.kpp_cols; col++) {	/* Col */
+		/* 2. Write 1.s to KPDR[15:8] setting column data to 1.s */
+		reg_val = __raw_readw(KPDR);
+		reg_val |= 0xff00;
+		__raw_writew(reg_val, KPDR);
+
+		/*
+		 * 3. Configure columns as totem pole outputs(for quick
+		 * discharging of keypad capacitance)
+		 */
+		reg_val = __raw_readw(KPCR);
+		reg_val &= 0x00ff;
+		__raw_writew(reg_val, KPCR);
+
+		udelay(2);
+
+#ifdef KPP_DEBUG
+		mxc_kpp_dump_regs();
+#endif
+
+		/*
+		 * 4. Configure columns as open-drain
+		 */
+		reg_val = __raw_readw(KPCR);
+		reg_val |= ((1 << kpp_dev.kpp_cols) - 1) << 8;
+		__raw_writew(reg_val, KPCR);
+
+		/*
+		 * 5. Write a single column to 0, others to 1.
+		 * 6. Sample row inputs and save data. Multiple key presses
+		 * can be detected on a single column.
+		 * 7. Repeat steps 2 - 6 for remaining columns.
+		 */
+
+		/* Col bit starts at 8th bit in KPDR */
+		reg_val = __raw_readw(KPDR);
+		reg_val &= ~(1 << (8 + col));
+		__raw_writew(reg_val, KPDR);
+
+		/* Delay added to avoid propagating the 0 from column to row
+		 * when scanning. */
+
+		udelay(5);
+
+#ifdef KPP_DEBUG
+		mxc_kpp_dump_regs();
+#endif
+
+		/* Read row input */
+		reg_val = __raw_readw(KPDR);
+		for (row = 0; row < kpp_dev.kpp_rows; row++) {	/* sample row */
+			if (TEST_BIT(reg_val, row) == 0) {
+				cur_rcmap[row] = BITSET(cur_rcmap[row], col);
+				keycnt++;
+			}
+		}
+	}
+
+	/*
+	 * 8. Return all columns to 0 in preparation for standby mode.
+	 * 9. Clear KPKD and KPKR status bit(s) by writing to a .1.,
+	 * set the KPKR synchronizer chain by writing "1" to KRSS register,
+	 * clear the KPKD synchronizer chain by writing "1" to KDSC register
+	 */
+	reg_val = 0x00;
+	__raw_writew(reg_val, KPDR);
+	reg_val = __raw_readw(KPDR);
+	reg_val = __raw_readw(KPSR);
+	reg_val |= KBD_STAT_KPKD | KBD_STAT_KPKR | KBD_STAT_KRSS |
+	    KBD_STAT_KDSC;
+	__raw_writew(reg_val, KPSR);
+
+#ifdef KPP_DEBUG
+	mxc_kpp_dump_regs();
+#endif
+
+	/* Check key press status change */
+
+	/*
+	 * prev_rcmap array will contain the previous status of the keypad
+	 * matrix.  cur_rcmap array will contains the present status of the
+	 * keypad matrix. If a bit is set in the array, that (row, col) bit is
+	 * pressed, else it is not pressed.
+	 *
+	 * XORing these two variables will give us the change in bit for
+	 * particular row and column.  If a bit is set in XOR output, then that
+	 * (row, col) has a change of status from the previous state.  From
+	 * the diff variable the key press and key release of row and column
+	 * are found out.
+	 *
+	 * If the key press is determined then scancode for key pressed
+	 * can be generated using the following statement:
+	 *    scancode = ((row * 8) + col);
+	 *
+	 * If the key release is determined then scancode for key release
+	 * can be generated using the following statement:
+	 *    scancode = ((row * 8) + col) + MXC_KEYRELEASE;
+	 */
+	for (row = 0; row < kpp_dev.kpp_rows; row++) {
+		unsigned char diff;
+
+		/*
+		 * Calculate the change in the keypad row status
+		 */
+		diff = prev_rcmap[row] ^ cur_rcmap[row];
+
+		for (col = 0; col < kpp_dev.kpp_cols; col++) {
+			if ((diff >> col) & 0x1) {
+				/* There is a status change on col */
+				if ((prev_rcmap[row] & BITSET(0, col)) == 0) {
+					/*
+					 * Previous state is 0, so now
+					 * a key is pressed
+					 */
+					scancode =
+					    ((row * kpp_dev.kpp_cols) +
+					     col);
+					KPress = 1;
+					kpp_dev.iKeyState = KStateUp;
+
+					KPP_PRINTF("Press   (%d, %d) scan=%d "
+						 "Kpress=%d\n",
+						 row, col, scancode, KPress);
+					press_scancode[row][col] =
+					    (short)scancode;
+				} else {
+					/*
+					 * Previous state is not 0, so
+					 * now a key is released
+					 */
+					scancode =
+					    (row * kpp_dev.kpp_cols) +
+					    col + MXC_KEYRELEASE;
+					KPress = 0;
+					kpp_dev.iKeyState = KStateDown;
+
+					KPP_PRINTF
+					    ("Release (%d, %d) scan=%d Kpress=%d\n",
+					     row, col, scancode, KPress);
+					release_scancode[row][col] =
+					    (short)scancode;
+					keycnt++;
+				}
+			}
+		}
+	}
+
+	return keycnt;
+}
+
+static int mxc_kpp_reset(void)
+{
+	unsigned short reg_val;
+	int i;
+
+	/*
+	* Stop scanning and wait for interrupt.
+	* Enable press interrupt and disable release interrupt.
+	*/
+	__raw_writew(0x00FF, KPDR);
+	reg_val = __raw_readw(KPSR);
+	reg_val |= (KBD_STAT_KPKR | KBD_STAT_KPKD);
+	reg_val |= KBD_STAT_KRSS | KBD_STAT_KDSC;
+	__raw_writew(reg_val, KPSR);
+	reg_val |= KBD_STAT_KDIE;
+	reg_val &= ~KBD_STAT_KRIE;
+	__raw_writew(reg_val, KPSR);
+
+#ifdef KPP_DEBUG
+	mxc_kpp_dump_regs();
+#endif
+
+	/*
+	* No more keys pressed... make sure unwanted key codes are
+	* not given upstairs
+	*/
+	for (i = 0; i < kpp_dev.kpp_rows; i++) {
+		memset(press_scancode[i], -1,
+			sizeof(press_scancode[0][0]) * kpp_dev.kpp_cols);
+		memset(release_scancode[i], -1,
+			sizeof(release_scancode[0][0]) *
+			kpp_dev.kpp_cols);
+	}
+
+	return 0;
+}
+
+int mxc_kpp_getc(struct kpp_key_info **key_info)
+{
+	int col, row;
+	int key_cnt;
+	unsigned short reg_val;
+	short scancode = 0;
+	int index = 0;
+	struct kpp_key_info *keyi;
+
+	reg_val = __raw_readw(KPSR);
+
+	if (reg_val & KBD_STAT_KPKD) {
+		/*
+		* Disable key press(KDIE status bit) interrupt
+		*/
+		reg_val &= ~KBD_STAT_KDIE;
+		__raw_writew(reg_val, KPSR);
+
+#ifdef KPP_DEBUG
+		mxc_kpp_dump_regs();
+#endif
+
+		key_cnt = mxc_kpp_scan_matrix();
+	} else {
+		return 0;
+	}
+
+	if (key_cnt <= 0)
+		return 0;
+
+	*key_info = keyi =
+		(struct kpp_key_info *)malloc
+		(sizeof(struct kpp_key_info) * key_cnt);
+
+	/*
+	* This switch case statement is the
+	* implementation of state machine of debounc
+	* logic for key press/release.
+	* The explaination of state machine is as
+	* follows:
+	*
+	* KStateUp State:
+	* This is in intial state of the state machine
+	* this state it checks for any key presses.
+	* The key press can be checked using the
+	* variable KPress. If KPress is set, then key
+	* press is identified and switches the to
+	* KStateFirstDown state for key press to
+	* debounce.
+	*
+	* KStateFirstDown:
+	* After debounce delay(10ms), if the KPress is
+	* still set then pass scancode generated to
+	* input device and change the state to
+	* KStateDown, else key press debounce is not
+	* satisfied so change the state to KStateUp.
+	*
+	* KStateDown:
+	* In this state it checks for any key release.
+	* If KPress variable is cleared, then key
+	* release is indicated and so, switch the
+	* state to KStateFirstUp else to state
+	* KStateDown.
+	*
+	* KStateFirstUp:
+	* After debounce delay(10ms), if the KPress is
+	* still reset then pass the key release
+	* scancode to input device and change
+	* the state to KStateUp else key release is
+	* not satisfied so change the state to
+	* KStateDown.
+	*/
+
+	for (row = 0; row < kpp_dev.kpp_rows; row++) {
+		for (col = 0; col < kpp_dev.kpp_cols; col++) {
+			if ((press_scancode[row][col] != -1)) {
+				/* Still Down, so add scancode */
+				scancode =
+				    press_scancode[row][col];
+
+				keyi[index].val = mxckpd_keycodes[scancode];
+				keyi[index++].evt = KDepress;
+
+				KPP_PRINTF("KStateFirstDown: scan=%d val=%d\n",
+					scancode, mxckpd_keycodes[scancode]);
+				if (index >= key_cnt)
+					goto key_detect;
+
+				kpp_dev.iKeyState = KStateDown;
+				press_scancode[row][col] = -1;
+			}
+		}
+	}
+
+	for (row = 0; row < kpp_dev.kpp_rows; row++) {
+		for (col = 0; col < kpp_dev.kpp_cols; col++) {
+			if ((release_scancode[row][col] != -1)) {
+				scancode =
+				    release_scancode[row][col];
+				scancode =
+					scancode - MXC_KEYRELEASE;
+
+				keyi[index].val = mxckpd_keycodes[scancode];
+				keyi[index++].evt = KRelease;
+
+				KPP_PRINTF("KStateFirstUp: scan=%d val=%d\n",
+					scancode, mxckpd_keycodes[scancode]);
+				if (index >= key_cnt)
+					goto key_detect;
+
+				kpp_dev.iKeyState = KStateUp;
+				release_scancode[row][col] = -1;
+			}
+		}
+	}
+
+key_detect:
+	mxc_kpp_reset();
+	return key_cnt;
+}
+
+/*!
+ * This function is called to free the allocated memory for local arrays
+ */
+static void mxc_kpp_free_allocated(void)
+{
+	int i;
+
+	if (press_scancode) {
+		for (i = 0; i < kpp_dev.kpp_rows; i++) {
+			if (press_scancode[i])
+				free(press_scancode[i]);
+		}
+		free(press_scancode);
+	}
+
+	if (release_scancode) {
+		for (i = 0; i < kpp_dev.kpp_rows; i++) {
+			if (release_scancode[i])
+				free(release_scancode[i]);
+		}
+		free(release_scancode);
+	}
+
+	if (cur_rcmap)
+		free(cur_rcmap);
+
+	if (prev_rcmap)
+		free(prev_rcmap);
+}
+
+/*!
+ * This function is called during the driver binding process.
+ *
+ * @param   pdev  the device structure used to store device specific
+ *                information that is used by the suspend, resume and remove
+ *                functions.
+ *
+ * @return  The function returns 0 on successful registration. Otherwise returns
+ *          specific error code.
+ */
+int mxc_kpp_init(void)
+{
+	int i;
+	int retval;
+	unsigned int reg_val;
+
+	kpp_dev.kpp_cols = CONFIG_MXC_KPD_COLMAX;
+	kpp_dev.kpp_rows = CONFIG_MXC_KPD_ROWMAX;
+
+	/* clock and IOMUX configuration for keypad */
+	setup_mxc_kpd();
+
+	/* Configure keypad */
+
+	/* Enable number of rows in keypad (KPCR[7:0])
+	 * Configure keypad columns as open-drain (KPCR[15:8])
+	 *
+	 * Configure the rows/cols in KPP
+	 * LSB nibble in KPP is for 8 rows
+	 * MSB nibble in KPP is for 8 cols
+	 */
+	reg_val = __raw_readw(KPCR);
+	reg_val |= (1  << kpp_dev.kpp_rows) - 1;	/* LSB */
+	reg_val |= ((1 << kpp_dev.kpp_cols) - 1) << 8;	/* MSB */
+	__raw_writew(reg_val, KPCR);
+
+	/* Write 0's to KPDR[15:8] */
+	reg_val = __raw_readw(KPDR);
+	reg_val &= 0x00ff;
+	__raw_writew(reg_val, KPDR);
+
+	/* Configure columns as output,
+	 * rows as input (KDDR[15:0]) */
+	reg_val = __raw_readw(KDDR);
+	reg_val |= 0xff00;
+	reg_val &= 0xff00;
+	__raw_writew(reg_val, KDDR);
+
+	/* Clear the KPKD Status Flag
+	 * and Synchronizer chain. */
+	reg_val = __raw_readw(KPSR);
+	reg_val &= ~(KBD_STAT_KPKR | KBD_STAT_KPKD);
+	reg_val |= KBD_STAT_KPKD;
+	reg_val |= KBD_STAT_KRSS | KBD_STAT_KDSC;
+	__raw_writew(reg_val, KPSR);
+	/* Set the KDIE control bit, and clear the KRIE
+	 * control bit (avoid false release events). */
+	reg_val |= KBD_STAT_KDIE;
+	reg_val &= ~KBD_STAT_KRIE;
+	__raw_writew(reg_val, KPSR);
+
+#ifdef KPP_DEBUG
+	mxc_kpp_dump_regs();
+#endif
+
+	mxckpd_keycodes = mxc_key_mapping;
+	mxckpd_keycodes_size = kpp_dev.kpp_cols * kpp_dev.kpp_rows;
+
+	if ((mxckpd_keycodes == (void *)0)
+	    || (mxckpd_keycodes_size == 0)) {
+		retval = -ENODEV;
+		goto err;
+	}
+
+	/* allocate required memory */
+	press_scancode   = (short **)malloc(kpp_dev.kpp_rows * sizeof(press_scancode[0]));
+	release_scancode = (short **)malloc(kpp_dev.kpp_rows * sizeof(release_scancode[0]));
+
+	if (!press_scancode || !release_scancode) {
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0; i < kpp_dev.kpp_rows; i++) {
+		press_scancode[i] = (short *)malloc(kpp_dev.kpp_cols
+					    * sizeof(press_scancode[0][0]));
+		release_scancode[i] =
+		    (short *)malloc(kpp_dev.kpp_cols * sizeof(release_scancode[0][0]));
+
+		if (!press_scancode[i] || !release_scancode[i]) {
+			retval = -ENOMEM;
+			goto err;
+		}
+	}
+
+	cur_rcmap =
+	    (unsigned short *)malloc(kpp_dev.kpp_rows * sizeof(cur_rcmap[0]));
+	prev_rcmap =
+	    (unsigned short *)malloc(kpp_dev.kpp_rows * sizeof(prev_rcmap[0]));
+
+	if (!cur_rcmap || !prev_rcmap) {
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	for (i = 0; i < kpp_dev.kpp_rows; i++) {
+		memset(press_scancode[i], -1,
+		       sizeof(press_scancode[0][0]) * kpp_dev.kpp_cols);
+		memset(release_scancode[i], -1,
+		       sizeof(release_scancode[0][0]) * kpp_dev.kpp_cols);
+	}
+	memset(cur_rcmap, 0, kpp_dev.kpp_rows * sizeof(cur_rcmap[0]));
+	memset(prev_rcmap, 0, kpp_dev.kpp_rows * sizeof(prev_rcmap[0]));
+
+	return 0;
+
+err:
+	mxc_kpp_free_allocated();
+	return retval;
+}
diff --git a/drivers/mmc/fsl_esdhc.c b/drivers/mmc/fsl_esdhc.c
index 4c3b93d..5e04cde 100644
--- a/drivers/mmc/fsl_esdhc.c
+++ b/drivers/mmc/fsl_esdhc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007, 2010-2011 Freescale Semiconductor, Inc
+ * Copyright 2007, 2010-2014 Freescale Semiconductor, Inc.
  * Andy Fleming
  *
  * Based vaguely on the pxa mmc code:
@@ -23,6 +23,11 @@
 
 DECLARE_GLOBAL_DATA_PTR;
 
+#define SDHCI_IRQ_EN_BITS		(IRQSTATEN_CC | IRQSTATEN_TC | \
+				IRQSTATEN_CINT | \
+				IRQSTATEN_CTOE | IRQSTATEN_CCE | IRQSTATEN_CEBE | \
+				IRQSTATEN_CIE | IRQSTATEN_DTOE | IRQSTATEN_DCE | IRQSTATEN_DEBE)
+
 struct fsl_esdhc {
 	uint    dsaddr;		/* SDMA system address register */
 	uint    blkattr;	/* Block attributes register */
@@ -47,20 +52,30 @@ struct fsl_esdhc {
 	uint    fevt;		/* Force event register */
 	uint    admaes;		/* ADMA error status register */
 	uint    adsaddr;	/* ADMA system address register */
-	char    reserved2[160];	/* reserved */
+	char    reserved2[4];
+	uint    dllctrl;
+	uint    dllstat;
+	uint    clktunectrlstatus;
+	char    reserved3[84];
+	uint    vendorspec;
+	uint    mmcboot;
+	uint    vendorspec2;
+	char	reserved4[48];
 	uint    hostver;	/* Host controller version register */
-	char    reserved3[4];	/* reserved */
+#ifndef ARCH_MXC
+	char    reserved5[4];	/* reserved */
 	uint    dmaerraddr;	/* DMA error address register */
-	char    reserved4[4];	/* reserved */
+	char    reserved6[4];	/* reserved */
 	uint    dmaerrattr;	/* DMA error attribute register */
-	char    reserved5[4];	/* reserved */
+	char    reserved7[4];	/* reserved */
 	uint    hostcapblt2;	/* Host controller capabilities register 2 */
-	char    reserved6[8];	/* reserved */
+	char    reserved8[8];	/* reserved */
 	uint    tcr;		/* Tuning control register */
-	char    reserved7[28];	/* reserved */
+	char    reserved9[28];	/* reserved */
 	uint    sddirctl;	/* SD direction control register */
-	char    reserved8[712];	/* reserved */
+	char    reserved10[712];/* reserved */
 	uint    scr;		/* eSDHC control register */
+#endif
 };
 
 /* Return the XFERTYP flags for a given command and data packet */
@@ -174,7 +189,7 @@ static int esdhc_setup_data(struct mmc *mmc, struct mmc_data *data)
 	int timeout;
 	struct fsl_esdhc_cfg *cfg = mmc->priv;
 	struct fsl_esdhc *regs = (struct fsl_esdhc *)cfg->esdhc_base;
-#ifndef CONFIG_SYS_FSL_ESDHC_USE_PIO
+
 	uint wml_value;
 
 	wml_value = data->blocksize/4;
@@ -184,12 +199,15 @@ static int esdhc_setup_data(struct mmc *mmc, struct mmc_data *data)
 			wml_value = WML_RD_WML_MAX_VAL;
 
 		esdhc_clrsetbits32(&regs->wml, WML_RD_WML_MASK, wml_value);
+#ifndef CONFIG_SYS_FSL_ESDHC_USE_PIO
 		esdhc_write32(&regs->dsaddr, (u32)data->dest);
+#endif
 	} else {
+#ifndef CONFIG_SYS_FSL_ESDHC_USE_PIO
 		flush_dcache_range((ulong)data->src,
 				   (ulong)data->src+data->blocks
 					 *data->blocksize);
-
+#endif
 		if (wml_value > WML_WR_WML_MAX)
 			wml_value = WML_WR_WML_MAX_VAL;
 		if ((esdhc_read32(&regs->prsstat) & PRSSTAT_WPSPL) == 0) {
@@ -199,19 +217,10 @@ static int esdhc_setup_data(struct mmc *mmc, struct mmc_data *data)
 
 		esdhc_clrsetbits32(&regs->wml, WML_WR_WML_MASK,
 					wml_value << 16);
+#ifndef CONFIG_SYS_FSL_ESDHC_USE_PIO
 		esdhc_write32(&regs->dsaddr, (u32)data->src);
+#endif
 	}
-#else	/* CONFIG_SYS_FSL_ESDHC_USE_PIO */
-	if (!(data->flags & MMC_DATA_READ)) {
-		if ((esdhc_read32(&regs->prsstat) & PRSSTAT_WPSPL) == 0) {
-			printf("\nThe SD card is locked. "
-				"Can not write to a locked card.\n\n");
-			return TIMEOUT;
-		}
-		esdhc_write32(&regs->dsaddr, (u32)data->src);
-	} else
-		esdhc_write32(&regs->dsaddr, (u32)data->dest);
-#endif	/* CONFIG_SYS_FSL_ESDHC_USE_PIO */
 
 	esdhc_write32(&regs->blkattr, data->blocks << 16 | data->blocksize);
 
@@ -388,9 +397,10 @@ esdhc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
 				goto out;
 			}
 		} while ((irqstat & DATA_COMPLETE) != DATA_COMPLETE);
-#endif
+
 		if (data->flags & MMC_DATA_READ)
 			check_and_invalidate_dcache_range(cmd, data);
+#endif
 	}
 
 out:
@@ -484,6 +494,17 @@ static int esdhc_init(struct mmc *mmc)
 	while ((esdhc_read32(&regs->sysctl) & SYSCTL_RSTA) && --timeout)
 		udelay(1000);
 
+#if defined(CONFIG_FSL_USDHC)
+	/* RSTA doesn't reset MMC_BOOT register, so manually reset it */
+	esdhc_write32(&regs->mmcboot, 0x0);
+	/* Reset MIX_CTRL and CLK_TUNE_CTRL_STATUS regs to 0 */
+	esdhc_write32(&regs->mixctrl, 0x0);
+	esdhc_write32(&regs->clktunectrlstatus, 0x0);
+
+	/* Put VEND_SPEC to default value */
+	esdhc_write32(&regs->vendorspec, VENDORSPEC_INIT);
+#endif
+
 #ifndef ARCH_MXC
 	/* Enable cache snooping */
 	esdhc_write32(&regs->scr, 0x00000040);
@@ -494,8 +515,15 @@ static int esdhc_init(struct mmc *mmc)
 	/* Set the initial clock speed */
 	mmc_set_clock(mmc, 400000);
 
+#ifdef CONFIG_SYS_FSL_ESDHC_USE_PIO
+	/* Enable the BRR and BWR bits in IRQSTAT */
+	esdhc_clrbits32(&regs->irqstaten, IRQSTATEN_DINT);
+	esdhc_setbits32(&regs->irqstaten, IRQSTATEN_BRR | IRQSTATEN_BWR);
+#else
 	/* Disable the BRR and BWR bits in IRQSTAT */
 	esdhc_clrbits32(&regs->irqstaten, IRQSTATEN_BRR | IRQSTATEN_BWR);
+	esdhc_setbits32(&regs->irqstaten, IRQSTATEN_DINT);
+#endif
 
 	/* Put the PROCTL reg back to the default */
 	esdhc_write32(&regs->proctl, PROCTL_INIT);
@@ -560,6 +588,7 @@ int fsl_esdhc_initialize(bd_t *bis, struct fsl_esdhc_cfg *cfg)
 	esdhc_setbits32(&regs->sysctl, SYSCTL_PEREN | SYSCTL_HCKEN
 				| SYSCTL_IPGEN | SYSCTL_CKEN);
 
+	writel(SDHCI_IRQ_EN_BITS, &regs->irqstaten);
 	memset(&cfg->cfg, 0, sizeof(cfg->cfg));
 
 	voltage_caps = 0;
diff --git a/drivers/mtd/nand/mxs_nand.c b/drivers/mtd/nand/mxs_nand.c
index 036c113..9479e11 100644
--- a/drivers/mtd/nand/mxs_nand.c
+++ b/drivers/mtd/nand/mxs_nand.c
@@ -7,7 +7,7 @@
  * Based on code from LTIB:
  * Freescale GPMI NFC NAND Flash Driver
  *
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
  * Copyright (C) 2008 Embedded Alley Solutions, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
@@ -146,21 +146,14 @@ static uint32_t mxs_nand_aux_status_offset(void)
 static inline uint32_t mxs_nand_get_ecc_strength(uint32_t page_data_size,
 						uint32_t page_oob_size)
 {
-	if (page_data_size == 2048)
-		return 8;
+	int ecc_strength;
 
-	if (page_data_size == 4096) {
-		if (page_oob_size == 128)
-			return 8;
+	ecc_strength = ((page_oob_size - MXS_NAND_METADATA_SIZE) * 8)
+			/ (13 * mxs_nand_ecc_chunk_cnt(page_data_size));
 
-		if (page_oob_size == 218)
-			return 16;
-
-		if (page_oob_size == 224)
-			return 16;
-	}
-
-	return 0;
+	/* We need the minor even number. */
+	ecc_strength -= ecc_strength & 1;
+	return ecc_strength;
 }
 
 static inline uint32_t mxs_nand_get_mark_offset(uint32_t page_data_size,
@@ -972,6 +965,12 @@ static int mxs_nand_scan_bbt(struct mtd_info *mtd)
 	struct mxs_bch_regs *bch_regs = (struct mxs_bch_regs *)MXS_BCH_BASE;
 	uint32_t tmp;
 
+	if (mtd->oobsize > MXS_NAND_CHUNK_DATA_CHUNK_SIZE) {
+		printf("we do not support the NAND whose OOB size is"
+			"larger then 512 bytes!\n");
+		return -EINVAL;
+	}
+
 	/* Configure BCH and set NFC geometry */
 	mxs_reset_block(&bch_regs->hw_bch_ctrl_reg);
 
diff --git a/drivers/mtd/spi/sf_internal.h b/drivers/mtd/spi/sf_internal.h
index 6bcd522..9b6aaff 100644
--- a/drivers/mtd/spi/sf_internal.h
+++ b/drivers/mtd/spi/sf_internal.h
@@ -75,6 +75,15 @@ int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
 		const void *buf);
 #endif
 
+/* Micron specific */
+#ifdef CONFIG_SPI_FLASH_STMICRO
+# define CMD_READ_NVCR		0xb5
+# define CMD_WRITE_NVCR		0xb1
+
+int stmicro_read_nvcr(struct spi_flash *flash, u8 *rch, u8 *rcl);
+int stmicro_write_nvcr(struct spi_flash *flash, u8 wch, u8 wcl);
+#endif
+
 /* Send a single-byte command to the device and read the response */
 int spi_flash_cmd(struct spi_slave *spi, u8 cmd, void *response, size_t len);
 
diff --git a/drivers/mtd/spi/sf_ops.c b/drivers/mtd/spi/sf_ops.c
index ef91b92..a437cd1 100644
--- a/drivers/mtd/spi/sf_ops.c
+++ b/drivers/mtd/spi/sf_ops.c
@@ -516,3 +516,43 @@ int sst_write_wp(struct spi_flash *flash, u32 offset, size_t len,
 	return ret;
 }
 #endif
+
+#ifdef CONFIG_SPI_FLASH_STMICRO
+int stmicro_read_nvcr(struct spi_flash *flash, u8 *rcl, u8 *rch)
+{
+	u8 data[2];
+	u8 cmd;
+	int ret;
+
+	cmd = CMD_READ_NVCR;
+	ret = spi_flash_read_common(flash, &cmd, 1, data, 2);
+	if (ret < 0) {
+		debug("SF: fail to read nonvolatile configuration register\n");
+		return ret;
+	}
+	
+	*rcl = data[1];
+	*rch = data[0];
+
+	return 0;
+}
+
+int stmicro_write_nvcr(struct spi_flash *flash, u8 wcl, u8 wch)
+{
+	u8 data[2];
+	u8 cmd;
+	int ret;
+	
+	data[0] = wch;
+	data[1] = wcl;
+
+	cmd = CMD_WRITE_NVCR;
+	ret = spi_flash_write_common(flash, &cmd, 1, data, 2);
+	if (ret) {
+		debug("SF: fail to write nonvolatile configuration register\n");
+		return ret;
+	}
+
+	return 0;
+}
+#endif
diff --git a/drivers/mtd/spi/sf_probe.c b/drivers/mtd/spi/sf_probe.c
index 0a46fe3..31c549c 100644
--- a/drivers/mtd/spi/sf_probe.c
+++ b/drivers/mtd/spi/sf_probe.c
@@ -197,16 +197,6 @@ static struct spi_flash *spi_flash_validate_params(struct spi_slave *spi,
 		/* Go for default supported write cmd */
 		flash->write_cmd = CMD_PAGE_PROGRAM;
 
-	/* Set the quad enable bit - only for quad commands */
-	if ((flash->read_cmd == CMD_READ_QUAD_OUTPUT_FAST) ||
-	    (flash->read_cmd == CMD_READ_QUAD_IO_FAST) ||
-	    (flash->write_cmd == CMD_QUAD_PAGE_PROGRAM)) {
-		if (spi_flash_set_qeb(flash, idcode[0])) {
-			debug("SF: Fail to set QEB for %02x\n", idcode[0]);
-			return NULL;
-		}
-	}
-
 	/* Read dummy_byte: dummy byte is determined based on the
 	 * dummy cycles of a particular command.
 	 * Fast commands - dummy_byte = dummy_cycles/8
@@ -260,6 +250,20 @@ static struct spi_flash *spi_flash_validate_params(struct spi_slave *spi,
 		spi_flash_cmd_write_status(flash, 0);
 #endif
 
+	/* Disable the HOLD pin if it's a Micron flash. */
+#if defined(CONFIG_SPI_FLASH_STMICRO) && \
+	defined(CONFIG_SPI_FLASH_DISABLE_HOLD)
+	if(idcode[0] == SPI_FLASH_CFI_MFR_STMICRO) {
+		u8 nvcr[2];
+		stmicro_read_nvcr(flash, &nvcr[1], &nvcr[0]);
+		if(nvcr[0] & (1<<4)) {
+			printf("Disabling SPI NOR HOLD pin\n");
+			nvcr[0] &= ~(1<<4);
+			stmicro_write_nvcr(flash, nvcr[1], nvcr[0]);
+		}
+	}
+#endif
+
 	return flash;
 }
 
@@ -327,6 +331,16 @@ static struct spi_flash *spi_flash_probe_slave(struct spi_slave *spi)
 	if (!flash)
 		goto err_read_id;
 
+	/* Set the quad enable bit - only for quad commands */
+	if ((flash->read_cmd == CMD_READ_QUAD_OUTPUT_FAST) ||
+	    (flash->read_cmd == CMD_READ_QUAD_IO_FAST) ||
+	    (flash->write_cmd == CMD_QUAD_PAGE_PROGRAM)) {
+		if (spi_flash_set_qeb(flash, idcode[0])) {
+			debug("SF: Fail to set QEB for %02x\n", idcode[0]);
+			return NULL;
+		}
+	}
+
 #ifdef CONFIG_OF_CONTROL
 	if (spi_flash_decode_fdt(gd->fdt_blob, flash)) {
 		debug("SF: FDT decode error\n");
diff --git a/drivers/net/fec_mxc.c b/drivers/net/fec_mxc.c
index 4cefda4..c3c07ed 100644
--- a/drivers/net/fec_mxc.c
+++ b/drivers/net/fec_mxc.c
@@ -286,7 +286,11 @@ static void fec_rbd_init(struct fec_priv *fec, int count, int dsize)
 	 * Reload the RX descriptors with default values and wipe
 	 * the RX buffers.
 	 */
+#if defined(CONFIG_FEC_DMA_MINALIGN)
+	size = roundup(dsize, CONFIG_FEC_DMA_MINALIGN);
+#else
 	size = roundup(dsize, ARCH_DMA_MINALIGN);
+#endif
 	for (i = 0; i < count; i++) {
 		data = (uint8_t *)fec->rbd_base[i].data_pointer;
 		memset(data, 0, dsize);
@@ -707,17 +711,14 @@ static int fec_send(struct eth_device *dev, void *packet, int length)
 	 * barrier here.
 	 */
 	while (--timeout) {
-		if (!(readl(&fec->eth->x_des_active) & FEC_X_DES_ACTIVE_TDAR))
+		invalidate_dcache_range(addr, addr + size);
+		if (!(readw(&fec->tbd_base[fec->tbd_index].status) & FEC_TBD_READY))
 			break;
 	}
 
 	if (!timeout)
 		ret = -EINVAL;
 
-	invalidate_dcache_range(addr, addr + size);
-	if (readw(&fec->tbd_base[fec->tbd_index].status) & FEC_TBD_READY)
-		ret = -EINVAL;
-
 	debug("fec_send: status 0x%x index %d ret %i\n",
 			readw(&fec->tbd_base[fec->tbd_index].status),
 			fec->tbd_index, ret);
@@ -881,9 +882,17 @@ static int fec_alloc_descs(struct fec_priv *fec)
 	/* Allocate RX buffers. */
 
 	/* Maximum RX buffer size. */
+#if defined(CONFIG_FEC_DMA_MINALIGN)
+	size = roundup(FEC_MAX_PKT_SIZE, CONFIG_FEC_DMA_MINALIGN);
+#else
 	size = roundup(FEC_MAX_PKT_SIZE, ARCH_DMA_MINALIGN);
+#endif
 	for (i = 0; i < FEC_RBD_NUM; i++) {
+#if defined(CONFIG_FEC_DMA_MINALIGN)
+		data = memalign(CONFIG_FEC_DMA_MINALIGN, size);
+#else
 		data = memalign(ARCH_DMA_MINALIGN, size);
+#endif
 		if (!data) {
 			printf("%s: error allocating rxbuf %d\n", __func__, i);
 			goto err_ring;
diff --git a/drivers/pci/pcie_imx.c b/drivers/pci/pcie_imx.c
index c48737e..9d6d0df 100644
--- a/drivers/pci/pcie_imx.c
+++ b/drivers/pci/pcie_imx.c
@@ -23,13 +23,20 @@
 #define PCI_ACCESS_READ  0
 #define PCI_ACCESS_WRITE 1
 
+#ifdef CONFIG_MX6SX
+#define MX6_DBI_ADDR	0x08ffc000
+#define MX6_IO_ADDR	0x08000000
+#define MX6_MEM_ADDR	0x08100000
+#define MX6_ROOT_ADDR	0x08f00000
+#else
 #define MX6_DBI_ADDR	0x01ffc000
-#define MX6_DBI_SIZE	0x4000
 #define MX6_IO_ADDR	0x01000000
-#define MX6_IO_SIZE	0x100000
 #define MX6_MEM_ADDR	0x01100000
-#define MX6_MEM_SIZE	0xe00000
 #define MX6_ROOT_ADDR	0x01f00000
+#endif
+#define MX6_DBI_SIZE	0x4000
+#define MX6_IO_SIZE	0x100000
+#define MX6_MEM_SIZE	0xe00000
 #define MX6_ROOT_SIZE	0xfc000
 
 /* PCIe Port Logic registers (memory-mapped) */
@@ -80,6 +87,47 @@
 #define PCIE_ATU_FUNC(x)		(((x) & 0x7) << 16)
 #define PCIE_ATU_UPPER_TARGET		0x91C
 
+#ifdef DEBUG
+
+#ifdef DEBUG_STRESS_WR /* warm-reset stress tests */
+#define SNVS_LPGRP 0x020cc068
+#endif
+
+#define DBGF(x...) printf(x)
+
+static void print_regs(int contain_pcie_reg)
+{
+	u32 val;
+#ifndef CONFIG_MX6SX
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+#else
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_GPR_BASE_ADDR;
+#endif
+	struct mxc_ccm_reg *ccm_regs = (struct mxc_ccm_reg *)CCM_BASE_ADDR;
+	val = readl(&iomuxc_regs->gpr[1]);
+	DBGF("GPR01 a:0x%08x v:0x%08x\n", (u32)&iomuxc_regs->gpr[1], val);
+	val = readl(&iomuxc_regs->gpr[5]);
+	DBGF("GPR05 a:0x%08x v:0x%08x\n", (u32)&iomuxc_regs->gpr[5], val);
+	val = readl(&iomuxc_regs->gpr[8]);
+	DBGF("GPR08 a:0x%08x v:0x%08x\n", (u32)&iomuxc_regs->gpr[8], val);
+	val = readl(&iomuxc_regs->gpr[12]);
+	DBGF("GPR12 a:0x%08x v:0x%08x\n", (u32)&iomuxc_regs->gpr[12], val);
+	val = readl(&ccm_regs->analog_pll_enet);
+	DBGF("PLL06 a:0x%08x v:0x%08x\n", (u32)&ccm_regs->analog_pll_enet, val);
+	val = readl(&ccm_regs->ana_misc1);
+	DBGF("MISC1 a:0x%08x v:0x%08x\n", (u32)&ccm_regs->ana_misc1, val);
+	if (contain_pcie_reg) {
+		val = readl(MX6_DBI_ADDR + 0x728);
+		DBGF("dbr0 offset 0x728 %08x\n", val);
+		val = readl(MX6_DBI_ADDR + 0x72c);
+		DBGF("dbr1 offset 0x72c %08x\n", val);
+	}
+}
+#else
+#define DBGF(x...)
+static void print_regs(int contain_pcie_reg) {}
+#endif
+
 /*
  * PHY access functions
  */
@@ -420,26 +468,54 @@ static int imx_pcie_write_config(struct pci_controller *hose, pci_dev_t d,
  */
 static int imx6_pcie_assert_core_reset(void)
 {
+#ifndef CONFIG_MX6SX
 	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+#else
+	u32 val;
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_GPR_BASE_ADDR;
+#endif
 
+#if defined(CONFIG_MX6SX)
+	/* SSP_EN is not used on iMX6SX anymore */
+	setbits_le32(&iomuxc_regs->gpr[12], IOMUXC_GPR12_TEST_POWERDOWN);
+	/* Force PCIe PHY reset */
+	setbits_le32(&iomuxc_regs->gpr[5], IOMUXC_GPR5_PCIE_BTNRST);
+
+	/* Power up PCIe PHY, ANATOP_REG_CORE offset 0x140, bit13-9 */
+	val = readl(GPC_BASE_ADDR + 0);
+	val |= (0x1 << 7);
+	writel(val, GPC_BASE_ADDR + 0);
+	pcie_power_up();
+#else
 	setbits_le32(&iomuxc_regs->gpr[1], IOMUXC_GPR1_TEST_POWERDOWN);
 	clrbits_le32(&iomuxc_regs->gpr[1], IOMUXC_GPR1_REF_SSP_EN);
+#endif
 
 	return 0;
 }
 
 static int imx6_pcie_init_phy(void)
 {
+#ifndef CONFIG_MX6SX
 	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+#else
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_GPR_BASE_ADDR;
+#endif
 
+#ifndef DEBUG
 	clrbits_le32(&iomuxc_regs->gpr[12], IOMUXC_GPR12_APPS_LTSSM_ENABLE);
+#endif
 
 	clrsetbits_le32(&iomuxc_regs->gpr[12],
-			IOMUXC_GPR12_DEVICE_TYPE_MASK,
-			IOMUXC_GPR12_DEVICE_TYPE_RC);
+			IOMUXC_GPR12_DEVICE_TYPE_MASK, 4 << 12);
 	clrsetbits_le32(&iomuxc_regs->gpr[12],
 			IOMUXC_GPR12_LOS_LEVEL_MASK,
 			IOMUXC_GPR12_LOS_LEVEL_9);
+#ifdef CONFIG_MX6SX
+	clrsetbits_le32(&iomuxc_regs->gpr[12],
+			IOMUXC_GPR12_RX_EQ_MASK,
+			IOMUXC_GPR12_RX_EQ_2);
+#endif
 
 	writel((0x0 << IOMUXC_GPR8_PCS_TX_DEEMPH_GEN1_OFFSET) |
 	       (0x0 << IOMUXC_GPR8_PCS_TX_DEEMPH_GEN2_3P5DB_OFFSET) |
@@ -505,21 +581,38 @@ __weak int imx6_pcie_toggle_reset(void)
 
 static int imx6_pcie_deassert_core_reset(void)
 {
+#ifndef CONFIG_MX6SX
 	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+#else
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_GPR_BASE_ADDR;
+#endif
 
 	imx6_pcie_toggle_power();
 
+	enable_pcie_clock();
+
 	/* Enable PCIe */
+#if defined(CONFIG_MX6SX)
+	/* SSP_EN is not used on iMX6SX anymore */
+	clrbits_le32(&iomuxc_regs->gpr[12], IOMUXC_GPR12_TEST_POWERDOWN);
+	/*
+	 * iMX6SX PCIe has the stand-alone power domain.
+	 * refer to the initialization for iMX6SX PCIe,
+	 * release the PCIe PHY reset here,
+	 * before LTSSM enable is set
+	 * .
+	 */
+	clrbits_le32(&iomuxc_regs->gpr[5], IOMUXC_GPR5_PCIE_BTNRST);
+#else
 	clrbits_le32(&iomuxc_regs->gpr[1], IOMUXC_GPR1_TEST_POWERDOWN);
 	setbits_le32(&iomuxc_regs->gpr[1], IOMUXC_GPR1_REF_SSP_EN);
 
-	enable_pcie_clock();
-
 	/*
 	 * Wait for the clock to settle a bit, when the clock are sourced
 	 * from the CPU, we need about 30mS to settle.
 	 */
 	mdelay(50);
+#endif
 
 	imx6_pcie_toggle_reset();
 
@@ -528,7 +621,11 @@ static int imx6_pcie_deassert_core_reset(void)
 
 static int imx_pcie_link_up(void)
 {
+#ifndef CONFIG_MX6SX
 	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_BASE_ADDR;
+#else
+	struct iomuxc *iomuxc_regs = (struct iomuxc *)IOMUXC_GPR_BASE_ADDR;
+#endif
 	uint32_t tmp;
 	int count = 0;
 
@@ -555,9 +652,25 @@ static int imx_pcie_link_up(void)
 	while (!imx6_pcie_link_up()) {
 		udelay(10);
 		count++;
+		if (count == 1000) {
+			print_regs(1);
+			/* link down, try reset ep, and re-try link here */
+			DBGF("pcie link is down, reset ep, then retry!\n");
+			imx6_pcie_toggle_reset();
+			continue;
+		}
+#ifdef DEBUG
+		else if (count >= 2000) {
+			print_regs(1);
+			/* link is down, stop here */
+			setenv("bootcmd", "sleep 2;");
+			DBGF("pcie link is down, stop here!\n");
+			return -EINVAL;
+		}
+#endif
 		if (count >= 2000) {
-			debug("phy link never came up\n");
-			debug("DEBUG_R0: 0x%08x, DEBUG_R1: 0x%08x\n",
+			printf("phy link never came up\n");
+			printf("DEBUG_R0: 0x%08x, DEBUG_R1: 0x%08x\n",
 			      readl(MX6_DBI_ADDR + PCIE_PHY_DEBUG_R0),
 			      readl(MX6_DBI_ADDR + PCIE_PHY_DEBUG_R1));
 			return -EINVAL;
@@ -573,6 +686,10 @@ void imx_pcie_init(void)
 	static struct pci_controller	pcc;
 	struct pci_controller		*hose = &pcc;
 	int ret;
+#ifdef DEBUG_STRESS_WR
+	u32 dbg_reg_addr = SNVS_LPGRP;
+	u32 dbg_reg = readl(dbg_reg_addr) + 1;
+#endif
 
 	memset(&pcc, 0, sizeof(pcc));
 
@@ -607,7 +724,15 @@ void imx_pcie_init(void)
 	if (!ret) {
 		pci_register_hose(hose);
 		hose->last_busno = pci_hose_scan(hose);
+#ifdef DEBUG_STRESS_WR
+		dbg_reg += 1<<16;
+#endif
 	}
+#ifdef DEBUG_STRESS_WR
+	writel(dbg_reg, dbg_reg_addr);
+	DBGF("PCIe Successes/Attempts: %d/%d\n",
+			dbg_reg >> 16, dbg_reg & 0xffff);
+#endif
 }
 
 /* Probe function. */
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 81b6af6..d7c6ecc 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -40,3 +40,4 @@ obj-$(CONFIG_TEGRA114_SPI) += tegra114_spi.o
 obj-$(CONFIG_TI_QSPI) += ti_qspi.o
 obj-$(CONFIG_XILINX_SPI) += xilinx_spi.o
 obj-$(CONFIG_ZYNQ_SPI) += zynq_spi.o
+obj-$(CONFIG_QSPI) += fsl_qspi.o
\ No newline at end of file
diff --git a/drivers/spi/fsl_qspi.c b/drivers/spi/fsl_qspi.c
new file mode 100644
index 0000000..8439dbd
--- /dev/null
+++ b/drivers/spi/fsl_qspi.c
@@ -0,0 +1,863 @@
+/*
+ * Freescale QuadSPI driver.
+ *
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <common.h>
+#include <malloc.h>
+#include <spi.h>
+
+#include <asm/io.h>
+
+#define QUADSPI_AHBMAP_BANK_MAXSIZE SZ_64M
+
+/* The registers */
+#define QUADSPI_MCR			0x00
+#define QUADSPI_MCR_RESERVED_SHIFT	16
+#define QUADSPI_MCR_RESERVED_MASK	(0xF << QUADSPI_MCR_RESERVED_SHIFT)
+#define QUADSPI_MCR_MDIS_SHIFT		14
+#define QUADSPI_MCR_MDIS_MASK		(1 << QUADSPI_MCR_MDIS_SHIFT)
+#define QUADSPI_MCR_CLR_TXF_SHIFT	11
+#define QUADSPI_MCR_CLR_TXF_MASK	(1 << QUADSPI_MCR_CLR_TXF_SHIFT)
+#define QUADSPI_MCR_CLR_RXF_SHIFT	10
+#define QUADSPI_MCR_CLR_RXF_MASK	(1 << QUADSPI_MCR_CLR_RXF_SHIFT)
+#define QUADSPI_MCR_DDR_EN_SHIFT	7
+#define QUADSPI_MCR_DDR_EN_MASK		(1 << QUADSPI_MCR_DDR_EN_SHIFT)
+#define QUADSPI_MCR_END_CFG_SHIFT   2
+#define QUADSPI_MCR_END_CFG_MASK    (3 << QUADSPI_MCR_END_CFG_SHIFT)
+#define QUADSPI_MCR_SWRSTHD_SHIFT	1
+#define QUADSPI_MCR_SWRSTHD_MASK	(1 << QUADSPI_MCR_SWRSTHD_SHIFT)
+#define QUADSPI_MCR_SWRSTSD_SHIFT	0
+#define QUADSPI_MCR_SWRSTSD_MASK	(1 << QUADSPI_MCR_SWRSTSD_SHIFT)
+
+#define QUADSPI_IPCR			0x08
+#define QUADSPI_IPCR_SEQID_SHIFT	24
+#define QUADSPI_IPCR_SEQID_MASK		(0xF << QUADSPI_IPCR_SEQID_SHIFT)
+
+#define QUADSPI_BUF0CR			0x10
+#define QUADSPI_BUF1CR			0x14
+#define QUADSPI_BUF2CR			0x18
+#define QUADSPI_BUFXCR_INVALID_MSTRID	0xe
+
+#define QUADSPI_BUF3CR			0x1c
+#define QUADSPI_BUF3CR_ALLMST_SHIFT	31
+#define QUADSPI_BUF3CR_ALLMST_MASK  (1 << QUADSPI_BUF3CR_ALLMST_SHIFT)
+#define QUADSPI_BUF3CR_ADATSZ_SHIFT	8
+#define QUADSPI_BUF3CR_ADATSZ_MASK	(0xFF << QUADSPI_BUF3CR_ADATSZ_SHIFT)
+
+#define QUADSPI_BFGENCR			0x20
+#define QUADSPI_BFGENCR_PAR_EN_SHIFT	16
+#define QUADSPI_BFGENCR_PAR_EN_MASK	(1 << (QUADSPI_BFGENCR_PAR_EN_SHIFT))
+#define QUADSPI_BFGENCR_SEQID_SHIFT	12
+#define QUADSPI_BFGENCR_SEQID_MASK	(0xF << QUADSPI_BFGENCR_SEQID_SHIFT)
+
+#define QUADSPI_BUF0IND			0x30
+#define QUADSPI_BUF1IND			0x34
+#define QUADSPI_BUF2IND			0x38
+#define QUADSPI_SFAR			0x100
+
+#define QUADSPI_SMPR			0x108
+#define QUADSPI_SMPR_DDRSMP_SHIFT	16
+#define QUADSPI_SMPR_DDRSMP_MASK	(7 << QUADSPI_SMPR_DDRSMP_SHIFT)
+#define QUADSPI_SMPR_FSDLY_SHIFT	6
+#define QUADSPI_SMPR_FSDLY_MASK		(1 << QUADSPI_SMPR_FSDLY_SHIFT)
+#define QUADSPI_SMPR_FSPHS_SHIFT	5
+#define QUADSPI_SMPR_FSPHS_MASK		(1 << QUADSPI_SMPR_FSPHS_SHIFT)
+#define QUADSPI_SMPR_HSENA_SHIFT	0
+#define QUADSPI_SMPR_HSENA_MASK		(1 << QUADSPI_SMPR_HSENA_SHIFT)
+
+#define QUADSPI_RBSR			0x10c
+#define QUADSPI_RBSR_RDBFL_SHIFT	8
+#define QUADSPI_RBSR_RDBFL_MASK		(0x3F << QUADSPI_RBSR_RDBFL_SHIFT)
+
+#define QUADSPI_RBCT			0x110
+#define QUADSPI_RBCT_WMRK_MASK		0x1F
+#define QUADSPI_RBCT_RXBRD_SHIFT	8
+#define QUADSPI_RBCT_RXBRD_USEIPS	(0x1 << QUADSPI_RBCT_RXBRD_SHIFT)
+
+#define QUADSPI_TBSR			0x150
+#define QUADSPI_TBDR			0x154
+#define QUADSPI_SR			0x15c
+#define QUADSPI_SR_IP_ACC_SHIFT     1
+#define QUADSPI_SR_IP_ACC_MASK      (0x1 << QUADSPI_SR_IP_ACC_SHIFT)
+#define QUADSPI_SR_AHB_ACC_SHIFT    2
+#define QUADSPI_SR_AHB_ACC_MASK     (0x1 << QUADSPI_SR_AHB_ACC_SHIFT)
+
+
+#define QUADSPI_FR			0x160
+#define QUADSPI_FR_TFF_MASK		0x1
+
+#define QUADSPI_SFA1AD			0x180
+#define QUADSPI_SFA2AD			0x184
+#define QUADSPI_SFB1AD			0x188
+#define QUADSPI_SFB2AD			0x18c
+#define QUADSPI_RBDR			0x200
+
+#define QUADSPI_LUTKEY			0x300
+#define QUADSPI_LUTKEY_VALUE		0x5AF05AF0
+
+#define QUADSPI_LCKCR			0x304
+#define QUADSPI_LCKER_LOCK		0x1
+#define QUADSPI_LCKER_UNLOCK		0x2
+
+#define QUADSPI_RSER			0x164
+#define QUADSPI_RSER_TFIE		(0x1 << 0)
+
+#define QUADSPI_LUT_BASE		0x310
+
+/*
+ * The definition of the LUT register shows below:
+ *
+ *  ---------------------------------------------------
+ *  | INSTR1 | PAD1 | OPRND1 | INSTR0 | PAD0 | OPRND0 |
+ *  ---------------------------------------------------
+ */
+#define OPRND0_SHIFT		0
+#define PAD0_SHIFT		8
+#define INSTR0_SHIFT		10
+#define OPRND1_SHIFT		16
+
+/* Instruction set for the LUT register. */
+#define LUT_STOP		0
+#define LUT_CMD			1
+#define LUT_ADDR		2
+#define LUT_DUMMY		3
+#define LUT_MODE		4
+#define LUT_MODE2		5
+#define LUT_MODE4		6
+#define LUT_READ		7
+#define LUT_WRITE		8
+#define LUT_JMP_ON_CS		9
+#define LUT_ADDR_DDR		10
+#define LUT_MODE_DDR		11
+#define LUT_MODE2_DDR		12
+#define LUT_MODE4_DDR		13
+#define LUT_READ_DDR		14
+#define LUT_WRITE_DDR		15
+#define LUT_DATA_LEARN		16
+
+/*
+ * The PAD definitions for LUT register.
+ *
+ * The pad stands for the lines number of IO[0:3].
+ * For example, the Quad read need four IO lines, so you should
+ * set LUT_PAD4 which means we use four IO lines.
+ */
+#define LUT_PAD1		0
+#define LUT_PAD2		1
+#define LUT_PAD4		2
+
+/* Oprands for the LUT register. */
+#define ADDR24BIT		0x18
+#define ADDR32BIT		0x20
+
+/* Macros for constructing the LUT register. */
+#define LUT0(ins, pad, opr)						\
+		(((opr) << OPRND0_SHIFT) | ((LUT_##pad) << PAD0_SHIFT) | \
+		((LUT_##ins) << INSTR0_SHIFT))
+
+#define LUT1(ins, pad, opr)	(LUT0(ins, pad, opr) << OPRND1_SHIFT)
+
+/* other macros for LUT register. */
+#define QUADSPI_LUT(x)          (QUADSPI_LUT_BASE + (x) * 4)
+#define QUADSPI_LUT_NUM		64
+
+/* SEQID -- we can have 16 seqids at most. */
+#define SEQID_QUAD_READ		0
+#define SEQID_WREN		1
+#define SEQID_FAST_READ		2
+#define SEQID_RDSR		3
+#define SEQID_SE		4
+#define SEQID_CHIP_ERASE	5
+#define SEQID_PP		6
+#define SEQID_RDID		7
+#define SEQID_WRSR		8
+#define SEQID_RDCR		9
+#define SEQID_DDR_QUAD_READ	10
+#define SEQID_BE_4K		11
+#ifdef CONFIG_SPI_FLASH_BAR
+#define SEQID_BRRD		12
+#define SEQID_BRWR		13
+#define SEQID_RDEAR		14
+#define SEQID_WREAR		15
+#endif
+
+/* Flash opcodes. */
+#define	OPCODE_WREN		0x06	/* Write enable */
+#define	OPCODE_RDSR		0x05	/* Read status register */
+#define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define	OPCODE_QUAD_READ        0x6b    /* Read data bytes */
+#define	OPCODE_DDR_QUAD_READ	0x6d    /* Read data bytes in DDR mode*/
+#define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
+#define	OPCODE_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips */
+#define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define	OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+#define	OPCODE_RDCR             0x35    /* Read configuration register */
+
+/* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
+#define	OPCODE_NORM_READ_4B	0x13	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ_4B	0x0c	/* Read data bytes (high frequency) */
+#define	OPCODE_QUAD_READ_4B	0x6c    /* Read data bytes */
+#define	OPCODE_PP_4B		0x12	/* Page program (up to 256 bytes) */
+#define	OPCODE_SE_4B		0xdc	/* Sector erase (usually 64KiB) */
+
+/* Used for SST flashes only. */
+#define	OPCODE_BP		0x02	/* Byte program */
+#define	OPCODE_WRDI		0x04	/* Write disable */
+#define	OPCODE_AAI_WP		0xad	/* Auto address increment word program */
+
+/* Used for Macronix and Winbond flashes. */
+#define	OPCODE_EN4B		0xb7	/* Enter 4-byte mode */
+#define	OPCODE_EX4B		0xe9	/* Exit 4-byte mode */
+
+/* Used for Micron, winbond and Macronix flashes */
+#define	OPCODE_WREAR		0xc5	/* EAR register write */
+#define	OPCODE_RDEAR		0xc8	/* EAR reigster read */
+
+/* Used for Spansion flashes only. */
+#define	OPCODE_BRRD		0x16	/* Bank register read */
+#define	OPCODE_BRWR		0x17	/* Bank register write */
+
+/* Status Register bits. */
+#define	SR_WIP			1	/* Write in progress */
+#define	SR_WEL			2	/* Write enable latch */
+/* meaning of other SR_* bits may differ between vendors */
+#define	SR_BP0			4	/* Block protect 0 */
+#define	SR_BP1			8	/* Block protect 1 */
+#define	SR_BP2			0x10	/* Block protect 2 */
+#define	SR_SRWD			0x80	/* SR write protect */
+
+#define SR_QUAD_EN_MX           0x40    /* Macronix Quad I/O */
+
+/* Configuration Register bits. */
+#define CR_QUAD_EN_SPAN		0x2     /* Spansion Quad I/O */
+
+/* Endianess Configuration */
+#define BE_64	0x00
+#define LE_32	0x01
+#define BE_32	0x02
+#define LE_64	0x03
+
+
+
+enum fsl_qspi_devtype {
+	FSL_QUADSPI_VYBRID,
+	FSL_QUADSPI_IMX6SX,
+};
+
+struct fsl_qspi_devtype_data {
+	enum fsl_qspi_devtype devtype;
+	int rxfifo;
+	int txfifo;
+};
+
+struct fsl_qspi {
+	struct spi_slave slave;
+	uint32_t max_khz;
+	uint32_t mode;
+	u32 iobase;
+	u32 ahb_base; /* Used when read from AHB bus */
+	u32 bank_memmap_phy[4];
+	struct fsl_qspi_devtype_data *devtype_data;
+};
+
+static inline void fsl_qspi_unlock_lut(struct fsl_qspi *q)
+{
+	writel(QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
+	writel(QUADSPI_LCKER_UNLOCK, q->iobase + QUADSPI_LCKCR);
+}
+
+static inline void fsl_qspi_lock_lut(struct fsl_qspi *q)
+{
+	writel(QUADSPI_LUTKEY_VALUE, q->iobase + QUADSPI_LUTKEY);
+	writel(QUADSPI_LCKER_LOCK, q->iobase + QUADSPI_LCKCR);
+}
+
+static void fsl_qspi_init_lut(struct fsl_qspi *q)
+{
+	u32 base = q->iobase;
+	int rxfifo = q->devtype_data->rxfifo;
+	u32 lut_base;
+	u8 cmd, addrlen, dummy;
+	int i;
+
+	fsl_qspi_unlock_lut(q);
+
+	/* Clear all the LUT table */
+	for (i = 0; i < QUADSPI_LUT_NUM; i++)
+		writel(0, base + QUADSPI_LUT_BASE + i * 4);
+
+	/* Quad Read */
+	lut_base = SEQID_QUAD_READ * 4;
+
+	/* U-boot SPI flash only support 24bits address*/
+	cmd = OPCODE_QUAD_READ;
+	addrlen = ADDR24BIT;
+	dummy = 8;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(DUMMY, PAD1, dummy) | LUT1(READ, PAD4, rxfifo),
+			base + QUADSPI_LUT(lut_base + 1));
+
+	/* Write enable */
+	lut_base = SEQID_WREN * 4;
+	writel(LUT0(CMD, PAD1, OPCODE_WREN), base + QUADSPI_LUT(lut_base));
+
+	/* Fast Read */
+	lut_base = SEQID_FAST_READ * 4;
+	cmd = OPCODE_FAST_READ;
+	addrlen = ADDR24BIT;
+	dummy = 8;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(DUMMY, PAD1, dummy) | LUT1(READ, PAD1, rxfifo),
+			base + QUADSPI_LUT(lut_base + 1));
+
+	/* Page Program */
+	lut_base = SEQID_PP * 4;
+	cmd = OPCODE_PP;
+	addrlen = ADDR24BIT;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(WRITE, PAD1, 0), base + QUADSPI_LUT(lut_base + 1));
+
+	/* Read Status */
+	lut_base = SEQID_RDSR * 4;
+	writel(LUT0(CMD, PAD1, OPCODE_RDSR) | LUT1(READ, PAD1, 0x1),
+			base + QUADSPI_LUT(lut_base));
+
+	/* Erase a sector */
+	lut_base = SEQID_SE * 4;
+	cmd = OPCODE_SE;
+	addrlen = ADDR24BIT;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+
+	/* Erase the whole chip */
+	lut_base = SEQID_CHIP_ERASE * 4;
+	writel(LUT0(CMD, PAD1, OPCODE_CHIP_ERASE),
+			base + QUADSPI_LUT(lut_base));
+
+	/* READ ID */
+	lut_base = SEQID_RDID * 4;
+	writel(LUT0(CMD, PAD1, OPCODE_RDID) | LUT1(READ, PAD1, 0x8),
+			base + QUADSPI_LUT(lut_base));
+
+	/* Write Register */
+	lut_base = SEQID_WRSR * 4;
+	writel(LUT0(CMD, PAD1, OPCODE_WRSR) | LUT1(WRITE, PAD1, 0x2),
+			base + QUADSPI_LUT(lut_base));
+
+	/* Read Configuration Register */
+	lut_base = SEQID_RDCR * 4;
+	writel(LUT0(CMD, PAD1, OPCODE_RDCR) | LUT1(READ, PAD1, 0x1),
+			base + QUADSPI_LUT(lut_base));
+
+	/* DDR QUAD Read */
+	lut_base = SEQID_DDR_QUAD_READ * 4;
+	cmd = OPCODE_DDR_QUAD_READ;
+	addrlen = ADDR24BIT;
+	dummy = 6;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR_DDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(DUMMY, PAD1, dummy) | LUT1(READ_DDR, PAD4, rxfifo),
+			base + QUADSPI_LUT(lut_base + 1));
+	writel(LUT0(JMP_ON_CS, PAD1, 0),
+			base + QUADSPI_LUT(lut_base + 2));
+
+	/* SUB SECTOR 4K ERASE */
+	lut_base = SEQID_BE_4K * 4;
+	cmd = OPCODE_BE_4K;
+	addrlen = ADDR24BIT;
+
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(ADDR, PAD1, addrlen),
+			base + QUADSPI_LUT(lut_base));
+
+#ifdef CONFIG_SPI_FLASH_BAR
+	/*
+	 * BRRD BRWR RDEAR WREAR are all supported, because it is hard to
+	 * dynamically check whether to set BRRD BRWR or RDEAR WREAR.
+	 */
+	lut_base = SEQID_BRRD * 4;
+	cmd = OPCODE_BRRD;
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(READ, PAD1, 0x1),
+	       base + QUADSPI_LUT(lut_base));
+
+	lut_base = SEQID_BRWR * 4;
+	cmd = OPCODE_BRWR;
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(WRITE, PAD1, 0x1),
+	       base + QUADSPI_LUT(lut_base));
+
+	lut_base = SEQID_RDEAR * 4;
+	cmd = OPCODE_RDEAR;
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(READ, PAD1, 0x1),
+	       base + QUADSPI_LUT(lut_base));
+
+	lut_base = SEQID_WREAR * 4;
+	cmd = OPCODE_WREAR;
+	writel(LUT0(CMD, PAD1, cmd) | LUT1(WRITE, PAD1, 0x1),
+	       base + QUADSPI_LUT(lut_base));
+#endif
+
+	fsl_qspi_lock_lut(q);
+}
+
+/*Enable DDR Read Mode*/
+static void fsl_enable_ddr_mode(struct fsl_qspi *q)
+{
+	u32 base = q->iobase;
+	u32 reg, reg2;
+
+	reg = readl(base + QUADSPI_MCR);
+	/* Firstly, disable the module */
+	writel(reg | QUADSPI_MCR_MDIS_MASK, base + QUADSPI_MCR);
+
+	/* Set the Sampling Register for DDR */
+	reg2 = readl(base + QUADSPI_SMPR);
+	reg2 &= ~QUADSPI_SMPR_DDRSMP_MASK;
+	reg2 |= (2 << QUADSPI_SMPR_DDRSMP_SHIFT);
+	writel(reg2, base + QUADSPI_SMPR);
+
+	/* Enable the module again (enable the DDR too) */
+	reg |= QUADSPI_MCR_DDR_EN_MASK;
+	reg |= (1 << 29); /* enable bit 29 for imx6sx */
+
+	writel(reg, base + QUADSPI_MCR);
+
+}
+
+/*
+ * There are two different ways to read out the data from the flash:
+ *  the "IP Command Read" and the "AHB Command Read".
+ *
+ * The IC guy suggests we use the "AHB Command Read" which is faster
+ * then the "IP Command Read". (What's more is that there is a bug in
+ * the "IP Command Read" in the Vybrid.)
+ *
+ * After we set up the registers for the "AHB Command Read", we can use
+ * the memcpy to read the data directly. A "missed" access to the buffer
+ * causes the controller to clear the buffer, and use the sequence pointed
+ * by the QUADSPI_BFGENCR[SEQID] to initiate a read from the flash.
+ */
+static void fsl_qspi_init_abh_read(struct fsl_qspi *q)
+{
+	u32 base = q->iobase;
+
+	/* Map the SPI NOR to accessiable address, arrage max space for each bank*/
+	writel(q->bank_memmap_phy[0] + QUADSPI_AHBMAP_BANK_MAXSIZE,
+		base + QUADSPI_SFA1AD);
+	writel(q->bank_memmap_phy[1] + QUADSPI_AHBMAP_BANK_MAXSIZE,
+		base + QUADSPI_SFA2AD);
+	writel(q->bank_memmap_phy[2] + QUADSPI_AHBMAP_BANK_MAXSIZE,
+		base + QUADSPI_SFB1AD);
+	writel(q->bank_memmap_phy[3] + QUADSPI_AHBMAP_BANK_MAXSIZE,
+		base + QUADSPI_SFB2AD);
+
+	/* AHB configuration for access buffer 0/1/2 .*/
+	writel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF0CR);
+	writel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF1CR);
+	writel(QUADSPI_BUFXCR_INVALID_MSTRID, base + QUADSPI_BUF2CR);
+	writel(QUADSPI_BUF3CR_ALLMST_MASK | (0x80 << QUADSPI_BUF3CR_ADATSZ_SHIFT),
+			base + QUADSPI_BUF3CR);
+
+	/* We only use the buffer3 */
+	writel(0, base + QUADSPI_BUF0IND);
+	writel(0, base + QUADSPI_BUF1IND);
+	writel(0, base + QUADSPI_BUF2IND);
+
+	/* Set the default lut sequence for AHB Read. */
+	writel(SEQID_FAST_READ << QUADSPI_BFGENCR_SEQID_SHIFT,
+		base + QUADSPI_BFGENCR);
+
+	/*Enable DDR Mode*/
+	fsl_enable_ddr_mode(q);
+}
+
+static int fsl_qspi_init(struct fsl_qspi *q)
+{
+	u32 base = q->iobase;
+	u32 reg;
+	void *ptr;
+
+	ptr = malloc(sizeof(struct fsl_qspi_devtype_data));
+	if (!ptr) {
+		puts("FSL_QSPI: per-type data not allocated !\n");
+		return 1;
+	}
+	q->devtype_data = ptr;
+	q->devtype_data->rxfifo = 128;
+	q->devtype_data->txfifo = 512;
+
+	/* init the LUT table */
+	fsl_qspi_init_lut(q);
+
+	/* Disable the module */
+	writel(QUADSPI_MCR_MDIS_MASK | QUADSPI_MCR_RESERVED_MASK,
+			base + QUADSPI_MCR);
+
+	reg = readl(base + QUADSPI_SMPR);
+	writel(reg & ~(QUADSPI_SMPR_FSDLY_MASK
+			| QUADSPI_SMPR_FSPHS_MASK
+			| QUADSPI_SMPR_HSENA_MASK
+			| QUADSPI_SMPR_DDRSMP_MASK), base + QUADSPI_SMPR);
+
+	/* Enable the module */
+	writel(QUADSPI_MCR_RESERVED_MASK | LE_64 << QUADSPI_MCR_END_CFG_SHIFT,
+		base + QUADSPI_MCR);
+
+	/* We do not enable the interrupt */
+
+	/* init for AHB read */
+	fsl_qspi_init_abh_read(q);
+
+	/*
+	 * High level code use page_size and max_write_size to calculate
+	 * the number of bytes that should be programmed once.
+	 */
+	q->slave.max_write_size = q->devtype_data->txfifo;
+
+	return 0;
+}
+
+void spi_init(void)
+{
+}
+
+struct spi_slave *spi_setup_slave(unsigned int bus, unsigned int cs,
+		unsigned int max_hz, unsigned int mode)
+{
+	struct fsl_qspi *q;
+	int ret;
+
+	if (bus > 1) {
+		puts("FSL_QSPI: Not a valid bus !\n");
+		return NULL;
+	}
+
+	if (cs > 1) {
+		puts("FSL_QSPI: Not a valid cs !\n");
+		return NULL;
+	}
+
+	q = spi_alloc_slave(struct fsl_qspi, bus, cs);
+	if (!q) {
+		puts("FSL_QSPI: SPI Slave not allocated !\n");
+		return NULL;
+	}
+
+	q->iobase = CONFIG_QSPI_BASE;
+	q->bank_memmap_phy[0] = CONFIG_QSPI_MEMMAP_BASE;
+	q->bank_memmap_phy[1] = q->bank_memmap_phy[0] + QUADSPI_AHBMAP_BANK_MAXSIZE;
+	q->bank_memmap_phy[2] = q->bank_memmap_phy[1] + QUADSPI_AHBMAP_BANK_MAXSIZE;
+	q->bank_memmap_phy[3] = q->bank_memmap_phy[2] + QUADSPI_AHBMAP_BANK_MAXSIZE;
+
+	/* Init the QuadSPI controller */
+	ret = fsl_qspi_init(q);
+	if (ret) {
+		puts("FSL_QSPI: init failed!\n");
+		return NULL;
+	}
+
+	return &q->slave;
+}
+
+void spi_free_slave(struct spi_slave *slave)
+{
+	struct fsl_qspi *q;
+
+	q = container_of(slave, struct fsl_qspi, slave);
+	free(q->devtype_data);
+	free(q);
+}
+
+int spi_claim_bus(struct spi_slave *q)
+{
+	return 0;
+}
+
+void spi_release_bus(struct spi_slave *q)
+{
+}
+
+/* Get the SEQID for the command */
+static int fsl_qspi_get_seqid(struct fsl_qspi *q, u8 cmd)
+{
+	switch (cmd) {
+	case OPCODE_QUAD_READ:
+	case OPCODE_QUAD_READ_4B:
+		return SEQID_QUAD_READ;
+	case OPCODE_FAST_READ:
+	case OPCODE_FAST_READ_4B:
+		return SEQID_FAST_READ;
+	case OPCODE_WREN:
+		return SEQID_WREN;
+	case OPCODE_RDSR:
+		return SEQID_RDSR;
+	case OPCODE_SE:
+		return SEQID_SE;
+	case OPCODE_CHIP_ERASE:
+		return SEQID_CHIP_ERASE;
+	case OPCODE_PP:
+	case OPCODE_PP_4B:
+		return SEQID_PP;
+	case OPCODE_RDID:
+		return SEQID_RDID;
+	case OPCODE_WRSR:
+		return SEQID_WRSR;
+	case OPCODE_RDCR:
+		return SEQID_RDCR;
+	case OPCODE_DDR_QUAD_READ:
+		return SEQID_DDR_QUAD_READ;
+	case OPCODE_BE_4K:
+		return SEQID_BE_4K;
+#ifdef CONFIG_SPI_FLASH_BAR
+	case OPCODE_BRRD:
+		return SEQID_BRRD;
+	case OPCODE_BRWR:
+		return SEQID_BRWR;
+	case OPCODE_RDEAR:
+		return SEQID_RDEAR;
+	case OPCODE_WREAR:
+		return SEQID_WREAR;
+#endif
+	default:
+		break;
+	}
+	return -1;
+}
+
+/* return 1 on success */
+static int fsl_qspi_wait_to_complete(struct fsl_qspi *q)
+{
+	u32 base = q->iobase;
+	u32 reg;
+
+	/*printf("QuadSPI: poll the busy bit\n");*/
+	while (1) {
+		reg = readl(base + QUADSPI_SR);
+		if (reg & 1)
+			continue;
+		else
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * If we have changed the content of the flash by writing or erasing,
+ * we need to invalidate the AHB buffer. If we do not do so, we may read out
+ * the wrong data. The spec tells us reset the AHB domain and Serial Flash
+ * domain at the same time.
+ */
+static inline void fsl_qspi_invalid(struct fsl_qspi *q)
+{
+    u32 reg;
+
+    reg = readl(q->iobase + QUADSPI_MCR);
+    reg |= QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK;
+    writel(reg, q->iobase + QUADSPI_MCR);
+
+    /*
+     * The minimum delay : 1 AHB + 2 SFCK clocks.
+     * Delay 1 us is enough.
+     */
+    udelay(1);
+
+    reg &= ~(QUADSPI_MCR_SWRSTHD_MASK | QUADSPI_MCR_SWRSTSD_MASK);
+    writel(reg, q->iobase + QUADSPI_MCR);
+}
+
+static int
+fsl_qspi_runcmd(struct fsl_qspi *q, u8 cmd, unsigned int addr, int len)
+{
+	u32 base = q->iobase;
+	int seqid;
+	u32 reg, reg2;
+	int err;
+	int bank_id;
+
+	/* check the SR first, wait previous cmd completed*/
+	do {
+		reg2 = readl(base + QUADSPI_SR);
+		if (reg2 & (QUADSPI_SR_IP_ACC_MASK | QUADSPI_SR_AHB_ACC_MASK)) {
+			udelay(1);
+			printf("The controller is busy, 0x%x\n", reg2);
+			continue;
+		}
+		break;
+	} while (1);
+
+	/* save the reg */
+	reg = readl(base + QUADSPI_MCR);
+
+	/* get the bank index */
+	bank_id = ((q->slave.bus) << 1) + (q->slave.cs);
+
+	writel(q->bank_memmap_phy[bank_id] + addr, base + QUADSPI_SFAR);
+	writel(QUADSPI_RBCT_WMRK_MASK | QUADSPI_RBCT_RXBRD_USEIPS,
+			base + QUADSPI_RBCT);
+	writel(reg | QUADSPI_MCR_CLR_RXF_MASK, base + QUADSPI_MCR);
+
+	/* trigger the LUT now */
+	seqid = fsl_qspi_get_seqid(q, cmd);
+	writel((seqid << QUADSPI_IPCR_SEQID_SHIFT) | len, base + QUADSPI_IPCR);
+
+	/* Wait until completed */
+	err = fsl_qspi_wait_to_complete(q);
+	if (!err)
+		err = -1;
+	else
+		err = 0;
+
+	/* restore the MCR */
+	writel(reg, base + QUADSPI_MCR);
+
+	/* After switch BANK, AHB buffer should also be invalid. */
+	if ((OPCODE_SE == cmd) || (OPCODE_PP == cmd) ||
+	    (OPCODE_BE_4K == cmd) || (OPCODE_WREAR == cmd) ||
+	    (OPCODE_BRWR == cmd))
+		fsl_qspi_invalid(q);
+	return err;
+}
+
+/*
+ * An IC bug makes us to re-arrange the 32-bit data.
+ * The following chips, such as IMX6SLX, have fixed this bug.
+ */
+static inline u32 fsl_qspi_endian_xchg(struct fsl_qspi *q, u32 a)
+{
+	return a;
+}
+
+/* Read out the data from the AHB buffer. */
+static void fsl_qspi_ahb_read(struct fsl_qspi *q,
+	unsigned int addr, int len, u8 *rxbuf)
+{
+	int bank_id;
+
+	/* get the bank index */
+	bank_id = ((q->slave.bus) << 1) + (q->slave.cs);
+
+	/* Read out the data directly from the AHB buffer.*/
+	memcpy(rxbuf, (u8 *)(q->bank_memmap_phy[bank_id] + addr), len);
+}
+
+/* Read out the data from the QUADSPI_RBDR buffer registers. */
+static void fsl_qspi_ip_read(struct fsl_qspi *q, int len, u8 *rxbuf)
+{
+	u32 tmp;
+	int i = 0;
+
+	while (len > 0) {
+		tmp = readl(q->iobase + QUADSPI_RBDR + i * 4);
+		tmp = fsl_qspi_endian_xchg(q, tmp);
+
+		if (len >= 4) {
+			memcpy(rxbuf, &tmp, 4);
+			rxbuf += 4;
+		} else {
+			memcpy(rxbuf, &tmp, len);
+			break;
+		}
+
+		len -= 4;
+		i++;
+	}
+}
+
+/* Write data to the QUADSPI_TBDR buffer registers. */
+static void fsl_qspi_write_data(struct fsl_qspi *q, int len, u8* txbuf)
+{
+	u32 tmp;
+	u32 t1, t2;
+	int j;
+
+	/* clear the TX FIFO. */
+	tmp = readl(q->iobase + QUADSPI_MCR);
+	writel(tmp | QUADSPI_MCR_CLR_RXF_MASK, q->iobase + QUADSPI_MCR);
+
+	/* fill the TX data to the FIFO */
+	t2 = len % 4;
+	t1 = len >> 2; /* 4 Bytes aligned */
+
+	for (j = 0; j < t1; j++) {
+		memcpy(&tmp, txbuf, 4);
+		tmp = fsl_qspi_endian_xchg(q, tmp);
+		writel(tmp, q->iobase + QUADSPI_TBDR);
+		txbuf += 4;
+	}
+
+	if (t2) {
+		tmp = 0;
+		memcpy(&tmp, txbuf, t2);
+		tmp = fsl_qspi_endian_xchg(q, tmp);
+		writel(tmp, q->iobase + QUADSPI_TBDR);
+	}
+}
+
+/* see the spi_flash_read_write() */
+int  spi_xfer(struct spi_slave *slave, unsigned int bitlen, const void *dout,
+		void *din, unsigned long flags)
+{
+	struct fsl_qspi *q = container_of(slave, struct fsl_qspi, slave);
+	int len = bitlen / 8;
+	int ret = 0;
+	u8 *buf;
+	static u8 opcode;
+	static unsigned int addr;
+
+	if (!opcode && (flags & SPI_XFER_BEGIN)) {
+		/* spi_xfer for cmd phase */
+		buf = (u8 *)dout;
+		opcode = buf[0];
+		if (len > 1)
+			addr = buf[1] << 16 | buf[2] << 8 | buf[3];
+
+		/* if transfer cmd only */
+		if (flags & SPI_XFER_END)
+			ret = fsl_qspi_runcmd(q, opcode, addr, 0);
+
+	} else if (opcode) {
+		/* spi_xfer for data phase */
+		if (din) {
+			/* read*/
+			buf = (u8 *)din;
+			if (OPCODE_FAST_READ == opcode) {
+				fsl_qspi_ahb_read(q, addr, len, buf);
+			} else {
+				ret = fsl_qspi_runcmd(q, opcode, addr, len);
+				if (!ret)
+					fsl_qspi_ip_read(q, len, buf);
+			}
+		} else if (dout) {
+			/* write data, prepare data first */
+			buf = (u8 *)dout;
+			fsl_qspi_write_data(q, len, buf);
+			/* then run page program cmd */
+			ret = fsl_qspi_runcmd(q, opcode, addr, len);
+		}
+	}
+
+	if (ret || (flags & SPI_XFER_END)) {
+		opcode = 0;
+		addr = 0;
+	}
+
+	return ret;
+}
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 804a2bd..2d5ae21 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -33,5 +33,6 @@ obj-$(CONFIG_OMAP1510) += omap1510_udc.o
 obj-$(CONFIG_OMAP1610) += omap1510_udc.o
 obj-$(CONFIG_MPC885_FAMILY) += mpc8xx_udc.o
 obj-$(CONFIG_CPU_PXA27X) += pxa27x_udc.o
+obj-$(CONFIG_IMX_UDC) += imx_udc.o
 endif
 endif
diff --git a/drivers/usb/gadget/imx_udc.c b/drivers/usb/gadget/imx_udc.c
new file mode 100644
index 0000000..9cdf3c8
--- /dev/null
+++ b/drivers/usb/gadget/imx_udc.c
@@ -0,0 +1,1189 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/types.h>
+#include <malloc.h>
+#include <command.h>
+#include <asm/errno.h>
+#include <usbdevice.h>
+#include <usb/imx_udc.h>
+
+#include "ep0.h"
+
+#ifdef DEBUG
+#define DBG(x...) printf(x)
+#else
+#define DBG(x...) do {} while (0)
+#endif
+
+#define mdelay(n) udelay((n)*1000)
+
+#define EP_TQ_ITEM_SIZE 16
+
+#define inc_index(x) (x = ((x+1) % EP_TQ_ITEM_SIZE))
+
+#define ep_is_in(e, tx) ((e == 0) ? (mxc_udc.ep0_dir == USB_DIR_IN) : tx)
+
+#define USB_RECIP_MASK	    0x03
+#define USB_TYPE_MASK	    (0x03 << 5)
+#define USB_MEM_ALIGN_BYTE  4096
+#define USB_DEV_DQH_ALIGN   64
+#define USB_DEV_DTD_ALIGN   64
+
+/*fixed the dtd buffer to 4096 bytes, even it could be 20KB*/
+#define USB_DEV_DTD_MAX_BUFFER_SIZE 4096
+
+#define CACHE_ALIGNED_END(start, length) \
+	(ALIGN((uint32_t)start + length, ARCH_DMA_MINALIGN))
+
+struct mxc_ep_t{
+	int epnum;
+	int dir;
+	int max_pkt_size;
+	struct usb_endpoint_instance *epi;
+	struct ep_queue_item *ep_dtd[EP_TQ_ITEM_SIZE];
+	int index; /* to index the free tx tqi */
+	int done;  /* to index the complete rx tqi */
+	struct ep_queue_item *tail; /* last item in the dtd chain */
+	struct ep_queue_head *ep_qh;
+} ;
+
+struct mxc_udc_ctrl{
+	int    max_ep;
+	int    ep0_dir;
+	int    setaddr;
+	struct ep_queue_head *ep_qh;
+	struct mxc_ep_t *mxc_ep;
+	u32    qh_unaligned;
+};
+
+static int usb_highspeed;
+static int usb_inited;
+static struct mxc_udc_ctrl mxc_udc;
+static struct usb_device_instance *udc_device;
+static struct urb *ep0_urb;
+/*
+ * malloc an aligned memory
+ * unaligned_addr: return a unaligned address for memory free
+ * size   : memory size
+ * align  : alignment for this memroy
+ * return : aligned address(NULL when malloc failt)
+*/
+static void *malloc_aligned_buffer(u32 *unaligned_addr,
+	int size, int align)
+{
+	int msize = (size + align  - 1);
+	u32 vir, vir_align;
+
+	/* force the allocated memory size to be aligned with min cache operation unit.
+	*   So it is safe to flush/invalidate the cache.
+	*/
+	msize = (msize + ARCH_DMA_MINALIGN - 1) / ARCH_DMA_MINALIGN;
+	msize = msize * ARCH_DMA_MINALIGN;
+
+	vir = (u32)malloc(msize);
+	memset((void *)vir, 0, msize);
+	vir_align = (vir + align - 1) & (~(align - 1));
+	*unaligned_addr = vir;
+
+	DBG("alloc aligned vir addr %x\n", vir_align);
+	return (void *)vir_align;
+}
+
+int is_usb_disconnected()
+{
+	int ret = 0;
+
+	ret = readl(USB_OTGSC) & OTGSC_B_SESSION_VALID ? 0 : 1;
+	return ret;
+}
+
+static int mxc_init_usb_qh(void)
+{
+	int size;
+	memset(&mxc_udc, 0, sizeof(mxc_udc));
+	mxc_udc.max_ep = (readl(USB_DCCPARAMS) & DCCPARAMS_DEN_MASK) * 2;
+	DBG("udc max ep = %d\n", mxc_udc.max_ep);
+	size = mxc_udc.max_ep * sizeof(struct ep_queue_head);
+	mxc_udc.ep_qh = malloc_aligned_buffer(&mxc_udc.qh_unaligned,
+					     size, USB_MEM_ALIGN_BYTE);
+	if (!mxc_udc.ep_qh) {
+		printf("malloc ep qh dma buffer failure\n");
+		return -1;
+	}
+	memset(mxc_udc.ep_qh, 0, size);
+
+	/*flush cache to physical memory*/
+	flush_dcache_range((unsigned long)mxc_udc.ep_qh,
+		CACHE_ALIGNED_END(mxc_udc.ep_qh, size));
+
+	writel(virt_to_phys(mxc_udc.ep_qh) & 0xfffff800, USB_ENDPOINTLISTADDR);
+	return 0;
+}
+
+static int mxc_destroy_usb_qh(void)
+{
+	if (mxc_udc.ep_qh && mxc_udc.qh_unaligned) {
+		free((void *)mxc_udc.qh_unaligned);
+		mxc_udc.ep_qh = 0;
+		mxc_udc.qh_unaligned = 0;
+		mxc_udc.max_ep = 0;
+	}
+
+	return 0;
+}
+
+static int mxc_init_ep_struct(void)
+{
+	int i;
+
+	DBG("init mxc ep\n");
+	mxc_udc.mxc_ep = malloc(mxc_udc.max_ep * sizeof(struct mxc_ep_t));
+	if (!mxc_udc.mxc_ep) {
+		printf("malloc ep struct failure\n");
+		return -1;
+	}
+	memset((void *)mxc_udc.mxc_ep, 0,
+		sizeof(struct mxc_ep_t) * mxc_udc.max_ep);
+	for (i = 0; i < mxc_udc.max_ep / 2; i++) {
+		struct mxc_ep_t *ep;
+		ep  = mxc_udc.mxc_ep + i * 2;
+		ep->epnum = i;
+		ep->index = ep->done = 0;
+		ep->dir = USB_RECV;  /* data from host to device */
+		ep->ep_qh = &mxc_udc.ep_qh[i * 2];
+
+		ep  = mxc_udc.mxc_ep + (i * 2 + 1);
+		ep->epnum = i;
+		ep->index = ep->done = 0;
+		ep->dir = USB_SEND;  /* data to host from device */
+		ep->ep_qh = &mxc_udc.ep_qh[(i * 2 + 1)];
+	}
+	return 0;
+}
+
+static int mxc_destroy_ep_struct(void)
+{
+	if (mxc_udc.mxc_ep) {
+		free(mxc_udc.mxc_ep);
+		mxc_udc.mxc_ep = 0;
+	}
+	return 0;
+}
+
+static int mxc_init_ep_dtd(u8 index)
+{
+	struct mxc_ep_t *ep;
+	u32 unaligned_addr;
+	int i;
+
+	if (index >= mxc_udc.max_ep)
+		DBG("%s ep %d is not valid\n", __func__, index);
+
+	ep = mxc_udc.mxc_ep + index;
+	for (i = 0; i < EP_TQ_ITEM_SIZE; i++) {
+		ep->ep_dtd[i] = malloc_aligned_buffer(&unaligned_addr,
+			    sizeof(struct ep_queue_item), USB_DEV_DTD_ALIGN);
+		ep->ep_dtd[i]->item_unaligned_addr = unaligned_addr;
+
+		if (NULL == ep->ep_dtd[i]) {
+			printf("%s malloc tq item failure\n", __func__);
+
+			/*free other already allocated dtd*/
+			while (i) {
+				i--;
+				free((void *)(ep->ep_dtd[i]->item_unaligned_addr));
+				ep->ep_dtd[i] = 0;
+			}
+			return -1;
+		}
+	}
+	return 0;
+}
+
+static int mxc_destroy_ep_dtd(u8 index)
+{
+	struct mxc_ep_t *ep;
+	int i;
+
+	if (index >= mxc_udc.max_ep)
+		DBG("%s ep %d is not valid\n", __func__, index);
+
+	ep = mxc_udc.mxc_ep + index;
+	for (i = 0; i < EP_TQ_ITEM_SIZE; i++) {
+		if (ep->ep_dtd[i]) {
+			free((void *)(ep->ep_dtd[i]->item_unaligned_addr));
+			ep->ep_dtd[i] = 0;
+		}
+	}
+
+	return 0;
+}
+
+static void mxc_ep_qh_setup(u8 ep_num, u8 dir, u8 ep_type,
+				 u32 max_pkt_len, u32 zlt, u8 mult)
+{
+	struct ep_queue_head *p_qh = mxc_udc.ep_qh + (2 * ep_num + dir);
+	u32 tmp = 0;
+
+	tmp = max_pkt_len << 16;
+	switch (ep_type) {
+	case USB_ENDPOINT_XFER_CONTROL:
+		tmp |= (1 << 15);
+		break;
+	case USB_ENDPOINT_XFER_ISOC:
+		tmp |= (mult << 30);
+		break;
+	case USB_ENDPOINT_XFER_BULK:
+	case USB_ENDPOINT_XFER_INT:
+		break;
+	default:
+		DBG("error ep type is %d\n", ep_type);
+		return;
+	}
+	if (zlt)
+		tmp |= (1<<29);
+
+	p_qh->config = tmp;
+
+	/*flush qh's config field to physical memory*/
+	flush_dcache_range((unsigned long)p_qh,
+		CACHE_ALIGNED_END(p_qh, sizeof(struct ep_queue_head)));
+}
+
+static void mxc_ep_setup(u8 ep_num, u8 dir, u8 ep_type)
+{
+	u32 epctrl = 0;
+	epctrl = readl(USB_ENDPTCTRL(ep_num));
+	if (dir) {
+		if (ep_num)
+			epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;
+		epctrl |= EPCTRL_TX_ENABLE;
+		epctrl |= ((u32)(ep_type) << EPCTRL_TX_EP_TYPE_SHIFT);
+	} else {
+		if (ep_num)
+			epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;
+		epctrl |= EPCTRL_RX_ENABLE;
+		epctrl |= ((u32)(ep_type) << EPCTRL_RX_EP_TYPE_SHIFT);
+	}
+	writel(epctrl, USB_ENDPTCTRL(ep_num));
+}
+
+static void mxc_ep_destroy(u8 ep_num, u8 dir)
+{
+	u32 epctrl = 0;
+	epctrl = readl(USB_ENDPTCTRL(ep_num));
+	if (dir)
+		epctrl &= ~EPCTRL_TX_ENABLE;
+	else
+		epctrl &= ~EPCTRL_RX_ENABLE;
+
+	writel(epctrl, USB_ENDPTCTRL(ep_num));
+}
+
+
+static void mxc_tqi_init_page(struct ep_queue_item *tqi)
+{
+	tqi->page0 = virt_to_phys((void *)(tqi->page_vir));
+	tqi->page1 = tqi->page0 + 0x1000;
+	tqi->page2 = tqi->page1 + 0x1000;
+	tqi->page3 = tqi->page2 + 0x1000;
+	tqi->page4 = tqi->page3 + 0x1000;
+}
+
+static int mxc_malloc_ep0_ptr(struct mxc_ep_t *ep)
+{
+	int i;
+	struct ep_queue_item *tqi;
+	int max_pkt_size = USB_MAX_CTRL_PAYLOAD;
+
+	ep->max_pkt_size = max_pkt_size;
+	for (i = 0; i < EP_TQ_ITEM_SIZE; i++) {
+		tqi = ep->ep_dtd[i];
+		tqi->page_vir = (u32)malloc_aligned_buffer(&tqi->page_unaligned,
+						    max_pkt_size,
+						    USB_MEM_ALIGN_BYTE);
+		if ((void *)tqi->page_vir == NULL) {
+			printf("malloc ep's dtd bufer failure, i=%d\n", i);
+			return -1;
+		}
+		mxc_tqi_init_page(tqi);
+
+		/*flush dtd's config field to physical memory*/
+		flush_dcache_range((unsigned long)tqi,
+			CACHE_ALIGNED_END(tqi, sizeof(struct ep_queue_item)));
+	}
+	return 0;
+}
+
+static int mxc_free_ep0_ptr(struct mxc_ep_t *ep)
+{
+	int i;
+	struct ep_queue_item *tqi;
+	for (i = 0; i < EP_TQ_ITEM_SIZE; i++) {
+		tqi = ep->ep_dtd[i];
+		if (tqi->page_vir) {
+			free((void *)(tqi->page_unaligned));
+			tqi->page_vir = 0;
+			tqi->page_unaligned = 0;
+			tqi->page0 = 0;
+			tqi->page1 = 0;
+			tqi->page2 = 0;
+			tqi->page3 = 0;
+			tqi->page4 = 0;
+
+			/*flush dtd's config field to physical memory*/
+			flush_dcache_range((unsigned long)tqi,
+				CACHE_ALIGNED_END(tqi, sizeof(struct ep_queue_item)));
+		}
+	}
+
+	return 0;
+}
+
+static void ep0_setup(void)
+{
+	mxc_ep_qh_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,
+			    USB_MAX_CTRL_PAYLOAD, 0, 0);
+	mxc_ep_qh_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,
+			    USB_MAX_CTRL_PAYLOAD, 0, 0);
+	mxc_ep_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL);
+	mxc_ep_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL);
+	mxc_init_ep_dtd(0 * 2 + USB_RECV);
+	mxc_init_ep_dtd(0 * 2 + USB_SEND);
+	mxc_malloc_ep0_ptr(mxc_udc.mxc_ep + (USB_RECV));
+	mxc_malloc_ep0_ptr(mxc_udc.mxc_ep + (USB_SEND));
+}
+
+static void ep0_destroy(void)
+{
+	mxc_ep_destroy(0, USB_RECV);
+	mxc_ep_destroy(0, USB_SEND);
+	mxc_free_ep0_ptr(mxc_udc.mxc_ep + (USB_RECV));
+	mxc_free_ep0_ptr(mxc_udc.mxc_ep + (USB_SEND));
+	mxc_destroy_ep_dtd(0 * 2 + USB_RECV);
+	mxc_destroy_ep_dtd(0 * 2 + USB_SEND);
+}
+
+static int mxc_tqi_is_busy(struct ep_queue_item *tqi)
+{
+	/* bit 7 is set by software when send, clear by controller
+	   when finish */
+	/*Invalidate cache to gain dtd content from physical memory*/
+	invalidate_dcache_range((unsigned long)tqi,
+		CACHE_ALIGNED_END(tqi, sizeof(struct ep_queue_item)));
+	return tqi->info & (1 << 7);
+}
+
+static int mxc_ep_xfer_is_working(struct mxc_ep_t *ep, u32 in)
+{
+	/* in: means device -> host */
+	u32 bitmask = 1 << (ep->epnum + in * 16);
+	u32 temp, prime, tstat;
+
+	prime = (bitmask & readl(USB_ENDPTPRIME));
+	if (prime)
+		return 1;
+	do {
+		temp = readl(USB_USBCMD);
+		writel(temp|USB_CMD_ATDTW, USB_USBCMD);
+		tstat = readl(USB_ENDPTSTAT) & bitmask;
+	} while (!(readl(USB_USBCMD) & USB_CMD_ATDTW));
+	writel(temp & (~USB_CMD_ATDTW), USB_USBCMD);
+
+	if (tstat)
+		return 1;
+	return 0;
+}
+
+static void mxc_update_qh(struct mxc_ep_t *ep,
+	struct ep_queue_item *tqi, u32 in)
+{
+	/* in: means device -> host */
+	struct ep_queue_head *qh = ep->ep_qh;
+	u32 bitmask = 1 << (ep->epnum + in * 16);
+	DBG("%s, line %d, epnum=%d, in=%d\n", __func__,
+		__LINE__, ep->epnum, in);
+	qh->next_queue_item = virt_to_phys(tqi);
+	qh->info = 0;
+
+	/*flush qh''s config field to physical memory*/
+	flush_dcache_range((unsigned long)qh,
+		CACHE_ALIGNED_END(qh, sizeof(struct ep_queue_head)));
+
+	writel(bitmask, USB_ENDPTPRIME);
+}
+
+static void _dump_buf(u8 *buf, u32 len)
+{
+#ifdef DEBUG
+	char *data = (char *)buf;
+	int i;
+	for (i = 0; i < len; i++) {
+		printf("0x%02x ", data[i]);
+		if (i%16 == 15)
+			printf("\n");
+	}
+	printf("\n");
+#endif
+}
+
+static void mxc_udc_queue_update(u8 epnum,
+	u8 *data, u32 len, u32 tx)
+{
+	struct mxc_ep_t *ep;
+	struct ep_queue_item *tqi, *head, *last;
+	int send = 0;
+	int in;
+
+	head = last = NULL;
+	in = ep_is_in(epnum, tx);
+	ep = mxc_udc.mxc_ep + (epnum * 2 + in);
+	DBG("epnum = %d,  in = %d\n", epnum, in);
+	do {
+		tqi = ep->ep_dtd[ep->index];
+		DBG("%s, index = %d, tqi = %p\n", __func__, ep->index, tqi);
+		while (mxc_tqi_is_busy(tqi))
+			;
+		mxc_tqi_init_page(tqi);
+		DBG("%s, line = %d, len = %d\n", __func__, __LINE__, len);
+		inc_index(ep->index);
+		send = MIN(len, ep->max_pkt_size);
+		if (data) {
+			memcpy((void *)tqi->page_vir, (void *)data, send);
+			_dump_buf((u8 *)(tqi->page_vir), send);
+
+			flush_dcache_range((unsigned long)(tqi->page_vir),
+				CACHE_ALIGNED_END(tqi->page_vir, send));
+		}
+		if (!head)
+			last = head = tqi;
+		else {
+			last->next_item_ptr = virt_to_phys(tqi);
+			last->next_item_vir = tqi;
+			last = tqi;
+		}
+		if (!tx)
+			tqi->reserved[0] = send;
+		/* we set IOC for every dtd */
+		tqi->info = ((send << 16) | (1 << 15) | (1 << 7));
+		data += send;
+		len -= send;
+
+		flush_dcache_range((unsigned long)tqi,
+			CACHE_ALIGNED_END(tqi, sizeof(struct ep_queue_item)));
+	} while (len);
+
+	last->next_item_ptr = 0x1; /* end */
+	flush_dcache_range((unsigned long)last,
+			CACHE_ALIGNED_END(last, sizeof(struct ep_queue_item)));
+
+	if (ep->tail) {
+		ep->tail->next_item_ptr = virt_to_phys(head);
+		ep->tail->next_item_vir = head;
+		flush_dcache_range((unsigned long)(ep->tail),
+			CACHE_ALIGNED_END(ep->tail, sizeof(struct ep_queue_item)));
+
+		if (mxc_ep_xfer_is_working(ep, in)) {
+			DBG("ep is working\n");
+			goto out;
+		}
+	}
+	mxc_update_qh(ep, head, in);
+out:
+	ep->tail = last;
+}
+
+static void mxc_udc_txqueue_update(u8 ep, u8 *data, u32 len)
+{
+	printf("[SEND DATA] EP= %d, Len = 0x%x\n", ep, len);
+	_dump_buf(data, len);
+	mxc_udc_queue_update(ep, data, len, 1);
+}
+
+void mxc_udc_rxqueue_update(u8 ep, u32 len)
+{
+	mxc_udc_queue_update(ep, NULL, len, 0);
+}
+
+static void mxc_ep0_stall(void)
+{
+	u32 temp;
+	temp = readl(USB_ENDPTCTRL(0));
+	temp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;
+	writel(temp, USB_ENDPTCTRL(0));
+}
+
+static void mxc_usb_run(void)
+{
+	unsigned int temp = 0;
+
+	/* Enable DR irq reg */
+	temp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN
+		| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN
+		| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;
+
+	writel(temp, USB_USBINTR);
+
+	/* Set controller to Run */
+	temp = readl(USB_USBCMD);
+	temp |= USB_CMD_RUN_STOP;
+	writel(temp, USB_USBCMD);
+}
+
+static void mxc_usb_stop(void)
+{
+	unsigned int temp = 0;
+
+	writel(temp, USB_USBINTR);
+
+	/* Set controller to Stop */
+	temp = readl(USB_USBCMD);
+	temp &= ~USB_CMD_RUN_STOP;
+	writel(temp, USB_USBCMD);
+}
+
+static void usb_phy_init(void)
+{
+	u32 temp;
+	/* select 24M clk */
+	temp = readl(USB_PHY1_CTRL);
+	temp &= ~3;
+	temp |= 1;
+	writel(temp, USB_PHY1_CTRL);
+	/* Config PHY interface */
+	temp = readl(USB_PORTSC1);
+	temp &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PORT_WIDTH);
+	temp |= PORTSCX_PTW_16BIT;
+	writel(temp, USB_PORTSC1);
+	DBG("Config PHY  END\n");
+}
+
+static void usb_set_mode_device(void)
+{
+	u32 temp;
+
+	/* Set controller to stop */
+	temp = readl(USB_USBCMD);
+	temp &= ~USB_CMD_RUN_STOP;
+	writel(temp, USB_USBCMD);
+
+	while (readl(USB_USBCMD) & USB_CMD_RUN_STOP)
+		;
+	/* Do core reset */
+	temp = readl(USB_USBCMD);
+	temp |= USB_CMD_CTRL_RESET;
+	writel(temp, USB_USBCMD);
+	while (readl(USB_USBCMD) & USB_CMD_CTRL_RESET)
+		;
+	DBG("DOORE RESET END\n");
+
+#if defined(CONFIG_MX6)
+	reset_usb_phy1();
+#endif
+	DBG("init core to device mode\n");
+	temp = readl(USB_USBMODE);
+	temp &= ~USB_MODE_CTRL_MODE_MASK;	/* clear mode bits */
+	temp |= USB_MODE_CTRL_MODE_DEVICE;
+	/* Disable Setup Lockout */
+	temp |= USB_MODE_SETUP_LOCK_OFF;
+	writel(temp, USB_USBMODE);
+
+	temp = readl(USB_OTGSC);
+	temp |= (1<<3);
+	writel(temp, USB_OTGSC);
+	DBG("init core to device mode end\n");
+}
+
+static void usb_init_eps(void)
+{
+	u32 temp;
+	DBG("Flush begin\n");
+	temp = readl(USB_ENDPTNAKEN);
+	temp |= 0x10001;	/* clear mode bits */
+	writel(temp, USB_ENDPTNAKEN);
+	writel(readl(USB_ENDPTCOMPLETE), USB_ENDPTCOMPLETE);
+	writel(readl(USB_ENDPTSETUPSTAT), USB_ENDPTSETUPSTAT);
+	writel(0xffffffff, USB_ENDPTFLUSH);
+	DBG("FLUSH END\n");
+}
+
+static void usb_udc_init(void)
+{
+	DBG("\n************************\n");
+	DBG("         usb init start\n");
+	DBG("\n************************\n");
+
+	usb_phy_init();
+	usb_set_mode_device();
+	mxc_init_usb_qh();
+	usb_init_eps();
+	mxc_init_ep_struct();
+	ep0_setup();
+	usb_inited = 1;
+}
+
+static void usb_udc_destroy(void)
+{
+	usb_set_mode_device();
+
+	usb_inited = 0;
+
+	ep0_destroy();
+	mxc_destroy_ep_struct();
+	mxc_destroy_usb_qh();
+}
+
+void usb_shutdown(void)
+{
+	u32 temp;
+	/* disable pullup */
+	temp = readl(USB_USBCMD);
+	temp &= ~USB_CMD_RUN_STOP;
+	writel(temp, USB_USBCMD);
+	mdelay(2);
+}
+
+static void ch9getstatus(u8 request_type,
+	u16 value, u16 index, u16 length)
+{
+	u16 tmp;
+
+	if ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {
+		tmp = 1 << 0; /* self powerd */
+		tmp |= 0 << 1; /* not remote wakeup able */
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {
+		tmp = 0;
+	} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {
+		tmp = 0;
+	}
+	mxc_udc.ep0_dir = USB_DIR_IN;
+	mxc_udc_queue_update(0, (u8 *)&tmp, 2, 0xffffffff);
+}
+
+static void mxc_udc_read_setup_pkt(struct usb_device_request *s)
+{
+	u32 temp;
+	temp = readl(USB_ENDPTSETUPSTAT);
+	writel(temp, USB_ENDPTSETUPSTAT);
+	DBG("setup stat %x\n", temp);
+	do {
+		temp = readl(USB_USBCMD);
+		temp |= USB_CMD_SUTW;
+		writel(temp, USB_USBCMD);
+
+		invalidate_dcache_range((unsigned long)(mxc_udc.mxc_ep[0].ep_qh),
+			CACHE_ALIGNED_END((mxc_udc.mxc_ep[0].ep_qh),
+				sizeof(struct ep_queue_head)));
+
+		memcpy((void *)s,
+			(void *)mxc_udc.mxc_ep[0].ep_qh->setup_data, 8);
+	} while (!(readl(USB_USBCMD) & USB_CMD_SUTW));
+
+	DBG("handle_setup s.type=%x req=%x len=%x\n",
+		s->bmRequestType, s->bRequest, s->wLength);
+	temp = readl(USB_USBCMD);
+	temp &= ~USB_CMD_SUTW;
+	writel(temp, USB_USBCMD);
+
+	DBG("[SETUP] type=%x req=%x val=%x index=%x len=%x\n",
+		s->bmRequestType, s->bRequest,
+		s->wValue, s->wIndex,
+		s->wLength);
+}
+
+static void mxc_udc_recv_setup(void)
+{
+	struct usb_device_request *s = &ep0_urb->device_request;
+
+	mxc_udc_read_setup_pkt(s);
+	if (s->wLength)	{
+		/* If has a data phase,
+		  * then prime a dtd for status stage which has zero length DATA0.
+		  * The direction of status stage should oppsite to direction of data phase.
+		  */
+		mxc_udc.ep0_dir = (s->bmRequestType & USB_DIR_IN) ?
+					USB_DIR_OUT : USB_DIR_IN;
+		mxc_udc_queue_update(0, NULL, 0, 0xffffffff);
+	}
+	if (ep0_recv_setup(ep0_urb)) {
+		mxc_ep0_stall();
+		return;
+	}
+	switch (s->bRequest) {
+	case USB_REQ_GET_STATUS:
+		if ((s->bmRequestType & (USB_DIR_IN | USB_TYPE_MASK)) !=
+					 (USB_DIR_IN | USB_TYPE_STANDARD))
+			break;
+		ch9getstatus(s->bmRequestType, s->wValue,
+				s->wIndex, s->wLength);
+
+		DBG("[SETUP] REQ_GET_STATUS\n");
+		return;
+	case USB_REQ_SET_ADDRESS:
+		if (s->bmRequestType != (USB_DIR_OUT |
+			    USB_TYPE_STANDARD | USB_RECIP_DEVICE))
+			break;
+		mxc_udc.setaddr = 1;
+		mxc_udc.ep0_dir = USB_DIR_IN;
+		mxc_udc_queue_update(0, NULL, 0, 0xffffffff);
+		usbd_device_event_irq(udc_device, DEVICE_ADDRESS_ASSIGNED, 0);
+		DBG("[SETUP] REQ_SET_ADDRESS\n");
+		return;
+	case USB_REQ_SET_CONFIGURATION:
+		usbd_device_event_irq(udc_device, DEVICE_CONFIGURED, 0);
+		DBG("[SETUP] REQ_SET_CONFIGURATION\n");
+	case USB_REQ_CLEAR_FEATURE:
+	case USB_REQ_SET_FEATURE:
+	{
+		int rc = -1;
+		if ((s->bmRequestType & (USB_RECIP_MASK | USB_TYPE_MASK)) ==
+				 (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD))
+			rc = 0;
+		else if ((s->bmRequestType &
+			    (USB_RECIP_MASK | USB_TYPE_MASK)) ==
+			     (USB_RECIP_DEVICE | USB_TYPE_STANDARD))
+			rc = 0;
+		else
+			break;
+		if (rc == 0) {
+			mxc_udc.ep0_dir = USB_DIR_IN;
+			mxc_udc_queue_update(0, NULL, 0, 0xffffffff);
+		}
+		return;
+	}
+	default:
+		break;
+	}
+	if (s->wLength) {
+		mxc_udc.ep0_dir = (s->bmRequestType & USB_DIR_IN) ?
+					USB_DIR_IN : USB_DIR_OUT;
+		mxc_udc_queue_update(0, ep0_urb->buffer,
+				ep0_urb->actual_length, 0xffffffff);
+		ep0_urb->actual_length = 0;
+	} else {
+		mxc_udc.ep0_dir = USB_DIR_IN;
+		mxc_udc_queue_update(0, NULL, 0, 0xffffffff);
+	}
+}
+
+static int mxc_udc_tqi_empty(struct ep_queue_item *tqi)
+{
+	int ret;
+
+	invalidate_dcache_range((unsigned long)tqi,
+		CACHE_ALIGNED_END(tqi, sizeof(struct ep_queue_item)));
+
+	ret = tqi->info & (1 << 7);
+	return ret;
+}
+
+static struct usb_endpoint_instance *mxc_get_epi(u8 epnum)
+{
+	int i;
+	for (i = 0; i < udc_device->bus->max_endpoints; i++) {
+		if ((udc_device->bus->endpoint_array[i].endpoint_address &
+			 USB_ENDPOINT_NUMBER_MASK) == epnum)
+			return &udc_device->bus->endpoint_array[i];
+	}
+	return NULL;
+}
+
+static u32 _mxc_ep_recv_data(u8 epnum, struct ep_queue_item *tqi)
+{
+	struct usb_endpoint_instance *epi = mxc_get_epi(epnum);
+	struct urb *urb;
+	u32 len = 0;
+
+	if (!epi)
+		return 0;
+
+	invalidate_dcache_range((unsigned long)tqi,
+		CACHE_ALIGNED_END(tqi, sizeof(struct ep_queue_item)));
+
+	urb = epi->rcv_urb;
+	if (urb) {
+		u8 *data = urb->buffer + urb->actual_length;
+		int remain_len = (tqi->info >> 16) & (0xefff);
+		len = tqi->reserved[0] - remain_len;
+		DBG("recv len %d-%d-%d\n", len, tqi->reserved[0], remain_len);
+
+
+		invalidate_dcache_range((unsigned long)tqi->page_vir,
+			CACHE_ALIGNED_END(tqi->page_vir, len));
+		memcpy(data, (void *)tqi->page_vir, len);
+
+		_dump_buf(data, len);
+	}
+	return len;
+}
+
+static void mxc_udc_ep_recv(u8 epnum)
+{
+	struct mxc_ep_t *ep = mxc_udc.mxc_ep + (epnum * 2 + USB_RECV);
+	struct ep_queue_item *tqi;
+	while (1) {
+		u32 nbytes;
+		tqi = ep->ep_dtd[ep->done];
+		if (mxc_udc_tqi_empty(tqi))
+			break;
+		nbytes = _mxc_ep_recv_data(epnum, tqi);
+		usbd_rcv_complete(ep->epi, nbytes, 0);
+		inc_index(ep->done);
+		if (ep->done == ep->index)
+			break;
+	}
+}
+
+static void mxc_udc_handle_xfer_complete(void)
+{
+	int i;
+	u32 bitpos = readl(USB_ENDPTCOMPLETE);
+
+	writel(bitpos, USB_ENDPTCOMPLETE);
+
+	for (i = 0; i < mxc_udc.max_ep; i++) {
+		int epnum = i >> 1;
+		int dir = i % 2;
+		u32 bitmask = 1 << (epnum + 16 * dir);
+		if (!(bitmask & bitpos))
+			continue;
+		DBG("ep %d, dir %d, complete\n", epnum, dir);
+		if (!epnum) {
+			if (mxc_udc.setaddr) {
+				writel(udc_device->address << 25,
+					USB_DEVICEADDR);
+				mxc_udc.setaddr = 0;
+			}
+			continue;
+		}
+		DBG("############### dir = %d ***************\n", dir);
+		if (dir == USB_SEND)
+			continue;
+		mxc_udc_ep_recv(epnum);
+	}
+}
+
+static void usb_dev_hand_usbint(void)
+{
+	if (readl(USB_ENDPTSETUPSTAT)) {
+		DBG("recv one setup packet\n");
+		mxc_udc_recv_setup();
+	}
+	if (readl(USB_ENDPTCOMPLETE)) {
+		DBG("Dtd complete irq\n");
+		mxc_udc_handle_xfer_complete();
+	}
+}
+
+static void usb_dev_hand_reset(void)
+{
+	u32 temp;
+	temp = readl(USB_DEVICEADDR);
+	temp &= ~0xfe000000;
+	writel(temp, USB_DEVICEADDR);
+	writel(readl(USB_ENDPTSETUPSTAT), USB_ENDPTSETUPSTAT);
+	writel(readl(USB_ENDPTCOMPLETE), USB_ENDPTCOMPLETE);
+	while (readl(USB_ENDPTPRIME))
+		;
+	writel(0xffffffff, USB_ENDPTFLUSH);
+	DBG("reset-PORTSC=%x\n", readl(USB_PORTSC1));
+	usbd_device_event_irq(udc_device, DEVICE_RESET, 0);
+}
+
+void usb_dev_hand_pci(void)
+{
+	u32 speed;
+	while (readl(USB_PORTSC1) & PORTSCX_PORT_RESET)
+		;
+	speed = readl(USB_PORTSC1) & PORTSCX_PORT_SPEED_MASK;
+	switch (speed) {
+	case PORTSCX_PORT_SPEED_HIGH:
+		usb_highspeed = 2;
+		break;
+	case PORTSCX_PORT_SPEED_FULL:
+		usb_highspeed = 1;
+		break;
+	case PORTSCX_PORT_SPEED_LOW:
+		usb_highspeed = 0;
+		break;
+	default:
+		break;
+	}
+	DBG("portspeed=%d, speed = %x, PORTSC = %x\n",
+		usb_highspeed, speed, readl(USB_PORTSC1));
+}
+
+void usb_dev_hand_suspend(void)
+{
+}
+
+void mxc_irq_poll(void)
+{
+	unsigned irq_src = readl(USB_USBSTS) & readl(USB_USBINTR);
+	writel(irq_src, USB_USBSTS);
+
+	if (irq_src == 0)
+		return;
+
+	if (irq_src & USB_STS_INT)
+		usb_dev_hand_usbint();
+
+	if (irq_src & USB_STS_RESET) {
+		printf("USB_RESET\n");
+		usb_dev_hand_reset();
+	}
+	if (irq_src & USB_STS_PORT_CHANGE) {
+		printf("USB_PORT_CHANGE 0x%x\n", irq_src);
+		usb_dev_hand_pci();
+	}
+	if (irq_src & USB_STS_SUSPEND)
+		printf("USB_SUSPEND\n");
+	if (irq_src & USB_STS_ERR)
+		printf("USB_ERR\n");
+}
+
+void mxc_udc_wait_cable_insert(void)
+{
+	u32 temp;
+	int cable_connect = 1;
+
+	do {
+		udelay(50);
+
+		temp = readl(USB_OTGSC);
+		if (temp & (OTGSC_B_SESSION_VALID)) {
+			printf("USB Mini b cable Connected!\n");
+			break;
+		} else if (cable_connect == 1) {
+			printf("wait usb cable into the connector!\n");
+			cable_connect = 0;
+		}
+	} while (1);
+}
+
+void udc_disable_over_current(void)
+{
+	u32 temp;
+	temp = readl(USB_OTG_CTRL);
+	temp |= (UCTRL_OVER_CUR_POL);
+	writel(temp, USB_OTG_CTRL);
+}
+
+/*
+ * mxc_udc_init function
+ */
+int mxc_udc_init(void)
+{
+    udc_pins_setting();
+	set_usb_phy1_clk();
+	enable_usboh3_clk(1);
+#if defined(CONFIG_MX6)
+	udc_disable_over_current();
+#endif
+	enable_usb_phy1_clk(1);
+	usb_udc_init();
+
+	return 0;
+}
+
+/*
+ * mxc_udc_init function
+ */
+int mxc_udc_destroy(void)
+{
+	usb_udc_destroy();
+	enable_usboh3_clk(0);
+	enable_usb_phy1_clk(0);
+
+	return 0;
+}
+
+void mxc_udc_poll(void)
+{
+	mxc_irq_poll();
+}
+
+/*
+ * Functions for gadget APIs
+ */
+int udc_init(void)
+{
+	mxc_udc_init();
+	return 0;
+}
+
+int udc_destroy(void)
+{
+	udc_disable();
+	mxc_udc_destroy();
+	return 0;
+}
+
+void udc_setup_ep(struct usb_device_instance *device, u32 index,
+		    struct usb_endpoint_instance *epi)
+{
+	u8 dir, epnum, zlt, mult;
+	u8 ep_type;
+	u32 max_pkt_size;
+	int ep_addr;
+	struct mxc_ep_t *ep;
+
+	if (epi) {
+		zlt = 1;
+		mult = 0;
+		ep_addr = epi->endpoint_address;
+		epnum = ep_addr & USB_ENDPOINT_NUMBER_MASK;
+		DBG("setup ep %d\n", epnum);
+		if ((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN) {
+			dir = USB_SEND;
+			ep_type = epi->tx_attributes;
+			max_pkt_size = epi->tx_packetSize;
+		} else {
+			dir = USB_RECV;
+			ep_type = epi->rcv_attributes;
+			max_pkt_size = epi->rcv_packetSize;
+		}
+		if (ep_type == USB_ENDPOINT_XFER_ISOC) {
+			mult = (u32)(1 + ((max_pkt_size >> 11) & 0x03));
+			max_pkt_size = max_pkt_size & 0x7ff;
+			DBG("mult = %d\n", mult);
+		}
+		ep = mxc_udc.mxc_ep + (epnum * 2 + dir);
+		ep->epi = epi;
+		if (epnum) {
+			struct ep_queue_item *tqi;
+			int i;
+
+			mxc_ep_qh_setup(epnum, dir, ep_type,
+					    max_pkt_size, zlt, mult);
+			mxc_ep_setup(epnum, dir, ep_type);
+			mxc_init_ep_dtd(epnum * 2 + dir);
+
+			/* malloc endpoint's dtd's data buffer*/
+			ep->max_pkt_size = max_pkt_size;
+			for (i = 0; i < EP_TQ_ITEM_SIZE; i++) {
+				tqi = ep->ep_dtd[i];
+				tqi->page_vir = (u32)malloc_aligned_buffer(
+					    &tqi->page_unaligned, max_pkt_size,
+					    USB_MEM_ALIGN_BYTE);
+				if ((void *)tqi->page_vir == NULL) {
+					printf("malloc dtd bufer failure\n");
+					return;
+				}
+				mxc_tqi_init_page(tqi);
+
+				flush_dcache_range((unsigned long)tqi,
+					CACHE_ALIGNED_END(tqi, sizeof(struct ep_queue_item)));
+			}
+		}
+	}
+}
+
+void udc_destroy_ep(struct usb_device_instance *device,
+		    struct usb_endpoint_instance *epi)
+{
+	struct mxc_ep_t *ep;
+	int ep_addr;
+	u8 dir, epnum;
+
+	if (epi) {
+		ep_addr = epi->endpoint_address;
+		epnum = ep_addr & USB_ENDPOINT_NUMBER_MASK;
+
+		if ((ep_addr & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)
+			dir = USB_SEND;
+		else
+			dir = USB_RECV;
+
+		ep = mxc_udc.mxc_ep + (epnum * 2 + dir);
+		ep->epi = 0;
+
+		if (epnum) {
+			struct ep_queue_item *tqi;
+			int i;
+
+			for (i = 0; i < EP_TQ_ITEM_SIZE; i++) {
+				tqi = ep->ep_dtd[i];
+				if (tqi->page_vir) {
+					free((void *)(tqi->page_unaligned));
+					tqi->page_unaligned = 0;
+					tqi->page_vir = 0;
+					tqi->page0 = 0;
+					tqi->page1 = 0;
+					tqi->page2 = 0;
+					tqi->page3 = 0;
+					tqi->page4 = 0;
+				}
+			}
+
+			mxc_destroy_ep_dtd(epnum * 2 + dir);
+			mxc_ep_destroy(epnum, dir);
+		}
+	}
+}
+
+int udc_endpoint_write(struct usb_endpoint_instance *epi)
+{
+	struct urb *urb = epi->tx_urb;
+	int ep_num = epi->endpoint_address & USB_ENDPOINT_NUMBER_MASK;
+	u8 *data = (u8 *)urb->buffer + epi->sent;
+	int n = urb->actual_length - epi->sent;
+	mxc_udc_txqueue_update(ep_num, data, n);
+	epi->last = n;
+
+	/* usbd_tx_complete will take care of updating 'sent' */
+	usbd_tx_complete(epi);
+	return 0;
+}
+
+void udc_enable(struct usb_device_instance *device)
+{
+	udc_device = device;
+	ep0_urb = usbd_alloc_urb(udc_device, udc_device->bus->endpoint_array);
+}
+
+void udc_disable(void)
+{
+	usbd_dealloc_urb(ep0_urb);
+	udc_device = NULL;
+}
+
+void udc_startup_events(struct usb_device_instance *device)
+{
+	usbd_device_event_irq(device, DEVICE_INIT, 0);
+	usbd_device_event_irq(device, DEVICE_CREATE, 0);
+	udc_enable(device);
+}
+
+void udc_irq(void)
+{
+	mxc_irq_poll();
+}
+
+void udc_connect(void)
+{
+	mxc_usb_run();
+	mxc_udc_wait_cable_insert();
+}
+
+void udc_disconnect(void)
+{
+	/* imx6 will hang if access usb register without init oh3
+	 * clock, so not access it if not init. */
+	if (usb_inited)
+		mxc_usb_stop();
+}
+
+void udc_set_nak(int epid)
+{
+}
+
+void udc_unset_nak(int epid)
+{
+}
diff --git a/drivers/usb/host/ehci-mx6.c b/drivers/usb/host/ehci-mx6.c
index c0a557b..005cf36 100644
--- a/drivers/usb/host/ehci-mx6.c
+++ b/drivers/usb/host/ehci-mx6.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2009 Daniel Mack <daniel@caiaq.de>
- * Copyright (C) 2010 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -11,7 +11,7 @@
 #include <linux/compiler.h>
 #include <usb/ehci-fsl.h>
 #include <asm/io.h>
-#include <asm/arch/imx-regs.h>
+#include <asm/arch/crm_regs.h>
 #include <asm/arch/clock.h>
 #include <asm/imx-common/iomux-v3.h>
 
@@ -45,7 +45,7 @@
 #define ANADIG_USB2_PLL_480_CTRL_POWER		0x00001000
 #define ANADIG_USB2_PLL_480_CTRL_EN_USB_CLKS	0x00000040
 
-
+#define UCTRL_PM		(1 << 9)	/* OTG Power Mask */
 #define UCTRL_OVER_CUR_POL	(1 << 8) /* OTG Polarity of Overcurrent */
 #define UCTRL_OVER_CUR_DIS	(1 << 7) /* Disable OTG Overcurrent Detection */
 
@@ -72,22 +72,22 @@ static void usb_internal_phy_clock_gate(int index, int on)
 
 static void usb_power_config(int index)
 {
-	struct anatop_regs __iomem *anatop =
-		(struct anatop_regs __iomem *)ANATOP_BASE_ADDR;
+	struct mxc_ccm_reg __iomem *ccm_regs =
+		(struct mxc_ccm_reg __iomem *)CCM_BASE_ADDR;
 	void __iomem *chrg_detect;
 	void __iomem *pll_480_ctrl_clr;
 	void __iomem *pll_480_ctrl_set;
 
 	switch (index) {
 	case 0:
-		chrg_detect = &anatop->usb1_chrg_detect;
-		pll_480_ctrl_clr = &anatop->usb1_pll_480_ctrl_clr;
-		pll_480_ctrl_set = &anatop->usb1_pll_480_ctrl_set;
+		chrg_detect = &ccm_regs->usb1_chrg_detect;
+		pll_480_ctrl_clr = &ccm_regs->analog_usb1_pll_480_ctrl_clr;
+		pll_480_ctrl_set = &ccm_regs->analog_usb1_pll_480_ctrl_set;
 		break;
 	case 1:
-		chrg_detect = &anatop->usb2_chrg_detect;
-		pll_480_ctrl_clr = &anatop->usb2_pll_480_ctrl_clr;
-		pll_480_ctrl_set = &anatop->usb2_pll_480_ctrl_set;
+		chrg_detect = &ccm_regs->usb2_chrg_detect;
+		pll_480_ctrl_clr = &ccm_regs->analog_usb2_pll_480_ctrl_clr;
+		pll_480_ctrl_set = &ccm_regs->analog_usb2_pll_480_ctrl_set;
 		break;
 	default:
 		return;
@@ -174,7 +174,7 @@ struct usbnc_regs {
 
 static void usb_oc_config(int index)
 {
-	struct usbnc_regs *usbnc = (struct usbnc_regs *)(USBOH3_USB_BASE_ADDR +
+	struct usbnc_regs *usbnc = (struct usbnc_regs *)(USB_BASE_ADDR +
 			USB_OTHERREGS_OFFSET);
 	void __iomem *ctrl = (void __iomem *)(&usbnc->ctrl[index]);
 	u32 val;
@@ -189,7 +189,7 @@ static void usb_oc_config(int index)
 	__raw_writel(val, ctrl);
 
 	val = __raw_readl(ctrl);
-	val |= UCTRL_OVER_CUR_DIS;
+	val |= (UCTRL_OVER_CUR_DIS | UCTRL_PM);
 	__raw_writel(val, ctrl);
 }
 
@@ -206,8 +206,7 @@ int __weak board_ehci_power(int port, int on)
 int ehci_hcd_init(int index, enum usb_init_type init,
 		struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 {
-	enum usb_init_type type;
-	struct usb_ehci *ehci = (struct usb_ehci *)(USBOH3_USB_BASE_ADDR +
+	struct usb_ehci *ehci = (struct usb_ehci *)(USB_BASE_ADDR +
 		(0x200 * index));
 
 	if (index > 3)
@@ -221,17 +220,14 @@ int ehci_hcd_init(int index, enum usb_init_type init,
 	usb_power_config(index);
 	usb_oc_config(index);
 	usb_internal_phy_clock_gate(index, 1);
-	type = usb_phy_enable(index, ehci) ? USB_INIT_DEVICE : USB_INIT_HOST;
+	usb_phy_enable(index, ehci);
 
 	*hccr = (struct ehci_hccr *)((uint32_t)&ehci->caplength);
 	*hcor = (struct ehci_hcor *)((uint32_t)*hccr +
 			HC_LENGTH(ehci_readl(&(*hccr)->cr_capbase)));
 
-	if ((type == init) || (type == USB_INIT_DEVICE))
-		board_ehci_power(index, (type == USB_INIT_DEVICE) ? 0 : 1);
-	if (type != init)
-		return -ENODEV;
-	if (type == USB_INIT_DEVICE)
+	board_ehci_power(index, (init == USB_INIT_DEVICE) ? 0 : 1);
+	if (init == USB_INIT_DEVICE)
 		return 0;
 	setbits_le32(&ehci->usbmode, CM_HOST);
 	__raw_writel(CONFIG_MXC_USB_PORTSC, &ehci->portsc);
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index c527029..bcfc1f1 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -40,3 +40,8 @@ obj-$(CONFIG_VIDEO_SMI_LYNXEM) += smiLynxEM.o videomodes.o
 obj-$(CONFIG_VIDEO_TEGRA) += tegra.o
 obj-$(CONFIG_VIDEO_VCXK) += bus_vcxk.o
 obj-$(CONFIG_FORMIKE) += formike.o
+obj-$(CONFIG_MXC_EPDC) += mxc_epdc_fb.o
+obj-$(CONFIG_VIDEO_VADC) += mxc_vadc.o
+obj-$(CONFIG_VIDEO_CSI) += mxc_csi.o
+obj-$(CONFIG_VIDEO_PXP) += mxc_pxp.o
+obj-$(CONFIG_VIDEO_GIS) += mxc_gis.o
\ No newline at end of file
diff --git a/drivers/video/atmel_lcdfb.c b/drivers/video/atmel_lcdfb.c
index 3cf008c..9c9cd38 100644
--- a/drivers/video/atmel_lcdfb.c
+++ b/drivers/video/atmel_lcdfb.c
@@ -17,7 +17,7 @@
 #define ATMEL_LCDC_CVAL_DEFAULT		0xc8
 #define ATMEL_LCDC_DMA_BURST_LEN	8
 #ifndef ATMEL_LCDC_GUARD_TIME
-#define ATMEL_LCDC_GUARD_TIME		1
+#define ATMEL_LCDC_GUARD_TIME		9
 #endif
 
 #if defined(CONFIG_AT91SAM9263) || defined(CONFIG_AT91CAP9)
@@ -67,7 +67,6 @@ void lcd_ctrl_init(void *lcdbase)
 	value = get_lcdc_clk_rate(0) / panel_info.vl_clk;
 	if (get_lcdc_clk_rate(0) % panel_info.vl_clk)
 		value++;
-	value = (value / 2) - 1;
 
 	if (!value) {
 		lcdc_writel(panel_info.mmio, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);
@@ -85,7 +84,11 @@ void lcd_ctrl_init(void *lcdbase)
 		value |= ATMEL_LCDC_DISTYPE_TFT;
 
 	value |= panel_info.vl_sync;
+#if LCD_BPP == LCD_COLOR32
+	value |= (6 << 5);
+#else
 	value |= (panel_info.vl_bpix << 5);
+#endif
 	lcdc_writel(panel_info.mmio, ATMEL_LCDC_LCDCON2, value);
 
 	/* Vertical timing */
diff --git a/drivers/video/cfb_console.c b/drivers/video/cfb_console.c
index b52e9ed..dece48f 100644
--- a/drivers/video/cfb_console.c
+++ b/drivers/video/cfb_console.c
@@ -2224,6 +2224,7 @@ static int video_init(void)
 	video_console_address = video_logo();
 #else
 	video_console_address = video_fb_address;
+        video_drawstring(VIDEO_FONT_WIDTH, 0, (uchar *)version_string);
 #endif
 
 	/* Initialize the console */
diff --git a/drivers/video/ipu.h b/drivers/video/ipu.h
index 3d2741f..a3dce8f 100644
--- a/drivers/video/ipu.h
+++ b/drivers/video/ipu.h
@@ -6,7 +6,7 @@
  *
  * Linux IPU driver for MX51:
  *
- * (C) Copyright 2005-2010 Freescale Semiconductor, Inc.
+ * (C) Copyright 2005-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -176,6 +176,14 @@ typedef union {
 } ipu_channel_params_t;
 
 /*
+ * Enumeration of IPU interrupts.
+ */
+enum ipu_irq_line {
+	IPU_IRQ_DP_SF_END = 448 + 3,
+	IPU_IRQ_DC_FC_1 = 448 + 9,
+};
+
+/*
  * Bitfield of Display Interface signal polarities.
  */
 typedef struct {
diff --git a/drivers/video/ipu_common.c b/drivers/video/ipu_common.c
index 8d4e925..92db82d 100644
--- a/drivers/video/ipu_common.c
+++ b/drivers/video/ipu_common.c
@@ -6,7 +6,7 @@
  *
  * Linux IPU driver for MX51:
  *
- * (C) Copyright 2005-2010 Freescale Semiconductor, Inc.
+ * (C) Copyright 2005-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -19,6 +19,7 @@
 #include <asm/errno.h>
 #include <asm/arch/imx-regs.h>
 #include <asm/arch/crm_regs.h>
+#include <div64.h>
 #include "ipu.h"
 #include "ipu_regs.h"
 
@@ -271,50 +272,80 @@ static inline void ipu_ch_param_set_buffer(uint32_t ch, int bufNum,
 
 static void ipu_pixel_clk_recalc(struct clk *clk)
 {
-	u32 div = __raw_readl(DI_BS_CLKGEN0(clk->id));
-	if (div == 0)
-		clk->rate = 0;
-	else
-		clk->rate = (clk->parent->rate * 16) / div;
+	u32 div;
+	u64 final_rate = (unsigned long long)clk->parent->rate * 16;
+
+	div = __raw_readl(DI_BS_CLKGEN0(clk->id));
+	debug("read BS_CLKGEN0 div:%d, final_rate:%lld, prate:%ld\n",
+			div, final_rate, clk->parent->rate);
+
+	clk->rate = 0;
+	if (div != 0) {
+		do_div(final_rate, div);
+		clk->rate = final_rate;
+	}
 }
 
 static unsigned long ipu_pixel_clk_round_rate(struct clk *clk,
 	unsigned long rate)
 {
-	u32 div, div1;
-	u32 tmp;
+	u64 div, final_rate;
+	u32 remainder;
+	u64 parent_rate = (unsigned long long)clk->parent->rate * 16;
+
 	/*
 	 * Calculate divider
 	 * Fractional part is 4 bits,
 	 * so simply multiply by 2^4 to get fractional part.
 	 */
-	tmp = (clk->parent->rate * 16);
-	div = tmp / rate;
-
+	div = parent_rate;
+	remainder = do_div(div, rate);
+	/* Round the divider value */
+	if (remainder > (rate/2))
+		div++;
 	if (div < 0x10)            /* Min DI disp clock divider is 1 */
 		div = 0x10;
 	if (div & ~0xFEF)
 		div &= 0xFF8;
 	else {
-		div1 = div & 0xFE0;
-		if ((tmp/div1 - tmp/div) < rate / 4)
-			div = div1;
-		else
-			div &= 0xFF8;
+		/* Round up divider if it gets us closer to desired pix clk */
+		if ((div & 0xC) == 0xC) {
+			div += 0x10;
+			div &= ~0xF;
+		}
 	}
-	return (clk->parent->rate * 16) / div;
+	final_rate = parent_rate;
+	do_div(final_rate, div);
+
+	return final_rate;
 }
 
 static int ipu_pixel_clk_set_rate(struct clk *clk, unsigned long rate)
 {
-	u32 div = (clk->parent->rate * 16) / rate;
+	u64 div, parent_rate;
+	u32 remainder;
+
+	parent_rate = (unsigned long long)clk->parent->rate * 16;
+	div = parent_rate;
+	remainder = do_div(div, rate);
+	/* Round the divider value */
+	if (remainder > (rate/2))
+		div++;
+
+	/* Round up divider if it gets us closer to desired pix clk */
+	if ((div & 0xC) == 0xC) {
+		div += 0x10;
+		div &= ~0xF;
+	}
+	if (div > 0x1000)
+		debug("Overflow, DI_BS_CLKGEN0 div:0x%x\n", (u32)div);
 
 	__raw_writel(div, DI_BS_CLKGEN0(clk->id));
 
 	/* Setup pixel clock timing */
+	/* Down time is half of period */
 	__raw_writel((div / 16) << 16, DI_BS_CLKGEN1(clk->id));
 
-	clk->rate = (clk->parent->rate * 16) / div;
 	return 0;
 }
 
diff --git a/drivers/video/ipu_disp.c b/drivers/video/ipu_disp.c
index cefd2dc..5bfe89e 100644
--- a/drivers/video/ipu_disp.c
+++ b/drivers/video/ipu_disp.c
@@ -6,7 +6,7 @@
  *
  * Linux IPU driver for MX51:
  *
- * (C) Copyright 2005-2010 Freescale Semiconductor, Inc.
+ * (C) Copyright 2005-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -666,13 +666,16 @@ void ipu_dp_dc_disable(ipu_channel_t channel, unsigned char swap)
 	uint32_t csc;
 	uint32_t dc_chan = 0;
 	int timeout = 50;
+	int irq = 0;
 
 	dc_swap = swap;
 
 	if (channel == MEM_DC_SYNC) {
 		dc_chan = 1;
+		irq = IPU_IRQ_DC_FC_1;
 	} else if (channel == MEM_BG_SYNC) {
 		dc_chan = 5;
+		irq = IPU_IRQ_DP_SF_END;
 	} else if (channel == MEM_FG_SYNC) {
 		/* Disable FG channel */
 		dc_chan = 5;
@@ -723,25 +726,11 @@ void ipu_dp_dc_disable(ipu_channel_t channel, unsigned char swap)
 		reg ^= DC_WR_CH_CONF_PROG_DI_ID;
 		__raw_writel(reg, DC_WR_CH_CONF(dc_chan));
 	} else {
-		timeout = 50;
-
-		/* Wait for DC triple buffer to empty */
-		if (g_dc_di_assignment[dc_chan] == 0)
-			while ((__raw_readl(DC_STAT) & 0x00000002)
-				!= 0x00000002) {
-				udelay(2000);
-				timeout -= 2;
-				if (timeout <= 0)
-					break;
-			}
-		else if (g_dc_di_assignment[dc_chan] == 1)
-			while ((__raw_readl(DC_STAT) & 0x00000020)
-				!= 0x00000020) {
-				udelay(2000);
-				timeout -= 2;
-				if (timeout <= 0)
-					break;
-			}
+		/* Make sure that we leave at the irq starting edge */
+		__raw_writel(IPUIRQ_2_MASK(irq), IPUIRQ_2_STATREG(irq));
+		do {
+			reg = __raw_readl(IPUIRQ_2_STATREG(irq));
+		} while (!(reg & IPUIRQ_2_MASK(irq)));
 
 		reg = __raw_readl(DC_WR_CH_CONF(dc_chan));
 		reg &= ~DC_WR_CH_CONF_PROG_TYPE_MASK;
diff --git a/drivers/video/ipu_regs.h b/drivers/video/ipu_regs.h
index 21e9c99..f800405 100644
--- a/drivers/video/ipu_regs.h
+++ b/drivers/video/ipu_regs.h
@@ -6,7 +6,7 @@
  *
  * Linux IPU driver for MX51:
  *
- * (C) Copyright 2005-2009 Freescale Semiconductor, Inc.
+ * (C) Copyright 2005-2014 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -313,9 +313,12 @@ struct ipu_dmfc {
 
 #define IPU_STAT		((struct ipu_stat *)(IPU_CTRL_BASE_ADDR + \
 				IPU_STAT_REG_BASE))
+#define IPU_INT_STAT(n)		(&IPU_STAT->int_stat[(n) - 1])
 #define IPU_CHA_CUR_BUF(ch)	(&IPU_STAT->cur_buf[ch / 32])
 #define IPU_CHA_BUF0_RDY(ch)	(&IPU_STAT->ch_buf0_rdy[ch / 32])
 #define IPU_CHA_BUF1_RDY(ch)	(&IPU_STAT->ch_buf1_rdy[ch / 32])
+#define IPUIRQ_2_STATREG(irq)	(IPU_INT_STAT(1) + ((irq) / 32))
+#define IPUIRQ_2_MASK(irq)	(1UL << ((irq) & 0x1F))
 
 #define IPU_INT_CTRL(n)		(&IPU_CM_REG->int_ctrl[(n) - 1])
 
diff --git a/drivers/video/mxc_csi.c b/drivers/video/mxc_csi.c
new file mode 100644
index 0000000..d0543bc
--- /dev/null
+++ b/drivers/video/mxc_csi.c
@@ -0,0 +1,272 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*!
+ * @file fsl_csi.c, this file is derived from mx27_csi.c
+ *
+ * @brief mx25 CMOS Sensor interface functions
+ *
+ * @ingroup CSI
+ */
+#include <common.h>
+#include <malloc.h>
+
+#include <asm/arch/imx-regs.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <linux/string.h>
+#include <linux/list.h>
+
+#include "mxc_csi.h"
+
+enum {
+	STD_NTSC = 0,
+	STD_PAL,
+};
+
+void __iomem *csi_regbase;
+
+static void csihw_reset_frame_count(void)
+{
+	__raw_writel(__raw_readl(CSI_CSICR3) | BIT_FRMCNT_RST, CSI_CSICR3);
+}
+
+static void csihw_reset(void)
+{
+	csihw_reset_frame_count();
+	__raw_writel(CSICR1_RESET_VAL, CSI_CSICR1);
+	__raw_writel(CSICR2_RESET_VAL, CSI_CSICR2);
+	__raw_writel(CSICR3_RESET_VAL, CSI_CSICR3);
+}
+
+/*!
+ * csi_init_interface
+ *    Init csi interface
+ */
+void csi_init_interface(void)
+{
+	unsigned int val = 0;
+	unsigned int imag_para;
+
+	val |= BIT_SOF_POL;
+	val |= BIT_REDGE;
+	val |= BIT_GCLK_MODE;
+	val |= BIT_HSYNC_POL;
+	val |= BIT_FCC;
+	val |= 1 << SHIFT_MCLKDIV;
+	val |= BIT_MCLKEN;
+	__raw_writel(val, CSI_CSICR1);
+
+	imag_para = (640 << 16) | 960;
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+	val = 0x1010;
+	val |= BIT_DMA_REFLASH_RFF;
+	__raw_writel(val, CSI_CSICR3);
+}
+
+void csi_format_swap16(bool enable)
+{
+	unsigned int val;
+
+	val = __raw_readl(CSI_CSICR1);
+	if (enable) {
+		val |= BIT_PACK_DIR;
+		val |= BIT_SWAP16_EN;
+	} else {
+		val &= ~BIT_PACK_DIR;
+		val &= ~BIT_SWAP16_EN;
+	}
+
+	__raw_writel(val, CSI_CSICR1);
+}
+
+void csi_enable_int(int arg)
+{
+	unsigned long cr1 = __raw_readl(CSI_CSICR1);
+
+	if (arg == 1) {
+		/* still capture needs DMA intterrupt */
+		cr1 |= BIT_FB1_DMA_DONE_INTEN;
+		cr1 |= BIT_FB2_DMA_DONE_INTEN;
+	}
+	__raw_writel(cr1, CSI_CSICR1);
+}
+
+void csi_disable_int(void)
+{
+	unsigned long cr1 = __raw_readl(CSI_CSICR1);
+
+	cr1 &= ~BIT_FB1_DMA_DONE_INTEN;
+	cr1 &= ~BIT_FB2_DMA_DONE_INTEN;
+	__raw_writel(cr1, CSI_CSICR1);
+}
+
+void csi_enable(int arg)
+{
+	unsigned long cr = __raw_readl(CSI_CSICR18);
+
+	if (arg == 1)
+		cr |= BIT_CSI_ENABLE;
+	else
+		cr &= ~BIT_CSI_ENABLE;
+	__raw_writel(cr, CSI_CSICR18);
+}
+
+void csi_buf_stride_set(u32 stride)
+{
+	__raw_writel(stride, CSI_CSIFBUF_PARA);
+}
+
+void csi_deinterlace_enable(bool enable)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+
+	if (enable == true)
+		cr18 |= BIT_DEINTERLACE_EN;
+	else
+		cr18 &= ~BIT_DEINTERLACE_EN;
+
+	__raw_writel(cr18, CSI_CSICR18);
+}
+
+void csi_deinterlace_mode(int mode)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+
+	if (mode == STD_NTSC)
+		cr18 |= BIT_NTSC_EN;
+	else
+		cr18 &= ~BIT_NTSC_EN;
+
+	__raw_writel(cr18, CSI_CSICR18);
+}
+
+void csi_tvdec_enable(bool enable)
+{
+	unsigned long cr18 = __raw_readl(CSI_CSICR18);
+	unsigned long cr1 = __raw_readl(CSI_CSICR1);
+
+	if (enable == true) {
+		cr18 |= (BIT_TVDECODER_IN_EN | BIT_BASEADDR_SWITCH_EN);
+		cr1 |= BIT_CCIR_MODE | BIT_EXT_VSYNC;
+		cr1 &= ~(BIT_SOF_POL | BIT_REDGE);
+	} else {
+		cr18 &= ~(BIT_TVDECODER_IN_EN | BIT_BASEADDR_SWITCH_EN);
+		cr1 &= ~(BIT_CCIR_MODE | BIT_EXT_VSYNC);
+		cr1 |= BIT_SOF_POL | BIT_REDGE;
+	}
+
+	__raw_writel(cr18, CSI_CSICR18);
+	__raw_writel(cr1, CSI_CSICR1);
+}
+
+void csi_set_32bit_imagpara(int width, int height)
+{
+	int imag_para = 0;
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	imag_para = (width << 16) | height;
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+
+	/* reflash the embeded DMA controller */
+	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+}
+
+void csi_set_16bit_imagpara(int width, int height)
+{
+	int imag_para = 0;
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	imag_para = (width << 16) | (height * 2);
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+	/* reflash the embeded DMA controller */
+	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+}
+
+void csi_set_12bit_imagpara(int width, int height)
+{
+	int imag_para = 0;
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	imag_para = (width << 16) | (height * 3 / 2);
+	__raw_writel(imag_para, CSI_CSIIMAG_PARA);
+
+	/* reflash the embeded DMA controller */
+	__raw_writel(cr3 | BIT_DMA_REFLASH_RFF, CSI_CSICR3);
+}
+
+void csi_dmareq_rff_enable(void)
+{
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	cr3 |= BIT_DMA_REQ_EN_RFF;
+	cr3 |= BIT_HRESP_ERR_EN;
+	__raw_writel(cr3, CSI_CSICR3);
+}
+
+void csi_dmareq_rff_disable(void)
+{
+	unsigned long cr3 = __raw_readl(CSI_CSICR3);
+
+	cr3 &= ~BIT_DMA_REQ_EN_RFF;
+	cr3 &= ~BIT_HRESP_ERR_EN;
+	__raw_writel(cr3, CSI_CSICR3);
+}
+
+void csi_disable(void)
+{
+	csi_dmareq_rff_disable();
+	csi_disable_int();
+	csi_buf_stride_set(0);
+	csi_deinterlace_enable(false);
+	csi_tvdec_enable(false);
+	csi_enable(0);
+}
+
+void csi_config(struct csi_conf_param *csi_conf)
+{
+	csi_regbase = (u32 *)CSI1_BASE_ADDR;
+
+	csihw_reset();
+
+	csi_init_interface();
+	csi_dmareq_rff_disable();
+
+	switch (csi_conf->bpp) {
+	case 32:
+		csi_set_32bit_imagpara(csi_conf->width, csi_conf->height);
+		break;
+	case 16:
+		csi_set_16bit_imagpara(csi_conf->width, csi_conf->height);
+		break;
+	default:
+		printf(" %s case not supported, bpp=%d\n",
+				__func__, csi_conf->bpp);
+		return;
+	}
+
+	__raw_writel((u32)csi_conf->fb0addr, CSI_CSIDMASA_FB1);
+	__raw_writel((u32)csi_conf->fb1addr, CSI_CSIDMASA_FB2);
+
+	csi_buf_stride_set(0);
+	if (csi_conf->btvmode) {
+		/* Enable csi PAL/NTSC deinterlace mode */
+		csi_buf_stride_set(csi_conf->width);
+		csi_deinterlace_mode(csi_conf->std);
+		csi_deinterlace_enable(true);
+		csi_tvdec_enable(true);
+	}
+
+	/* start csi */
+	csi_dmareq_rff_enable();
+	csi_enable_int(1);
+	csi_enable(1);
+}
+
diff --git a/drivers/video/mxc_csi.h b/drivers/video/mxc_csi.h
new file mode 100644
index 0000000..ef671e4
--- /dev/null
+++ b/drivers/video/mxc_csi.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*!
+ * @file mxc_csi.h
+ *
+ * @brief mxc CMOS Sensor interface functions
+ *
+ * @ingroup CSI
+ */
+
+#ifndef MXC_CSI_H
+#define MXC_CSI_H
+
+/* reset values */
+#define CSICR1_RESET_VAL	0x40000800
+#define CSICR2_RESET_VAL	0x0
+#define CSICR3_RESET_VAL	0x0
+
+/* csi control reg 1 */
+#define BIT_SWAP16_EN		(0x1 << 31)
+#define BIT_EXT_VSYNC		(0x1 << 30)
+#define BIT_EOF_INT_EN		(0x1 << 29)
+#define BIT_PRP_IF_EN		(0x1 << 28)
+#define BIT_CCIR_MODE		(0x1 << 27)
+#define BIT_COF_INT_EN		(0x1 << 26)
+#define BIT_SF_OR_INTEN		(0x1 << 25)
+#define BIT_RF_OR_INTEN		(0x1 << 24)
+#define BIT_SFF_DMA_DONE_INTEN  (0x1 << 22)
+#define BIT_STATFF_INTEN	(0x1 << 21)
+#define BIT_FB2_DMA_DONE_INTEN  (0x1 << 20)
+#define BIT_FB1_DMA_DONE_INTEN  (0x1 << 19)
+#define BIT_RXFF_INTEN		(0x1 << 18)
+#define BIT_SOF_POL		(0x1 << 17)
+#define BIT_SOF_INTEN		(0x1 << 16)
+#define BIT_MCLKDIV		(0xF << 12)
+#define BIT_HSYNC_POL		(0x1 << 11)
+#define BIT_CCIR_EN		(0x1 << 10)
+#define BIT_MCLKEN		(0x1 << 9)
+#define BIT_FCC			(0x1 << 8)
+#define BIT_PACK_DIR		(0x1 << 7)
+#define BIT_CLR_STATFIFO	(0x1 << 6)
+#define BIT_CLR_RXFIFO		(0x1 << 5)
+#define BIT_GCLK_MODE		(0x1 << 4)
+#define BIT_INV_DATA		(0x1 << 3)
+#define BIT_INV_PCLK		(0x1 << 2)
+#define BIT_REDGE		(0x1 << 1)
+#define BIT_PIXEL_BIT		(0x1 << 0)
+
+#define SHIFT_MCLKDIV		12
+
+/* control reg 3 */
+#define BIT_FRMCNT		(0xFFFF << 16)
+#define BIT_FRMCNT_RST		(0x1 << 15)
+#define BIT_DMA_REFLASH_RFF	(0x1 << 14)
+#define BIT_DMA_REFLASH_SFF	(0x1 << 13)
+#define BIT_DMA_REQ_EN_RFF	(0x1 << 12)
+#define BIT_DMA_REQ_EN_SFF	(0x1 << 11)
+#define BIT_STATFF_LEVEL	(0x7 << 8)
+#define BIT_HRESP_ERR_EN	(0x1 << 7)
+#define BIT_RXFF_LEVEL		(0x7 << 4)
+#define BIT_TWO_8BIT_SENSOR	(0x1 << 3)
+#define BIT_ZERO_PACK_EN	(0x1 << 2)
+#define BIT_ECC_INT_EN		(0x1 << 1)
+#define BIT_ECC_AUTO_EN		(0x1 << 0)
+
+#define SHIFT_FRMCNT		16
+
+/* csi status reg */
+#define BIT_SFF_OR_INT		(0x1 << 25)
+#define BIT_RFF_OR_INT		(0x1 << 24)
+#define BIT_DMA_TSF_DONE_SFF	(0x1 << 22)
+#define BIT_STATFF_INT		(0x1 << 21)
+#define BIT_DMA_TSF_DONE_FB2	(0x1 << 20)
+#define BIT_DMA_TSF_DONE_FB1	(0x1 << 19)
+#define BIT_RXFF_INT		(0x1 << 18)
+#define BIT_EOF_INT		(0x1 << 17)
+#define BIT_SOF_INT		(0x1 << 16)
+#define BIT_F2_INT		(0x1 << 15)
+#define BIT_F1_INT		(0x1 << 14)
+#define BIT_COF_INT		(0x1 << 13)
+#define BIT_HRESP_ERR_INT	(0x1 << 7)
+#define BIT_ECC_INT		(0x1 << 1)
+#define BIT_DRDY		(0x1 << 0)
+
+/* csi control reg 18 */
+#define BIT_CSI_ENABLE			(0x1 << 31)
+#define BIT_BASEADDR_SWITCH_SEL	(0x1 << 5)
+#define BIT_BASEADDR_SWITCH_EN	(0x1 << 4)
+#define BIT_PARALLEL24_EN		(0x1 << 3)
+#define BIT_DEINTERLACE_EN		(0x1 << 2)
+#define BIT_TVDECODER_IN_EN		(0x1 << 1)
+#define BIT_NTSC_EN				(0x1 << 0)
+
+#define CSI_MCLK_VF		1
+#define CSI_MCLK_ENC		2
+#define CSI_MCLK_RAW		4
+#define CSI_MCLK_I2C		8
+
+#define CSI_CSICR1				(csi_regbase)
+#define CSI_CSICR2				(csi_regbase + 0x4)
+#define CSI_CSICR3				(csi_regbase + 0x8)
+#define CSI_STATFIFO			(csi_regbase + 0xC)
+#define CSI_CSIRXFIFO			(csi_regbase + 0x10)
+#define CSI_CSIRXCNT			(csi_regbase + 0x14)
+#define CSI_CSISR				(csi_regbase + 0x18)
+#define CSI_CSIDBG				(csi_regbase + 0x1C)
+#define CSI_CSIDMASA_STATFIFO	(csi_regbase + 0x20)
+#define CSI_CSIDMATS_STATFIFO	(csi_regbase + 0x24)
+#define CSI_CSIDMASA_FB1		(csi_regbase + 0x28)
+#define CSI_CSIDMASA_FB2		(csi_regbase + 0x2C)
+#define CSI_CSIFBUF_PARA		(csi_regbase + 0x30)
+#define CSI_CSIIMAG_PARA		(csi_regbase + 0x34)
+#define CSI_CSICR18				(csi_regbase + 0x48)
+#define CSI_CSICR19				(csi_regbase + 0x4c)
+
+struct mxs_csi_regs {
+	u32 csi_csicr1;				/* 0x0 */
+	u32 csi_csicr2;				/* 0x4 */
+	u32 csi_csicr3;				/* 0x8 */
+	u32 csi_statfifo;			/* 0xC */
+	u32 csi_csirxfifo;			/* 0x10 */
+	u32 csi_csirxcnt;			/* 0x14 */
+	u32 csi_csisr;				/* 0x18 */
+	u32 csi_csidbg;				/* 0x1C */
+	u32 csi_csidmasa_statfifo;	/* 0x20 */
+	u32 csi_csidmats_statfifo;	/* 0x24 */
+	u32 csi_csidmasa_fb1;		/* 0x28 */
+	u32 csi_csidmasa_fb2;		/* 0x2C */
+	u32 csi_csifbuf_para;		/* 0x30 */
+	u32 csi_csiimag_para;		/* 0x34 */
+	u32 reserver[4];
+	u32 csi_csicr18;			/* 0x48 */
+	u32 csi_csicr19;			/* 0x4c */
+};
+
+struct csi_conf_param {
+	unsigned short width;
+	unsigned short height;
+	unsigned int pixel_fmt;
+	unsigned int bpp;
+	bool btvmode;
+	unsigned int std;
+	void *fb0addr;
+	void *fb1addr;
+};
+
+void csi_config(struct csi_conf_param *csi_conf);
+void csi_disable(void);
+#endif
diff --git a/drivers/video/mxc_epdc_fb.c b/drivers/video/mxc_epdc_fb.c
new file mode 100644
index 0000000..5a400e1
--- /dev/null
+++ b/drivers/video/mxc_epdc_fb.c
@@ -0,0 +1,454 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+/*
+ * Based on STMP378X LCDIF
+ * Copyright 2008 Embedded Alley Solutions, Inc All Rights Reserved.
+ */
+
+#include <common.h>
+#include <lcd.h>
+#include <linux/list.h>
+#include <linux/err.h>
+#include <linux/types.h>
+
+#include <mxc_epdc_fb.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+void *lcd_base;			/* Start of framebuffer memory	*/
+void *lcd_console_address;	/* Start of console buffer	*/
+
+int lcd_color_fg;
+int lcd_color_bg;
+
+short console_col;
+short console_row;
+
+int rev;
+
+void lcd_initcolregs(void)
+{
+}
+
+void lcd_setcolreg(ushort regno, ushort red, ushort green, ushort blue)
+{
+}
+
+#define TEMP_USE_DEFAULT 8
+
+#define UPDATE_MODE_PARTIAL			0x0
+#define UPDATE_MODE_FULL			0x1
+
+#define TRUE 1
+#define FALSE 0
+
+#define msleep(a)	udelay(a * 1000)
+
+
+/********************************************************
+ * Start Low-Level EPDC Functions
+ ********************************************************/
+
+static inline void epdc_set_screen_res(u32 width, u32 height)
+{
+	u32 val = (height << EPDC_RES_VERTICAL_OFFSET) | width;
+
+	REG_WR(EPDC_BASE, EPDC_RES, val);
+}
+
+static inline void epdc_set_update_coord(u32 x, u32 y)
+{
+	u32 val = (y << EPDC_UPD_CORD_YCORD_OFFSET) | x;
+
+	REG_WR(EPDC_BASE, EPDC_UPD_CORD, val);
+}
+
+static inline void epdc_set_update_dimensions(u32 width, u32 height)
+{
+	u32 val = (height << EPDC_UPD_SIZE_HEIGHT_OFFSET) | width;
+
+	REG_WR(EPDC_BASE, EPDC_UPD_SIZE, val);
+}
+
+static void epdc_submit_update(u32 lut_num, u32 waveform_mode, u32 update_mode,
+			       int use_test_mode, u32 np_val)
+{
+	u32 reg_val = 0;
+
+	if (use_test_mode) {
+		reg_val |=
+			((np_val << EPDC_UPD_FIXED_FIXNP_OFFSET) &
+			EPDC_UPD_FIXED_FIXNP_MASK) | EPDC_UPD_FIXED_FIXNP_EN;
+
+		REG_WR(EPDC_BASE, EPDC_UPD_FIXED, reg_val);
+
+		reg_val = EPDC_UPD_CTRL_USE_FIXED;
+	} else {
+		REG_WR(EPDC_BASE, EPDC_UPD_FIXED, reg_val);
+	}
+
+	reg_val |=
+		((lut_num << EPDC_UPD_CTRL_LUT_SEL_OFFSET) &
+		EPDC_UPD_CTRL_LUT_SEL_MASK) |
+		((waveform_mode << EPDC_UPD_CTRL_WAVEFORM_MODE_OFFSET) &
+		EPDC_UPD_CTRL_WAVEFORM_MODE_MASK) |
+		update_mode;
+
+	REG_WR(EPDC_BASE, EPDC_UPD_CTRL, reg_val);
+}
+
+static inline int epdc_is_lut_active(u32 lut_num)
+{
+	u32 val = REG_RD(EPDC_BASE, EPDC_STATUS_LUTS);
+	int is_active = val & (1 << lut_num) ? TRUE : FALSE;
+
+	return is_active;
+}
+
+static void epdc_set_horizontal_timing(u32 horiz_start, u32 horiz_end,
+				       u32 hsync_width, u32 hsync_line_length)
+{
+	u32 reg_val =
+		((hsync_width << EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_OFFSET) &
+		EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_MASK)
+		| ((hsync_line_length << EPDC_TCE_HSCAN1_LINE_SYNC_OFFSET) &
+		EPDC_TCE_HSCAN1_LINE_SYNC_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_HSCAN1, reg_val);
+
+	reg_val =
+		((horiz_start << EPDC_TCE_HSCAN2_LINE_BEGIN_OFFSET) &
+		EPDC_TCE_HSCAN2_LINE_BEGIN_MASK)
+		| ((horiz_end << EPDC_TCE_HSCAN2_LINE_END_OFFSET) &
+		EPDC_TCE_HSCAN2_LINE_END_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_HSCAN2, reg_val);
+}
+
+static void epdc_set_vertical_timing(u32 vert_start, u32 vert_end,
+					u32 vsync_width)
+{
+	u32 reg_val =
+		((vert_start << EPDC_TCE_VSCAN_FRAME_BEGIN_OFFSET) &
+		EPDC_TCE_VSCAN_FRAME_BEGIN_MASK)
+		| ((vert_end << EPDC_TCE_VSCAN_FRAME_END_OFFSET) &
+		EPDC_TCE_VSCAN_FRAME_END_MASK)
+		| ((vsync_width << EPDC_TCE_VSCAN_FRAME_SYNC_OFFSET) &
+		EPDC_TCE_VSCAN_FRAME_SYNC_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_VSCAN, reg_val);
+}
+
+static void epdc_init_settings(void)
+{
+	u32 reg_val;
+	int num_ce;
+
+	/* EPDC_CTRL */
+	reg_val = REG_RD(EPDC_BASE, EPDC_CTRL);
+	reg_val &= ~EPDC_CTRL_UPD_DATA_SWIZZLE_MASK;
+	reg_val |= EPDC_CTRL_UPD_DATA_SWIZZLE_NO_SWAP;
+	reg_val &= ~EPDC_CTRL_LUT_DATA_SWIZZLE_MASK;
+	reg_val |= EPDC_CTRL_LUT_DATA_SWIZZLE_NO_SWAP;
+	REG_SET(EPDC_BASE, EPDC_CTRL, reg_val);
+
+	/* EPDC_FORMAT - 2bit TFT and 4bit Buf pixel format */
+	reg_val = EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT
+		| EPDC_FORMAT_BUF_PIXEL_FORMAT_P4N
+		| ((0x0 << EPDC_FORMAT_DEFAULT_TFT_PIXEL_OFFSET) &
+		EPDC_FORMAT_DEFAULT_TFT_PIXEL_MASK);
+	REG_WR(EPDC_BASE, EPDC_FORMAT, reg_val);
+
+	/* EPDC_FIFOCTRL (disabled) */
+	reg_val =
+		((100 << EPDC_FIFOCTRL_FIFO_INIT_LEVEL_OFFSET) &
+		EPDC_FIFOCTRL_FIFO_INIT_LEVEL_MASK)
+		| ((200 << EPDC_FIFOCTRL_FIFO_H_LEVEL_OFFSET) &
+		EPDC_FIFOCTRL_FIFO_H_LEVEL_MASK)
+		| ((100 << EPDC_FIFOCTRL_FIFO_L_LEVEL_OFFSET) &
+		EPDC_FIFOCTRL_FIFO_L_LEVEL_MASK);
+	REG_WR(EPDC_BASE, EPDC_FIFOCTRL, reg_val);
+
+	/* EPDC_TEMP - Use default temperature */
+	REG_WR(EPDC_BASE, EPDC_TEMP, TEMP_USE_DEFAULT);
+
+	/* EPDC_RES */
+	epdc_set_screen_res(panel_info.vl_col, panel_info.vl_row);
+
+	/*
+	 * EPDC_TCE_CTRL
+	 * VSCAN_HOLDOFF = 4
+	 * VCOM_MODE = MANUAL
+	 * VCOM_VAL = 0
+	 * DDR_MODE = DISABLED
+	 * LVDS_MODE_CE = DISABLED
+	 * LVDS_MODE = DISABLED
+	 * DUAL_SCAN = DISABLED
+	 * SDDO_WIDTH = 8bit
+	 * PIXELS_PER_SDCLK = 4
+	 */
+	reg_val =
+		((panel_info.epdc_data.epdc_timings.vscan_holdoff <<
+			EPDC_TCE_CTRL_VSCAN_HOLDOFF_OFFSET) &
+			EPDC_TCE_CTRL_VSCAN_HOLDOFF_MASK)
+		| EPDC_TCE_CTRL_PIXELS_PER_SDCLK_4;
+	REG_WR(EPDC_BASE, EPDC_TCE_CTRL, reg_val);
+
+	/* EPDC_TCE_HSCAN */
+	epdc_set_horizontal_timing(panel_info.vl_left_margin,
+				panel_info.vl_right_margin,
+				panel_info.vl_hsync,
+				panel_info.vl_hsync);
+
+	/* EPDC_TCE_VSCAN */
+	epdc_set_vertical_timing(panel_info.vl_upper_margin,
+				 panel_info.vl_lower_margin,
+				 panel_info.vl_vsync);
+
+	/* EPDC_TCE_OE */
+	reg_val =
+		((panel_info.epdc_data.epdc_timings.sdoed_width <<
+			EPDC_TCE_OE_SDOED_WIDTH_OFFSET) &
+			EPDC_TCE_OE_SDOED_WIDTH_MASK)
+		| ((panel_info.epdc_data.epdc_timings.sdoed_delay <<
+			EPDC_TCE_OE_SDOED_DLY_OFFSET) &
+			EPDC_TCE_OE_SDOED_DLY_MASK)
+		| ((panel_info.epdc_data.epdc_timings.sdoez_width <<
+			EPDC_TCE_OE_SDOEZ_WIDTH_OFFSET) &
+			EPDC_TCE_OE_SDOEZ_WIDTH_MASK)
+		| ((panel_info.epdc_data.epdc_timings.sdoez_delay <<
+			EPDC_TCE_OE_SDOEZ_DLY_OFFSET) &
+			EPDC_TCE_OE_SDOEZ_DLY_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_OE, reg_val);
+
+	/* EPDC_TCE_TIMING1 */
+	REG_WR(EPDC_BASE, EPDC_TCE_TIMING1, 0x0);
+
+	/* EPDC_TCE_TIMING2 */
+	reg_val =
+		((panel_info.epdc_data.epdc_timings.gdclk_hp_offs <<
+			EPDC_TCE_TIMING2_GDCLK_HP_OFFSET) &
+			EPDC_TCE_TIMING2_GDCLK_HP_MASK)
+		| ((panel_info.epdc_data.epdc_timings.gdsp_offs <<
+			EPDC_TCE_TIMING2_GDSP_OFFSET_OFFSET) &
+			EPDC_TCE_TIMING2_GDSP_OFFSET_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_TIMING2, reg_val);
+
+	/* EPDC_TCE_TIMING3 */
+	reg_val =
+		((panel_info.epdc_data.epdc_timings.gdoe_offs <<
+			EPDC_TCE_TIMING3_GDOE_OFFSET_OFFSET) &
+			EPDC_TCE_TIMING3_GDOE_OFFSET_MASK)
+		| ((panel_info.epdc_data.epdc_timings.gdclk_offs <<
+			EPDC_TCE_TIMING3_GDCLK_OFFSET_OFFSET) &
+			EPDC_TCE_TIMING3_GDCLK_OFFSET_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_TIMING3, reg_val);
+
+	/*
+	 * EPDC_TCE_SDCFG
+	 * SDCLK_HOLD = 1
+	 * SDSHR = 1
+	 * NUM_CE = 1
+	 * SDDO_REFORMAT = FLIP_PIXELS
+	 * SDDO_INVERT = DISABLED
+	 * PIXELS_PER_CE = display horizontal resolution
+	 */
+	num_ce = panel_info.epdc_data.epdc_timings.num_ce;
+	if (num_ce == 0)
+		num_ce = 1;
+	reg_val = EPDC_TCE_SDCFG_SDCLK_HOLD | EPDC_TCE_SDCFG_SDSHR
+		| ((num_ce << EPDC_TCE_SDCFG_NUM_CE_OFFSET) & EPDC_TCE_SDCFG_NUM_CE_MASK)
+		| EPDC_TCE_SDCFG_SDDO_REFORMAT_FLIP_PIXELS
+		| ((panel_info.vl_col << EPDC_TCE_SDCFG_PIXELS_PER_CE_OFFSET) &
+		EPDC_TCE_SDCFG_PIXELS_PER_CE_MASK);
+	REG_WR(EPDC_BASE, EPDC_TCE_SDCFG, reg_val);
+
+	/*
+	 * EPDC_TCE_GDCFG
+	 * GDRL = 1
+	 * GDOE_MODE = 0;
+	 * GDSP_MODE = 0;
+	 */
+	reg_val = EPDC_TCE_SDCFG_GDRL;
+	REG_WR(EPDC_BASE, EPDC_TCE_GDCFG, reg_val);
+
+	/*
+	 * EPDC_TCE_POLARITY
+	 * SDCE_POL = ACTIVE LOW
+	 * SDLE_POL = ACTIVE HIGH
+	 * SDOE_POL = ACTIVE HIGH
+	 * GDOE_POL = ACTIVE HIGH
+	 * GDSP_POL = ACTIVE LOW
+	 */
+	reg_val = EPDC_TCE_POLARITY_SDLE_POL_ACTIVE_HIGH
+		| EPDC_TCE_POLARITY_SDOE_POL_ACTIVE_HIGH
+		| EPDC_TCE_POLARITY_GDOE_POL_ACTIVE_HIGH;
+	REG_WR(EPDC_BASE, EPDC_TCE_POLARITY, reg_val);
+
+	/* EPDC_IRQ_MASK */
+	REG_WR(EPDC_BASE, EPDC_IRQ_MASK,
+		EPDC_IRQ_TCE_UNDERRUN_IRQ);
+
+	/*
+	 * EPDC_GPIO
+	 * PWRCOM = ?
+	 * PWRCTRL = ?
+	 * BDR = ?
+	 */
+	reg_val = ((0 << EPDC_GPIO_PWRCTRL_OFFSET) & EPDC_GPIO_PWRCTRL_MASK)
+		| ((0 << EPDC_GPIO_BDR_OFFSET) & EPDC_GPIO_BDR_MASK);
+	REG_WR(EPDC_BASE, EPDC_GPIO, reg_val);
+}
+
+static void draw_mode0(void)
+{
+	int i;
+
+	/* Program EPDC update to process buffer */
+	epdc_set_update_coord(0, 0);
+	epdc_set_update_dimensions(panel_info.vl_col, panel_info.vl_row);
+	epdc_submit_update(0, panel_info.epdc_data.wv_modes.mode_init,
+				UPDATE_MODE_FULL, FALSE, 0);
+
+	debug("Mode0 update - Waiting for LUT to complete...\n");
+
+	/* Will timeout after ~4-5 seconds */
+
+	for (i = 0; i < 40; i++) {
+		if (!epdc_is_lut_active(0)) {
+			debug("Mode0 init complete\n");
+			return;
+		}
+		msleep(100);
+	}
+
+	debug("Mode0 init failed!\n");
+
+}
+
+static void draw_splash_screen(void)
+{
+	int i;
+	int lut_num = 0;
+
+	/* Program EPDC update to process buffer */
+	epdc_set_update_coord(0, 0);
+	epdc_set_update_dimensions(panel_info.vl_col, panel_info.vl_row);
+	epdc_submit_update(lut_num, panel_info.epdc_data.wv_modes.mode_gc16,
+		UPDATE_MODE_FULL, FALSE, 0);
+
+	for (i = 0; i < 40; i++) {
+		if (!epdc_is_lut_active(lut_num)) {
+			debug("Splash screen update complete\n");
+			return;
+		}
+		msleep(100);
+	}
+	debug("Splash screen update failed!\n");
+}
+
+void lcd_enable(void)
+{
+	int i;
+
+	epdc_power_on();
+
+	lcd_base = (void *)CONFIG_FB_BASE;
+	/* Draw black border around framebuffer*/
+	memset(lcd_base, 0xFF, panel_info.vl_col * panel_info.vl_row);
+	memset(lcd_base, 0x0, 24 * panel_info.vl_col);
+	for (i = 24; i < (panel_info.vl_row - 24); i++) {
+		memset((u8 *)lcd_base + i * panel_info.vl_col, 0x00, 24);
+		memset((u8 *)lcd_base + i * panel_info.vl_col
+			+ panel_info.vl_col - 24, 0x00, 24);
+	}
+	memset((u8 *)lcd_base + panel_info.vl_col * (panel_info.vl_row - 24),
+		0x00, 24 * panel_info.vl_col);
+
+	flush_cache((ulong)lcd_base, panel_info.vl_col * panel_info.vl_row);
+
+	/* Draw data to display */
+	draw_mode0();
+
+	draw_splash_screen();
+}
+
+void lcd_disable(void)
+{
+	debug("lcd_disable\n");
+
+	/* Disable clocks to EPDC */
+	REG_SET(EPDC_BASE, EPDC_CTRL, EPDC_CTRL_CLKGATE);
+}
+
+void lcd_panel_disable(void)
+{
+	epdc_power_off();
+}
+
+void lcd_ctrl_init(void *lcdbase)
+{
+	unsigned int val;
+
+	/*
+	 * We rely on lcdbase being a physical address, i.e., either MMU off,
+	 * or 1-to-1 mapping. Might want to add some virt2phys here.
+	 */
+	if (!lcdbase)
+		return;
+
+	lcd_color_fg = 0xFF;
+	lcd_color_bg = 0xFF;
+
+	/* Reset */
+	REG_SET(EPDC_BASE, EPDC_CTRL, EPDC_CTRL_SFTRST);
+	while (!(REG_RD(EPDC_BASE, EPDC_CTRL) & EPDC_CTRL_CLKGATE))
+		;
+	REG_CLR(EPDC_BASE, EPDC_CTRL, EPDC_CTRL_SFTRST);
+
+	/* Enable clock gating (clear to enable) */
+	REG_CLR(EPDC_BASE, EPDC_CTRL, EPDC_CTRL_CLKGATE);
+	while (REG_RD(EPDC_BASE, EPDC_CTRL) &
+	       (EPDC_CTRL_SFTRST | EPDC_CTRL_CLKGATE))
+		;
+
+	debug("resolution %dx%d, bpp %d\n", (int)panel_info.vl_col,
+		(int)panel_info.vl_row, NBITS(panel_info.vl_bpix));
+
+	/* Get EPDC version */
+	val = REG_RD(EPDC_BASE, EPDC_VERSION);
+	rev = ((val & EPDC_VERSION_MAJOR_MASK) >>
+				EPDC_VERSION_MAJOR_OFFSET) * 10
+			+ ((val & EPDC_VERSION_MINOR_MASK) >>
+				EPDC_VERSION_MINOR_OFFSET);
+
+	/* Set framebuffer pointer */
+	REG_WR(EPDC_BASE, EPDC_UPD_ADDR, (u32)lcdbase);
+
+	/* Set Working Buffer pointer */
+	REG_WR(EPDC_BASE, EPDC_WB_ADDR, panel_info.epdc_data.working_buf_addr);
+	if (rev > 20)
+		REG_WR(EPDC_BASE, EPDC_WB_ADDR_TCE, panel_info.epdc_data.working_buf_addr);
+
+	/* Get waveform data address and offset */
+	if (setup_waveform_file()) {
+		printf("Can't load waveform data!\n");
+		return;
+	}
+
+	/* Set Waveform Buffer pointer */
+	REG_WR(EPDC_BASE, EPDC_WVADDR,
+		panel_info.epdc_data.waveform_buf_addr);
+
+	/* Initialize EPDC, passing pointer to EPDC registers */
+	epdc_init_settings();
+
+	return;
+}
+
+ulong calc_fbsize(void)
+{
+	return panel_info.vl_row * panel_info.vl_col * 2 \
+		* NBITS(panel_info.vl_bpix) / 8;
+}
+
diff --git a/drivers/video/mxc_gis.c b/drivers/video/mxc_gis.c
new file mode 100644
index 0000000..01befb3
--- /dev/null
+++ b/drivers/video/mxc_gis.c
@@ -0,0 +1,392 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <malloc.h>
+#include <video_fb.h>
+
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/fb.h>
+#include <gis.h>
+#include <mxsfb.h>
+
+#include "mxc_gis.h"
+#include "mxc_csi.h"
+#include "mxc_pxp.h"
+#include "mxc_vadc.h"
+
+#define CHANNEL_OFFSET 36
+#define COMMAND_OFFSET 8
+#define REG_OFFSET 4
+#define COMMAND_OPCODE_SHIFT 8
+
+enum {
+	CMD_SET_ACC = 0,
+	CMD_WR_DATA,
+	CMD_WR_ACC,
+	CMD_WR_ALU,
+	CMD_MOV_ACC,
+	CMD_RD_DATA,
+	CMD_RD_ALU,
+	CMD_WR_FB_CSI,
+	CMD_WR_FB_PXP_IN,
+	CMD_WR_FB_PXP_OUT,
+	CMD_WR_FB_LCDIF,
+};
+
+enum {
+	ALU_AND = 0,
+	ALU_OR,
+	ALU_XOR,
+	ALU_ADD,
+	ALU_SUB,
+};
+
+enum {
+	CH_MAPPING_CSI_ISR = 0,
+	CH_MAPPING_CSI_FB_UPDATE,
+	CH_MAPPING_PXP_ISR,
+	CH_MAPPING_LCDIF_FB_UPDATE,
+	CH_MAPPING_PXP_KICK,
+	CH_MAPPING_CHANNEL_UNUSED = 0xf,
+};
+
+enum {
+	LCDIF1_SEL = 0x10,
+	LCDIF0_SEL = 0x8,
+	PXP_SEL    = 0x4,
+	CSI1_SEL   = 0x2,
+	CSI0_SEL   = 0x1,
+};
+
+struct command_opcode {
+	unsigned opcode:4;
+	unsigned alu:3;
+	unsigned acc_neg:1;
+};
+
+struct command_param {
+	union {
+		struct command_opcode cmd_bits;
+		u8  cmd_opc;
+	};
+	u32 addr;
+	u32 data;
+};
+
+struct channel_param {
+	u32 ch_num;
+	u32 ch_map;
+	u32 cmd_num;
+	struct command_param cmd_data[4];
+};
+
+static void *csibuf0, *csibuf1, *fb0, *fb1;
+static struct mxs_gis_regs *gis_regs;
+static struct mxs_pxp_regs *pxp_regs;
+static struct mxs_csi_regs *csi_regs;
+static struct mxs_lcdif_regs *lcdif_regs;
+static u32 lcdif_sel;
+static bool gis_running;
+
+static void config_channel(struct channel_param *ch)
+{
+	u32 val, i;
+	u32 reg_offset;
+
+	/* Config channel map and command */
+	switch (ch->ch_num) {
+	case 0:
+		val = readl(&gis_regs->hw_gis_config0);
+		val &= ~(GIS_CONFIG0_CH0_MAPPING_MASK | GIS_CONFIG0_CH0_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG0_CH0_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG0_CH0_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config0);
+		break;
+	case 1:
+		val = readl(&gis_regs->hw_gis_config0);
+		val &= ~(GIS_CONFIG0_CH1_MAPPING_MASK | GIS_CONFIG0_CH1_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG0_CH1_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG0_CH1_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config0);
+		break;
+	case 2:
+		val = readl(&gis_regs->hw_gis_config0);
+		val &= ~(GIS_CONFIG0_CH2_MAPPING_MASK | GIS_CONFIG0_CH2_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG0_CH2_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG0_CH2_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config0);
+		break;
+	case 3:
+		val = readl(&gis_regs->hw_gis_config0);
+		val &= ~(GIS_CONFIG0_CH3_MAPPING_MASK | GIS_CONFIG0_CH3_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG0_CH3_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG0_CH3_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config0);
+		break;
+	case 4:
+		val = readl(&gis_regs->hw_gis_config1);
+		val &= ~(GIS_CONFIG1_CH4_MAPPING_MASK | GIS_CONFIG1_CH4_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG1_CH4_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG1_CH4_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config1);
+		break;
+	case 5:
+		val = readl(&gis_regs->hw_gis_config1);
+		val &= ~(GIS_CONFIG1_CH5_MAPPING_MASK | GIS_CONFIG1_CH5_NUM_MASK);
+		val |= ch->ch_map << GIS_CONFIG1_CH5_MAPPING_SHIFT;
+		val |= ch->cmd_num << GIS_CONFIG1_CH5_NUM_SHIFT;
+		writel(val, &gis_regs->hw_gis_config1);
+		break;
+	default:
+		printf("Error channel num\n");
+	}
+
+	/* Config command  */
+	for (i = 0; i < ch->cmd_num; i++) {
+		val = readl(&gis_regs->hw_gis_ch0_ctrl + ch->ch_num * CHANNEL_OFFSET);
+		val &= ~(0xFF << (COMMAND_OPCODE_SHIFT * i));
+		val |= ch->cmd_data[i].cmd_opc << (COMMAND_OPCODE_SHIFT * i);
+		writel(val, &gis_regs->hw_gis_ch0_ctrl + ch->ch_num * CHANNEL_OFFSET);
+
+		reg_offset = ch->ch_num * CHANNEL_OFFSET + i * COMMAND_OFFSET;
+		writel(ch->cmd_data[i].addr, &gis_regs->hw_gis_ch0_addr0 + reg_offset);
+		writel(ch->cmd_data[i].data, &gis_regs->hw_gis_ch0_data0 + reg_offset);
+	}
+}
+
+static void gis_channel_init(void)
+{
+	struct channel_param ch;
+	int ret;
+	u32 addr0, data0, addr1, data1;
+	u32 val;
+
+	/* Restart the GIS block */
+	ret = mxs_reset_block(&gis_regs->hw_gis_ctrl_reg);
+	if (ret) {
+		debug("MXS GIS: Block reset timeout\n");
+		return;
+	}
+
+	writel((u32)csibuf0, &gis_regs->hw_gis_fb0);
+	writel((u32)csibuf1, &gis_regs->hw_gis_fb1);
+	writel((u32)fb0, &gis_regs->hw_gis_pxp_fb0);
+	writel((u32)fb1, &gis_regs->hw_gis_pxp_fb1);
+
+	/* Config channel 0 -- CSI clean interrupt  */
+	addr0 = (u32)&csi_regs->csi_csisr;
+	data0 = BIT_DMA_TSF_DONE_FB1 | BIT_DMA_TSF_DONE_FB2 | BIT_SOF_INT;
+	ch.ch_num = 0;
+	ch.ch_map = CH_MAPPING_CSI_ISR;
+	ch.cmd_num = 1;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_DATA;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = CSI0_SEL << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	config_channel(&ch);
+
+	/* Config channel 1 -- CSI set next framebuffer addr  */
+	addr0 = (u32)&csi_regs->csi_csidmasa_fb1;
+	data0 = (u32)&csi_regs->csi_csidmasa_fb2;
+	ch.ch_num = 1;
+	ch.ch_map = CH_MAPPING_CSI_FB_UPDATE;
+	ch.cmd_num = 1;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_FB_CSI;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = CSI0_SEL << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	config_channel(&ch);
+
+	/* Config channel 2 -- PXP clear interrupt and set framebuffer */
+	addr0 = (u32)&pxp_regs->pxp_stat_clr;
+	data0 = BM_PXP_STAT_IRQ;
+	addr1 = (u32)&pxp_regs->pxp_out_buf;
+	data1 = 0;
+	ch.ch_num = 2;
+	ch.ch_map = CH_MAPPING_PXP_ISR;
+	ch.cmd_num = 2;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_DATA;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = PXP_SEL << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	ch.cmd_data[1].cmd_bits.opcode = CMD_WR_FB_PXP_OUT;
+	ch.cmd_data[1].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[1].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[1].addr = PXP_SEL << GIS_CH_ADDR_SEL_SHIFT | addr1;
+	ch.cmd_data[1].data = data1;
+	config_channel(&ch);
+
+	/* Config channel 3 -- LCDIF set framebuffer to display */
+	addr0 = (u32)&lcdif_regs->hw_lcdif_next_buf;
+	data0 = 0;
+	ch.ch_num = 3;
+	ch.ch_map = CH_MAPPING_LCDIF_FB_UPDATE;
+	ch.cmd_num = 1;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_FB_LCDIF;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = ((lcdif_sel == 0) ? LCDIF0_SEL : LCDIF1_SEL) << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	config_channel(&ch);
+
+	/* Config channel 4 -- PXP kick to process next framebuffer */
+	addr0 = (u32)&pxp_regs->pxp_ps_buf;
+	data0 = 0;
+	addr1 = (u32)&pxp_regs->pxp_ctrl;
+	data1 = BM_PXP_CTRL_IRQ_ENABLE | BM_PXP_CTRL_ENABLE;
+	ch.ch_num = 4;
+	ch.ch_map = CH_MAPPING_PXP_KICK;
+	ch.cmd_num = 2;
+	ch.cmd_data[0].cmd_bits.opcode = CMD_WR_FB_PXP_IN;
+	ch.cmd_data[0].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[0].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[0].addr = PXP_SEL << GIS_CH_ADDR_SEL_SHIFT | addr0;
+	ch.cmd_data[0].data = data0;
+	ch.cmd_data[1].cmd_bits.opcode = CMD_WR_DATA;
+	ch.cmd_data[1].cmd_bits.alu = ALU_AND;
+	ch.cmd_data[1].cmd_bits.acc_neg = GIS_CH_CTRL_CMD_ACC_NO_NEGATE;
+	ch.cmd_data[1].addr = PXP_SEL << GIS_CH_ADDR_SEL_SHIFT | addr1;
+	ch.cmd_data[1].data = data1;
+	config_channel(&ch);
+
+	/* start gis  */
+	val = readl(&gis_regs->hw_gis_ctrl);
+	if (lcdif_sel == 1)
+		val |= GIS_CTRL_ENABLE_SET | GIS_CTRL_LCDIF_SEL_LCDIF1;
+	else
+		val |= GIS_CTRL_ENABLE_SET | GIS_CTRL_LCDIF_SEL_LCDIF0;
+	writel(val, &gis_regs->hw_gis_ctrl);
+}
+
+void mxc_disable_gis(void)
+{
+	u32 val;
+
+	if (!gis_running)
+		return;
+
+	/* Stop gis */
+	val = GIS_CTRL_SFTRST_SET | GIS_CTRL_CLK_GATE_SET;
+	writel(val, &gis_regs->hw_gis_ctrl);
+
+	/* Stop pxp */
+	mxs_reset_block(&pxp_regs->pxp_ctrl_reg);
+	val = BM_PXP_CTRL_SFTRST | BM_PXP_CTRL_CLKGATE;
+	writel(val , &pxp_regs->pxp_ctrl);
+
+	csi_disable();
+
+	vadc_power_down();
+}
+
+void mxc_enable_gis(void)
+{
+	struct sensor_data sensor;
+	struct csi_conf_param csi_conf;
+	struct pxp_config_data pxp_conf;
+	struct display_panel panel;
+	u32 csimemsize, pxpmemsize;
+	char const *gis_input = getenv("gis");
+
+	gis_regs = (struct mxs_gis_regs *)GIS_BASE_ADDR;
+	pxp_regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+	csi_regs = (struct mxs_csi_regs *)CSI1_BASE_ADDR;
+
+	gis_running = false;
+
+	if (!strcmp(gis_input, "vadc")) {
+		printf("gis input --- vadc\n");
+		/* vadc_in 0 */
+		vadc_config(0);
+
+		/* Get vadc mode */
+		vadc_get_std(&sensor);
+	} else {
+		printf("gis input --- No input\n");
+		return;
+	}
+
+	/* Get display mode */
+	mxs_lcd_get_panel(&panel);
+
+	lcdif_regs = (struct mxs_lcdif_regs *)panel.reg_base;
+	if (panel.reg_base == LCDIF2_BASE_ADDR)
+		lcdif_sel = 1;
+	else
+		lcdif_sel = 0;
+
+	/* Allocate csi buffer */
+	if (sensor.pixel_fmt == FMT_YUV444) {
+		csimemsize = sensor.width * sensor.height * 4;
+		csi_conf.bpp = 32;
+	} else {
+		csimemsize = sensor.width * sensor.height * 2;
+		csi_conf.bpp = 16;
+	}
+
+	pxpmemsize = panel.width * panel.height * panel.gdfbytespp;
+	csibuf0 = malloc(csimemsize);
+	csibuf1 = malloc(csimemsize);
+	fb0 = malloc(pxpmemsize);
+	fb1 = malloc(pxpmemsize);
+	if (!csibuf0 || !csibuf1 || !fb0 || !fb1) {
+		printf("MXSGIS: Error allocating csibuffer!\n");
+		return;
+	}
+	/* Wipe framebuffer */
+	memset(csibuf0, 0, csimemsize);
+	memset(csibuf1, 0, csimemsize);
+	memset(fb0, 0, pxpmemsize);
+	memset(fb1, 0, pxpmemsize);
+
+	/*config csi  */
+	csi_conf.width = sensor.width;
+	csi_conf.height = sensor.height;
+	csi_conf.btvmode = true;
+	csi_conf.std = sensor.std_id;
+	csi_conf.fb0addr = csibuf0;
+	csi_conf.fb1addr = csibuf1;
+	csi_config(&csi_conf);
+
+	/* config pxp */
+	pxp_conf.s0_param.pixel_fmt = sensor.pixel_fmt;
+	pxp_conf.s0_param.width = sensor.width;
+	pxp_conf.s0_param.height = sensor.height;
+	pxp_conf.s0_param.stride = sensor.width * csi_conf.bpp/8;
+	pxp_conf.s0_param.paddr = csibuf0;
+
+	switch (panel.gdfindex) {
+	case GDF_32BIT_X888RGB:
+		pxp_conf.out_param.pixel_fmt = FMT_RGB888;
+		break;
+	case GDF_16BIT_565RGB:
+		pxp_conf.out_param.pixel_fmt = FMT_RGB565;
+		break;
+	default:
+		printf("GIS unsupported format!");
+	}
+
+	pxp_conf.out_param.width = panel.width;
+	pxp_conf.out_param.height = panel.height;
+	pxp_conf.out_param.stride = pxp_conf.out_param.width * panel.gdfbytespp;
+	pxp_conf.out_param.paddr = fb0;
+	pxp_config(&pxp_conf);
+
+	gis_running = true;
+
+	/* Config gis */
+	gis_channel_init();
+}
diff --git a/drivers/video/mxc_gis.h b/drivers/video/mxc_gis.h
new file mode 100644
index 0000000..93bff95
--- /dev/null
+++ b/drivers/video/mxc_gis.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MXC_GIS_H
+#define MXC_GIS_H
+
+#include <asm/imx-common/regs-common.h>
+
+struct mxs_gis_regs {
+	mxs_reg_32(hw_gis_ctrl)				/* 0x00 */
+	mxs_reg_32(hw_gis_config0)			/* 0x10 */
+	mxs_reg_32(hw_gis_config1)			/* 0x20 */
+	mxs_reg_32(hw_gis_fb0)				/* 0x30 */
+	mxs_reg_32(hw_gis_fb1)				/* 0x40 */
+	mxs_reg_32(hw_gis_pxp_fb0)			/* 0x50 */
+	mxs_reg_32(hw_gis_pxp_fb1)			/* 0x60 */
+
+	mxs_reg_32(hw_gis_ch0_ctrl)			/* 0x70 */
+	mxs_reg_32(hw_gis_ch0_addr0)		/* 0x80 */
+	mxs_reg_32(hw_gis_ch0_data0)		/* 0x90 */
+	mxs_reg_32(hw_gis_ch0_addr1)		/* 0xa0 */
+	mxs_reg_32(hw_gis_ch0_data1)		/* 0xb0 */
+	mxs_reg_32(hw_gis_ch0_addr2)		/* 0xc0 */
+	mxs_reg_32(hw_gis_ch0_data2)		/* 0xd0 */
+	mxs_reg_32(hw_gis_ch0_addr3)		/* 0xe0 */
+	mxs_reg_32(hw_gis_ch0_data3)		/* 0xf0 */
+
+	mxs_reg_32(hw_gis_ch1_ctrl)			/* 0x100 */
+	mxs_reg_32(hw_gis_ch1_addr0)		/* 0x110 */
+	mxs_reg_32(hw_gis_ch1_data0)		/* 0x120 */
+	mxs_reg_32(hw_gis_ch1_addr1)		/* 0x130 */
+	mxs_reg_32(hw_gis_ch1_data1)		/* 0x140 */
+	mxs_reg_32(hw_gis_ch1_addr2)		/* 0x150 */
+	mxs_reg_32(hw_gis_ch1_data2)		/* 0x160 */
+	mxs_reg_32(hw_gis_ch1_addr3)		/* 0x170 */
+	mxs_reg_32(hw_gis_ch1_data3)		/* 0x180 */
+
+	mxs_reg_32(hw_gis_ch2_ctrl)			/* 0x190 */
+	mxs_reg_32(hw_gis_ch2_addr0)		/* 0x1a0 */
+	mxs_reg_32(hw_gis_ch2_data0)		/* 0x1b0 */
+	mxs_reg_32(hw_gis_ch2_addr1)		/* 0x1c0 */
+	mxs_reg_32(hw_gis_ch2_data1)		/* 0x1d0 */
+	mxs_reg_32(hw_gis_ch2_addr2)		/* 0x1e0 */
+	mxs_reg_32(hw_gis_ch2_data2)		/* 0x1f0 */
+	mxs_reg_32(hw_gis_ch2_addr3)		/* 0x200 */
+	mxs_reg_32(hw_gis_ch2_data3)		/* 0x210 */
+
+	mxs_reg_32(hw_gis_ch3_ctrl)			/* 0x220 */
+	mxs_reg_32(hw_gis_ch3_addr0)		/* 0x230 */
+	mxs_reg_32(hw_gis_ch3_data0)		/* 0x240 */
+	mxs_reg_32(hw_gis_ch3_addr1)		/* 0x250 */
+	mxs_reg_32(hw_gis_ch3_data1)		/* 0x260 */
+	mxs_reg_32(hw_gis_ch3_addr2)		/* 0x270 */
+	mxs_reg_32(hw_gis_ch3_data2)		/* 0x280 */
+	mxs_reg_32(hw_gis_ch3_addr3)		/* 0x290 */
+	mxs_reg_32(hw_gis_ch3_data3)		/* 0x2a0 */
+
+	mxs_reg_32(hw_gis_ch4_ctrl)			/* 0x2b0 */
+	mxs_reg_32(hw_gis_ch4_addr0)		/* 0x2c0 */
+	mxs_reg_32(hw_gis_ch4_data0)		/* 0x2d0 */
+	mxs_reg_32(hw_gis_ch4_addr1)		/* 0x2e0 */
+	mxs_reg_32(hw_gis_ch4_data1)		/* 0x2f0 */
+	mxs_reg_32(hw_gis_ch4_addr2)		/* 0x300 */
+	mxs_reg_32(hw_gis_ch4_data2)		/* 0x310 */
+	mxs_reg_32(hw_gis_ch4_addr3)		/* 0x320 */
+	mxs_reg_32(hw_gis_ch4_data3)		/* 0x330 */
+
+	mxs_reg_32(hw_gis_ch5_ctrl)			/* 0x340 */
+	mxs_reg_32(hw_gis_ch5_addr0)		/* 0x350 */
+	mxs_reg_32(hw_gis_ch5_data0)		/* 0x360 */
+	mxs_reg_32(hw_gis_ch5_addr1)		/* 0x370 */
+	mxs_reg_32(hw_gis_ch5_data1)		/* 0x380 */
+	mxs_reg_32(hw_gis_ch5_addr2)		/* 0x390 */
+	mxs_reg_32(hw_gis_ch5_data2)		/* 0x3a0 */
+	mxs_reg_32(hw_gis_ch5_addr3)		/* 0x3b0 */
+	mxs_reg_32(hw_gis_ch5_data3)		/* 0x3c0 */
+
+	mxs_reg_32(hw_gis_debug0)			/* 0x3d0 */
+	mxs_reg_32(hw_gis_debug1)			/* 0x3e0 */
+	mxs_reg_32(hw_gis_version)			/* 0x3f0 */
+};
+
+/* register bit */
+#define GIS_CTRL_SFTRST_CLR				0
+#define GIS_CTRL_SFTRST_SET				(1 << 31)
+#define GIS_CTRL_CLK_GATE_CLR			0
+#define GIS_CTRL_CLK_GATE_SET			(1 << 30)
+#define GIS_CTRL_LCDIF1_IRQ_POL_LOW		0
+#define GIS_CTRL_LCDIF1_IRQ_POL_HIGH	(1 << 8)
+#define GIS_CTRL_LCDIF0_IRQ_POL_LOW		0
+#define GIS_CTRL_LCDIF0_IRQ_POL_HIGH	(1 << 7)
+#define GIS_CTRL_PXP_IRQ_POL_LOW		0
+#define GIS_CTRL_PXP_IRQ_POL_HIGH		(1 << 6)
+#define GIS_CTRL_CSI1_IRQ_POL_LOW		0
+#define GIS_CTRL_CSI1_IRQ_POL_HIGH		(1 << 5)
+#define GIS_CTRL_CSI0_IRQ_POL_LOW		0
+#define GIS_CTRL_CSI0_IRQ_POL_HIGH		(1 << 4)
+#define GIS_CTRL_CSI_SEL_CSI0			0
+#define GIS_CTRL_CSI_SEL_CSI1			(1 << 3)
+#define GIS_CTRL_LCDIF_SEL_LCDIF0		0
+#define GIS_CTRL_LCDIF_SEL_LCDIF1		(1 << 2)
+#define GIS_CTRL_FB_START_FB0			0
+#define GIS_CTRL_FB_START_FB1			(1 << 1)
+#define GIS_CTRL_ENABLE_CLR				0
+#define GIS_CTRL_ENABLE_SET				(1 << 0)
+
+#define GIS_CONFIG0_CH3_NUM_MASK		(0x7 << 27)
+#define GIS_CONFIG0_CH3_NUM_SHIFT		27
+#define GIS_CONFIG0_CH3_MAPPING_MASK	(0x7 << 24)
+#define GIS_CONFIG0_CH3_MAPPING_SHIFT	24
+#define GIS_CONFIG0_CH2_NUM_MASK		(0x7 << 19)
+#define GIS_CONFIG0_CH2_NUM_SHIFT		19
+#define GIS_CONFIG0_CH2_MAPPING_MASK	(0x7 << 16)
+#define GIS_CONFIG0_CH2_MAPPING_SHIFT	16
+#define GIS_CONFIG0_CH1_NUM_MASK		(0x7 << 11)
+#define GIS_CONFIG0_CH1_NUM_SHIFT		11
+#define GIS_CONFIG0_CH1_MAPPING_MASK	(0x7 << 8)
+#define GIS_CONFIG0_CH1_MAPPING_SHIFT	8
+#define GIS_CONFIG0_CH0_NUM_MASK		(0x7 << 3)
+#define GIS_CONFIG0_CH0_NUM_SHIFT		3
+#define GIS_CONFIG0_CH0_MAPPING_MASK	(0x7 << 0)
+#define GIS_CONFIG0_CH0_MAPPING_SHIFT	0
+
+#define GIS_CONFIG1_CH5_NUM_MASK		(0x7 << 11)
+#define GIS_CONFIG1_CH5_NUM_SHIFT		11
+#define GIS_CONFIG1_CH5_MAPPING_MASK	(0x7 << 8)
+#define GIS_CONFIG1_CH5_MAPPING_SHIFT	8
+#define GIS_CONFIG1_CH4_NUM_MASK		(0x7 << 3)
+#define GIS_CONFIG1_CH4_NUM_SHIFT		3
+#define GIS_CONFIG1_CH4_MAPPING_MASK	(0x7 << 0)
+#define GIS_CONFIG1_CH4_MAPPING_SHIFT	0
+
+#define GIS_CH_CTRL_CMD3_ACC_MASK		(0x1 << 31)
+#define GIS_CH_CTRL_CMD3_ACC_SHIFT		31
+#define GIS_CH_CTRL_CMD3_ALU_MASK		(0x7 << 28)
+#define GIS_CH_CTRL_CMD3_ALU_SHIFT		28
+#define GIS_CH_CTRL_CMD3_OPCODE_MASK	(0xF << 24)
+#define GIS_CH_CTRL_CMD3_OPCODE_SHIFT	24
+#define GIS_CH_CTRL_CMD2_ACC_MASK		(0x1 << 23)
+#define GIS_CH_CTRL_CMD2_ACC_SHIFT		23
+#define GIS_CH_CTRL_CMD2_ALU_MASK		(0xF << 20)
+#define GIS_CH_CTRL_CMD2_ALU_SHIFT		20
+#define GIS_CH_CTRL_CMD2_OPCODE_MASK	(0xF << 16)
+#define GIS_CH_CTRL_CMD2_OPCODE_SHIFT	16
+#define GIS_CH_CTRL_CMD1_ACC_MASK		(0x1 << 15)
+#define GIS_CH_CTRL_CMD1_ACC_SHIFT		15
+#define GIS_CH_CTRL_CMD1_ALU_MASK		(0x7 << 12)
+#define GIS_CH_CTRL_CMD1_ALU_SHIFT		12
+#define GIS_CH_CTRL_CMD1_OPCODE_MASK	(0xF << 8)
+#define GIS_CH_CTRL_CMD1_OPCODE_SHIFT	8
+#define GIS_CH_CTRL_CMD0_ACC_MASK		(0x1 << 7)
+#define GIS_CH_CTRL_CMD0_ACC_SHIFT		7
+#define GIS_CH_CTRL_CMD0_ALU_MASK		(0x7 << 4)
+#define GIS_CH_CTRL_CMD0_ALU_SHIFT		4
+#define GIS_CH_CTRL_CMD0_OPCODE_MASK	(0xF << 0)
+#define GIS_CH_CTRL_CMD0_OPCODE_SHIFT	0
+
+#define GIS_CH_CTRL_CMD_ACC_NO_NEGATE	0
+#define GIS_CH_CTRL_CMD_ACC_NEGATE		1
+
+#define GIS_CH_ADDR_SEL_MASK			(0xF8 << 27)
+#define GIS_CH_ADDR_SEL_LCDIF1			(0x1 << 31)
+#define GIS_CH_ADDR_SEL_LCDIF0			(0x1 << 30)
+#define GIS_CH_ADDR_SEL_PXP				(0x1 << 29)
+#define GIS_CH_ADDR_SEL_CSI1			(0x1 << 28)
+#define GIS_CH_ADDR_SEL_CSI0			(0x1 << 27)
+#define GIS_CH_ADDR_SEL_SHIFT			27
+#define GIS_CH_ADDR_ADDR_MASK			0x7FFFFFF
+#define GIS_CH_ADDR_ADDR_SHIFT			0
+
+#endif
+
diff --git a/drivers/video/mxc_pxp.c b/drivers/video/mxc_pxp.c
new file mode 100644
index 0000000..ea70bdd
--- /dev/null
+++ b/drivers/video/mxc_pxp.c
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/sys_proto.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <linux/string.h>
+#include <linux/list.h>
+#include <gis.h>
+
+#include "mxc_pxp.h"
+
+#define BV_PXP_OUT_CTRL_FORMAT__RGB888	  0x4
+#define BV_PXP_OUT_CTRL_FORMAT__RGB555	  0xC
+#define BV_PXP_OUT_CTRL_FORMAT__RGB444	  0xD
+#define BV_PXP_OUT_CTRL_FORMAT__RGB565	  0xE
+#define BV_PXP_OUT_CTRL_FORMAT__YUV1P444  0x10
+#define BV_PXP_OUT_CTRL_FORMAT__UYVY1P422 0x12
+#define BV_PXP_OUT_CTRL_FORMAT__VYUY1P422 0x13
+
+#define BV_PXP_PS_CTRL_FORMAT__RGB888	 0x4
+#define BV_PXP_PS_CTRL_FORMAT__RGB565	 0xE
+#define BV_PXP_PS_CTRL_FORMAT__YUV1P444  0x10
+#define BV_PXP_PS_CTRL_FORMAT__UYVY1P422 0x12
+#define BV_PXP_PS_CTRL_FORMAT__VYUY1P422 0x13
+
+#define BP_PXP_PS_CTRL_SWAP 5
+#define BM_PXP_PS_CTRL_SWAP 0x000000E0
+#define BF_PXP_PS_CTRL_SWAP(v)  \
+	(((v) << 5) & BM_PXP_PS_CTRL_SWAP)
+
+#define PXP_DOWNSCALE_THRESHOLD     0x4000
+
+static void pxp_set_ctrl(struct pxp_config_data *pxp_conf)
+{
+	u32 ctrl;
+	u32 fmt_ctrl;
+	int need_swap = 0;   /* to support YUYV and YVYU formats */
+	struct mxs_pxp_regs *regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+
+	/* Configure S0 input format */
+	switch (pxp_conf->s0_param.pixel_fmt) {
+	case FMT_YUV444:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__YUV1P444;
+		break;
+	case FMT_UYVY:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__UYVY1P422;
+		break;
+	case FMT_YUYV:
+		fmt_ctrl = BV_PXP_PS_CTRL_FORMAT__UYVY1P422;
+		need_swap = 1;
+	default:
+		fmt_ctrl = 0;
+	}
+
+	ctrl = BF_PXP_PS_CTRL_FORMAT(fmt_ctrl) | BF_PXP_PS_CTRL_SWAP(need_swap);
+	writel(ctrl, &regs->pxp_ps_ctrl);
+
+	/* Configure output format based on out_channel format */
+	switch (pxp_conf->out_param.pixel_fmt) {
+	case FMT_RGB565:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB565;
+		break;
+	case FMT_RGB888:
+		fmt_ctrl = BV_PXP_OUT_CTRL_FORMAT__RGB888;
+		break;
+	default:
+		fmt_ctrl = 0;
+	}
+
+	ctrl = BF_PXP_OUT_CTRL_FORMAT(fmt_ctrl);
+	writel(ctrl, &regs->pxp_out_ctrl);
+}
+
+static int pxp_set_scaling(struct pxp_config_data *pxp_conf)
+{
+	int ret = 0;
+	u32 xscale, yscale, s0scale;
+	u32 decx, decy, xdec = 0, ydec = 0;
+	struct pxp_layer_param *s0_params = &pxp_conf->s0_param;
+	struct pxp_layer_param *out_params = &pxp_conf->out_param;
+	struct mxs_pxp_regs *regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+
+	decx = s0_params->width / out_params->width;
+	decy = s0_params->height / out_params->height;
+	if (decx > 1) {
+		if (decx >= 2 && decx < 4) {
+			decx = 2;
+			xdec = 1;
+		} else if (decx >= 4 && decx < 8) {
+			decx = 4;
+			xdec = 2;
+		} else if (decx >= 8) {
+			decx = 8;
+			xdec = 3;
+		}
+		xscale = s0_params->width * 0x1000 /
+			 (out_params->width * decx);
+	} else {
+		if ((s0_params->pixel_fmt == FMT_YUYV) ||
+		    (s0_params->pixel_fmt == FMT_UYVY) ||
+		    (s0_params->pixel_fmt == FMT_YUV444))
+			xscale = (s0_params->width - 1) * 0x1000 /
+				 (out_params->width - 1);
+		else
+			xscale = (s0_params->width - 2) * 0x1000 /
+				 (out_params->width - 1);
+	}
+	if (decy > 1) {
+		if (decy >= 2 && decy < 4) {
+			decy = 2;
+			ydec = 1;
+		} else if (decy >= 4 && decy < 8) {
+			decy = 4;
+			ydec = 2;
+		} else if (decy >= 8) {
+			decy = 8;
+			ydec = 3;
+		}
+		yscale = s0_params->height * 0x1000 /
+			 (out_params->height * decy);
+	} else
+		yscale = (s0_params->height - 1) * 0x1000 /
+			 (out_params->height - 1);
+
+	writel((xdec << 10) | (ydec << 8), &regs->pxp_ps_ctrl);
+
+	if (xscale > PXP_DOWNSCALE_THRESHOLD)
+		xscale = PXP_DOWNSCALE_THRESHOLD;
+	if (yscale > PXP_DOWNSCALE_THRESHOLD)
+		yscale = PXP_DOWNSCALE_THRESHOLD;
+	s0scale = BF_PXP_PS_SCALE_YSCALE(yscale) |
+		BF_PXP_PS_SCALE_XSCALE(xscale);
+	writel(s0scale, &regs->pxp_ps_scale);
+
+	pxp_set_ctrl(pxp_conf);
+
+	return ret;
+}
+
+void pxp_power_down(void)
+{
+	struct mxs_pxp_regs *regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+	u32 val;
+
+	val = BM_PXP_CTRL_SFTRST | BM_PXP_CTRL_CLKGATE;
+	writel(val , &regs->pxp_ctrl);
+}
+
+void pxp_config(struct pxp_config_data *pxp_conf)
+{
+	struct mxs_pxp_regs *regs = (struct mxs_pxp_regs *)PXP_BASE_ADDR;
+
+	/* reset */
+	mxs_reset_block(&regs->pxp_ctrl_reg);
+
+	/* output buffer */
+	if (pxp_conf->out_param.pixel_fmt == FMT_RGB888)
+		writel(BV_PXP_OUT_CTRL_FORMAT__RGB888, &regs->pxp_out_ctrl);
+	else
+		writel(BV_PXP_OUT_CTRL_FORMAT__RGB565, &regs->pxp_out_ctrl);
+
+	writel((u32)pxp_conf->out_param.paddr, &regs->pxp_out_buf);
+
+	writel(pxp_conf->out_param.stride, &regs->pxp_out_pitch);
+	writel((pxp_conf->out_param.width - 1) << 16 |
+			(pxp_conf->out_param.height - 1),
+			&regs->pxp_out_lrc);
+
+	/* scale needed  */
+	writel(0, &regs->pxp_out_ps_ulc);
+	writel((pxp_conf->out_param.width - 1) << 16 |
+			(pxp_conf->out_param.height - 1),
+			&regs->pxp_out_ps_lrc);
+	pxp_set_scaling(pxp_conf);
+
+	writel(0, &regs->pxp_out_as_ulc);
+	writel(0, &regs->pxp_out_as_lrc);
+
+	/* input buffer */
+	if (pxp_conf->s0_param.pixel_fmt == FMT_YUV444)
+		writel(BV_PXP_PS_CTRL_FORMAT__YUV1P444, &regs->pxp_ps_ctrl);
+	else if (pxp_conf->s0_param.pixel_fmt == FMT_YUYV)
+		writel(BV_PXP_PS_CTRL_FORMAT__UYVY1P422 | BF_PXP_PS_CTRL_SWAP(1),
+				&regs->pxp_ps_ctrl);
+	else if (pxp_conf->s0_param.pixel_fmt == FMT_UYVY)
+		writel(BV_PXP_PS_CTRL_FORMAT__UYVY1P422, &regs->pxp_ps_ctrl);
+	else
+		printf("%s, unsupport fmt\n", __func__);
+
+	writel((u32)pxp_conf->s0_param.paddr, &regs->pxp_ps_buf);
+	writel(pxp_conf->s0_param.stride, &regs->pxp_ps_pitch);
+	writel(0, &regs->pxp_ps_background);
+	writel(0x84ab01f0, &regs->pxp_csc1_coef0);
+	writel(0x01980204, &regs->pxp_csc1_coef1);
+	writel(0x0730079c, &regs->pxp_csc1_coef2);
+
+	/* pxp start  */
+	writel(BM_PXP_CTRL_IRQ_ENABLE | BM_PXP_CTRL_ENABLE, &regs->pxp_ctrl);
+}
diff --git a/drivers/video/mxc_pxp.h b/drivers/video/mxc_pxp.h
new file mode 100644
index 0000000..106f929
--- /dev/null
+++ b/drivers/video/mxc_pxp.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MXC_PXP_H
+#define MXC_PXP_H
+
+#include <asm/imx-common/regs-common.h>
+
+struct mxs_pxp_regs{
+	mxs_reg_32(pxp_ctrl)           /* 0x00  */
+	mxs_reg_32(pxp_stat)           /* 0x10  */
+	mxs_reg_32(pxp_out_ctrl)       /* 0x20  */
+	mxs_reg_32(pxp_out_buf)        /* 0x30  */
+	mxs_reg_32(pxp_out_buf2)       /* 0x40  */
+	mxs_reg_32(pxp_out_pitch)      /* 0x50  */
+	mxs_reg_32(pxp_out_lrc)        /* 0x60  */
+	mxs_reg_32(pxp_out_ps_ulc)     /* 0x70  */
+	mxs_reg_32(pxp_out_ps_lrc)     /* 0x80  */
+	mxs_reg_32(pxp_out_as_ulc)     /* 0x90  */
+	mxs_reg_32(pxp_out_as_lrc)     /* 0xa0  */
+	mxs_reg_32(pxp_ps_ctrl)        /* 0xb0  */
+	mxs_reg_32(pxp_ps_buf)         /* 0xc0  */
+	mxs_reg_32(pxp_ps_ubuf)        /* 0xd0  */
+	mxs_reg_32(pxp_ps_vbuf)        /* 0xe0  */
+	mxs_reg_32(pxp_ps_pitch)       /* 0xf0  */
+	mxs_reg_32(pxp_ps_background)  /* 0x100 */
+	mxs_reg_32(pxp_ps_scale)       /* 0x110 */
+	mxs_reg_32(pxp_ps_offset)      /* 0x120 */
+	mxs_reg_32(pxp_ps_clrkeylow)   /* 0x130 */
+	mxs_reg_32(pxp_ps_clrkeyhigh)  /* 0x140 */
+	mxs_reg_32(pxp_as_ctrl)        /* 0x150 */
+	mxs_reg_32(pxp_as_buf)         /* 0x160 */
+	mxs_reg_32(pxp_as_pitch)       /* 0x170 */
+	mxs_reg_32(pxp_as_clrkeylow)   /* 0x180 */
+	mxs_reg_32(pxp_as_clrkeyhigh)  /* 0x190 */
+	mxs_reg_32(pxp_csc1_coef0)     /* 0x1a0 */
+	mxs_reg_32(pxp_csc1_coef1)     /* 0x1b0 */
+	mxs_reg_32(pxp_csc1_coef2)     /* 0x1c0 */
+	mxs_reg_32(pxp_csc2_ctrl)      /* 0x1d0 */
+	mxs_reg_32(pxp_csc2_coef0)     /* 0x1e0 */
+	mxs_reg_32(pxp_csc2_coef1)     /* 0x1f0 */
+	mxs_reg_32(pxp_csc2_coef2)     /* 0x200 */
+	mxs_reg_32(pxp_csc2_coef3)     /* 0x210 */
+	mxs_reg_32(pxp_csc2_coef4)     /* 0x220 */
+	mxs_reg_32(pxp_csc2_coef5)     /* 0x230 */
+	mxs_reg_32(pxp_lut_ctrl)       /* 0x240 */
+	mxs_reg_32(pxp_lut_addr)       /* 0x250 */
+	mxs_reg_32(pxp_lut_data)       /* 0x260 */
+	mxs_reg_32(pxp_lut_extmem)     /* 0x270 */
+	mxs_reg_32(pxp_cfa)            /* 0x280 */
+	mxs_reg_32(pxp_hist_ctrl)      /* 0x290 */
+	mxs_reg_32(pxp_hist2_param)    /* 0x2a0 */
+	mxs_reg_32(pxp_hist4_param)    /* 0x2b0 */
+	mxs_reg_32(pxp_hist8_param0)   /* 0x2c0 */
+	mxs_reg_32(pxp_hist8_param1)   /* 0x2d0 */
+	mxs_reg_32(pxp_hist16_param0)  /* 0x2e0 */
+	mxs_reg_32(pxp_hist16_param1)  /* 0x2f0 */
+	mxs_reg_32(pxp_hist16_param2)  /* 0x300 */
+	mxs_reg_32(pxp_hist16_param3)  /* 0x310 */
+	mxs_reg_32(pxp_power)          /* 0x320 */
+	uint32_t	reserved1[4*13];
+	mxs_reg_32(pxp_next)           /* 0x400 */
+};
+
+#define BM_PXP_CTRL_IRQ_ENABLE 0x00000002
+#define BM_PXP_CTRL_ENABLE 0x00000001
+
+#define BM_PXP_STAT_IRQ 0x00000001
+
+#define BP_PXP_OUT_CTRL_FORMAT	    0
+#define BM_PXP_OUT_CTRL_FORMAT 0x0000001F
+#define BF_PXP_OUT_CTRL_FORMAT(v)  \
+	(((v) << 0) & BM_PXP_OUT_CTRL_FORMAT)
+
+#define HW_PXP_PS_SCALE	(0x00000110)
+
+#define BM_PXP_PS_SCALE_RSVD2 0x80000000
+#define BP_PXP_PS_SCALE_YSCALE	    16
+#define BM_PXP_PS_SCALE_YSCALE 0x7FFF0000
+#define BF_PXP_PS_SCALE_YSCALE(v)  \
+	(((v) << 16) & BM_PXP_PS_SCALE_YSCALE)
+#define BM_PXP_PS_SCALE_RSVD1 0x00008000
+#define BP_PXP_PS_SCALE_XSCALE	    0
+#define BM_PXP_PS_SCALE_XSCALE 0x00007FFF
+#define BF_PXP_PS_SCALE_XSCALE(v)  \
+	(((v) << 0) & BM_PXP_PS_SCALE_XSCALE)
+
+#define BP_PXP_PS_CTRL_SWAP 5
+#define BM_PXP_PS_CTRL_SWAP 0x000000E0
+#define BF_PXP_PS_CTRL_SWAP(v)  \
+	(((v) << 5) & BM_PXP_PS_CTRL_SWAP)
+#define BP_PXP_PS_CTRL_FORMAT	   0
+#define BM_PXP_PS_CTRL_FORMAT 0x0000001F
+#define BF_PXP_PS_CTRL_FORMAT(v)  \
+	(((v) << 0) & BM_PXP_PS_CTRL_FORMAT)
+#define BM_PXP_CTRL_SFTRST 0x80000000
+#define BM_PXP_CTRL_CLKGATE 0x40000000
+
+struct pxp_layer_param {
+	unsigned short width;
+	unsigned short height;
+	unsigned short stride; /* aka pitch */
+	unsigned int pixel_fmt;
+	void *paddr;
+};
+
+struct pxp_config_data {
+	struct pxp_layer_param s0_param;
+	struct pxp_layer_param out_param;
+};
+
+void pxp_config(struct pxp_config_data *pxp_conf);
+
+#endif
diff --git a/drivers/video/mxc_vadc.c b/drivers/video/mxc_vadc.c
new file mode 100644
index 0000000..3490871
--- /dev/null
+++ b/drivers/video/mxc_vadc.c
@@ -0,0 +1,372 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/clock.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#include <linux/string.h>
+#include <linux/list.h>
+#include <gis.h>
+
+#include "mxc_vadc.h"
+
+#define reg32_write(addr, val) __raw_writel(val, addr)
+#define reg32_read(addr)       __raw_readl(addr)
+#define reg32setbit(addr, bitpos) \
+	reg32_write((addr), (reg32_read((addr)) | (1<<(bitpos))))
+
+#define reg32clrbit(addr, bitpos) \
+	reg32_write((addr), (reg32_read((addr)) & (0xFFFFFFFF ^ (1<<(bitpos)))))
+
+void __iomem *vafe_regbase;
+void __iomem *vdec_regbase;
+
+enum {
+	STD_NTSC = 0,
+	STD_PAL,
+};
+
+/* Video format structure. */
+struct video_fmt_t{
+	int v4l2_id;		/* Video for linux ID. */
+	char name[16];		/* Name (e.g., "NTSC", "PAL", etc.) */
+	u16 active_width;	/* Active width. */
+	u16 active_height;	/* Active height. */
+};
+
+/* Description of video formats supported.
+ *
+ *  PAL: active=720x576.
+ *  NTSC:active=720x480.
+ */
+static struct video_fmt_t video_fmts[] = {
+	/* NTSC */
+	{
+	 .v4l2_id = STD_NTSC,
+	 .name = "NTSC",
+	 .active_width = 720,
+	 .active_height = 480,
+	 },
+	/* (B, G, H, I, N) PAL */
+	{
+	 .v4l2_id = STD_PAL,
+	 .name = "PAL",
+	 .active_width = 720,
+	 .active_height = 576,
+	 },
+};
+
+static void afe_voltage_clampingmode(void)
+{
+	reg32_write(AFE_CLAMP, 0x07);
+	reg32_write(AFE_CLMPAMP, 0x60);
+	reg32_write(AFE_CLMPDAT, 0xF0);
+}
+
+static void afe_alwayson_clampingmode(void)
+{
+	reg32_write(AFE_CLAMP, 0x15);
+	reg32_write(AFE_CLMPDAT, 0x08);
+	reg32_write(AFE_CLMPAMP, 0x00);
+}
+
+static void afe_init(void)
+{
+	reg32_write(AFE_PDBUF, 0x1f);
+	reg32_write(AFE_PDADC, 0x0f);
+	reg32_write(AFE_PDSARH, 0x01);
+	reg32_write(AFE_PDSARL, 0xff);
+	reg32_write(AFE_PDADCRFH, 0x01);
+	reg32_write(AFE_PDADCRFL, 0xff);
+	reg32_write(AFE_ICTRL, 0x3a);
+	reg32_write(AFE_ICTLSTG, 0x1e);
+
+	reg32_write(AFE_RCTRLSTG, 0x1e);
+	reg32_write(AFE_INPBUF, 0x035);
+	reg32_write(AFE_INPFLT, 0x02);
+	reg32_write(AFE_ADCDGN, 0x40);
+	reg32_write(AFE_TSTSEL, 0x10);
+
+	reg32_write(AFE_ACCTST, 0x07);
+
+	reg32_write(AFE_BGREG, 0x08);
+
+	reg32_write(AFE_ADCGN, 0x09);
+
+	/* set current controlled clamping
+	* always on, low current */
+	reg32_write(AFE_CLAMP, 0x11);
+	reg32_write(AFE_CLMPAMP, 0x08);
+}
+
+static void vdec_mode_timing_init(u32 std)
+{
+	if (std == STD_NTSC) {
+		/* NTSC 720x480 */
+		printf("NTSC\n");
+		reg32_write(VDEC_HACTS, 0x66);
+		reg32_write(VDEC_HACTE, 0x24);
+
+		reg32_write(VDEC_VACTS, 0x29);
+		reg32_write(VDEC_VACTE, 0x04);
+
+		/* set V Position */
+		reg32_write(VDEC_VRTPOS, 0x2);
+	} else if (std == STD_PAL) {
+		/* PAL 720x576 */
+		printf("PAL\n");
+		reg32_write(VDEC_HACTS, 0x66);
+		reg32_write(VDEC_HACTE, 0x24);
+
+		reg32_write(VDEC_VACTS, 0x29);
+		reg32_write(VDEC_VACTE, 0x04);
+
+		/* set V Position */
+		reg32_write(VDEC_VRTPOS, 0x6);
+	} else
+		printf("Error not support video mode\n");
+
+	/* set H Position */
+	reg32_write(VDEC_HZPOS, 0x60);
+
+	/* set H ignore start */
+	reg32_write(VDEC_HSIGS, 0xf8);
+
+	/* set H ignore end */
+	reg32_write(VDEC_HSIGE, 0x18);
+}
+
+/*
+* vdec_init()
+* Initialises the VDEC registers
+* Returns: nothing
+*/
+static void vdec_init(struct sensor_data *vadc)
+{
+	/* Get work mode PAL or NTSC
+	 * delay 500ms wait vdec detect input format*/
+	udelay(500*1000);
+	vadc_get_std(vadc);
+
+	vdec_mode_timing_init(vadc->std_id);
+
+	/* vcr detect threshold high, automatic detections */
+	reg32_write(VDEC_VSCON2, 0);
+
+	reg32_write(VDEC_BASE + 0x110, 0x01);
+
+	/* set the noramp mode on the Hloop PLL. */
+	reg32_write(VDEC_BASE+(0x14*4), 0x10);
+
+	/* set the YC relative delay.*/
+	reg32_write(VDEC_YCDEL, 0x90);
+
+	/* setup the Hpll */
+	reg32_write(VDEC_BASE+(0x13*4), 0x13);
+
+	/* setup the 2d comb */
+	/* set the gain of the Hdetail output to 3
+	 * set the notch alpha gain to 1 */
+	reg32_write(VDEC_CFC2, 0x34);
+
+	/* setup various 2d comb bits.*/
+	reg32_write(VDEC_BASE+(0x02*4), 0x01);
+	reg32_write(VDEC_BASE+(0x03*4), 0x18);
+	reg32_write(VDEC_BASE+(0x04*4), 0x34);
+
+	/* set the start of the burst gate */
+	reg32_write(VDEC_BRSTGT, 0x30);
+
+	/* set 1f motion gain */
+	reg32_write(VDEC_BASE+(0x0f*4), 0x20);
+
+	/* set the 1F chroma motion detector thresh for colour reverse detection */
+	reg32_write(VDEC_THSH1, 0x02);
+	reg32_write(VDEC_BASE+(0x4a*4), 0x20);
+	reg32_write(VDEC_BASE+(0x4b*4), 0x08);
+
+	reg32_write(VDEC_BASE+(0x4c*4), 0x08);
+
+	/* set the threshold for the narrow/wide adaptive chroma BW */
+	reg32_write(VDEC_BASE+(0x20*4), 0x20);
+
+	/* turn up the colour with the new colour gain reg */
+	/* hue: */
+	reg32_write(VDEC_HUE, 0x00);
+
+	/* cbgain: 22 B4 */
+	reg32_write(VDEC_CBGN, 0xb4);
+	/* cr gain 80 */
+	reg32_write(VDEC_CRGN, 0x80);
+	/* luma gain (contrast) */
+	reg32_write(VDEC_CNTR, 0x80);
+
+	/* setup the signed black level register, brightness */
+	reg32_write(VDEC_BRT, 0x00);
+
+	/* filter the standard detection
+	 * enable the comb for the ntsc443 */
+	reg32_write(VDEC_STDDBG, 0x20);
+
+	/* setup chroma kill thresh for no chroma */
+	reg32_write(VDEC_CHBTH, 0x0);
+
+	/* set chroma loop to wider BW
+	 * no set it to normal BW. i fixed the bw problem.*/
+	reg32_write(VDEC_YCDEL, 0x00);
+
+	/* set the compensation in the chroma loop for the Hloop
+	 * set the ratio for the nonarithmetic 3d comb modes.*/
+	reg32_write(VDEC_BASE + (0x1d*4), 0x90);
+
+	/* set the threshold for the nonarithmetic mode for the 2d comb
+	 * the higher the value the more Fc Fh offset we will tolerate before turning off the comb. */
+	reg32_write(VDEC_BASE + (0x33*4), 0xa0);
+
+	/* setup the bluescreen output colour */
+	reg32_write(VDEC_BASE + (0x3d*4), 35);
+	reg32_write(VDEC_BLSCRCR, 114);
+	reg32_write(VDEC_BLSCRCB, 212);
+
+	/* disable the active blanking */
+	reg32_write(VDEC_BASE + (0x15*4), 0x02);
+
+	/* setup the luma agc for automatic gain. */
+	reg32_write(VDEC_LMAGC2, 0x5e);
+	reg32_write(VDEC_BASE + (0x40*4), 0x81);
+
+	/* setup chroma agc */
+	reg32_write(VDEC_CHAGC2, 0xa0);
+	reg32_write(VDEC_CHAGC1, 0x01);
+
+	/* setup the MV thresh lower nibble
+	 * setup the sync top cap, upper nibble */
+	reg32_write(VDEC_BASE + (0x3a*4), 0x80);
+	reg32_write(VDEC_SHPIMP, 0x00);
+
+	/* setup the vsync block */
+	reg32_write(VDEC_VSCON1, 0x87);
+
+	/* set the nosignal threshold
+	 * set the vsync threshold */
+	reg32_write(VDEC_VSSGTH, 0x35);
+
+	/* set length for min hphase filter (or saturate limit if saturate is chosen) */
+	reg32_write(VDEC_BASE + (0x45*4), 0x40);
+
+	/* enable the internal resampler,
+	 * select min filter not saturate for hphase noise filter for vcr detect.
+	 * enable vcr pause mode different field lengths */
+	reg32_write(VDEC_BASE + (0x46*4), 0x90);
+
+	/* disable VCR detection, lock to the Hsync rather than the Vsync */
+	reg32_write(VDEC_VSCON2, 0x04);
+
+	/* set tiplevel goal for dc clamp. */
+	reg32_write(VDEC_BASE + (0x3c*4), 0xB0);
+
+	/* override SECAM detection and force SECAM off */
+	reg32_write(VDEC_BASE + (0x2f*4), 0x20);
+
+	/* Set r3d_hardblend in 3D control2 reg */
+	reg32_write(VDEC_BASE + (0x0c*4), 0x04);
+}
+
+/* set Input selector & input pull-downs */
+static void vadc_select_input(int vadc_in)
+{
+	switch (vadc_in) {
+	case 0:
+		reg32_write(AFE_INPFLT, 0x02);
+		reg32_write(AFE_OFFDRV, 0x00);
+		reg32_write(AFE_INPCONFIG, 0x1e);
+		break;
+	case 1:
+		reg32_write(AFE_INPFLT, 0x02);
+		reg32_write(AFE_OFFDRV, 0x00);
+		reg32_write(AFE_INPCONFIG, 0x2d);
+		break;
+	case 2:
+		reg32_write(AFE_INPFLT, 0x02);
+		reg32_write(AFE_OFFDRV, 0x00);
+		reg32_write(AFE_INPCONFIG, 0x4b);
+		break;
+	case 3:
+		reg32_write(AFE_INPFLT, 0x02);
+		reg32_write(AFE_OFFDRV, 0x00);
+		reg32_write(AFE_INPCONFIG, 0x87);
+		break;
+	default:
+		printf("error video input %d\n", vadc_in);
+	}
+}
+
+/*!
+ * Return attributes of current video standard.
+ * Since this device autodetects the current standard, this function also
+ * sets the values that need to be changed if the standard changes.
+ * There is no set std equivalent function.
+ *
+ *  @return		None.
+ */
+void vadc_get_std(struct sensor_data *vadc)
+{
+	int tmp;
+	int idx;
+
+	/* Read PAL mode detected result */
+	tmp = reg32_read(VDEC_VIDMOD);
+	tmp &= (VDEC_VIDMOD_PAL_MASK | VDEC_VIDMOD_M625_MASK);
+
+	if (tmp)
+		idx = STD_PAL;
+	else
+		idx = STD_NTSC;
+
+	vadc->std_id = idx;
+	vadc->pixel_fmt = FMT_YUV444;
+	vadc->width = video_fmts[idx].active_width;
+	vadc->height = video_fmts[idx].active_height;
+}
+
+void vadc_config(u32 vadc_in)
+{
+	struct sensor_data vadc;
+
+	/* map vafe,vdec,gpr,gpc address  */
+	vafe_regbase = (u32 *)VADC_BASE_ADDR;
+	vdec_regbase = (u32 *)VDEC_BASE_ADDR;
+
+	vadc_power_up();
+
+	/* clock config for vadc */
+	reg32_write(VDEC_BASE + 0x320, 0xe3);
+	reg32_write(VDEC_BASE + 0x324, 0x38);
+	reg32_write(VDEC_BASE + 0x328, 0x8e);
+	reg32_write(VDEC_BASE + 0x32c, 0x23);
+	mxs_set_vadcclk();
+
+	afe_init();
+
+	/* select Video Input 0-3 */
+	vadc_select_input(vadc_in);
+
+	afe_voltage_clampingmode();
+
+	vdec_init(&vadc);
+
+	/*
+	* current control loop will move sinewave input off below
+	* the bottom of the signal range visible when the testbus is viewed as magnitude,
+	* so have to break before this point while capturing ENOB data:
+	*/
+	afe_alwayson_clampingmode();
+}
+
diff --git a/drivers/video/mxc_vadc.h b/drivers/video/mxc_vadc.h
new file mode 100644
index 0000000..7134b1e
--- /dev/null
+++ b/drivers/video/mxc_vadc.h
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MXC_VADC_H
+#define MXC_VADC_H
+
+/*** define base address ***/
+#define VDEC_BASE vdec_regbase
+#define AFE_BASE vafe_regbase
+
+/* AFE - Register offsets */
+#define AFE_BLOCK_ID_OFFSET				0x00000000
+#define AFE_PDBUF_OFFSET				0x00000004
+#define AFE_SWRST_OFFSET				0x00000008
+#define AFE_TSTSEL_OFFSET				0x0000000c
+#define AFE_TSTMSC_OFFSET				0x00000010
+#define AFE_ENPADIO_OFFSET				0x00000014
+#define AFE_BGREG_OFFSET				0x00000018
+#define AFE_ACCESSAR_ID_OFFSET			0x00000400
+#define AFE_PDADC_OFFSET				0x00000404
+#define AFE_PDSARH_OFFSET				0x00000408
+#define AFE_PDSARL_OFFSET				0x0000040C
+#define AFE_PDADCRFH_OFFSET				0x00000410
+#define AFE_PDADCRFL_OFFSET				0x00000414
+#define AFE_ACCTST_OFFSET				0x00000418
+#define AFE_ADCGN_OFFSET				0x0000041C
+#define AFE_ICTRL_OFFSET				0x00000420
+#define AFE_ICTLSTG_OFFSET				0x00000424
+#define AFE_RCTRLSTG_OFFSET				0x00000428
+#define AFE_TCTRLSTG_OFFSET				0x0000042c
+#define AFE_REFMOD_OFFSET				0x00000430
+#define AFE_REFTRIML_OFFSET				0x00000434
+#define AFE_REFTRIMH_OFFSET				0x00000438
+#define AFE_ADCR_OFFSET					0x0000043c
+#define AFE_DUMMY0_OFFSET				0x00000440
+#define AFE_DUMMY1_OFFSET				0x00000444
+#define AFE_DUMMY2_OFFSET				0x00000448
+#define AFE_DACAMP_OFFSET				0x0000044c
+#define AFE_CLMPTST_OFFSET				0x00000450
+#define AFE_CLMPDAT_OFFSET				0x00000454
+#define AFE_CLMPAMP_OFFSET				0x00000458
+#define AFE_CLAMP_OFFSET				0x0000045c
+#define AFE_INPBUF_OFFSET				0x00000460
+#define AFE_INPFLT_OFFSET				0x00000464
+#define AFE_ADCDGN_OFFSET				0x00000468
+#define AFE_OFFDRV_OFFSET				0x0000046c
+#define AFE_INPCONFIG_OFFSET			0x00000470
+#define AFE_PROGDELAY_OFFSET			0x00000474
+#define AFE_ADCOMT_OFFSET				0x00000478
+#define AFE_ALGDELAY_OFFSET				0x0000047c
+#define AFE_ACC_ID_OFFSET				0x00000800
+#define AFE_ACCSTA_OFFSET				0x00000804
+#define AFE_ACCNOSLI_OFFSET				0x00000808
+#define AFE_ACCCALCON_OFFSET			0x0000080c
+#define AFE_BWEWRICTRL_OFFSET			0x00000810
+#define AFE_SELSLI_OFFSET				0x00000814
+#define AFE_SELBYT_OFFSET				0x00000818
+#define AFE_REDVAL_OFFSET				0x00000820
+#define AFE_WRIBYT_OFFSET				0x00000824
+
+/* AFE Register per module */
+#define AFE_BLOCK_ID			(AFE_BASE + AFE_BLOCK_ID_OFFSET)
+#define AFE_PDBUF				(AFE_BASE + AFE_PDBUF_OFFSET)
+#define AFE_SWRST				(AFE_BASE + AFE_SWRST_OFFSET)
+#define AFE_TSTSEL				(AFE_BASE + AFE_TSTSEL_OFFSET)
+#define AFE_TSTMSC				(AFE_BASE + AFE_TSTMSC_OFFSET)
+#define AFE_ENPADIO				(AFE_BASE + AFE_ENPADIO_OFFSET)
+#define AFE_BGREG				(AFE_BASE + AFE_BGREG_OFFSET)
+#define AFE_ACCESSAR_ID			(AFE_BASE + AFE_ACCESSAR_ID_OFFSET)
+#define AFE_PDADC				(AFE_BASE + AFE_PDADC_OFFSET)
+#define AFE_PDSARH			    (AFE_BASE + AFE_PDSARH_OFFSET)
+#define AFE_PDSARL			    (AFE_BASE + AFE_PDSARL_OFFSET)
+#define AFE_PDADCRFH			(AFE_BASE + AFE_PDADCRFH_OFFSET)
+#define AFE_PDADCRFL			(AFE_BASE + AFE_PDADCRFL_OFFSET)
+#define AFE_ACCTST				(AFE_BASE + AFE_ACCTST_OFFSET)
+#define AFE_ADCGN				(AFE_BASE + AFE_ADCGN_OFFSET)
+#define AFE_ICTRL				(AFE_BASE + AFE_ICTRL_OFFSET)
+#define AFE_ICTLSTG				(AFE_BASE + AFE_ICTLSTG_OFFSET)
+#define AFE_RCTRLSTG			(AFE_BASE + AFE_RCTRLSTG_OFFSET)
+#define AFE_TCTRLSTG			(AFE_BASE + AFE_TCTRLSTG_OFFSET)
+#define AFE_REFMOD				(AFE_BASE + AFE_REFMOD_OFFSET)
+#define AFE_REFTRIML			(AFE_BASE + AFE_REFTRIML_OFFSET)
+#define AFE_REFTRIMH			(AFE_BASE + AFE_REFTRIMH_OFFSET)
+#define AFE_ADCR				(AFE_BASE + AFE_ADCR_OFFSET)
+#define AFE_DUMMY0				(AFE_BASE + AFE_DUMMY0_OFFSET)
+#define AFE_DUMMY1				(AFE_BASE + AFE_DUMMY1_OFFSET)
+#define AFE_DUMMY2				(AFE_BASE + AFE_DUMMY2_OFFSET)
+#define AFE_DACAMP				(AFE_BASE + AFE_DACAMP_OFFSET)
+#define AFE_CLMPTST				(AFE_BASE + AFE_CLMPTST_OFFSET)
+#define AFE_CLMPDAT				(AFE_BASE + AFE_CLMPDAT_OFFSET)
+#define AFE_CLMPAMP				(AFE_BASE + AFE_CLMPAMP_OFFSET)
+#define AFE_CLAMP				(AFE_BASE + AFE_CLAMP_OFFSET)
+#define AFE_INPBUF				(AFE_BASE + AFE_INPBUF_OFFSET)
+#define AFE_INPFLT				(AFE_BASE + AFE_INPFLT_OFFSET)
+#define AFE_ADCDGN				(AFE_BASE + AFE_ADCDGN_OFFSET)
+#define AFE_OFFDRV				(AFE_BASE + AFE_OFFDRV_OFFSET)
+#define AFE_INPCONFIG			(AFE_BASE + AFE_INPCONFIG_OFFSET)
+#define AFE_PROGDELAY			(AFE_BASE + AFE_PROGDELAY_OFFSET)
+#define AFE_ADCOMT				(AFE_BASE + AFE_ADCOMT_OFFSET)
+#define AFE_ALGDELAY			(AFE_BASE + AFE_ALGDELAY_OFFSET)
+#define AFE_ACC_ID				(AFE_BASE + AFE_ACC_ID_OFFSET)
+#define AFE_ACCSTA				(AFE_BASE + AFE_ACCSTA_OFFSET)
+#define AFE_ACCNOSLI			(AFE_BASE + AFE_ACCNOSLI_OFFSET)
+#define AFE_ACCCALCON			(AFE_BASE + AFE_ACCCALCON_OFFSET)
+#define AFE_BWEWRICTRL			(AFE_BASE + AFE_BWEWRICTRL_OFFSET)
+#define AFE_SELSLI				(AFE_BASE + AFE_SELSLI_OFFSET)
+#define AFE_SELBYT				(AFE_BASE + AFE_SELBYT_OFFSET)
+#define AFE_REDVAL				(AFE_BASE + AFE_REDVAL_OFFSET)
+#define AFE_WRIBYT				(AFE_BASE + AFE_WRIBYT_OFFSET)
+
+/* VDEC - Register offsets */
+#define VDEC_CFC1_OFFSET                0x00000000
+#define VDEC_CFC2_OFFSET                0x00000004
+#define VDEC_BRSTGT_OFFSET              0x00000024
+#define VDEC_HZPOS_OFFSET               0x00000040
+#define VDEC_VRTPOS_OFFSET              0x00000044
+#define VDEC_HVSHIFT_OFFSET             0x00000054
+#define VDEC_HSIGS_OFFSET               0x00000058
+#define VDEC_HSIGE_OFFSET               0x0000005C
+#define VDEC_VSCON1_OFFSET              0x00000060
+#define VDEC_VSCON2_OFFSET              0x00000064
+#define VDEC_YCDEL_OFFSET               0x0000006C
+#define VDEC_AFTCLP_OFFSET              0x00000070
+#define VDEC_DCOFF_OFFSET               0x00000078
+#define VDEC_CSID_OFFSET                0x00000084
+#define VDEC_CBGN_OFFSET                0x00000088
+#define VDEC_CRGN_OFFSET                0x0000008C
+#define VDEC_CNTR_OFFSET                0x00000090
+#define VDEC_BRT_OFFSET                 0x00000094
+#define VDEC_HUE_OFFSET                 0x00000098
+#define VDEC_CHBTH_OFFSET               0x0000009C
+#define VDEC_SHPIMP_OFFSET              0x000000A4
+#define VDEC_CHPLLIM_OFFSET             0x000000A8
+#define VDEC_VIDMOD_OFFSET              0x000000AC
+#define VDEC_VIDSTS_OFFSET              0x000000B0
+#define VDEC_NOISE_OFFSET               0x000000B4
+#define VDEC_STDDBG_OFFSET              0x000000B8
+#define VDEC_MANOVR_OFFSET              0x000000BC
+#define VDEC_VSSGTH_OFFSET              0x000000C8
+#define VDEC_DBGFBH_OFFSET              0x000000D0
+#define VDEC_DBGFBL_OFFSET              0x000000D4
+#define VDEC_HACTS_OFFSET               0x000000D8
+#define VDEC_HACTE_OFFSET               0x000000DC
+#define VDEC_VACTS_OFFSET               0x000000E0
+#define VDEC_VACTE_OFFSET               0x000000E4
+#define VDEC_HSTIP_OFFSET               0x000000EC
+#define VDEC_BLSCRY_OFFSET              0x000000F4
+#define VDEC_BLSCRCR_OFFSET             0x000000F8
+#define VDEC_BLSCRCB_OFFSET             0x000000FC
+#define VDEC_LMAGC2_OFFSET              0x00000104
+#define VDEC_CHAGC1_OFFSET              0x00000108
+#define VDEC_CHAGC2_OFFSET              0x0000010C
+#define VDEC_MINTH_OFFSET               0x00000114
+#define VDEC_VFRQOH_OFFSET              0x0000011C
+#define VDEC_VFRQOL_OFFSET              0x00000120
+#define VDEC_THSH1_OFFSET               0x00000124
+#define VDEC_THSH2_OFFSET               0x00000128
+#define VDEC_NCHTH_OFFSET               0x0000012C
+#define VDEC_TH1F_OFFSET                0x00000130
+
+/* VDEC Register per module */
+#define VDEC_CFC1                        (VDEC_BASE + VDEC_CFC1_OFFSET)
+#define VDEC_CFC2                        (VDEC_BASE + VDEC_CFC2_OFFSET)
+#define VDEC_BRSTGT                      (VDEC_BASE + VDEC_BRSTGT_OFFSET)
+#define VDEC_HZPOS                       (VDEC_BASE + VDEC_HZPOS_OFFSET)
+#define VDEC_VRTPOS                      (VDEC_BASE + VDEC_VRTPOS_OFFSET)
+#define VDEC_HVSHIFT                     (VDEC_BASE + VDEC_HVSHIFT_OFFSET)
+#define VDEC_HSIGS                       (VDEC_BASE + VDEC_HSIGS_OFFSET)
+#define VDEC_HSIGE                       (VDEC_BASE + VDEC_HSIGE_OFFSET)
+#define VDEC_VSCON1                      (VDEC_BASE + VDEC_VSCON1_OFFSET)
+#define VDEC_VSCON2                      (VDEC_BASE + VDEC_VSCON2_OFFSET)
+#define VDEC_YCDEL                       (VDEC_BASE + VDEC_YCDEL_OFFSET)
+#define VDEC_AFTCLP                      (VDEC_BASE + VDEC_AFTCLP_OFFSET)
+#define VDEC_DCOFF                       (VDEC_BASE + VDEC_DCOFF_OFFSET)
+#define VDEC_CSID                        (VDEC_BASE + VDEC_CSID_OFFSET)
+#define VDEC_CBGN                        (VDEC_BASE + VDEC_CBGN_OFFSET)
+#define VDEC_CRGN                        (VDEC_BASE + VDEC_CRGN_OFFSET)
+#define VDEC_CNTR                        (VDEC_BASE + VDEC_CNTR_OFFSET)
+#define VDEC_BRT                         (VDEC_BASE + VDEC_BRT_OFFSET)
+#define VDEC_HUE                         (VDEC_BASE + VDEC_HUE_OFFSET)
+#define VDEC_CHBTH                       (VDEC_BASE + VDEC_CHBTH_OFFSET)
+#define VDEC_SHPIMP                      (VDEC_BASE + VDEC_SHPIMP_OFFSET)
+#define VDEC_CHPLLIM                     (VDEC_BASE + VDEC_CHPLLIM_OFFSET)
+#define VDEC_VIDMOD                      (VDEC_BASE + VDEC_VIDMOD_OFFSET)
+#define VDEC_VIDSTS                      (VDEC_BASE + VDEC_VIDSTS_OFFSET)
+#define VDEC_NOISE                       (VDEC_BASE + VDEC_NOISE_OFFSET)
+#define VDEC_STDDBG                      (VDEC_BASE + VDEC_STDDBG_OFFSET)
+#define VDEC_MANOVR                      (VDEC_BASE + VDEC_MANOVR_OFFSET)
+#define VDEC_VSSGTH                      (VDEC_BASE + VDEC_VSSGTH_OFFSET)
+#define VDEC_DBGFBH                      (VDEC_BASE + VDEC_DBGFBH_OFFSET)
+#define VDEC_DBGFBL                      (VDEC_BASE + VDEC_DBGFBL_OFFSET)
+#define VDEC_HACTS                       (VDEC_BASE + VDEC_HACTS_OFFSET)
+#define VDEC_HACTE                       (VDEC_BASE + VDEC_HACTE_OFFSET)
+#define VDEC_VACTS                       (VDEC_BASE + VDEC_VACTS_OFFSET)
+#define VDEC_VACTE                       (VDEC_BASE + VDEC_VACTE_OFFSET)
+#define VDEC_HSTIP                       (VDEC_BASE + VDEC_HSTIP_OFFSET)
+#define VDEC_BLSCRY                      (VDEC_BASE + VDEC_BLSCRY_OFFSET)
+#define VDEC_BLSCRCR                     (VDEC_BASE + VDEC_BLSCRCR_OFFSET)
+#define VDEC_BLSCRCB                     (VDEC_BASE + VDEC_BLSCRCB_OFFSET)
+#define VDEC_LMAGC2                      (VDEC_BASE + VDEC_LMAGC2_OFFSET)
+#define VDEC_CHAGC1                      (VDEC_BASE + VDEC_CHAGC1_OFFSET)
+#define VDEC_CHAGC2                      (VDEC_BASE + VDEC_CHAGC2_OFFSET)
+#define VDEC_MINTH                       (VDEC_BASE + VDEC_MINTH_OFFSET)
+#define VDEC_VFRQOH                      (VDEC_BASE + VDEC_VFRQOH_OFFSET)
+#define VDEC_VFRQOL                      (VDEC_BASE + VDEC_VFRQOL_OFFSET)
+#define VDEC_THSH1                       (VDEC_BASE + VDEC_THSH1_OFFSET)
+#define VDEC_THSH2                       (VDEC_BASE + VDEC_THSH2_OFFSET)
+#define VDEC_NCHTH                       (VDEC_BASE + VDEC_NCHTH_OFFSET)
+#define VDEC_TH1F                        (VDEC_BASE + VDEC_TH1F_OFFSET)
+
+#define VDEC_VIDMOD_M625_SHIFT            4
+#define VDEC_VIDMOD_M625_MASK             (1 << VDEC_VIDMOD_M625_SHIFT)
+
+#define VDEC_VIDMOD_PAL_SHIFT             7
+#define VDEC_VIDMOD_PAL_MASK              (1 << VDEC_VIDMOD_PAL_SHIFT)
+
+struct sensor_data {
+	u32 width;
+	u32 height;
+	u32 pixel_fmt;
+	u32 std_id;
+};
+
+void vadc_config(u32 vadc_in);
+void vadc_get_std(struct sensor_data *vadc);
+
+#endif
diff --git a/drivers/video/mxsfb.c b/drivers/video/mxsfb.c
index 03b0f88..44004b1 100644
--- a/drivers/video/mxsfb.c
+++ b/drivers/video/mxsfb.c
@@ -18,8 +18,17 @@
 #include <asm/imx-common/dma.h>
 
 #include "videomodes.h"
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/fb.h>
+#include <mxsfb.h>
+
+#ifdef CONFIG_VIDEO_GIS
+#include <gis.h>
+#endif
 
 #define	PS2KHZ(ps)	(1000000000UL / (ps))
+#define	WAIT_FOR_VSYNC_TIMEOUT	1000000
 
 static GraphicDevice panel;
 struct mxs_dma_desc desc;
@@ -35,6 +44,31 @@ __weak void mxsfb_system_setup(void)
 {
 }
 
+static int setup;
+static struct fb_videomode fbmode;
+static int depth;
+
+int mxs_lcd_panel_setup(struct fb_videomode mode, int bpp,
+	uint32_t base_addr)
+{
+	fbmode = mode;
+	depth  = bpp;
+	panel.isaBase  = base_addr;
+
+	setup = 1;
+
+	return 0;
+}
+
+void mxs_lcd_get_panel(struct display_panel *dispanel)
+{
+	dispanel->width = fbmode.xres;
+	dispanel->height = fbmode.yres;
+	dispanel->reg_base = panel.isaBase;
+	dispanel->gdfindex = panel.gdfIndex;
+	dispanel->gdfbytespp = panel.gdfBytesPP;
+}
+
 /*
  * DENX M28EVK:
  * setenv videomode
@@ -50,15 +84,15 @@ __weak void mxsfb_system_setup(void)
 static void mxs_lcd_init(GraphicDevice *panel,
 			struct ctfb_res_modes *mode, int bpp)
 {
-	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)MXS_LCDIF_BASE;
+	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)(panel->isaBase);
 	uint32_t word_len = 0, bus_width = 0;
 	uint8_t valid_data = 0;
 
 	/* Kick in the LCDIF clock */
-	mxs_set_lcdclk(PS2KHZ(mode->pixclock));
+	mxs_set_lcdclk(panel->isaBase, PS2KHZ(mode->pixclock));
 
 	/* Restart the LCDIF block */
-	mxs_reset_block(&regs->hw_lcdif_ctrl_reg);
+	mxs_reset_block((struct mxs_register_32 *)&regs->hw_lcdif_ctrl);
 
 	switch (bpp) {
 	case 24:
@@ -131,6 +165,22 @@ static void mxs_lcd_init(GraphicDevice *panel,
 	writel(LCDIF_CTRL_RUN, &regs->hw_lcdif_ctrl_set);
 }
 
+void lcdif_power_down()
+{
+	struct mxs_lcdif_regs *regs = (struct mxs_lcdif_regs *)(panel.isaBase);
+	int timeout = WAIT_FOR_VSYNC_TIMEOUT;
+
+	writel(panel.frameAdrs, &regs->hw_lcdif_cur_buf);
+	writel(panel.frameAdrs, &regs->hw_lcdif_next_buf);
+	writel(LCDIF_CTRL1_VSYNC_EDGE_IRQ, &regs->hw_lcdif_ctrl1_clr);
+	while (--timeout) {
+		if (readl(&regs->hw_lcdif_ctrl1) & LCDIF_CTRL1_VSYNC_EDGE_IRQ)
+			break;
+		udelay(1);
+	}
+	mxs_reset_block((struct mxs_register_32 *)&regs->hw_lcdif_ctrl);
+}
+
 void *video_hw_init(void)
 {
 	int bpp = -1;
@@ -140,19 +190,37 @@ void *video_hw_init(void)
 
 	puts("Video: ");
 
-	/* Suck display configuration from "videomode" variable */
-	penv = getenv("videomode");
-	if (!penv) {
-		puts("MXSFB: 'videomode' variable not set!\n");
-		return NULL;
+	if (!setup) {
+
+		/* Suck display configuration from "videomode" variable */
+		penv = getenv("videomode");
+		if (!penv) {
+			printf("MXSFB: 'videomode' variable not set!\n");
+			return NULL;
+		}
+
+		bpp = video_get_params(&mode, penv);
+		panel.isaBase  = MXS_LCDIF_BASE;
+	} else {
+		mode.xres = fbmode.xres;
+		mode.yres = fbmode.yres;
+		mode.pixclock = fbmode.pixclock;
+		mode.left_margin = fbmode.left_margin;
+		mode.right_margin = fbmode.right_margin;
+		mode.upper_margin = fbmode.upper_margin;
+		mode.lower_margin = fbmode.lower_margin;
+		mode.hsync_len = fbmode.hsync_len;
+		mode.vsync_len = fbmode.vsync_len;
+		mode.sync = fbmode.sync;
+		mode.vmode = fbmode.vmode;
+		bpp = depth;
 	}
 
-	bpp = video_get_params(&mode, penv);
-
 	/* fill in Graphic device struct */
 	sprintf(panel.modeIdent, "%dx%dx%d",
 			mode.xres, mode.yres, bpp);
 
+
 	panel.winSizeX = mode.xres;
 	panel.winSizeY = mode.yres;
 	panel.plnSizeX = mode.xres;
@@ -179,6 +247,7 @@ void *video_hw_init(void)
 
 	panel.memSize = mode.xres * mode.yres * panel.gdfBytesPP;
 
+
 	/* Allocate framebuffer */
 	fb = memalign(ARCH_DMA_MINALIGN,
 		      roundup(panel.memSize, ARCH_DMA_MINALIGN));
@@ -220,5 +289,10 @@ void *video_hw_init(void)
 	mxs_dma_circ_start(MXS_DMA_CHANNEL_AHB_APBH_LCDIF, &desc);
 #endif
 
+#ifdef CONFIG_VIDEO_GIS
+	/* Entry for GIS */
+	mxc_enable_gis();
+#endif
+
 	return (void *)&panel;
 }
diff --git a/include/android_image.h b/include/android_image.h
new file mode 100644
index 0000000..094d60a
--- /dev/null
+++ b/include/android_image.h
@@ -0,0 +1,69 @@
+/*
+ * This is from the Android Project,
+ * Repository: https://android.googlesource.com/platform/bootable/bootloader/legacy
+ * File: include/boot/bootimg.h
+ * Commit: 4205b865141ff2e255fe1d3bd16de18e217ef06a
+ *
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * SPDX-License-Identifier: BSD-2-Clause
+ */
+
+#ifndef _ANDROID_IMAGE_H_
+#define _ANDROID_IMAGE_H_
+
+#define ANDR_BOOT_MAGIC "ANDROID!"
+#define ANDR_BOOT_MAGIC_SIZE 8
+#define ANDR_BOOT_NAME_SIZE 16
+#define ANDR_BOOT_ARGS_SIZE 512
+
+struct andr_img_hdr {
+	char magic[ANDR_BOOT_MAGIC_SIZE];
+
+	u32 kernel_size;	/* size in bytes */
+	u32 kernel_addr;	/* physical load addr */
+
+	u32 ramdisk_size;	/* size in bytes */
+	u32 ramdisk_addr;	/* physical load addr */
+
+	u32 second_size;	/* size in bytes */
+	u32 second_addr;	/* physical load addr */
+
+	u32 tags_addr;		/* physical addr for kernel tags */
+	u32 page_size;		/* flash page size we assume */
+	u32 unused[2];		/* future expansion: should be 0 */
+
+	char name[ANDR_BOOT_NAME_SIZE]; /* asciiz product name */
+
+	char cmdline[ANDR_BOOT_ARGS_SIZE];
+
+	u32 id[8]; /* timestamp / checksum / sha1 / etc */
+};
+
+/*
+ * +-----------------+
+ * | boot header     | 1 page
+ * +-----------------+
+ * | kernel          | n pages
+ * +-----------------+
+ * | ramdisk         | m pages
+ * +-----------------+
+ * | second stage    | o pages
+ * +-----------------+
+ *
+ * n = (kernel_size + page_size - 1) / page_size
+ * m = (ramdisk_size + page_size - 1) / page_size
+ * o = (second_size + page_size - 1) / page_size
+ *
+ * 0. all entities are page_size aligned in flash
+ * 1. kernel and ramdisk are required (size != 0)
+ * 2. second is optional (second_size == 0 -> no second)
+ * 3. load each element (kernel, ramdisk, second) at
+ *    the specified physical address (kernel_addr, etc)
+ * 4. prepare tags at tag_addr.  kernel_args[] is
+ *    appended to the kernel commandline in the tags.
+ * 5. r0 = 0, r1 = MACHINE_TYPE, r2 = tags_addr
+ * 6. if second_size != 0: jump to second_addr
+ *    else: jump to kernel_addr
+ */
+#endif
diff --git a/include/configs/ag11005.h b/include/configs/ag11005.h
new file mode 100644
index 0000000..4090380
--- /dev/null
+++ b/include/configs/ag11005.h
@@ -0,0 +1,198 @@
+/*
+ * (C) Copyright 2011-2014
+ * Daniel Dyer, Axent Global, daniel_dyer@axent.com.au
+ *
+ * Configuration settings for the AG11005 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/hardware.h>
+
+#define CONFIG_SYS_TEXT_BASE		0x73f00000
+
+#define CONFIG_ATMEL_LEGACY		/* required until (g)pio is fixed */
+
+/* ARM asynchronous clock */
+#define CONFIG_SYS_AT91_SLOW_CLOCK	32768
+#define CONFIG_SYS_AT91_MAIN_CLOCK	12000000	/* from 12 MHz crystal */
+
+#define CONFIG_AT91FAMILY
+
+#define CONFIG_CMDLINE_TAG		/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_DISPLAY_CPUINFO
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_AT91_GPIO
+#define CONFIG_ATMEL_USART
+#define CONFIG_USART_BASE		ATMEL_BASE_DBGU
+#define	CONFIG_USART_ID			ATMEL_ID_SYS
+#define CONFIG_ATMEL_SPI
+
+/* LCD */
+#define CONFIG_LCD
+#define LCD_BPP				LCD_COLOR32
+#define CONFIG_LCD_LOGO
+#undef LCD_TEST_PATTERN
+#define CONFIG_LCD_INFO
+#define CONFIG_LCD_INFO_BELOW_LOGO
+#define CONFIG_SYS_WHITE_ON_BLACK
+#define CONFIG_ATMEL_LCD
+#define CONFIG_ATMEL_LCD_RGB565
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+/* board specific(not enough SRAM) */
+#define CONFIG_AT91SAM9G45_LCD_BASE		0x74000000
+
+/* LED */
+#define CONFIG_AT91_LED
+#define	CONFIG_RED_LED		AT91_PIN_PD1	/* this is the user1 led */
+#define	CONFIG_GREEN_LED	AT91_PIN_PD0	/* this is the user2 led */
+
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+/*
+ * Debug
+ */
+#undef DEBUG
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_IMLS
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_LOADS
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_USB
+#define CONFIG_CMD_I2C
+#define CONFIG_CMD_FPGA
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_FAT
+
+/* FPGA */
+#define CONFIG_FPGA
+#define CONFIG_FPGA_XILINX
+#define CONFIG_FPGA_SPARTAN6
+#define CONFIG_FPGA_COUNT		1
+#define CONFIG_FPGA_DELAY()		udelay(1)
+
+/* MMC */
+#define CONFIG_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_GENERIC_ATMEL_MCI
+#define CONFIG_SYS_MMC_CD_PIN	AT91_PIN_PA6
+
+/* I2C */
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_SOFT		/* I2C bit-banged */
+#define CONFIG_SYS_I2C_SPEED	100000
+#define CONFIG_SYS_I2C_SLAVE	0x7E
+
+#define I2C_ACTIVE
+#define I2C_TRISTATE
+#define I2C_READ		at91_get_gpio_value(AT91_PIN_PA20);
+#define I2C_SDA(bit)		at91_set_gpio_value(AT91_PIN_PA20, bit)
+#define I2C_SCL(bit)		at91_set_gpio_value(AT91_PIN_PA21, bit)
+#define I2C_DELAY		udelay(2)	/* 100 kHz */
+
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS		1
+#define CONFIG_SYS_SDRAM_BASE		ATMEL_BASE_CS6
+#define CONFIG_SYS_SDRAM_SIZE		0x08000000
+
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_SDRAM_BASE + 4 * 1024 - GENERATED_GBL_DATA_SIZE)
+
+#define CONFIG_SYS_NO_FLASH
+
+/* NAND flash */
+#ifdef CONFIG_CMD_NAND
+#define CONFIG_NAND_ATMEL
+#define CONFIG_SYS_MAX_NAND_DEVICE		1
+#define CONFIG_SYS_NAND_BASE			ATMEL_BASE_CS3
+#define CONFIG_SYS_NAND_DBW_16			1
+#define CONFIG_NAND_ECC_BCH
+#define CONFIG_BCH
+/* our ALE is AD21 */
+#define CONFIG_SYS_NAND_MASK_ALE		(1 << 21)
+/* our CLE is AD22 */
+#define CONFIG_SYS_NAND_MASK_CLE		(1 << 22)
+#define CONFIG_SYS_NAND_ENABLE_PIN		AT91_PIN_PC14
+#define CONFIG_SYS_NAND_READY_PIN		AT91_PIN_PC12
+
+#endif
+
+/* Ethernet */
+#define CONFIG_MACB
+#define CONFIG_MACB_SEARCH_PHY
+#define CONFIG_RMII
+#define CONFIG_NET_MULTI
+#define CONFIG_NET_RETRY_COUNT		20
+#define CONFIG_RESET_PHY_R
+#define CONFIG_AT91_WANTS_COMMON_PHY
+
+/* USB */
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_ATMEL
+#define CONFIG_SYS_USB_EHCI_MAX_ROOT_PORTS	2
+#define CONFIG_DOS_PARTITION
+#define CONFIG_USB_STORAGE
+
+#define CONFIG_SYS_LOAD_ADDR			0x72000000	/* load address */
+
+#define CONFIG_SYS_MEMTEST_START		PHYS_SDRAM
+#define CONFIG_SYS_MEMTEST_END			0x73e00000
+
+/* bootstrap + u-boot + env + linux in nandflash */
+#define CONFIG_ENV_IS_IN_NAND
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_ENV_OFFSET		0xa0000
+#define CONFIG_ENV_SIZE		0x20000		/* 1 sector = 128 kB */
+#define CONFIG_BOOTCOMMAND	"nand read 0x72000000 0x200000 0x400000; bootm"
+#define CONFIG_BOOTARGS		"mem=128M console=ttyS0,115200 console=tty0 " \
+				"root=/dev/mtdblock5 " \
+				"ubi.mtd=4 ubi.mtd=5 " \
+				"ubi.mtd=6 root=ubi0:rootfs " \
+				"rootfstype=ubifs"
+
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{115200 , 19200, 38400, 57600, 9600 }
+
+#define CONFIG_SYS_PROMPT		"U-Boot> "
+#define CONFIG_SYS_CBSIZE		256
+#define CONFIG_SYS_MAXARGS		16
+#define CONFIG_SYS_PBSIZE		(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_LONGHELP		1
+#define CONFIG_CMDLINE_EDITING	1
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2	"> "
+
+/*
+ * Size of malloc() pool
+ */
+#define CONFIG_SYS_MALLOC_LEN		ROUND(3 * CONFIG_ENV_SIZE + 128*1024, 0x1000)
+
+#endif
diff --git a/include/configs/ag13008.h b/include/configs/ag13008.h
new file mode 100644
index 0000000..2d738ff
--- /dev/null
+++ b/include/configs/ag13008.h
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2014 Axent Global
+ * Daniel Dyer <daniel_dyer@axent.com.au>
+ *
+ * Configuration settings for the Axent AG13008 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "mx6_common.h"
+#define CONFIG_MX6
+#define CONFIG_MX6Q
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define MACH_TYPE_AG13008		4935
+#define CONFIG_MACH_TYPE		MACH_TYPE_AG13008
+
+#include <asm/arch/imx-regs.h>
+#include <asm/imx-common/gpio.h>
+
+#undef is_boot_from_usb
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(10 * 1024 * 1024)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_MXC_GPIO
+#define CONFIG_CI_UDC
+#define CONFIG_USBD_HS
+#define CONFIG_USB_GADGET_DUALSPEED
+#define CONFIG_NETCONSOLE
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+#define CONFIG_CMD_SF
+#ifdef CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_BAR
+#define CONFIG_SPI_FLASH_SST
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_STMICRO
+#ifdef CONFIG_AG13008B
+#define CONFIG_SPI_FLASH_DISABLE_HOLD
+#endif
+#define CONFIG_MXC_SPI
+#ifdef CONFIG_AG13008A
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(4, 9)<<8))
+#else
+#define CONFIG_SF_DEFAULT_BUS  3
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(3, 20)<<8))
+#endif
+#define CONFIG_SF_DEFAULT_SPEED 25000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+/* I2C Configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_I2C_MULTI_BUS
+#define CONFIG_SYS_I2C_SOFT
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_I2C_EEPROM_BUS_NUM   3
+#define CONFIG_I2C_EDID
+
+#define CONFIG_SOFT_I2C_GPIO_SCL	IMX_GPIO_NR(1, 7)
+#define CONFIG_SOFT_I2C_GPIO_SDA	IMX_GPIO_NR(1, 8)
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#define CONFIG_SYS_FSL_USDHC_NUM	1
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_BOUNCE_BUFFER
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+
+#ifdef CONFIG_MX6Q
+#define CONFIG_CMD_SATA
+#endif
+
+/*
+ * SATA Configs
+ */
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define	CONFIG_FEC_MXC
+#define CONFIG_CMD_CONSOLE
+#define CONFIG_CMD_MEMTEST
+#define	CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define	CONFIG_FEC_XCV_TYPE		RGMII
+#define CONFIG_ETHPRIME			"FEC"
+#define CONFIG_FEC_MXC_PHYADDR	7
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_MICREL
+#define CONFIG_PHY_MICREL_KSZ9021
+#define CONFIG_PHY_GIGE
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET	/* For OTG port */
+#define CONFIG_MXC_USB_PORTSC	(PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS	0
+#define CONFIG_USB_KEYBOARD
+#define CONFIG_SYS_USB_EVENT_POLL_VIA_CONTROL_EP
+
+/* Framebuffer */
+#ifndef CONFIG_NOCONSOLE
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#define CONFIG_IPUV3_CLK 260000000
+#define CONFIG_CMD_HDMIDETECT
+#define CONFIG_CONSOLE_MUX
+#define CONFIG_IMX_HDMI
+#endif
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_BAUDRATE			115200
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		1
+
+#define CONFIG_LOADADDR			       0x12000000
+#define CONFIG_SYS_TEXT_BASE	       0x17800000
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DRIVE_SATA "sata "
+#else
+#define CONFIG_DRIVE_SATA
+#endif
+
+#ifdef CONFIG_CMD_MMC
+#define CONFIG_DRIVE_MMC "mmc "
+#else
+#define CONFIG_DRIVE_MMC
+#endif
+
+#ifdef CONFIG_NOCONSOLE
+#define CONFIG_ARGS_STDIN "stdin=serial\0"
+#define CONFIG_ARGS_STOUT "stdout=serial\0"
+#define CONFIG_ARGS_STERR "stderr=serial\0"
+#define CONFIG_ARGS_CONSOLE ""
+#else
+#define CONFIG_ARGS_STDIN "stdin=serial,usbkbd\0"
+#define CONFIG_ARGS_STOUT "stdout=serial,vga\0"
+#define CONFIG_ARGS_STERR "stderr=serial,vga\0"
+#define CONFIG_ARGS_CONSOLE "console=tty0"
+#endif
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	CONFIG_ARGS_STDIN \
+	CONFIG_ARGS_STOUT \
+	CONFIG_ARGS_STERR \
+	"mmcdev=0\0" \
+	"mmcpart=1\0" \
+	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} "CONFIG_ARGS_CONSOLE" consoleblank=0 " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"bootz\0" \
+	"flashargs=setenv bootargs console=${console},${baudrate} "CONFIG_ARGS_CONSOLE" consoleblank=0 " \
+		"root=/dev/mtdblock3 rootfstype=squashfs ro\0" \
+	"flashboot=echo Booting from SPI flash ...; " \
+	    "sf probe; " \
+		"run flashargs; " \
+		"sf read 0x12000000 0xa0000 0x4e0000; bootz\0"
+
+#define CONFIG_BOOTCOMMAND \
+	"mmc dev ${mmcdev}; " \
+	"if mmc rescan; then " \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"else " \
+			"if run loadimage; then " \
+				"run mmcboot; " \
+			"else run flashboot; " \
+			"fi; " \
+		"fi; " \
+	"else run flashboot; fi"
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"U-Boot > "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		16
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_SYS_MEMTEST_START	0x10000000
+#define CONFIG_SYS_MEMTEST_END		0x11000000
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+
+#define CONFIG_CMDLINE_EDITING
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS	       1
+#define PHYS_SDRAM		       MMDC0_ARB_BASE_ADDR
+
+#define CONFIG_SYS_SDRAM_BASE	       PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR       IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE       IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			(128 * 1024)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_ENV_OFFSET		(512 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(128 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+#define CONFIG_SUPPORT_RAW_INITRD
+#define CONFIG_CMD_FS_GENERIC
+#define CONFIG_BOARD_LATE_INIT
+
+
+/*
+ * PCI express
+ */
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_CMD_PCI_ENUM
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#endif
+
+#endif				/* __CONFIG_H */
diff --git a/include/configs/mx6_common.h b/include/configs/mx6_common.h
index 8a8920f..a46124c 100644
--- a/include/configs/mx6_common.h
+++ b/include/configs/mx6_common.h
@@ -23,6 +23,8 @@
 #define CONFIG_ARM_ERRATA_794072
 #define CONFIG_ARM_ERRATA_761320
 #define CONFIG_BOARD_POSTCLK_INIT
+#define CONFIG_LDO_BYPASS_CHECK
+#define CONFIG_MXC_GPT_HCLK
 
 #ifndef CONFIG_SYS_L2CACHE_OFF
 #define CONFIG_SYS_L2_PL310
diff --git a/include/configs/mx6qarm2.h b/include/configs/mx6qarm2.h
index fd651cf..f292f78 100644
--- a/include/configs/mx6qarm2.h
+++ b/include/configs/mx6qarm2.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q Armadillo2 board.
  *
@@ -10,10 +10,16 @@
 #define __CONFIG_H
 
 #define CONFIG_MX6
-#define CONFIG_MX6Q
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
 
 #include "mx6_common.h"
 
+#define CONFIG_SYS_GENERIC_BOARD
 #define CONFIG_DISPLAY_CPUINFO
 #define CONFIG_DISPLAY_BOARDINFO
 
@@ -27,11 +33,18 @@
 #define CONFIG_SYS_MALLOC_LEN		(CONFIG_ENV_SIZE + 2 * 1024 * 1024)
 
 #define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
 #define CONFIG_MXC_GPIO
 
 #define CONFIG_MXC_UART
 #define CONFIG_MXC_UART_BASE		UART4_BASE
 
+/* OCOTP Config */
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
 /* MMC Configs */
 #define CONFIG_FSL_ESDHC
 #define CONFIG_FSL_USDHC
@@ -45,6 +58,8 @@
 #define CONFIG_CMD_FAT
 #define CONFIG_DOS_PARTITION
 
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_MII
@@ -67,18 +82,23 @@
 
 #define CONFIG_BOOTDELAY		3
 
-#define CONFIG_LOADADDR			0x10800000
+#define CONFIG_LOADADDR			0x12000000
 #define CONFIG_SYS_TEXT_BASE		0x17800000
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"console=ttymxc3\0" \
+	"fdt_file=imx6q-arm2.dtb\0" \
+	"fdt_addr=0x18000000\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
-	"mmcdev=1\0" \
-	"mmcpart=2\0" \
-	"mmcroot=/dev/mmcblk0p3 rootwait rw\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"mmcargs=setenv bootargs console=${console},${baudrate} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
@@ -86,15 +106,46 @@
 	"bootscript=echo Running bootscript from mmc ...; " \
 		"source\0" \
 	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
 	"mmcboot=echo Booting from mmc ...; " \
 		"run mmcargs; " \
-		"bootz\0" \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
 	"netargs=setenv bootargs console=${console},${baudrate} " \
 		"root=/dev/nfs " \
 		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
 	"netboot=echo Booting from net ...; " \
 		"run netargs; " \
-		"dhcp ${image}; bootz\0" \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
 
 #define CONFIG_BOOTCOMMAND \
 	"mmc dev ${mmcdev};" \
@@ -114,14 +165,16 @@
 /* Miscellaneous configurable options */
 #define CONFIG_SYS_LONGHELP
 #define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"ARM2 U-Boot > "
 #define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		256
+#define CONFIG_SYS_CBSIZE		1024
 
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16
+#define CONFIG_SYS_MAXARGS		256
 #define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
 
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START	0x10000000
 #define CONFIG_SYS_MEMTEST_END		0x10010000
 
@@ -132,7 +185,6 @@
 /* Physical Memory Map */
 #define CONFIG_NR_DRAM_BANKS		1
 #define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
-#define PHYS_SDRAM_SIZE			(2u * 1024 * 1024 * 1024)
 
 #define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
 #define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
@@ -146,12 +198,26 @@
 /* FLASH and environment organization */
 #define CONFIG_SYS_NO_FLASH
 
-#define CONFIG_ENV_OFFSET		(6 * 64 * 1024)
+#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
 #define CONFIG_ENV_SIZE			(8 * 1024)
 #define CONFIG_ENV_IS_IN_MMC
-#define CONFIG_SYS_MMC_ENV_DEV		1
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* SDHC4 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+#define CONFIG_MMCROOT			"/dev/mmcblk3p2"  /* SDHC4 */
 
 #define CONFIG_OF_LIBFDT
 #define CONFIG_CMD_BOOTZ
 
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+
 #endif				/* __CONFIG_H */
diff --git a/include/configs/mx6qsabreauto.h b/include/configs/mx6qsabreauto.h
index bd0144f..456dbe1 100644
--- a/include/configs/mx6qsabreauto.h
+++ b/include/configs/mx6qsabreauto.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreAuto board.
  *
@@ -12,36 +12,46 @@
 #define CONFIG_MACH_TYPE	3529
 #define CONFIG_MXC_UART_BASE	UART4_BASE
 #define CONFIG_CONSOLE_DEV		"ttymxc3"
-#define CONFIG_DEFAULT_FDT_FILE	"imx6q-sabreauto.dtb"
-#define CONFIG_MMCROOT			"/dev/mmcblk0p2"
-#define PHYS_SDRAM_SIZE		(2u * 1024 * 1024 * 1024)
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* SDHC3 */
 
+#define CONFIG_SYS_USE_NAND
+
+#include "mx6sabre_common.h"
+#include <asm/imx-common/gpio.h>
+
+#undef CONFIG_MFG_NAND_PARTITION
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=8000000.nor:1m(boot),-(rootfs)\\\\;gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+/*Since the pin conflicts on EIM D18, disable the USB host if the NOR flash is enabled */
+#if !defined(CONFIG_SYS_USE_SPINOR) && !defined(CONFIG_SYS_USE_EIMNOR)
 /* USB Configs */
 #define CONFIG_CMD_USB
 #define CONFIG_USB_EHCI
 #define CONFIG_USB_EHCI_MX6
 #define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
 #define CONFIG_USB_HOST_ETHER
 #define CONFIG_USB_ETHER_ASIX
-#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
-#define CONFIG_EHCI_HCD_INIT_AFTER_RESET	/* For OTG port */
-#define CONFIG_MXC_USB_PORTSC	(PORT_PTS_UTMI | PORT_PTS_PTW)
-#define CONFIG_MXC_USB_FLAGS	0
-
-#include "mx6sabre_common.h"
-
-#define CONFIG_SYS_FSL_USDHC_NUM	2
-#if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_SYS_MMC_ENV_DEV		0
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2 /* Enabled USB controller number */
+
+/* MAX7310 configs*/
+#define CONFIG_MAX7310_IOEXP
+#define CONFIG_IOEXP_DEVICES_NUM 3
+#define CONFIG_IOEXP_DEV_PINS_NUM 8
 #endif
 
-/* I2C Configs */
-#define CONFIG_CMD_I2C
-#define CONFIG_SYS_I2C
-#define CONFIG_SYS_I2C_MXC
-#define CONFIG_SYS_I2C_SPEED		100000
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+#define CONFIG_SYS_MMC_ENV_DEV		1  /* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART                0       /* user partition */
 
-#define CONFIG_OF_SEPARATE
-#define CONFIG_DEFAULT_DEVICE_TREE   imx6q-sabreauto
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   (1|(IMX_GPIO_NR(3, 19)<<8))
+#endif
 
 #endif                         /* __MX6QSABREAUTO_CONFIG_H */
diff --git a/include/configs/mx6sabre_common.h b/include/configs/mx6sabre_common.h
index 7a2c172..93d4c4b 100644
--- a/include/configs/mx6sabre_common.h
+++ b/include/configs/mx6sabre_common.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreSD board.
  *
@@ -11,9 +11,20 @@
 
 #define CONFIG_MX6
 
+#ifdef CONFIG_MX6SOLO
+#define CONFIG_MX6DL
+#endif
+
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
 #include "mx6_common.h"
 #include <linux/sizes.h>
 
+#define CONFIG_SYS_GENERIC_BOARD
 #define CONFIG_DISPLAY_CPUINFO
 #define CONFIG_DISPLAY_BOARDINFO
 
@@ -52,6 +63,8 @@
 #define CONFIG_CMD_FAT
 #define CONFIG_DOS_PARTITION
 
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_MII
@@ -66,17 +79,6 @@
 #define CONFIG_PHYLIB
 #define CONFIG_PHY_ATHEROS
 
-#define CONFIG_CMD_SF
-#ifdef CONFIG_CMD_SF
-#define CONFIG_SPI_FLASH
-#define CONFIG_SPI_FLASH_STMICRO
-#define CONFIG_MXC_SPI
-#define CONFIG_SF_DEFAULT_BUS		0
-#define CONFIG_SF_DEFAULT_CS		(0 | (IMX_GPIO_NR(4, 9) << 8))
-#define CONFIG_SF_DEFAULT_SPEED		20000000
-#define CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
-#endif
-
 /* allow to overwrite serial and ethaddr */
 #define CONFIG_ENV_OVERWRITE
 #define CONFIG_CONS_INDEX              1
@@ -94,30 +96,65 @@
 
 #define CONFIG_LOADADDR                        0x12000000
 #define CONFIG_SYS_TEXT_BASE           0x17800000
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
 
-#ifdef CONFIG_SUPPORT_EMMC_BOOT
-#define EMMC_ENV \
-	"emmcdev=2\0" \
-	"update_emmc_firmware=" \
-		"if test ${ip_dyn} = yes; then " \
-			"setenv get_cmd dhcp; " \
-		"else " \
-			"setenv get_cmd tftp; " \
-		"fi; " \
-		"if ${get_cmd} ${update_sd_firmware_filename}; then " \
-			"if mmc dev ${emmcdev} && " \
-				"mmc open ${emmcdev} 1; then "	\
-				"setexpr fw_sz ${filesize} / 0x200; " \
-				"setexpr fw_sz ${fw_sz} + 1; "	\
-				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
-				"mmc close ${emmcdev} 1; " \
-			"fi; "	\
-		"fi\0"
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
 #else
-#define EMMC_ENV ""
+#define CONFIG_MFG_NAND_PARTITION ""
 #endif
 
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=" CONFIG_CONSOLE_DEV ",115200 " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"enable_wait_mode=off "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+		"initrd_addr=0x12C00000\0" \
+		"initrd_high=0xffffffff\0" \
+		"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+	/*
+	 * The dts also enables the WEIN NOR which is mtd0.
+	 * So the partions' layout for NAND is:
+	 *     mtd1: 16M      (uboot)
+	 *     mtd2: 16M      (kernel)
+	 *     mtd3: 16M      (dtb)
+	 *     mtd4: left     (rootfs)
+	 */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	"fdt_addr=0x18000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 ubi.mtd=4 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#elif defined(CONFIG_SYS_BOOT_SATA)
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+		CONFIG_MFG_ENV_SETTINGS \
+		"fdt_addr=0x18000000\0" \
+		"fdt_high=0xffffffff\0"   \
+		"bootargs=console=" CONFIG_CONSOLE_DEV ",115200 \0"\
+		"bootargs_sata=setenv bootargs ${bootargs} " \
+			"root=/dev/sda1 rootwait rw \0" \
+		"bootcmd_sata=run bootargs_sata; sata init; " \
+			"sata read ${loadaddr} 0x800  0x4000; " \
+			"sata read ${fdt_addr} 0x8000 0x800; " \
+			"bootz ${loadaddr} - ${fdt_addr} \0" \
+		"bootcmd=run bootcmd_sata \0"
+
+#else
 #define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
@@ -127,9 +164,10 @@
 	"console=" CONFIG_CONSOLE_DEV "\0" \
 	"fdt_high=0xffffffff\0"	  \
 	"initrd_high=0xffffffff\0" \
-	"mmcdev=" __stringify(CONFIG_SYS_MMC_ENV_DEV) "\0" \
-	"mmcpart=1\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
 	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"update_sd_firmware=" \
 		"if test ${ip_dyn} = yes; then " \
 			"setenv get_cmd dhcp; " \
@@ -143,8 +181,8 @@
 				"mmc write ${loadaddr} 0x2 ${fw_sz}; " \
 			"fi; "	\
 		"fi\0" \
-	EMMC_ENV	  \
-	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+	"smp=" CONFIG_SYS_NOSMP "\0"\
+	"mmcargs=setenv bootargs console=${console},${baudrate} ${smp} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
 		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
@@ -167,7 +205,7 @@
 		"else " \
 			"bootz; " \
 		"fi;\0" \
-	"netargs=setenv bootargs console=${console},${baudrate} " \
+	"netargs=setenv bootargs console=${console},${baudrate} ${smp} " \
 		"root=/dev/nfs " \
 		"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
 	"netboot=echo Booting from net ...; " \
@@ -204,6 +242,7 @@
 			"fi; " \
 		"fi; " \
 	"else run netboot; fi"
+#endif
 
 #define CONFIG_ARP_TIMEOUT     200UL
 
@@ -212,13 +251,14 @@
 #define CONFIG_SYS_HUSH_PARSER
 #define CONFIG_SYS_PROMPT_HUSH_PS2     "> "
 #define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE              256
+#define CONFIG_SYS_CBSIZE              1024
 
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS             16
+#define CONFIG_SYS_MAXARGS             256
 #define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
 
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START       0x10000000
 #define CONFIG_SYS_MEMTEST_END         0x10010000
 #define CONFIG_SYS_MEMTEST_SCRATCH     0x10800000
@@ -246,10 +286,97 @@
 
 #define CONFIG_ENV_SIZE			(8 * 1024)
 
+#ifndef CONFIG_SYS_NOSMP
+#define CONFIG_SYS_NOSMP
+#endif
+
+#if defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_ENV_IS_IN_SATA
+#define CONFIG_CMD_SATA
+#else
 #define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_CMD_SATA
+#define CONFIG_DWC_AHSATA
+#define CONFIG_SYS_SATA_MAX_DEVICE	1
+#define CONFIG_DWC_AHSATA_PORT_ID	0
+#define CONFIG_DWC_AHSATA_BASE_ADDR	SATA_ARB_BASE_ADDR
+#define CONFIG_LBA48
+#define CONFIG_LIBATA
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE     (128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE     1
+#define CONFIG_SYS_NAND_BASE           0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
 
 #if defined(CONFIG_ENV_IS_IN_MMC)
-#define CONFIG_ENV_OFFSET		(6 * 64 * 1024)
+#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET              (768 * 1024)
+#define CONFIG_ENV_SECT_SIZE           (64 * 1024)
+#define CONFIG_ENV_SPI_BUS             CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS              CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE            CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ          CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE                        CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE           CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET              (4 * CONFIG_SYS_FLASH_SECT_SIZE)
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET              (8 << 20)
+#define CONFIG_ENV_SECT_SIZE           (128 << 10)
+#define CONFIG_ENV_SIZE                        CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_SATA)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_SATA_ENV_DEV		0
+#define CONFIG_SYS_DCACHE_OFF /* remove when sata driver support cache */
 #endif
 
 #define CONFIG_OF_LIBFDT
@@ -258,4 +385,36 @@
 #define CONFIG_CMD_CACHE
 #endif
 
+/*
+ * I2C configs
+ */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* Framebuffer */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_IPUV3
+#define CONFIG_CFB_CONSOLE
+#define CONFIG_VGA_AS_SINGLE_DEVICE
+#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
+#define CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define CONFIG_BMP_16BPP
+#define CONFIG_VIDEO_LOGO
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_MX6DL
+#define CONFIG_IPUV3_CLK 198000000
+#else
+#define CONFIG_IPUV3_CLK 264000000
+#endif
+#define CONFIG_IMX_HDMI
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sabreandroid_common.h"
+#endif
+
 #endif                         /* __MX6QSABRE_COMMON_CONFIG_H */
diff --git a/include/configs/mx6sabreandroid_common.h b/include/configs/mx6sabreandroid_common.h
new file mode 100644
index 0000000..c9d9576
--- /dev/null
+++ b/include/configs/mx6sabreandroid_common.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MX6_SABRE_ANDROID_COMMON_H
+#define MX6_SABRE_ANDROID_COMMON_H
+
+#define CONFIG_SERIAL_TAG
+
+#define CONFIG_USB_DEVICE
+#define CONFIG_IMX_UDC		       1
+
+#define CONFIG_FASTBOOT		       1
+#define CONFIG_FASTBOOT_VENDOR_ID      0x18d1
+#define CONFIG_FASTBOOT_PRODUCT_ID     0x0d02
+#define CONFIG_FASTBOOT_BCD_DEVICE     0x311
+#define CONFIG_FASTBOOT_MANUFACTURER_STR  "Freescale"
+#define CONFIG_FASTBOOT_PRODUCT_NAME_STR "i.mx6 Sabre Board"
+#define CONFIG_FASTBOOT_INTERFACE_STR	 "Android fastboot"
+#define CONFIG_FASTBOOT_CONFIGURATION_STR  "Android fastboot"
+#define CONFIG_FASTBOOT_SERIAL_NUM	"12345"
+#define CONFIG_FASTBOOT_SATA_NO		 0
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_FASTBOOT_STORAGE_SATA
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+/*  For system.img growing up more than 256MB, more buffer needs
+*   to receive the system.img*/
+#define CONFIG_FASTBOOT_TRANSFER_BUF	0x2c000000
+#define CONFIG_FASTBOOT_TRANSFER_BUF_SIZE 0x19000000 /* 400M byte */
+
+
+#define CONFIG_CMD_BOOTI
+#define CONFIG_ANDROID_RECOVERY
+/* which mmc bus is your main storage ? */
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#endif
+
+#endif /* MX6_SABRE_ANDROID_COMMON_H */
diff --git a/include/configs/mx6sabresd.h b/include/configs/mx6sabresd.h
index 5d02d23..9f3fae7 100644
--- a/include/configs/mx6sabresd.h
+++ b/include/configs/mx6sabresd.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 Freescale Semiconductor, Inc.
+ * Copyright (C) 2012-2014 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6Q SabreSD board.
  *
@@ -15,40 +15,42 @@
 #define CONFIG_MACH_TYPE	3980
 #define CONFIG_MXC_UART_BASE	UART1_BASE
 #define CONFIG_CONSOLE_DEV		"ttymxc0"
-#define CONFIG_MMCROOT			"/dev/mmcblk1p2"
-#if defined(CONFIG_MX6Q)
-#define CONFIG_DEFAULT_FDT_FILE	"imx6q-sabresd.dtb"
-#elif defined(CONFIG_MX6DL)
-#define CONFIG_DEFAULT_FDT_FILE	"imx6dl-sabresd.dtb"
-#endif
-#define PHYS_SDRAM_SIZE		(1u * 1024 * 1024 * 1024)
-
-#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* SDHC3 */
 
 #include "mx6sabre_common.h"
 
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1 /* Enabled USB controller number */
+
 #define CONFIG_SYS_FSL_USDHC_NUM	3
-#if defined(CONFIG_ENV_IS_IN_MMC)
 #define CONFIG_SYS_MMC_ENV_DEV		1	/* SDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART                0       /* user partition */
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(4, 9)<<8))
 #endif
 
-/* Framebuffer */
-#define CONFIG_VIDEO
-#define CONFIG_VIDEO_IPUV3
-#define CONFIG_CFB_CONSOLE
-#define CONFIG_VGA_AS_SINGLE_DEVICE
-#define CONFIG_SYS_CONSOLE_IS_IN_ENV
-#define CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE
-#define CONFIG_VIDEO_BMP_RLE8
-#define CONFIG_SPLASH_SCREEN
-#define CONFIG_SPLASH_SCREEN_ALIGN
-#define CONFIG_BMP_16BPP
-#define CONFIG_VIDEO_LOGO
-#define CONFIG_VIDEO_BMP_LOGO
-#define CONFIG_IPUV3_CLK 260000000
-#define CONFIG_IMX_HDMI
-
-#define CONFIG_CMD_PCI
+/*
+ * imx6 q/dl/solo pcie would be failed to work properly in kernel, if
+ * the pcie module is iniialized/enumerated both in uboot and linux
+ * kernel.
+ * rootcause:imx6 q/dl/solo pcie don't have the reset mechanism.
+ * it is only be RESET by the POR. So, the pcie module only be
+ * initialized/enumerated once in one POR.
+ * Set to use pcie in kernel defaultly, mask the pcie config here.
+ * Remove the mask freely, if the uboot pcie functions, rather than
+ * the kernel's, are required.
+ */
+/* #define CONFIG_CMD_PCI */
 #ifdef CONFIG_CMD_PCI
 #define CONFIG_PCI
 #define CONFIG_PCI_PNP
@@ -58,4 +60,35 @@
 #define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(3, 19)
 #endif
 
+/*#define CONFIG_SPLASH_SCREEN*/
+/*#define CONFIG_MXC_EPDC*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#if defined(CONFIG_SPLASH_SCREEN) && defined(CONFIG_MXC_EPDC)
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif /* CONFIG_SPLASH_SCREEN && CONFIG_MXC_EPDC */
+
 #endif                         /* __MX6QSABRESD_CONFIG_H */
diff --git a/include/configs/mx6slevk.h b/include/configs/mx6slevk.h
index 1876dbf..834e710 100644
--- a/include/configs/mx6slevk.h
+++ b/include/configs/mx6slevk.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2013 Freescale Semiconductor, Inc.
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc.
  *
  * Configuration settings for the Freescale i.MX6SL EVK board.
  *
@@ -12,11 +12,19 @@
 #include <asm/arch/imx-regs.h>
 #include <linux/sizes.h>
 #include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
 
 #define CONFIG_MX6
+#define CONFIG_SYS_GENERIC_BOARD
 #define CONFIG_DISPLAY_CPUINFO
 #define CONFIG_DISPLAY_BOARDINFO
 
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
 #define MACH_TYPE_MX6SLEVK		4307
 #define CONFIG_MACH_TYPE		MACH_TYPE_MX6SLEVK
 
@@ -29,15 +37,23 @@
 #define CONFIG_SYS_MALLOC_LEN		(3 * SZ_1M)
 
 #define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
 #define CONFIG_MXC_GPIO
 
 #define CONFIG_MXC_UART
 #define CONFIG_MXC_UART_BASE		UART1_IPS_BASE_ADDR
 
+/* OCOTP Config */
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
 /* MMC Configs */
 #define CONFIG_FSL_ESDHC
 #define CONFIG_FSL_USDHC
 #define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#define CONFIG_SYS_FSL_USDHC_NUM 3
 
 #define CONFIG_MMC
 #define CONFIG_CMD_MMC
@@ -45,6 +61,8 @@
 #define CONFIG_CMD_FAT
 #define CONFIG_DOS_PARTITION
 
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
 #define CONFIG_CMD_PING
 #define CONFIG_CMD_DHCP
 #define CONFIG_CMD_MII
@@ -64,6 +82,12 @@
 #define CONFIG_CONS_INDEX		1
 #define CONFIG_BAUDRATE			115200
 
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
 /* Command definition */
 #include <config_cmd_default.h>
 
@@ -71,22 +95,35 @@
 
 #define CONFIG_BOOTDELAY		3
 
-#define CONFIG_LOADADDR			0x82000000
+#define CONFIG_LOADADDR			0x80800000
 #define CONFIG_SYS_TEXT_BASE		0x87800000
 
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
 #define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
 	"script=boot.scr\0" \
 	"image=zImage\0" \
 	"console=ttymxc0\0" \
 	"fdt_high=0xffffffff\0" \
 	"initrd_high=0xffffffff\0" \
 	"fdt_file=imx6sl-evk.dtb\0" \
-	"fdt_addr=0x88000000\0" \
+	"fdt_addr=0x83000000\0" \
 	"boot_fdt=try\0" \
 	"ip_dyn=yes\0" \
-	"mmcdev=0\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
 	"mmcpart=1\0" \
-	"mmcroot=/dev/mmcblk0p2 rootwait rw\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
 	"mmcargs=setenv bootargs console=${console},${baudrate} " \
 		"root=${mmcroot}\0" \
 	"loadbootscript=" \
@@ -152,13 +189,14 @@
 #define CONFIG_SYS_LONGHELP
 #define CONFIG_SYS_HUSH_PARSER
 #define CONFIG_AUTO_COMPLETE
-#define CONFIG_SYS_CBSIZE		256
+#define CONFIG_SYS_CBSIZE		1024
 
 /* Print Buffer Size */
 #define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
-#define CONFIG_SYS_MAXARGS		16
+#define CONFIG_SYS_MAXARGS		256
 #define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
 
+#define CONFIG_CMD_MEMTEST
 #define CONFIG_SYS_MEMTEST_START	0x80000000
 #define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + SZ_512M)
 
@@ -184,10 +222,39 @@
 /* FLASH and environment organization */
 #define CONFIG_SYS_NO_FLASH
 
-#define CONFIG_ENV_OFFSET		(6 * SZ_64K)
 #define CONFIG_ENV_SIZE			SZ_8K
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC2 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user partition */
+#define CONFIG_MMCROOT			"/dev/mmcblk1p2"  /* USDHC2 */
+
+#if defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
 #define CONFIG_ENV_IS_IN_MMC
-#define CONFIG_SYS_MMC_ENV_DEV		0
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  0
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(4, 11)<<8))
+#endif
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * 64 * 1024)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#endif
 
 #define CONFIG_OF_LIBFDT
 #define CONFIG_CMD_BOOTZ
@@ -196,4 +263,53 @@
 #define CONFIG_CMD_CACHE
 #endif
 
+/*#define CONFIG_SPLASH_SCREEN*/
+
+/*
+ * SPLASH SCREEN Configs
+ */
+#ifdef CONFIG_SPLASH_SCREEN
+	/*
+	 * Framebuffer and LCD
+	 */
+	#define CONFIG_CMD_BMP
+	#define CONFIG_MXC_EPDC				1
+	#define CONFIG_LCD
+	#define CONFIG_FB_BASE				(CONFIG_SYS_TEXT_BASE + 0x300000)
+	#define CONFIG_SYS_CONSOLE_IS_IN_ENV
+#ifdef CONFIG_MXC_EPDC
+	#undef LCD_TEST_PATTERN
+	/* #define CONFIG_SPLASH_IS_IN_MMC			1 */
+	#define LCD_BPP					LCD_MONOCHROME
+	/* #define CONFIG_SPLASH_SCREEN_ALIGN		1 */
+
+	#define CONFIG_WORKING_BUF_ADDR			(CONFIG_SYS_TEXT_BASE + 0x100000)
+	#define CONFIG_WAVEFORM_BUF_ADDR		(CONFIG_SYS_TEXT_BASE + 0x200000)
+	#define CONFIG_WAVEFORM_FILE_OFFSET		0x600000
+	#define CONFIG_WAVEFORM_FILE_SIZE		0xF0A00
+	#define CONFIG_WAVEFORM_FILE_IN_MMC
+
+#ifdef CONFIG_SPLASH_IS_IN_MMC
+	#define CONFIG_SPLASH_IMG_OFFSET		0x4c000
+	#define CONFIG_SPLASH_IMG_SIZE			0x19000
+#endif
+#endif
+#endif /* CONFIG_SPLASH_SCREEN */
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6slevkandroid.h"
+#endif
+
 #endif				/* __CONFIG_H */
diff --git a/include/configs/mx6slevkandroid.h b/include/configs/mx6slevkandroid.h
new file mode 100644
index 0000000..a2447c1
--- /dev/null
+++ b/include/configs/mx6slevkandroid.h
@@ -0,0 +1,76 @@
+
+/*
+ * Copyright (C) 2013-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef MX6SL_EVK_ANDROID_H
+#define MX6SL_EVK_ANDROID_H
+
+#include <asm/imx-common/mxc_key_defs.h>
+
+#define CONFIG_SERIAL_TAG
+
+#define CONFIG_USB_DEVICE
+#define CONFIG_IMX_UDC		       1
+
+#define CONFIG_FASTBOOT		       1
+#define CONFIG_FASTBOOT_VENDOR_ID      0x18d1
+#define CONFIG_FASTBOOT_PRODUCT_ID     0x0d02
+#define CONFIG_FASTBOOT_BCD_DEVICE     0x311
+#define CONFIG_FASTBOOT_MANUFACTURER_STR  "Freescale"
+#define CONFIG_FASTBOOT_PRODUCT_NAME_STR "i.mx6sl EVK Board"
+#define CONFIG_FASTBOOT_INTERFACE_STR	 "Android fastboot"
+#define CONFIG_FASTBOOT_CONFIGURATION_STR  "Android fastboot"
+#define CONFIG_FASTBOOT_SERIAL_NUM	"12345"
+#define CONFIG_FASTBOOT_SATA_NO		 0
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#elif defined CONFIG_SYS_BOOT_SATA
+#define CONFIG_FASTBOOT_STORAGE_SATA
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+/*  For system.img growing up more than 256MB, more buffer needs
+*   to receive the system.img*/
+#define CONFIG_FASTBOOT_TRANSFER_BUF	0x8c000000
+#define CONFIG_FASTBOOT_TRANSFER_BUF_SIZE 0x19000000 /* 400M byte */
+
+
+#define CONFIG_CMD_BOOTI
+#define CONFIG_ANDROID_RECOVERY
+/* which mmc bus is your main storage ? */
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+
+/*keyboard mapping*/
+#define CONFIG_VOL_DOWN_KEY     KEY_BACK
+#define CONFIG_POWER_KEY        KEY_5
+
+#define CONFIG_MXC_KPD
+#define CONFIG_MXC_KEYMAPPING \
+	{       \
+		KEY_SELECT, KEY_BACK, KEY_1,     KEY_2, \
+		KEY_3,      KEY_4,    KEY_5,     KEY_MENU, \
+		KEY_6,      KEY_7,    KEY_8,     KEY_9, \
+		KEY_UP,     KEY_LEFT, KEY_RIGHT, KEY_DOWN, \
+	}
+#define CONFIG_MXC_KPD_COLMAX 4
+#define CONFIG_MXC_KPD_ROWMAX 4
+
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#endif
diff --git a/include/configs/mx6sx_17x17_arm2.h b/include/configs/mx6sx_17x17_arm2.h
new file mode 100644
index 0000000..bedb1db
--- /dev/null
+++ b/include/configs/mx6sx_17x17_arm2.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SX 17x17 ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_17X17_ARM2_CONFIG_H
+#define __MX6SX_17X17_ARM2_CONFIG_H
+
+#include "mx6sx_arm2.h"
+
+#ifdef CONFIG_SYS_USE_SPINOR  /* Pin conflict between SPI-NOR and SD2 */
+#define CONFIG_SYS_FSL_USDHC_NUM    2
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* USDHC3 */
+#else
+#define CONFIG_SYS_FSL_USDHC_NUM    3
+#define CONFIG_SYS_MMC_ENV_DEV		1   /* USDHC3 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* USDHC3 */
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_FLASH_SECT_SIZE
+#undef CONFIG_SYS_MAX_FLASH_SECT
+#define CONFIG_SYS_FLASH_SECT_SIZE	(256 * 1024)
+#define CONFIG_SYS_MAX_FLASH_SECT 512   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_PROTECTION
+#endif
+
+#endif
diff --git a/include/configs/mx6sx_19x19_arm2.h b/include/configs/mx6sx_19x19_arm2.h
new file mode 100644
index 0000000..e2bb434
--- /dev/null
+++ b/include/configs/mx6sx_19x19_arm2.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SX 19x19 ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_19X19_ARM2_CONFIG_H
+#define __MX6SX_19X19_ARM2_CONFIG_H
+
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_GIS
+
+#include "mx6sx_arm2.h"
+
+#define CONFIG_SYS_FSL_USDHC_NUM    1
+#define CONFIG_SYS_MMC_ENV_DEV		0   /* USDHC1 */
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk0p2"  /* USDHC1 */
+
+#endif
diff --git a/include/configs/mx6sx_arm2.h b/include/configs/mx6sx_arm2.h
new file mode 100644
index 0000000..91a78d9
--- /dev/null
+++ b/include/configs/mx6sx_arm2.h
@@ -0,0 +1,441 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SX ARM2 board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_ARM2_CONFIG_H
+#define __MX6SX_ARM2_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_MX6
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(32 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define CONFIG_BAUDRATE			115200
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+#define CONFIG_FEC_MXC_PHYADDR          1
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_FEC_DMA_MINALIGN		64
+
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+#define CONFIG_FEC_ENABLE_MAX7322
+/* MAX7322 */
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+#define CONFIG_MAX7322_I2C_ADDR		0x68
+#define CONFIG_MAX7322_I2C_BUS		1
+#endif
+
+/* PMIC */
+#define CONFIG_PFUZE100_PMIC_I2C
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define CONFIG_PMIC_I2C_BUS		0
+#define CONFIG_PMIC_I2C_SLAVE		0x8
+#endif
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x78000000 /* Set to QSPI2 B flash at default */
+#define CONFIG_CMD_BOOTAUX /* Boot M4 */
+#define CONFIG_CMD_SETEXPR
+
+#ifdef CONFIG_CMD_BOOTAUX
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 1:0; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 1:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#define CONFIG_SYS_MMC_IMG_LOAD_PART	1
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=Hannstar-XGA\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=3 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=" CONFIG_DEFAULT_FDT_FILE "\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=" __stringify(CONFIG_SYS_MMC_IMG_LOAD_PART) "\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "mmc dev ${mmcdev}; if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#elif defined CONFIG_SYS_BOOT_SPINOR
+#define CONFIG_SYS_USE_SPINOR
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_EIMNOR
+#define CONFIG_SYS_USE_EIMNOR
+#define CONFIG_ENV_IS_IN_FLASH
+#else
+#define CONFIG_SYS_USE_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_QSPI    /* enable the QUADSPI driver */
+#define CONFIG_QSPI_BASE			QSPI2_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI2_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#ifdef CONFIG_SYS_USE_SPINOR
+#define CONFIG_CMD_SF
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_MXC_SPI
+#define CONFIG_SF_DEFAULT_BUS  3
+#define CONFIG_SF_DEFAULT_SPEED 20000000
+#define CONFIG_SF_DEFAULT_MODE (SPI_MODE_0)
+#define CONFIG_SF_DEFAULT_CS   (0|(IMX_GPIO_NR(6, 10)<<8))
+#endif
+
+#ifdef CONFIG_SYS_USE_EIMNOR
+#undef CONFIG_SYS_NO_FLASH
+#define CONFIG_SYS_FLASH_BASE           WEIM_ARB_BASE_ADDR
+#define CONFIG_SYS_FLASH_SECT_SIZE	(128 * 1024)
+#define CONFIG_SYS_MAX_FLASH_BANKS 1    /* max number of memory banks */
+#define CONFIG_SYS_MAX_FLASH_SECT 256   /* max number of sectors on one chip */
+#define CONFIG_SYS_FLASH_CFI            /* Flash memory is CFI compliant */
+#define CONFIG_FLASH_CFI_DRIVER         /* Use drivers/cfi_flash.c */
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE /* Use buffered writes*/
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(8 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#elif defined(CONFIG_ENV_IS_IN_FLASH)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_SIZE			CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_SECT_SIZE		CONFIG_SYS_FLASH_SECT_SIZE
+#define CONFIG_ENV_OFFSET		(4 * CONFIG_SYS_FLASH_SECT_SIZE)
+#endif
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_VIDEO_GIS
+#define CONFIG_VIDEO_CSI
+#define CONFIG_VIDEO_PXP
+#define CONFIG_VIDEO_VADC
+#endif
+#endif
+
+/* USB Configs */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+/*Only enable OTG1, the OTG2 has pin conflicts with PWM and WDOG*/
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 1
+
+#endif				/* __CONFIG_H */
diff --git a/include/configs/mx6sxsabreauto.h b/include/configs/mx6sxsabreauto.h
new file mode 100644
index 0000000..dc1b918
--- /dev/null
+++ b/include/configs/mx6sxsabreauto.h
@@ -0,0 +1,425 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SX SABREAUTO board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_SABREAUTO_CONFIG_H
+#define __MX6SX_SABREAUTO_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_MX6
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(32 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#define CONFIG_SYS_FSL_USDHC_NUM	2
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define CONFIG_BAUDRATE			115200
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 1  /* Use onboard ethernet as default */
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x0
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x0
+#endif
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_FEC_DMA_MINALIGN		64
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* PMIC */
+#define CONFIG_PFUZE100_PMIC_I2C
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define CONFIG_PMIC_I2C_BUS		1
+#define CONFIG_PMIC_I2C_SLAVE		0x8
+#endif
+
+/* MAX7310 configs*/
+#define CONFIG_MAX7310_IOEXP
+#define CONFIG_IOEXP_DEVICES_NUM 2
+#define CONFIG_IOEXP_DEV_PINS_NUM 8
+
+/* VIDEO */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_GIS
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x68000000 /* Set to QSPI1 B flash at default */
+#ifndef CONFIG_SYS_AUXCORE_FASTUP
+#define CONFIG_CMD_BOOTAUX /* Boot M4 by command, disable this when M4 fast up */
+#define CONFIG_CMD_SETEXPR
+#endif
+
+#ifdef CONFIG_CMD_BOOTAUX
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 1:0; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 1:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=Hannstar-XGA\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#ifdef CONFIG_SYS_BOOT_NAND
+#define CONFIG_MFG_NAND_PARTITION "mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs) "
+#else
+#define CONFIG_MFG_NAND_PARTITION ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		CONFIG_MFG_NAND_PARTITION \
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#if defined(CONFIG_SYS_BOOT_NAND)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	CONFIG_VIDEO_MODE \
+	"fdt_addr=0x83000000\0" \
+	"fdt_high=0xffffffff\0"	  \
+	"console=ttymxc0\0" \
+	"bootargs=console=ttymxc0,115200 ubi.mtd=5 "  \
+		"root=ubi0:rootfs rootfstype=ubifs "		     \
+		"mtdparts=gpmi-nand:64m(boot),16m(kernel),16m(dtb),-(rootfs)\0"\
+	"bootcmd=nand read ${loadaddr} 0x4000000 0x800000;"\
+		"nand read ${fdt_addr} 0x5000000 0x100000;"\
+		"bootz ${loadaddr} - ${fdt_addr}\0"
+
+#else
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6sx-sabreauto.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+#endif
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE			SZ_2G
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+/*#define CONFIG_MXC_RDC*/   /* Disable the RDC temporarily, will enable it in future */
+#define CONFIG_ENV_IS_IN_MMC  /* Must disable QSPI driver, because M4 run on QSPI */
+#elif defined CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#elif defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_SYS_USE_NAND
+#define CONFIG_ENV_IS_IN_NAND
+#else
+#define CONFIG_SYS_USE_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_QSPI    /* enable the QUADSPI driver */
+#define CONFIG_QSPI_BASE			QSPI1_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI1_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#ifdef CONFIG_SYS_USE_NAND
+#define CONFIG_CMD_NAND
+#define CONFIG_CMD_NAND_TRIMFFS
+
+/* NAND stuff */
+#define CONFIG_NAND_MXS
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+#define CONFIG_SYS_NAND_BASE		0x40000000
+#define CONFIG_SYS_NAND_5_ADDR_CYCLE
+#define CONFIG_SYS_NAND_ONFI_DETECTION
+
+/* DMA stuff, needed for GPMI/MXS NAND support */
+#define CONFIG_APBH_DMA
+#define CONFIG_APBH_DMA_BURST
+#define CONFIG_APBH_DMA_BURST8
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		0  /*USDHC3*/
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk2p2"  /* USDHC3 */
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#elif defined(CONFIG_ENV_IS_IN_NAND)
+#undef CONFIG_ENV_SIZE
+#define CONFIG_ENV_OFFSET		(8 << 20)
+#define CONFIG_ENV_SECT_SIZE		(128 << 10)
+#define CONFIG_ENV_SIZE			CONFIG_ENV_SECT_SIZE
+#endif
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_VIDEO_GIS
+#define CONFIG_VIDEO_CSI
+#define CONFIG_VIDEO_PXP
+#define CONFIG_VIDEO_VADC
+#endif
+#endif
+
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sxsabreautoandroid.h"
+#endif
+
+#endif				/* __CONFIG_H */
diff --git a/include/configs/mx6sxsabreautoandroid.h b/include/configs/mx6sxsabreautoandroid.h
new file mode 100644
index 0000000..905debf
--- /dev/null
+++ b/include/configs/mx6sxsabreautoandroid.h
@@ -0,0 +1,60 @@
+
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_SABREAUTO_ANDROID_H
+#define __MX6SX_SABREAUTO_ANDROID_H
+
+#define CONFIG_SERIAL_TAG
+
+#define CONFIG_USB_DEVICE
+#define CONFIG_IMX_UDC		       1
+
+#define CONFIG_FASTBOOT		       1
+#define CONFIG_FASTBOOT_VENDOR_ID      0x18d1
+#define CONFIG_FASTBOOT_PRODUCT_ID     0x0d02
+#define CONFIG_FASTBOOT_BCD_DEVICE     0x311
+#define CONFIG_FASTBOOT_MANUFACTURER_STR  "Freescale"
+#define CONFIG_FASTBOOT_PRODUCT_NAME_STR "i.mx6sx SABRE-AUTO Board"
+#define CONFIG_FASTBOOT_INTERFACE_STR	 "Android fastboot"
+#define CONFIG_FASTBOOT_CONFIGURATION_STR  "Android fastboot"
+#define CONFIG_FASTBOOT_SERIAL_NUM	"12345"
+#define CONFIG_FASTBOOT_SATA_NO		 0
+
+#if defined CONFIG_SYS_BOOT_NAND
+#define CONFIG_FASTBOOT_STORAGE_NAND
+#else
+#define CONFIG_FASTBOOT_STORAGE_MMC
+#endif
+
+/*  For system.img growing up more than 256MB, more buffer needs
+*   to receive the system.img*/
+#define CONFIG_FASTBOOT_TRANSFER_BUF	0x8c000000
+#define CONFIG_FASTBOOT_TRANSFER_BUF_SIZE 0x19000000 /* 400M byte */
+
+
+#define CONFIG_CMD_BOOTI
+#define CONFIG_ANDROID_RECOVERY
+/* which mmc bus is your main storage ? */
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#if defined(CONFIG_FASTBOOT_STORAGE_NAND)
+#define ANDROID_FASTBOOT_NAND_PARTS "16m@64m(boot) 16m@80m(recovery) 810m@96m(android_root)ubifs"
+#endif
+
+#endif
diff --git a/include/configs/mx6sxsabresd.h b/include/configs/mx6sxsabresd.h
new file mode 100644
index 0000000..0868976
--- /dev/null
+++ b/include/configs/mx6sxsabresd.h
@@ -0,0 +1,401 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Configuration settings for the Freescale i.MX6SX SABRESD board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_SABRESD_CONFIG_H
+#define __MX6SX_SABRESD_CONFIG_H
+
+#include <asm/arch/imx-regs.h>
+#include <linux/sizes.h>
+#include "mx6_common.h"
+#include <asm/imx-common/gpio.h>
+
+#define CONFIG_MX6
+#define CONFIG_ROM_UNIFIED_SECTIONS
+#define CONFIG_SYS_GENERIC_BOARD
+#define CONFIG_DISPLAY_CPUINFO
+#define CONFIG_DISPLAY_BOARDINFO
+
+#define CONFIG_DBG_MONITOR
+/* uncomment for PLUGIN mode support */
+/* #define CONFIG_USE_PLUGIN */
+
+/* uncomment for SECURE mode support */
+/* #define CONFIG_SECURE_BOOT */
+
+#define CONFIG_CMDLINE_TAG
+#define CONFIG_SETUP_MEMORY_TAGS
+#define CONFIG_INITRD_TAG
+#define CONFIG_REVISION_TAG
+
+/* Size of malloc() pool */
+#define CONFIG_SYS_MALLOC_LEN		(16 * SZ_1M)
+
+#define CONFIG_BOARD_EARLY_INIT_F
+#define CONFIG_BOARD_LATE_INIT
+#define CONFIG_MXC_GPIO
+
+#define CONFIG_MXC_UART
+#define CONFIG_MXC_UART_BASE		UART1_BASE
+
+#define CONFIG_CMD_FUSE
+#ifdef CONFIG_CMD_FUSE
+#define CONFIG_MXC_OCOTP
+#endif
+
+/* MMC Configs */
+#define CONFIG_FSL_ESDHC
+#define CONFIG_FSL_USDHC
+#define CONFIG_SYS_FSL_ESDHC_ADDR	0
+#define CONFIG_SYS_FSL_USDHC_NUM	3
+
+#define CONFIG_MMC
+#define CONFIG_CMD_MMC
+#define CONFIG_GENERIC_MMC
+#define CONFIG_CMD_FAT
+#define CONFIG_DOS_PARTITION
+#define CONFIG_SUPPORT_EMMC_BOOT /* eMMC specific */
+
+#define CONFIG_BAUDRATE			115200
+
+#undef CONFIG_BOOTM_NETBSD
+#undef CONFIG_BOOTM_PLAN9
+#undef CONFIG_BOOTM_RTEMS
+
+#undef CONFIG_CMD_EXPORTENV
+#undef CONFIG_CMD_IMPORTENV
+
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_MII
+#define CONFIG_CMD_NET
+#define CONFIG_FEC_MXC
+#define CONFIG_MII
+#define CONFIG_FEC_ENET_DEV 0
+
+#if (CONFIG_FEC_ENET_DEV == 0)
+#define IMX_FEC_BASE			ENET_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x1
+#elif (CONFIG_FEC_ENET_DEV == 1)
+#define IMX_FEC_BASE			ENET2_BASE_ADDR
+#define CONFIG_FEC_MXC_PHYADDR          0x2
+#endif
+#define CONFIG_FEC_XCV_TYPE             RGMII
+#define CONFIG_ETHPRIME                 "FEC"
+
+#define CONFIG_PHYLIB
+#define CONFIG_PHY_ATHEROS
+#define CONFIG_FEC_DMA_MINALIGN		64
+#define CONFIG_FEC_MXC_25M_REF_CLK
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+#define CONFIG_CONS_INDEX		1
+
+/* I2C configs */
+#define CONFIG_CMD_I2C
+#define CONFIG_SYS_I2C
+#define CONFIG_SYS_I2C_MXC
+#define CONFIG_SYS_I2C_SPEED		100000
+
+/* MAX7322 */
+#ifdef CONFIG_FEC_ENABLE_MAX7322
+#define CONFIG_MAX7322_I2C_ADDR		0x68
+#define CONFIG_MAX7322_I2C_BUS		1
+#endif
+
+/* PMIC */
+#define CONFIG_PFUZE100_PMIC_I2C
+#ifdef CONFIG_PFUZE100_PMIC_I2C
+#define CONFIG_PMIC_I2C_BUS		0
+#define CONFIG_PMIC_I2C_SLAVE		0x8
+#endif
+
+/* VIDEO */
+#define CONFIG_VIDEO
+#define CONFIG_VIDEO_GIS
+
+/* Command definition */
+#include <config_cmd_default.h>
+
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_BOOTDELAY		3
+
+#define CONFIG_LOADADDR			0x80800000
+#define CONFIG_SYS_TEXT_BASE		0x87800000
+
+#define CONFIG_SYS_AUXCORE_BOOTDATA 0x78000000 /* Set to QSPI2 B flash at default */
+#ifndef CONFIG_SYS_AUXCORE_FASTUP
+#define CONFIG_CMD_BOOTAUX /* Boot M4 by command, disable this when M4 fast up */
+#define CONFIG_CMD_SETEXPR
+#endif
+
+#ifdef CONFIG_CMD_BOOTAUX
+#define UPDATE_M4_ENV \
+	"m4image=m4_qspi.bin\0" \
+	"loadm4image=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${m4image}\0" \
+	"update_m4_from_sd=" \
+		"if sf probe 1:0; then " \
+			"if run loadm4image; then " \
+				"setexpr fw_sz ${filesize} + 0xffff; " \
+				"setexpr fw_sz ${fw_sz} / 0x10000; "	\
+				"setexpr fw_sz ${fw_sz} * 0x10000; "	\
+				"sf erase 0x0 ${fw_sz}; " \
+				"sf write ${loadaddr} 0x0 ${filesize}; " \
+			"fi; " \
+		"fi\0" \
+	"m4boot=sf probe 1:0; bootaux "__stringify(CONFIG_SYS_AUXCORE_BOOTDATA)"\0"
+#else
+#define UPDATE_M4_ENV ""
+#endif
+
+#ifdef CONFIG_VIDEO
+#define CONFIG_VIDEO_MODE \
+	"panel=Hannstar-XGA\0"
+#else
+#define CONFIG_VIDEO_MODE ""
+#endif
+
+#define CONFIG_MFG_ENV_SETTINGS \
+	"mfgtool_args=setenv bootargs console=${console},${baudrate} " \
+		"rdinit=/linuxrc " \
+		"g_mass_storage.stall=0 g_mass_storage.removable=1 " \
+		"g_mass_storage.idVendor=0x066F g_mass_storage.idProduct=0x37FF "\
+		"g_mass_storage.iSerialNumber=\"\" "\
+		"\0" \
+	"initrd_addr=0x83800000\0" \
+	"initrd_high=0xffffffff\0" \
+	"bootcmd_mfg=run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr};\0" \
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	CONFIG_MFG_ENV_SETTINGS \
+	UPDATE_M4_ENV \
+	CONFIG_VIDEO_MODE \
+	"script=boot.scr\0" \
+	"image=zImage\0" \
+	"console=ttymxc0\0" \
+	"fdt_high=0xffffffff\0" \
+	"initrd_high=0xffffffff\0" \
+	"fdt_file=imx6sx-sdb.dtb\0" \
+	"fdt_addr=0x83000000\0" \
+	"boot_fdt=try\0" \
+	"ip_dyn=yes\0" \
+	"mmcdev="__stringify(CONFIG_SYS_MMC_ENV_DEV)"\0" \
+	"mmcpart=1\0" \
+	"mmcroot=" CONFIG_MMCROOT " rootwait rw\0" \
+	"mmcautodetect=yes\0" \
+	"mmcargs=setenv bootargs console=${console},${baudrate} " \
+		"root=${mmcroot}\0" \
+	"loadbootscript=" \
+		"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
+	"bootscript=echo Running bootscript from mmc ...; " \
+		"source\0" \
+	"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
+	"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
+	"mmcboot=echo Booting from mmc ...; " \
+		"run mmcargs; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if run loadfdt; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0" \
+	"netargs=setenv bootargs console=${console},${baudrate} " \
+		"root=/dev/nfs " \
+	"ip=dhcp nfsroot=${serverip}:${nfsroot},v3,tcp\0" \
+		"netboot=echo Booting from net ...; " \
+		"run netargs; " \
+		"if test ${ip_dyn} = yes; then " \
+			"setenv get_cmd dhcp; " \
+		"else " \
+			"setenv get_cmd tftp; " \
+		"fi; " \
+		"${get_cmd} ${image}; " \
+		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
+			"if ${get_cmd} ${fdt_addr} ${fdt_file}; then " \
+				"bootz ${loadaddr} - ${fdt_addr}; " \
+			"else " \
+				"if test ${boot_fdt} = try; then " \
+					"bootz; " \
+				"else " \
+					"echo WARN: Cannot load the DT; " \
+				"fi; " \
+			"fi; " \
+		"else " \
+			"bootz; " \
+		"fi;\0"
+
+#define CONFIG_BOOTCOMMAND \
+	   "mmc dev ${mmcdev};" \
+	   "if mmc rescan; then " \
+		   "if run loadbootscript; then " \
+			   "run bootscript; " \
+		   "else " \
+			   "if run loadimage; then " \
+				   "run mmcboot; " \
+			   "else run netboot; " \
+			   "fi; " \
+		   "fi; " \
+	   "else run netboot; fi"
+
+/* Miscellaneous configurable options */
+#define CONFIG_SYS_LONGHELP
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT		"=> "
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_SYS_CBSIZE		1024
+
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16)
+#define CONFIG_SYS_MAXARGS		256
+#define CONFIG_SYS_BARGSIZE CONFIG_SYS_CBSIZE
+
+#define CONFIG_CMD_MEMTEST
+#define CONFIG_SYS_MEMTEST_START	0x80000000
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_MEMTEST_START + 0x10000)
+
+#define CONFIG_SYS_LOAD_ADDR		CONFIG_LOADADDR
+#define CONFIG_SYS_HZ			1000
+
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_STACKSIZE		SZ_128K
+
+/* Physical Memory Map */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			MMDC0_ARB_BASE_ADDR
+#define PHYS_SDRAM_SIZE			SZ_1G
+
+#define CONFIG_SYS_SDRAM_BASE		PHYS_SDRAM
+#define CONFIG_SYS_INIT_RAM_ADDR	IRAM_BASE_ADDR
+#define CONFIG_SYS_INIT_RAM_SIZE	IRAM_SIZE
+
+#define CONFIG_SYS_INIT_SP_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - GENERATED_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_ADDR \
+	(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
+
+/* FLASH and environment organization */
+#define CONFIG_SYS_NO_FLASH
+
+#define CONFIG_ENV_SIZE			SZ_8K
+
+#ifdef CONFIG_SYS_AUXCORE_FASTUP
+/*#define CONFIG_MXC_RDC*/   /* Disable the RDC temporarily, will enable it in future */
+#define CONFIG_ENV_IS_IN_MMC  /* Must disable QSPI driver, because M4 run on QSPI */
+#elif defined CONFIG_SYS_BOOT_QSPI
+#define CONFIG_SYS_USE_QSPI
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#else
+#define CONFIG_SYS_USE_QSPI   /* Enable the QSPI flash at default */
+#define CONFIG_ENV_IS_IN_MMC
+#endif
+
+#ifdef CONFIG_SYS_USE_QSPI
+#define CONFIG_QSPI    /* enable the QUADSPI driver */
+#define CONFIG_QSPI_BASE			QSPI2_BASE_ADDR
+#define CONFIG_QSPI_MEMMAP_BASE		QSPI2_ARB_BASE_ADDR
+
+#define CONFIG_CMD_SF
+#define	CONFIG_SPI_FLASH
+#define	CONFIG_SPI_FLASH_BAR
+#define	CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_STMICRO
+#define	CONFIG_SF_DEFAULT_BUS		0
+#define	CONFIG_SF_DEFAULT_CS		0
+#define	CONFIG_SF_DEFAULT_SPEED		40000000
+#define	CONFIG_SF_DEFAULT_MODE		SPI_MODE_0
+#endif
+
+#define CONFIG_SYS_MMC_ENV_DEV		2  /*USDHC4*/
+#define CONFIG_SYS_MMC_ENV_PART		0	/* user area */
+#define CONFIG_MMCROOT			"/dev/mmcblk3p2"  /* USDHC4 */
+
+#if defined(CONFIG_ENV_IS_IN_MMC)
+#define CONFIG_ENV_OFFSET		(8 * SZ_64K)
+#elif defined(CONFIG_ENV_IS_IN_SPI_FLASH)
+#define CONFIG_ENV_OFFSET		(768 * 1024)
+#define CONFIG_ENV_SECT_SIZE		(64 * 1024)
+#define CONFIG_ENV_SPI_BUS		CONFIG_SF_DEFAULT_BUS
+#define CONFIG_ENV_SPI_CS		CONFIG_SF_DEFAULT_CS
+#define CONFIG_ENV_SPI_MODE		CONFIG_SF_DEFAULT_MODE
+#define CONFIG_ENV_SPI_MAX_HZ		CONFIG_SF_DEFAULT_SPEED
+#endif
+
+
+#define CONFIG_OF_LIBFDT
+#define CONFIG_CMD_BOOTZ
+
+#define CONFIG_CMD_BMODE
+
+#ifndef CONFIG_SYS_DCACHE_OFF
+#define CONFIG_CMD_CACHE
+#endif
+
+#ifdef CONFIG_VIDEO
+#define	CONFIG_CFB_CONSOLE
+#define	CONFIG_VIDEO_MXS
+#define	CONFIG_VIDEO_LOGO
+#define	CONFIG_VIDEO_SW_CURSOR
+#define	CONFIG_VGA_AS_SINGLE_DEVICE
+#define	CONFIG_SYS_CONSOLE_IS_IN_ENV
+#define	CONFIG_SPLASH_SCREEN
+#define CONFIG_SPLASH_SCREEN_ALIGN
+#define	CONFIG_CMD_BMP
+#define	CONFIG_BMP_16BPP
+#define	CONFIG_VIDEO_BMP_RLE8
+#define CONFIG_VIDEO_BMP_LOGO
+#ifdef CONFIG_VIDEO_GIS
+#define CONFIG_VIDEO_CSI
+#define CONFIG_VIDEO_PXP
+#define CONFIG_VIDEO_VADC
+#endif
+#endif
+
+#define CONFIG_CMD_USB
+#define CONFIG_USB_EHCI
+#define CONFIG_USB_EHCI_MX6
+#define CONFIG_USB_STORAGE
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+#define CONFIG_USB_HOST_ETHER
+#define CONFIG_USB_ETHER_ASIX
+#define CONFIG_MXC_USB_PORTSC  (PORT_PTS_UTMI | PORT_PTS_PTW)
+#define CONFIG_MXC_USB_FLAGS   0
+#define CONFIG_USB_MAX_CONTROLLER_COUNT 2
+
+/*
+ * The PCIe support in uboot would bring failures in i.MX6SX PCIe
+ * EP/RC validations. Disable PCIe support in uboot here.
+ * RootCause: The bit10(ltssm_en) of GPR12 would be set in uboot,
+ * thus the i.MX6SX PCIe EP would be cheated that the other i.MX6SX
+ * PCIe RC had been configured and trying to setup PCIe link directly,
+ * although the i.MX6SX RC is not properly configured at that time.
+ * PCIe can be supported in uboot, if the i.MX6SX PCIe EP/RC validation
+ * is not running.
+ */
+/* #define CONFIG_CMD_PCI */
+#ifdef CONFIG_CMD_PCI
+#define CONFIG_PCI
+#define CONFIG_PCI_PNP
+#define CONFIG_PCI_SCAN_SHOW
+#define CONFIG_PCIE_IMX
+#define CONFIG_PCIE_IMX_PERST_GPIO	IMX_GPIO_NR(2, 0)
+#define CONFIG_PCIE_IMX_POWER_GPIO	IMX_GPIO_NR(2, 1)
+#endif
+
+#if defined(CONFIG_ANDROID_SUPPORT)
+#include "mx6sxsabresdandroid.h"
+#endif
+
+#endif				/* __CONFIG_H */
diff --git a/include/configs/mx6sxsabresdandroid.h b/include/configs/mx6sxsabresdandroid.h
new file mode 100644
index 0000000..0c16fe8
--- /dev/null
+++ b/include/configs/mx6sxsabresdandroid.h
@@ -0,0 +1,52 @@
+
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MX6SX_SABRESD_ANDROID_H
+#define __MX6SX_SABRESD_ANDROID_H
+
+#define CONFIG_SERIAL_TAG
+
+#define CONFIG_USB_DEVICE
+#define CONFIG_IMX_UDC		       1
+
+#define CONFIG_FASTBOOT		       1
+#define CONFIG_FASTBOOT_VENDOR_ID      0x18d1
+#define CONFIG_FASTBOOT_PRODUCT_ID     0x0d02
+#define CONFIG_FASTBOOT_BCD_DEVICE     0x311
+#define CONFIG_FASTBOOT_MANUFACTURER_STR  "Freescale"
+#define CONFIG_FASTBOOT_PRODUCT_NAME_STR "i.mx6sx SABRESD Board"
+#define CONFIG_FASTBOOT_INTERFACE_STR	 "Android fastboot"
+#define CONFIG_FASTBOOT_CONFIGURATION_STR  "Android fastboot"
+#define CONFIG_FASTBOOT_SERIAL_NUM	"12345"
+#define CONFIG_FASTBOOT_SATA_NO		 0
+
+#define CONFIG_FASTBOOT_STORAGE_MMC
+
+/*  For system.img growing up more than 256MB, more buffer needs
+*   to receive the system.img*/
+#define CONFIG_FASTBOOT_TRANSFER_BUF	0x8c000000
+#define CONFIG_FASTBOOT_TRANSFER_BUF_SIZE 0x19000000 /* 400M byte */
+
+
+#define CONFIG_CMD_BOOTI
+#define CONFIG_ANDROID_RECOVERY
+/* which mmc bus is your main storage ? */
+#define CONFIG_ANDROID_MAIN_MMC_BUS 2
+#define CONFIG_ANDROID_BOOT_PARTITION_MMC 1
+#define CONFIG_ANDROID_SYSTEM_PARTITION_MMC 5
+#define CONFIG_ANDROID_RECOVERY_PARTITION_MMC 2
+#define CONFIG_ANDROID_CACHE_PARTITION_MMC 6
+
+#undef CONFIG_EXTRA_ENV_SETTINGS
+#undef CONFIG_BOOTCOMMAND
+
+#define CONFIG_EXTRA_ENV_SETTINGS					\
+	"splashpos=m,m\0"	  \
+	"fdt_high=0xffffffff\0"	  \
+	"initrd_high=0xffffffff\0" \
+
+#endif
diff --git a/include/fastboot.h b/include/fastboot.h
new file mode 100644
index 0000000..c81abcf
--- /dev/null
+++ b/include/fastboot.h
@@ -0,0 +1,376 @@
+/*
+ * (C) Copyright 2008 - 2009
+ * Windriver, <www.windriver.com>
+ * Tom Rix <Tom.Rix@windriver.com>
+ *
+ * Copyright (C) 2010-2013 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ * The logical naming of flash comes from the Android project
+ * Thse structures and functions that look like fastboot_flash_*
+ * They come from bootloader/legacy/include/boot/flash.h
+ *
+ * The boot_img_hdr structure and associated magic numbers also
+ * come from the Android project.  They are from
+ * system/core/mkbootimg/bootimg.h
+ *
+ * Here are their copyrights
+ *
+ * Copyright (C) 2008 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#ifndef FASTBOOT_H
+#define FASTBOOT_H
+
+#include <common.h>
+#include <command.h>
+
+/* This is the interface file between the common cmd_fastboot.c and
+   the board specific support.
+
+   To use this interface, define CONFIG_FASTBOOT in your board config file.
+   An example is include/configs/mx6slevkandroid.h
+   ...
+   #define CONFIG_FASTBOOT	        1    / * Using fastboot interface * /
+   ...
+
+*/
+
+/* From fastboot client.. */
+#define FASTBOOT_INTERFACE_CLASS     0xff
+#define FASTBOOT_INTERFACE_SUB_CLASS 0x42
+#define FASTBOOT_INTERFACE_PROTOCOL  0x03
+
+#define FASTBOOT_VERSION "0.5"
+
+/* Max size of responses from us to host */
+#define FASTBOOT_RESPONSE_SIZE 65
+
+/* The fastboot client uses a value of 2048 for the
+   page size of it boot.img file format.
+   Reset this in your board config file as needed. */
+#ifndef CFG_FASTBOOT_MKBOOTIMAGE_PAGE_SIZE
+#define CFG_FASTBOOT_MKBOOTIMAGE_PAGE_SIZE 2048
+#endif
+
+/* Lower byte shows if the read/write/erase operation in
+   repeated.  The base address is incremented.
+   Either 0 or 1 is ok for a default */
+
+#define FASTBOOT_PTENTRY_FLAGS_REPEAT(n)              (n & 0x0f)
+#define FASTBOOT_PTENTRY_FLAGS_REPEAT_MASK            0x0000000F
+
+/* Writes happen a block at a time.
+   If the write fails, go to next block
+   NEXT_GOOD_BLOCK and CONTIGOUS_BLOCK can not both be set */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_NEXT_GOOD_BLOCK  0x00000010
+
+/* Find a contiguous block big enough for a the whole file
+   NEXT_GOOD_BLOCK and CONTIGOUS_BLOCK can not both be set */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_CONTIGUOUS_BLOCK 0x00000020
+
+/* Write the file with write.i */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_I                0x00000100
+
+/* Write the file with write.trimffs */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_TRIMFFS          0x00000200
+
+/* Write the file as a series of variable/value pairs
+   using the setenv and saveenv commands */
+#define FASTBOOT_PTENTRY_FLAGS_WRITE_ENV              0x00000400
+
+/* Status values */
+#define FASTBOOT_OK			0
+#define FASTBOOT_ERROR			-1
+#define FASTBOOT_DISCONNECT		1
+#define FASTBOOT_INACTIVE		2
+
+/* Android bootimage file format */
+#define FASTBOOT_BOOT_MAGIC "ANDROID!"
+#define FASTBOOT_BOOT_MAGIC_SIZE 8
+#define FASTBOOT_BOOT_NAME_SIZE 16
+#define FASTBOOT_BOOT_ARGS_SIZE 512
+
+#define FASTBOOT_MMC_BOOT_PARTITION_ID  1
+#define FASTBOOT_MMC_USER_PARTITION_ID  0
+#define FASTBOOT_MMC_NONE_PARTITION_ID -1
+
+enum {
+    DEV_SATA,
+    DEV_MMC,
+    DEV_NAND
+};
+
+struct cmd_fastboot_interface {
+	/* This function is called when a buffer has been
+	   recieved from the client app.
+	   The buffer is a supplied by the board layer and must be unmodified.
+	   The buffer_size is how much data is passed in.
+	   Returns 0 on success
+	   Returns 1 on failure
+
+	   Set by cmd_fastboot	*/
+	int (*rx_handler)(const unsigned char *buffer,
+			  unsigned int buffer_size);
+
+	/* This function is called when an exception has
+	   occurred in the device code and the state
+	   off fastboot needs to be reset
+
+	   Set by cmd_fastboot */
+	void (*reset_handler)(void);
+
+	/* A getvar string for the product name
+	   It can have a maximum of 60 characters
+
+	   Set by board	*/
+	char *product_name;
+
+	/* A getvar string for the serial number
+	   It can have a maximum of 60 characters
+
+	   Set by board */
+	char *serial_no;
+
+	/* Nand block size
+	   Supports the write option WRITE_NEXT_GOOD_BLOCK
+
+	   Set by board */
+	unsigned int nand_block_size;
+
+	/* Nand oob size
+	   Set by board */
+	unsigned int nand_oob_size;
+
+	/* Transfer buffer, for handling flash updates
+	   Should be multiple of the nand_block_size
+	   Care should be take so it does not overrun bootloader memory
+	   Controlled by the configure variable CFG_FASTBOOT_TRANSFER_BUFFER
+
+	   Set by board */
+	unsigned char *transfer_buffer;
+
+	/* How big is the transfer buffer
+	   Controlled by the configure variable
+	   CFG_FASTBOOT_TRANSFER_BUFFER_SIZE
+
+	   Set by board	*/
+	unsigned int transfer_buffer_size;
+
+};
+
+/* flash partitions are defined in terms of blocks
+** (flash erase units)
+*/
+struct fastboot_ptentry {
+	/* The logical name for this partition, null terminated */
+	char name[16];
+	/* The start wrt the nand part, must be multiple of nand block size */
+	unsigned int start;
+	/* The length of the partition, must be multiple of nand block size */
+	unsigned int length;
+	/* Controls the details of how operations are done on the partition
+	   See the FASTBOOT_PTENTRY_FLAGS_*'s defined below */
+	unsigned int flags;
+	/* partition id: 0 - normal partition; 1 - boot partition */
+	unsigned int partition_id;
+};
+
+struct fastboot_device_info {
+	unsigned char type;
+	unsigned char dev_id;
+};
+
+/* Boot img hdr structure comes from the Android project
+  * See it in: system/core/mkbootimg/bootimg.h
+  */
+struct fastboot_boot_img_hdr {
+	unsigned char magic[FASTBOOT_BOOT_MAGIC_SIZE];
+
+	unsigned kernel_size;  /* size in bytes */
+	unsigned kernel_addr;  /* physical load addr */
+
+	unsigned ramdisk_size; /* size in bytes */
+	unsigned ramdisk_addr; /* physical load addr */
+
+	unsigned second_size;  /* size in bytes */
+	unsigned second_addr;  /* physical load addr */
+
+	unsigned tags_addr;    /* physical addr for kernel tags */
+	unsigned page_size;    /* flash page size we assume */
+	unsigned unused[2];    /* future expansion: should be 0 */
+
+	unsigned char name[FASTBOOT_BOOT_NAME_SIZE]; /* asciiz product name */
+
+	unsigned char cmdline[FASTBOOT_BOOT_ARGS_SIZE];
+
+	unsigned id[8]; /* timestamp / checksum / sha1 / etc */
+};
+
+#ifdef CONFIG_FASTBOOT
+
+extern struct fastboot_device_info fastboot_devinfo;
+
+/* Prepare the fastboot environments,
+  * should be executed before "fastboot" cmd
+  */
+void fastboot_setup(void);
+
+/* Initizes the board specific fastboot
+  * Returns 0 on success
+  * Returns 1 on failure
+  */
+int fastboot_init(struct cmd_fastboot_interface *interface);
+
+/* Cleans up the board specific fastboot */
+void fastboot_shutdown(void);
+
+/*
+ * Handles board specific usb protocol exchanges
+ * Returns 0 on success
+ * Returns 1 on disconnects, break out of loop
+ * Returns 2 if no USB activity detected
+ * Returns -1 on failure, unhandled usb requests and other error conditions
+*/
+int fastboot_poll(void);
+
+/* Is this high speed (2.0) or full speed (1.1) ?
+  * Returns 0 on full speed
+  * Returns 1 on high speed
+  */
+int fastboot_is_highspeed(void);
+
+/* Return the size of the fifo */
+int fastboot_fifo_size(void);
+
+/* Send a status reply to the client app
+  * buffer does not have to be null terminated.
+  * buffer_size must be not be larger than what is returned by
+  * fastboot_fifo_size
+  * Returns 0 on success
+  * Returns 1 on failure
+  */
+int fastboot_tx_status(const char *buffer, unsigned int buffer_size);
+
+/*
+ * Send some data to the client app
+ * buffer does not have to be null terminated.
+ * buffer_size can be larger than what is returned by
+ * fastboot_fifo_size
+ * Returns number of bytes written
+ */
+int fastboot_tx(unsigned char *buffer, unsigned int buffer_size);
+
+/* A board specific variable handler.
+  * The size of the buffers is governed by the fastboot spec.
+  * rx_buffer is at most 57 bytes
+  * tx_buffer is at most 60 bytes
+  * Returns 0 on success
+  * Returns 1 on failure
+  */
+int fastboot_getvar(const char *rx_buffer, char *tx_buffer);
+
+/* The Android-style flash handling */
+
+/* tools to populate and query the partition table */
+void fastboot_flash_add_ptn(struct fastboot_ptentry *ptn);
+struct fastboot_ptentry *fastboot_flash_find_ptn(const char *name);
+struct fastboot_ptentry *fastboot_flash_get_ptn(unsigned n);
+unsigned int fastboot_flash_get_ptn_count(void);
+void fastboot_flash_dump_ptn(void);
+
+
+/* Check the board special boot mode reboot to fastboot mode. */
+int fastboot_check_and_clean_flag(void);
+
+/*fastboot command handling function*/
+int do_fastboot(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]);
+
+/*check if fastboot mode is requested by user*/
+void check_fastboot(void);
+
+/*Setup board-relative fastboot environment */
+void board_fastboot_setup(void);
+
+#ifdef CONFIG_FASTBOOT_STORAGE_NAND
+/*Save parameters for NAND storage partitions */
+void save_parts_values(struct fastboot_ptentry *ptn,
+	unsigned int offset, unsigned int size);
+
+/* Checks parameters for NAND storage partitions
+  * Return 1 if the parameter is not set
+  * Return 0 if the parameter has been set
+  */
+int check_parts_values(struct fastboot_ptentry *ptn);
+#endif /*CONFIG_FASTBOOT_STORAGE_NAND*/
+
+#else /*! CONFIG_FASTBOOT*/
+
+/* Stubs for when CONFIG_FASTBOOT is not defined */
+#define fastboot_setup() 0
+#define fastboot_init(a) 1
+#define fastboot_shutdown()
+#define fastboot_poll() 1
+#define fastboot_is_highspeed() 0
+#define fastboot_fifo_size() 0
+#define fastboot_tx_status(a, b) 1
+#define fastboot_getvar(a, b) 1
+#define fastboot_tx(a, b) 1
+
+#define fastboot_flash_add_ptn(a)
+#define fastboot_flash_find_ptn(a) NULL
+#define fastboot_flash_get_ptn(a) NULL
+#define fastboot_flash_get_ptn_count() 0
+#define fastboot_flash_dump_ptn()
+#define do_fastboot(a, b, c, d) 0
+
+#define fastboot_quick(a) 0
+#define fastboot_get_ep_num(a, b)  0
+#define fastboot_dump_memory(a, b) 0
+#define DBG_ALWS(x...)
+#define DBG_ERR(x...)
+#define DBG_DEBUG(x...)
+#define DBG_INFO(x...)
+
+
+#endif /*! CONFIG_FASTBOOT*/
+#endif /* FASTBOOT_H */
diff --git a/include/fsl_esdhc.h b/include/fsl_esdhc.h
index a6e3a5d..b06aafb 100644
--- a/include/fsl_esdhc.h
+++ b/include/fsl_esdhc.h
@@ -2,7 +2,7 @@
  * FSL SD/MMC Defines
  *-------------------------------------------------------------------
  *
- * Copyright 2007-2008,2010-2011 Freescale Semiconductor, Inc
+ * Copyright 2007-2008, 2010-2013 Freescale Semiconductor, Inc.
  *
  * SPDX-License-Identifier:	GPL-2.0+
  */
@@ -29,6 +29,12 @@
 #define SYSCTL_RSTC		0x02000000
 #define SYSCTL_RSTD		0x04000000
 
+#define VENDORSPEC_CKEN		0x00004000
+#define VENDORSPEC_PEREN		0x00002000
+#define VENDORSPEC_HCKEN		0x00001000
+#define VENDORSPEC_IPGEN		0x00000800
+#define VENDORSPEC_INIT     0x20007809
+
 #define IRQSTAT			0x0002e030
 #define IRQSTAT_DMAE		(0x10000000)
 #define IRQSTAT_AC12E		(0x01000000)
@@ -82,6 +88,7 @@
 #define PRSSTAT_CINS		(0x00010000)
 #define PRSSTAT_BREN		(0x00000800)
 #define PRSSTAT_BWEN		(0x00000400)
+#define PRSSTAT_SDSTB		(0x00000008)
 #define PRSSTAT_DLA		(0x00000004)
 #define PRSSTAT_CICHB		(0x00000002)
 #define PRSSTAT_CIDHB		(0x00000001)
diff --git a/include/gis.h b/include/gis.h
new file mode 100644
index 0000000..e156743
--- /dev/null
+++ b/include/gis.h
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef GIS_H
+#define GIS_H
+
+#define FMT_YUV444		0
+#define FMT_YUYV		1
+#define FMT_UYVY		2
+#define FMT_RGB565		3
+#define FMT_RGB888		4
+
+void mxc_enable_gis(void);
+void mxc_disable_gis(void);
+
+#endif
diff --git a/include/gpio_exp.h b/include/gpio_exp.h
new file mode 100644
index 0000000..6dc5eed
--- /dev/null
+++ b/include/gpio_exp.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __GPIO_EXP_H
+#define __GPIO_EXP_H
+
+#ifndef CONFIG_IOEXP_DEV_PINS_NUM
+#define CONFIG_IOEXP_DEV_PINS_NUM 8
+#endif
+
+#ifndef CONFIG_IOEXP_DEVICES_NUM
+#define CONFIG_IOEXP_DEVICES_NUM 1
+#endif
+
+/*Define for building ioexp gpio, port starts from 1, index starts from 0*/
+#define IOEXP_GPIO_NR(port, index) \
+	((((port)-1)*CONFIG_IOEXP_DEV_PINS_NUM)+ \
+	 ((index)&(CONFIG_IOEXP_DEV_PINS_NUM-1)))
+
+/*Get the device number from a ioexp gpio*/
+#define IOEXP_GPIO_TO_DEVICE(gpio_nr) \
+	(gpio_nr / CONFIG_IOEXP_DEV_PINS_NUM)
+
+/*Get the port number from a ioexp gpio*/
+#define IOEXP_GPIO_TO_PORT(gpio_nr) \
+	((gpio_nr / CONFIG_IOEXP_DEV_PINS_NUM) + 1)
+
+/*Get the pin number from a ioexp gpio*/
+#define IOEXP_GPIO_TO_PIN(gpio_nr) \
+	(gpio_nr % CONFIG_IOEXP_DEV_PINS_NUM)
+
+/**
+ * Make a GPIO an input.
+ *
+ * @param gpio	GPIO number
+ * @return 0 if ok, -1 on error
+ */
+int gpio_exp_direction_input(unsigned gpio);
+
+/**
+ * Make a GPIO an output, and set its value.
+ *
+ * @param gpio	GPIO number
+ * @param value	GPIO value (0 for low or 1 for high)
+ * @return 0 if ok, -1 on error
+ */
+int gpio_exp_direction_output(unsigned gpio, int value);
+
+/**
+ * Setup the io expander's port.
+ *
+ * @param port	IO expander port , starts from 1
+ * @param i2c_bus_id	i2c bus index, starts from 0
+ * @param i2c_slave_addr	i2c address of the io expander port
+ * @return 0 if ok, -1 on error
+ */
+int gpio_exp_setup_port(int port, int i2c_bus_id, int i2c_slave_addr);
+
+#endif	/*__GPIO_EXP_H*/
diff --git a/include/image.h b/include/image.h
index 6afd57b..5f85b96 100644
--- a/include/image.h
+++ b/include/image.h
@@ -403,6 +403,7 @@ enum fit_load_op {
 #define IMAGE_FORMAT_INVALID	0x00
 #define IMAGE_FORMAT_LEGACY	0x01	/* legacy image_header based format */
 #define IMAGE_FORMAT_FIT	0x02	/* new, libfdt based format */
+#define IMAGE_FORMAT_ANDROID	0x03	/* Android boot image */
 
 int genimg_get_format(const void *img_addr);
 int genimg_has_config(bootm_headers_t *images);
@@ -996,4 +997,16 @@ static inline int fit_image_check_target_arch(const void *fdt, int node)
 #endif /* CONFIG_FIT_VERBOSE */
 #endif /* CONFIG_FIT */
 
+#if defined(CONFIG_ANDROID_BOOT_IMAGE)
+struct andr_img_hdr;
+int android_image_check_header(const struct andr_img_hdr *hdr);
+int android_image_get_kernel(const struct andr_img_hdr *hdr, int verify,
+			     ulong *os_data, ulong *os_len);
+int android_image_get_ramdisk(const struct andr_img_hdr *hdr,
+			      ulong *rd_data, ulong *rd_len);
+ulong android_image_get_end(const struct andr_img_hdr *hdr);
+ulong android_image_get_kload(const struct andr_img_hdr *hdr);
+
+#endif /* CONFIG_ANDROID_BOOT_IMAGE */
+
 #endif	/* __IMAGE_H__ */
diff --git a/include/lcd.h b/include/lcd.h
index 5f84cd3..5ff403b 100644
--- a/include/lcd.h
+++ b/include/lcd.h
@@ -239,6 +239,59 @@ typedef struct vidinfo {
 
 void init_panel_info(vidinfo_t *vid);
 
+#elif defined(CONFIG_MXC_EPDC)
+
+struct waveform_modes {
+	int mode_init;
+	int mode_du;
+	int mode_gc4;
+	int mode_gc8;
+	int mode_gc16;
+	int mode_gc32;
+};
+
+struct epdc_timing_params {
+    int vscan_holdoff;
+    int sdoed_width;
+    int sdoed_delay;
+    int sdoez_width;
+    int sdoez_delay;
+    int gdclk_hp_offs;
+    int gdsp_offs;
+    int gdoe_offs;
+    int gdclk_offs;
+    int num_ce;
+};
+
+struct epdc_data_struct {
+	/* EPDC buffer pointers */
+	u_long working_buf_addr;
+	u_long waveform_buf_addr;
+
+	/* Waveform mode definitions */
+	struct waveform_modes wv_modes;
+	struct epdc_timing_params epdc_timings;
+};
+
+typedef struct vidinfo {
+	u_long vl_refresh;      /* Refresh Rate Hz */
+	u_long vl_row;          /* resolution in x */
+	u_long vl_col;          /* resolution in y */
+	u_long vl_pixclock;     /* pixel clock in picoseconds */
+	u_long vl_left_margin;  /* Horizontal back porch */
+	u_long vl_right_margin; /* Horizontal front porch */
+	u_long vl_upper_margin; /* Vertical back porch */
+	u_long vl_lower_margin; /* Vertical front porch */
+	u_long vl_hsync;        /* Horizontal sync pulse length */
+	u_long vl_vsync;        /* Vertical sync pulse length */
+	u_long vl_sync;         /* Polarity on data enable */
+	u_long vl_mode;         /* Video Mode */
+	u_long vl_flag;
+	u_char  vl_bpix;
+	ushort  *cmap;
+	struct epdc_data_struct epdc_data;
+} vidinfo_t;
+
 #else
 
 typedef struct vidinfo {
@@ -337,6 +390,7 @@ void lcd_sync(void);
 #define LCD_COLOR4	2
 #define LCD_COLOR8	3
 #define LCD_COLOR16	4
+#define LCD_COLOR32	5
 
 /*----------------------------------------------------------------------*/
 #if defined(CONFIG_LCD_INFO_BELOW_LOGO)
@@ -388,7 +442,7 @@ void lcd_sync(void);
 # define CONSOLE_COLOR_GREY	14
 # define CONSOLE_COLOR_WHITE	15	/* Must remain last / highest	*/
 
-#else
+#elif LCD_BPP == LCD_COLOR16
 
 /*
  * 16bpp color definitions
@@ -396,6 +450,14 @@ void lcd_sync(void);
 # define CONSOLE_COLOR_BLACK	0x0000
 # define CONSOLE_COLOR_WHITE	0xffff	/* Must remain last / highest	*/
 
+#else
+
+/*
+ * 32bpp colour definitions
+ */
+# define CONSOLE_COLOR_BLACK	0x00000000
+# define CONSOLE_COLOR_WHITE	0x00ffffff
+
 #endif /* color definitions */
 
 /************************************************************************/
diff --git a/include/mxc_epdc_fb.h b/include/mxc_epdc_fb.h
new file mode 100644
index 0000000..bff58bc
--- /dev/null
+++ b/include/mxc_epdc_fb.h
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+#ifndef __EPDC_REGS_INCLUDED__
+#define __EPDC_REGS_INCLUDED__
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <asm/arch/imx-regs.h>
+
+/*************************************
+ * Register addresses
+ *************************************/
+#define EPDC_BASE			(EPDC_BASE_ADDR)
+
+#define EPDC_CTRL			(0x000)
+#define EPDC_CTRL_SET			(0x004)
+#define EPDC_CTRL_CLR			(0x008)
+#define EPDC_CTRL_TOG			(0x00c)
+#define EPDC_WVADDR			(0x020)
+#define EPDC_WB_ADDR			(0x030)
+#define EPDC_RES			(0x040)
+#define EPDC_FORMAT			(0x050)
+#define EPDC_FORMAT_SET			(0x054)
+#define EPDC_FORMAT_CLR			(0x058)
+#define EPDC_FORMAT_TOG			(0x05c)
+#define EPDC_FIFOCTRL			(0x0a0)
+#define EPDC_FIFOCTRL_SET		(0x0a4)
+#define EPDC_FIFOCTRL_CLR		(0x0a8)
+#define EPDC_FIFOCTRL_TOG		(0x0ac)
+#define EPDC_UPD_ADDR			(0x100)
+#define EPDC_UPD_STRIDE			(0x110)
+#define EPDC_UPD_CORD			(0x120)
+#define EPDC_UPD_SIZE			(0x140)
+#define EPDC_UPD_CTRL			(0x160)
+#define EPDC_UPD_FIXED			(0x180)
+#define EPDC_TEMP			(0x1a0)
+#define EPDC_AUTOWV_LUT			(0x1C0)
+#define EPDC_TCE_CTRL			(0x200)
+#define EPDC_TCE_SDCFG			(0x220)
+#define EPDC_TCE_GDCFG			(0x240)
+#define EPDC_TCE_HSCAN1			(0x260)
+#define EPDC_TCE_HSCAN2			(0x280)
+#define EPDC_TCE_VSCAN			(0x2a0)
+#define EPDC_TCE_OE			(0x2c0)
+#define EPDC_TCE_POLARITY		(0x2e0)
+#define EPDC_TCE_TIMING1		(0x300)
+#define EPDC_TCE_TIMING2		(0x310)
+#define EPDC_TCE_TIMING3		(0x320)
+#define EPDC_PIGEON_CTRL0		(0x380)
+#define EPDC_PIGEON_CTRL1		(0x390)
+#define EPDC_IRQ_MASK1			(0x3C0)
+#define EPDC_IRQ_MASK1_SET		(0x3C4)
+#define EPDC_IRQ_MASK1_CLR		(0x3C8)
+#define EPDC_IRQ_MASK1_TOG		(0x3CC)
+#define EPDC_IRQ_MASK2			(0x3D0)
+#define EPDC_IRQ_MASK2_SET		(0x3D4)
+#define EPDC_IRQ_MASK2_CLR		(0x3D8)
+#define EPDC_IRQ_MASK2_TOG		(0x3DC)
+#define EPDC_IRQ1			(0x3E0)
+#define EPDC_IRQ1_SET			(0x3E4)
+#define EPDC_IRQ1_CLR			(0x3E8)
+#define EPDC_IRQ1_TOG			(0x3EC)
+#define EPDC_IRQ2			(0x3F0)
+#define EPDC_IRQ2_SET			(0x3F4)
+#define EPDC_IRQ2_CLR			(0x3F8)
+#define EPDC_IRQ2_TOG			(0x3FC)
+#define EPDC_IRQ_MASK			(0x400)
+#define EPDC_IRQ_MASK_SET		(0x404)
+#define EPDC_IRQ_MASK_CLR		(0x408)
+#define EPDC_IRQ_MASK_TOG		(0x40c)
+#define EPDC_IRQ			(0x420)
+#define EPDC_IRQ_SET			(0x424)
+#define EPDC_IRQ_CLR			(0x428)
+#define EPDC_IRQ_TOG			(0x42c)
+#define EPDC_STATUS_LUTS		(0x440)
+#define EPDC_STATUS_LUTS_SET		(0x444)
+#define EPDC_STATUS_LUTS_CLR		(0x448)
+#define EPDC_STATUS_LUTS_TOG		(0x44c)
+#define EPDC_STATUS_LUTS2		(0x450)
+#define EPDC_STATUS_LUTS2_SET		(0x454)
+#define EPDC_STATUS_LUTS2_CLR		(0x458)
+#define EPDC_STATUS_LUTS2_TOG		(0x45C)
+#define EPDC_STATUS_NEXTLUT		(0x460)
+#define EPDC_STATUS_COL			(0x480)
+#define EPDC_STATUS_COL2		(0x490)
+#define EPDC_STATUS			(0x4a0)
+#define EPDC_STATUS_SET			(0x4a4)
+#define EPDC_STATUS_CLR			(0x4a8)
+#define EPDC_STATUS_TOG			(0x4ac)
+#define EPDC_UPD_COL_CORD		(0x4C0)
+#define EPDC_UPD_COL_SIZE		(0x4E0)
+#define EPDC_DEBUG			(0x500)
+#define EPDC_DEBUG_LUT			(0x530)
+#define EPDC_HIST1_PARAM		(0x600)
+#define EPDC_HIST2_PARAM		(0x610)
+#define EPDC_HIST4_PARAM		(0x620)
+#define EPDC_HIST8_PARAM0		(0x630)
+#define EPDC_HIST8_PARAM1		(0x640)
+#define EPDC_HIST16_PARAM0		(0x650)
+#define EPDC_HIST16_PARAM1		(0x660)
+#define EPDC_HIST16_PARAM2		(0x670)
+#define EPDC_HIST16_PARAM3		(0x680)
+#define EPDC_GPIO			(0x700)
+#define EPDC_VERSION			(0x7f0)
+#define EPDC_PIGEON_0_0			(0x800)
+#define EPDC_PIGEON_0_1			(0x810)
+#define EPDC_PIGEON_0_2			(0x820)
+#define EPDC_PIGEON_1_0			(0x840)
+#define EPDC_PIGEON_1_1			(0x850)
+#define EPDC_PIGEON_1_2			(0x860)
+#define EPDC_PIGEON_2_0			(0x880)
+#define EPDC_PIGEON_2_1			(0x890)
+#define EPDC_PIGEON_2_2			(0x8A0)
+#define EPDC_PIGEON_3_0			(0x8C0)
+#define EPDC_PIGEON_3_1			(0x8D0)
+#define EPDC_PIGEON_3_2			(0x8E0)
+#define EPDC_PIGEON_4_0			(0x900)
+#define EPDC_PIGEON_4_1			(0x910)
+#define EPDC_PIGEON_4_2			(0x920)
+#define EPDC_PIGEON_5_0			(0x940)
+#define EPDC_PIGEON_5_1			(0x950)
+#define EPDC_PIGEON_5_2			(0x960)
+#define EPDC_PIGEON_6_0			(0x980)
+#define EPDC_PIGEON_6_1			(0x990)
+#define EPDC_PIGEON_6_2			(0x9A0)
+#define EPDC_PIGEON_7_0			(0x9C0)
+#define EPDC_PIGEON_7_1			(0x9D0)
+#define EPDC_PIGEON_7_2			(0x9E0)
+#define EPDC_PIGEON_8_0			(0xA00)
+#define EPDC_PIGEON_8_1			(0xA10)
+#define EPDC_PIGEON_8_2			(0xA20)
+#define EPDC_PIGEON_9_0			(0xA40)
+#define EPDC_PIGEON_9_1			(0xA50)
+#define EPDC_PIGEON_9_2			(0xA60)
+#define EPDC_PIGEON_10_0		(0xA80)
+#define EPDC_PIGEON_10_1		(0xA90)
+#define EPDC_PIGEON_10_2		(0xAA0)
+#define EPDC_PIGEON_11_0		(0xAC0)
+#define EPDC_PIGEON_11_1		(0xAD0)
+#define EPDC_PIGEON_11_2		(0xAE0)
+#define EPDC_PIGEON_12_0		(0xB00)
+#define EPDC_PIGEON_12_1		(0xB10)
+#define EPDC_PIGEON_12_2		(0xB20)
+#define EPDC_PIGEON_13_0		(0xB40)
+#define EPDC_PIGEON_13_1		(0xB50)
+#define EPDC_PIGEON_13_2		(0xB60)
+#define EPDC_PIGEON_14_0		(0xB80)
+#define EPDC_PIGEON_14_1		(0xB90)
+#define EPDC_PIGEON_14_2		(0xBA0)
+#define EPDC_PIGEON_15_0		(0xBC0)
+#define EPDC_PIGEON_15_1		(0xBD0)
+#define EPDC_PIGEON_15_2		(0xBE0)
+#define EPDC_WB_ADDR_TCE		(0xC10)
+
+#define REG_RD(base, reg) \
+	(*(volatile unsigned int *)((base) + (reg)))
+#define REG_WR(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg))) = (value))
+#define REG_SET(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg ## _SET))) = (value))
+#define REG_CLR(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg ## _CLR))) = (value))
+#define REG_TOG(base, reg, value) \
+	((*(volatile unsigned int *)((base) + (reg ## _TOG))) = (value))
+/*
+ * Register field definitions
+ */
+
+enum {
+	/* EPDC_CTRL field values */
+	EPDC_CTRL_SFTRST = 0x80000000,
+	EPDC_CTRL_CLKGATE = 0x40000000,
+	EPDC_CTRL_SRAM_POWERDOWN = 0x100,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_MASK = 0xc0,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_NO_SWAP = 0,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_ALL_BYTES_SWAP = 0x40,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_HWD_SWAP = 0x80,
+	EPDC_CTRL_UPD_DATA_SWIZZLE_HWD_BYTE_SWAP = 0xc0,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_MASK = 0x30,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_NO_SWAP = 0,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_ALL_BYTES_SWAP = 0x10,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_HWD_SWAP = 0x20,
+	EPDC_CTRL_LUT_DATA_SWIZZLE_HWD_BYTE_SWAP = 0x30,
+	EPDC_CTRL_BURST_LEN_8_8 = 0x1,
+	EPDC_CTRL_BURST_LEN_8_16 = 0,
+
+	/* EPDC_RES field values */
+	EPDC_RES_VERTICAL_MASK = 0x1fff0000,
+	EPDC_RES_VERTICAL_OFFSET = 16,
+	EPDC_RES_HORIZONTAL_MASK = 0x1fff,
+	EPDC_RES_HORIZONTAL_OFFSET = 0,
+
+	/* EPDC_FORMAT field values */
+	EPDC_FORMAT_BUF_PIXEL_SCALE_ROUND = 0x1000000,
+	EPDC_FORMAT_DEFAULT_TFT_PIXEL_MASK = 0xff0000,
+	EPDC_FORMAT_DEFAULT_TFT_PIXEL_OFFSET = 16,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P2N = 0x200,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P3N = 0x300,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P4N = 0x400,
+	EPDC_FORMAT_BUF_PIXEL_FORMAT_P5N = 0x500,
+	EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT = 0x0,
+	EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT_VCOM = 0x1,
+	EPDC_FORMAT_TFT_PIXEL_FORMAT_4BIT = 0x2,
+	EPDC_FORMAT_TFT_PIXEL_FORMAT_4BIT_VCOM = 0x3,
+
+	/* EPDC_FIFOCTRL field values */
+	EPDC_FIFOCTRL_ENABLE_PRIORITY = 0x80000000,
+	EPDC_FIFOCTRL_FIFO_INIT_LEVEL_MASK = 0xff0000,
+	EPDC_FIFOCTRL_FIFO_INIT_LEVEL_OFFSET = 16,
+	EPDC_FIFOCTRL_FIFO_H_LEVEL_MASK = 0xff00,
+	EPDC_FIFOCTRL_FIFO_H_LEVEL_OFFSET = 8,
+	EPDC_FIFOCTRL_FIFO_L_LEVEL_MASK = 0xff,
+	EPDC_FIFOCTRL_FIFO_L_LEVEL_OFFSET = 0,
+
+	/* EPDC_UPD_CORD field values */
+	EPDC_UPD_CORD_YCORD_MASK = 0x1fff0000,
+	EPDC_UPD_CORD_YCORD_OFFSET = 16,
+	EPDC_UPD_CORD_XCORD_MASK = 0x1fff,
+	EPDC_UPD_CORD_XCORD_OFFSET = 0,
+
+	/* EPDC_UPD_SIZE field values */
+	EPDC_UPD_SIZE_HEIGHT_MASK = 0x1fff0000,
+	EPDC_UPD_SIZE_HEIGHT_OFFSET = 16,
+	EPDC_UPD_SIZE_WIDTH_MASK = 0x1fff,
+	EPDC_UPD_SIZE_WIDTH_OFFSET = 0,
+
+	/* EPDC_UPD_CTRL field values */
+	EPDC_UPD_CTRL_USE_FIXED = 0x80000000,
+	EPDC_UPD_CTRL_LUT_SEL_MASK = 0xf0000,
+	EPDC_UPD_CTRL_LUT_SEL_OFFSET = 16,
+	EPDC_UPD_CTRL_WAVEFORM_MODE_MASK = 0xff00,
+	EPDC_UPD_CTRL_WAVEFORM_MODE_OFFSET = 8,
+	EPDC_UPD_CTRL_AUTOWV_PAUSE = 0x8,
+	EPDC_UPD_CTRL_AUTOWV = 0x4,
+	EPDC_UPD_CTRL_DRY_RUN = 0x2,
+	EPDC_UPD_CTRL_UPDATE_MODE_FULL = 0x1,
+
+	/* EPDC_UPD_FIXED field values */
+	EPDC_UPD_FIXED_FIXNP_EN = 0x80000000,
+	EPDC_UPD_FIXED_FIXCP_EN = 0x40000000,
+	EPDC_UPD_FIXED_FIXNP_MASK = 0xff00,
+	EPDC_UPD_FIXED_FIXNP_OFFSET = 8,
+	EPDC_UPD_FIXED_FIXCP_MASK = 0xff,
+	EPDC_UPD_FIXED_FIXCP_OFFSET = 0,
+
+	/* EPDC_AUTOWV_LUT field values */
+	EPDC_AUTOWV_LUT_DATA_MASK = 0xFF0000,
+	EPDC_AUTOWV_LUT_DATA_OFFSET = 16,
+	EPDC_AUTOWV_LUT_ADDR_MASK = 0xFF,
+	EPDC_AUTOWV_LUT_ADDR_OFFSET = 0,
+
+	/* EPDC_TCE_CTRL field values */
+	EPDC_TCE_CTRL_VSCAN_HOLDOFF_MASK = 0x1ff0000,
+	EPDC_TCE_CTRL_VSCAN_HOLDOFF_OFFSET = 16,
+	EPDC_TCE_CTRL_VCOM_VAL_MASK = 0xc00,
+	EPDC_TCE_CTRL_VCOM_VAL_OFFSET = 10,
+	EPDC_TCE_CTRL_VCOM_MODE_AUTO = 0x200,
+	EPDC_TCE_CTRL_VCOM_MODE_MANUAL = 0x000,
+	EPDC_TCE_CTRL_DDR_MODE_ENABLE = 0x100,
+	EPDC_TCE_CTRL_LVDS_MODE_CE_ENABLE = 0x80,
+	EPDC_TCE_CTRL_LVDS_MODE_ENABLE = 0x40,
+	EPDC_TCE_CTRL_SCAN_DIR_1_UP = 0x20,
+	EPDC_TCE_CTRL_SCAN_DIR_0_UP = 0x10,
+	EPDC_TCE_CTRL_DUAL_SCAN_ENABLE = 0x8,
+	EPDC_TCE_CTRL_SDDO_WIDTH_16BIT = 0x4,
+	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_2 = 1,
+	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_4 = 2,
+	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_8 = 3,
+
+	/* EPDC_TCE_SDCFG field values */
+	EPDC_TCE_SDCFG_SDCLK_HOLD = 0x200000,
+	EPDC_TCE_SDCFG_SDSHR = 0x100000,
+	EPDC_TCE_SDCFG_NUM_CE_MASK = 0xf0000,
+	EPDC_TCE_SDCFG_NUM_CE_OFFSET = 16,
+	EPDC_TCE_SDCFG_SDDO_REFORMAT_STANDARD = 0,
+	EPDC_TCE_SDCFG_SDDO_REFORMAT_FLIP_PIXELS = 0x4000,
+	EPDC_TCE_SDCFG_SDDO_INVERT_ENABLE = 0x2000,
+	EPDC_TCE_SDCFG_PIXELS_PER_CE_MASK = 0x1fff,
+	EPDC_TCE_SDCFG_PIXELS_PER_CE_OFFSET = 0,
+
+	/* EPDC_TCE_GDCFG field values */
+	EPDC_TCE_SDCFG_GDRL = 0x10,
+	EPDC_TCE_SDCFG_GDOE_MODE_DELAYED_GDCLK = 0x2,
+	EPDC_TCE_SDCFG_GDSP_MODE_FRAME_SYNC = 0x1,
+	EPDC_TCE_SDCFG_GDSP_MODE_ONE_LINE = 0x0,
+
+	/* EPDC_TCE_HSCAN1 field values */
+	EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_MASK = 0xfff0000,
+	EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_OFFSET = 16,
+	EPDC_TCE_HSCAN1_LINE_SYNC_MASK = 0xfff,
+	EPDC_TCE_HSCAN1_LINE_SYNC_OFFSET = 0,
+
+	/* EPDC_TCE_HSCAN2 field values */
+	EPDC_TCE_HSCAN2_LINE_END_MASK = 0xfff0000,
+	EPDC_TCE_HSCAN2_LINE_END_OFFSET = 16,
+	EPDC_TCE_HSCAN2_LINE_BEGIN_MASK = 0xfff,
+	EPDC_TCE_HSCAN2_LINE_BEGIN_OFFSET = 0,
+
+	/* EPDC_TCE_VSCAN field values */
+	EPDC_TCE_VSCAN_FRAME_END_MASK = 0xff0000,
+	EPDC_TCE_VSCAN_FRAME_END_OFFSET = 16,
+	EPDC_TCE_VSCAN_FRAME_BEGIN_MASK = 0xff00,
+	EPDC_TCE_VSCAN_FRAME_BEGIN_OFFSET = 8,
+	EPDC_TCE_VSCAN_FRAME_SYNC_MASK = 0xff,
+	EPDC_TCE_VSCAN_FRAME_SYNC_OFFSET = 0,
+
+	/* EPDC_TCE_OE field values */
+	EPDC_TCE_OE_SDOED_WIDTH_MASK = 0xff000000,
+	EPDC_TCE_OE_SDOED_WIDTH_OFFSET = 24,
+	EPDC_TCE_OE_SDOED_DLY_MASK = 0xff0000,
+	EPDC_TCE_OE_SDOED_DLY_OFFSET = 16,
+	EPDC_TCE_OE_SDOEZ_WIDTH_MASK = 0xff00,
+	EPDC_TCE_OE_SDOEZ_WIDTH_OFFSET = 8,
+	EPDC_TCE_OE_SDOEZ_DLY_MASK = 0xff,
+	EPDC_TCE_OE_SDOEZ_DLY_OFFSET = 0,
+
+	/* EPDC_TCE_POLARITY field values */
+	EPDC_TCE_POLARITY_GDSP_POL_ACTIVE_HIGH = 0x10,
+	EPDC_TCE_POLARITY_GDOE_POL_ACTIVE_HIGH = 0x8,
+	EPDC_TCE_POLARITY_SDOE_POL_ACTIVE_HIGH = 0x4,
+	EPDC_TCE_POLARITY_SDLE_POL_ACTIVE_HIGH = 0x2,
+	EPDC_TCE_POLARITY_SDCE_POL_ACTIVE_HIGH = 0x1,
+
+	/* EPDC_TCE_TIMING1 field values */
+	EPDC_TCE_TIMING1_SDLE_SHIFT_NONE = 0x00,
+	EPDC_TCE_TIMING1_SDLE_SHIFT_1 = 0x10,
+	EPDC_TCE_TIMING1_SDLE_SHIFT_2 = 0x20,
+	EPDC_TCE_TIMING1_SDLE_SHIFT_3 = 0x30,
+	EPDC_TCE_TIMING1_SDCLK_INVERT = 0x8,
+	EPDC_TCE_TIMING1_SDCLK_SHIFT_NONE = 0,
+	EPDC_TCE_TIMING1_SDCLK_SHIFT_1CYCLE = 1,
+	EPDC_TCE_TIMING1_SDCLK_SHIFT_2CYCLES = 2,
+	EPDC_TCE_TIMING1_SDCLK_SHIFT_3CYCLES = 3,
+
+	/* EPDC_TCE_TIMING2 field values */
+	EPDC_TCE_TIMING2_GDCLK_HP_MASK = 0xffff0000,
+	EPDC_TCE_TIMING2_GDCLK_HP_OFFSET = 16,
+	EPDC_TCE_TIMING2_GDSP_OFFSET_MASK = 0xffff,
+	EPDC_TCE_TIMING2_GDSP_OFFSET_OFFSET = 0,
+
+	/* EPDC_TCE_TIMING3 field values */
+	EPDC_TCE_TIMING3_GDOE_OFFSET_MASK = 0xffff0000,
+	EPDC_TCE_TIMING3_GDOE_OFFSET_OFFSET = 16,
+	EPDC_TCE_TIMING3_GDCLK_OFFSET_MASK = 0xffff,
+	EPDC_TCE_TIMING3_GDCLK_OFFSET_OFFSET = 0,
+
+	/* EPDC_IRQ_MASK/EPDC_IRQ field values */
+	EPDC_IRQ_WB_CMPLT_IRQ = 0x10000,
+	EPDC_IRQ_LUT_COL_IRQ = 0x20000,
+	EPDC_IRQ_TCE_UNDERRUN_IRQ = 0x40000,
+	EPDC_IRQ_FRAME_END_IRQ = 0x80000,
+	EPDC_IRQ_BUS_ERROR_IRQ = 0x100000,
+	EPDC_IRQ_TCE_IDLE_IRQ = 0x200000,
+	EPDC_IRQ_UPD_DONE_IRQ = 0x400000,
+	EPDC_IRQ_PWR_IRQ = 0x800000,
+
+	/* EPDC_STATUS_NEXTLUT field values */
+	EPDC_STATUS_NEXTLUT_NEXT_LUT_VALID = 0x100,
+	EPDC_STATUS_NEXTLUT_NEXT_LUT_MASK = 0x3F,
+	EPDC_STATUS_NEXTLUT_NEXT_LUT_OFFSET = 0,
+
+	/* EPDC_STATUS field values */
+	EPDC_STATUS_HISTOGRAM_CP_MASK = 0x1F0000,
+	EPDC_STATUS_HISTOGRAM_CP_OFFSET = 16,
+	EPDC_STATUS_HISTOGRAM_NP_MASK = 0x1F00,
+	EPDC_STATUS_HISTOGRAM_NP_OFFSET = 8,
+	EPDC_STATUS_UPD_VOID = 0x8,
+	EPDC_STATUS_LUTS_UNDERRUN = 0x4,
+	EPDC_STATUS_LUTS_BUSY = 0x2,
+	EPDC_STATUS_WB_BUSY = 0x1,
+
+	/* EPDC_UPD_COL_CORD field values */
+	EPDC_UPD_COL_CORD_YCORD_MASK = 0x1FFF0000,
+	EPDC_UPD_COL_CORD_YCORD_OFFSET = 16,
+	EPDC_UPD_COL_CORD_XCORD_MASK = 0x1FFF,
+	EPDC_UPD_COL_CORD_XCORD_OFFSET = 0,
+
+	/* EPDC_UPD_COL_SIZE field values */
+	EPDC_UPD_COL_SIZE_HEIGHT_MASK = 0x1FFF0000,
+	EPDC_UPD_COL_SIZE_HEIGHT_OFFSET = 16,
+	EPDC_UPD_COL_SIZE_WIDTH_MASK = 0x1FFF,
+	EPDC_UPD_COL_SIZE_WIDTH_OFFSET = 0,
+
+	/* EPDC_DEBUG field values */
+	EPDC_DEBUG_UNDERRUN_RECOVER = 0x2,
+	EPDC_DEBUG_COLLISION_OFF = 0x1,
+
+/* EPDC_HISTx_PARAM field values */
+	EPDC_HIST_PARAM_VALUE0_MASK = 0x1F,
+	EPDC_HIST_PARAM_VALUE0_OFFSET = 0,
+	EPDC_HIST_PARAM_VALUE1_MASK = 0x1F00,
+	EPDC_HIST_PARAM_VALUE1_OFFSET = 8,
+	EPDC_HIST_PARAM_VALUE2_MASK = 0x1F0000,
+	EPDC_HIST_PARAM_VALUE2_OFFSET = 16,
+	EPDC_HIST_PARAM_VALUE3_MASK = 0x1F000000,
+	EPDC_HIST_PARAM_VALUE3_OFFSET = 24,
+	EPDC_HIST_PARAM_VALUE4_MASK = 0x1F,
+	EPDC_HIST_PARAM_VALUE4_OFFSET = 0,
+	EPDC_HIST_PARAM_VALUE5_MASK = 0x1F00,
+	EPDC_HIST_PARAM_VALUE5_OFFSET = 8,
+	EPDC_HIST_PARAM_VALUE6_MASK = 0x1F0000,
+	EPDC_HIST_PARAM_VALUE6_OFFSET = 16,
+	EPDC_HIST_PARAM_VALUE7_MASK = 0x1F000000,
+	EPDC_HIST_PARAM_VALUE7_OFFSET = 24,
+	EPDC_HIST_PARAM_VALUE8_MASK = 0x1F,
+	EPDC_HIST_PARAM_VALUE8_OFFSET = 0,
+	EPDC_HIST_PARAM_VALUE9_MASK = 0x1F00,
+	EPDC_HIST_PARAM_VALUE9_OFFSET = 8,
+	EPDC_HIST_PARAM_VALUE10_MASK = 0x1F0000,
+	EPDC_HIST_PARAM_VALUE10_OFFSET = 16,
+	EPDC_HIST_PARAM_VALUE11_MASK = 0x1F000000,
+	EPDC_HIST_PARAM_VALUE11_OFFSET = 24,
+	EPDC_HIST_PARAM_VALUE12_MASK = 0x1F,
+	EPDC_HIST_PARAM_VALUE12_OFFSET = 0,
+	EPDC_HIST_PARAM_VALUE13_MASK = 0x1F00,
+	EPDC_HIST_PARAM_VALUE13_OFFSET = 8,
+	EPDC_HIST_PARAM_VALUE14_MASK = 0x1F0000,
+	EPDC_HIST_PARAM_VALUE14_OFFSET = 16,
+	EPDC_HIST_PARAM_VALUE15_MASK = 0x1F000000,
+	EPDC_HIST_PARAM_VALUE15_OFFSET = 24,
+
+	/* EPDC_GPIO field values */
+	EPDC_GPIO_PWRCOM = 0x40,
+	EPDC_GPIO_PWRCTRL_MASK = 0x3c,
+	EPDC_GPIO_PWRCTRL_OFFSET = 2,
+	EPDC_GPIO_BDR_MASK = 0x3,
+	EPDC_GPIO_BDR_OFFSET = 0,
+
+	/* EPDC_VERSION field values */
+	EPDC_VERSION_MAJOR_MASK = 0xFF000000,
+	EPDC_VERSION_MAJOR_OFFSET = 24,
+	EPDC_VERSION_MINOR_MASK = 0xFF0000,
+	EPDC_VERSION_MINOR_OFFSET = 16,
+	EPDC_VERSION_STEP_MASK = 0xFFFF,
+	EPDC_VERSION_STEP_OFFSET = 0,
+};
+
+int setup_waveform_file(void);
+void epdc_power_on(void);
+void epdc_power_off(void);
+
+#endif
diff --git a/include/mxc_keyb.h b/include/mxc_keyb.h
new file mode 100644
index 0000000..eba8b77
--- /dev/null
+++ b/include/mxc_keyb.h
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2009-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/*!
+ * @defgroup keypad Keypad Driver
+ */
+
+/*!
+ * @file mxc_keyb.h
+ *
+ * @brief MXC keypad header file.
+ *
+ * @ingroup keypad
+ */
+#ifndef __MXC_KEYB_H__
+#define __MXC_KEYB_H__
+
+/*!
+ * Keypad Module Name
+ */
+#define MOD_NAME  "mxckpd"
+
+/*!
+ * Keypad irq number
+ */
+#define KPP_IRQ  MXC_INT_KPP
+
+/*!
+ * XLATE mode selection
+ */
+#define KEYPAD_XLATE        0
+
+/*!
+ * RAW mode selection
+ */
+#define KEYPAD_RAW          1
+
+/*!
+ * Maximum number of keys.
+ */
+#define MAXROW			8
+#define MAXCOL			8
+#define MXC_MAXKEY		(MAXROW * MAXCOL)
+
+/*!
+ * This define indicates break scancode for every key release. A constant
+ * of 128 is added to the key press scancode.
+ */
+#define  MXC_KEYRELEASE   128
+
+/*
+ * _reg_KPP_KPCR   _reg_KPP_KPSR _reg_KPP_KDDR _reg_KPP_KPDR
+ * Keypad Control Register Address
+ */
+#define KPCR    (KPP_BASE_ADDR + 0x00)
+
+/*
+ * Keypad Status Register Address
+ */
+#define KPSR    (KPP_BASE_ADDR + 0x02)
+
+/*
+ * Keypad Data Direction Address
+ */
+#define KDDR    (KPP_BASE_ADDR + 0x04)
+
+/*
+ * Keypad Data Register
+ */
+#define KPDR    (KPP_BASE_ADDR + 0x06)
+
+/*
+ * Key Press Interrupt Status bit
+ */
+#define KBD_STAT_KPKD        0x01
+
+/*
+ * Key Release Interrupt Status bit
+ */
+#define KBD_STAT_KPKR        0x02
+
+/*
+ * Key Depress Synchronizer Chain Status bit
+ */
+#define KBD_STAT_KDSC        0x04
+
+/*
+ * Key Release Synchronizer Status bit
+ */
+#define KBD_STAT_KRSS        0x08
+
+/*
+ * Key Depress Interrupt Enable Status bit
+ */
+#define KBD_STAT_KDIE        0x100
+
+/*
+ * Key Release Interrupt Enable
+ */
+#define KBD_STAT_KRIE        0x200
+
+/*
+ * Keypad Clock Enable
+ */
+#define KBD_STAT_KPPEN       0x400
+
+/*!
+ * Buffer size of keypad queue. Should be a power of 2.
+ */
+#define KPP_BUF_SIZE    128
+
+/*!
+ * Test whether bit is set for integer c
+ */
+#define TEST_BIT(c, n) ((c) & (0x1 << (n)))
+
+/*!
+ * Set nth bit in the integer c
+ */
+#define BITSET(c, n)   ((c) | (1 << (n)))
+
+/*!
+ * Reset nth bit in the integer c
+ */
+#define BITRESET(c, n) ((c) & ~(1 << (n)))
+
+enum KeyEvent {
+	KDepress,
+	KRelease
+};
+
+/*!
+ * This enum represents the keypad state machine to maintain debounce logic
+ * for key press/release.
+ */
+enum KeyState {
+
+	/*!
+	 * Key press state.
+	 */
+	KStateUp,
+
+	/*!
+	 * Key press debounce state.
+	 */
+	KStateFirstDown,
+
+	/*!
+	 * Key release state.
+	 */
+	KStateDown,
+
+	/*!
+	 * Key release debounce state.
+	 */
+	KStateFirstUp
+};
+
+/*!
+ * Keypad Private Data Structure
+ */
+struct keypad_priv {
+
+	/*!
+	 * Keypad state machine.
+	 */
+	enum KeyState iKeyState;
+
+	/*!
+	 * Number of rows configured in the keypad matrix
+	 */
+	unsigned long kpp_rows;
+
+	/*!
+	 * Number of Columns configured in the keypad matrix
+	 */
+	unsigned long kpp_cols;
+};
+
+/*!
+ * Keypad Data Structure
+ * */
+struct kpp_key_info {
+	enum KeyEvent evt;
+	unsigned short val;
+};
+
+int mxc_kpp_init(void);
+int mxc_kpp_getc(struct kpp_key_info **);
+
+/*!
+ * These functions are used to configure and the GPIO pins for keypad to
+ * activate and deactivate it.
+ */
+void setup_mxc_kpd(void);
+
+
+#endif				/* __MXC_KEYB_H__ */
diff --git a/include/mxsfb.h b/include/mxsfb.h
new file mode 100644
index 0000000..ddea7aa
--- /dev/null
+++ b/include/mxsfb.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __MXSFB_H__
+#define __MXSFB_H__
+
+#ifdef CONFIG_VIDEO_MXS
+struct display_panel {
+	unsigned int reg_base;
+	unsigned int width;
+	unsigned int height;
+	unsigned int gdfindex;
+	unsigned int gdfbytespp;
+};
+
+void mxs_lcd_get_panel(struct display_panel *panel);
+void lcdif_power_down(void);
+int mxs_lcd_panel_setup(struct fb_videomode mode, int bpp,
+	uint32_t base_addr);
+#endif
+
+#endif				/* __MXSFB_H__ */
diff --git a/include/net.h b/include/net.h
index 0802fad..b9951e1 100644
--- a/include/net.h
+++ b/include/net.h
@@ -643,7 +643,7 @@ static inline int is_zero_ether_addr(const u8 *addr)
  */
 static inline int is_multicast_ether_addr(const u8 *addr)
 {
-	return 0x01 & addr[0];
+	return addr[0] == 0x01;
 }
 
 /*
diff --git a/include/recovery.h b/include/recovery.h
new file mode 100644
index 0000000..1e0492a
--- /dev/null
+++ b/include/recovery.h
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __RECOVERY_H_
+#define __RECOVERY_H_
+
+struct reco_envs {
+	char *cmd;
+	char *args;
+};
+
+void check_recovery_mode(void);
+int recovery_check_and_clean_flag(void);
+int check_recovery_cmd_file(void);
+void board_recovery_setup(void);
+
+#endif
diff --git a/include/spartan3.h b/include/spartan3.h
index 72e7c0d..3535689 100644
--- a/include/spartan3.h
+++ b/include/spartan3.h
@@ -63,12 +63,6 @@ typedef struct {
 #define	XILINX_XC3S1200E_SIZE	3841184/8
 #define	XILINX_XC3S1600E_SIZE	5969696/8
 
-/*
- * Spartan-6 : the Spartan-6 family can be programmed
- * exactly as the Spartan-3
- */
-#define XILINK_XC6SLX4_SIZE	(3713568/8)
-
 /* Descriptor Macros
  *********************************************************************/
 /* Spartan-III devices */
@@ -112,7 +106,4 @@ typedef struct {
 #define XILINX_XC3S1600E_DESC(iface, fn_table, cookie) \
 { Xilinx_Spartan3, iface, XILINX_XC3S1600E_SIZE, fn_table, cookie }
 
-#define XILINX_XC6SLX4_DESC(iface, fn_table, cookie) \
-{ Xilinx_Spartan3, iface, XILINK_XC6SLX4_SIZE, fn_table, cookie }
-
 #endif /* _SPARTAN3_H_ */
diff --git a/include/spartan6.h b/include/spartan6.h
new file mode 100644
index 0000000..b8b2f73
--- /dev/null
+++ b/include/spartan6.h
@@ -0,0 +1,109 @@
+/*
+ * (C) Copyright 2011
+ * Daniel Dyer, Axent Global, daniel_dyer@axent.com.au
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SPARTAN6_H_
+#define _SPARTAN6_H_
+
+#include <xilinx.h>
+
+extern int Spartan6_load(Xilinx_desc *desc, const void *image, size_t size);
+extern int Spartan6_dump(Xilinx_desc *desc, const void *buf, size_t bsize);
+extern int Spartan6_info(Xilinx_desc *desc);
+
+/* Slave Parallel Implementation function table */
+typedef struct {
+	Xilinx_pre_fn	pre;
+	Xilinx_pgm_fn	pgm;
+	Xilinx_init_fn	init;
+	Xilinx_err_fn	err;
+	Xilinx_done_fn	done;
+	Xilinx_clk_fn	clk;
+	Xilinx_cs_fn	cs;
+	Xilinx_wr_fn	wr;
+	Xilinx_rdata_fn	rdata;
+	Xilinx_wdata_fn	wdata;
+	Xilinx_busy_fn	busy;
+	Xilinx_abort_fn	abort;
+	Xilinx_post_fn	post;
+} Xilinx_Spartan6_Slave_Parallel_fns;
+
+/* Slave Serial Implementation function table */
+typedef struct {
+	Xilinx_pre_fn	pre;
+	Xilinx_pgm_fn	pgm;
+	Xilinx_clk_fn	clk;
+	Xilinx_init_fn	init;
+	Xilinx_done_fn	done;
+	Xilinx_wr_fn	wr;
+	Xilinx_post_fn	post;
+	Xilinx_bwr_fn	bwr; /* block write function */
+	Xilinx_abort_fn abort;
+} Xilinx_Spartan6_Slave_Serial_fns;
+
+/* Device Image Sizes
+ *********************************************************************/
+/* Spartan-6 LX */
+#define XILINX_XC6SLX4_SIZE	    2724832/8
+#define XILINX_XC6SLX9_SIZE	    2724832/8
+#define XILINX_XC6SLX16_SIZE	3713568/8
+#define XILINX_XC6SLX25_SIZE	6411696/8
+#define XILINX_XC6SLX45_SIZE	11875232/8
+#define XILINX_XC6SLX75_SIZE	19624736/8
+#define XILINX_XC6SLX100_SIZE	26543264/8
+#define XILINX_XC6SLX150_SIZE	33761696/8
+
+/* Spartan-6 LXT */
+#define XILINX_XC6SLX25T_SIZE	6411696/8
+#define XILINX_XC6SLX45T_SIZE	11875232/8
+#define XILINX_XC6SLX75T_SIZE	19624736/8
+#define XILINX_XC6SLX100T_SIZE	26543264/8
+#define XILINX_XC6SLX150T_SIZE	33761696/8
+
+/* Descriptor Macros
+ *********************************************************************/
+/* Spartan-6 LX devices */
+#define XILINX_XC6SLX4_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX4_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX9_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX9_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX16_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX16_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX25_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX25_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX45_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX45_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX75_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX75_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX100_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX100_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX150_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX150_SIZE, fn_table, cookie }
+
+/* Spartan-6 LXT devices */
+#define XILINX_XC6SLX25T_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX25T_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX45T_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX45T_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX75T_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX75T_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX100T_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX100T_SIZE, fn_table, cookie }
+
+#define XILINX_XC6SLX150T_DESC(iface, fn_table, cookie) \
+{ Xilinx_Spartan6, iface, XILINX_XC6SLX150T_SIZE, fn_table, cookie }
+
+#endif /* _SPARTAN6_H_ */
diff --git a/include/usb/imx_udc.h b/include/usb/imx_udc.h
new file mode 100644
index 0000000..870405f
--- /dev/null
+++ b/include/usb/imx_udc.h
@@ -0,0 +1,573 @@
+/*
+ * Copyright (C) 2010-2014 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _IMX_UDC_H_
+#define _IMX_UDC_H_
+
+#include <usbdevice.h>
+
+#define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
+#define USB_H1REGS_BASE		(OTG_BASE_ADDR + 0x200)
+#define USB_H2REGS_BASE		(OTG_BASE_ADDR + 0x400)
+#if (defined CONFIG_MX51 || defined CONFIG_MX50 || defined CONFIG_MX6Q \
+     || defined CONFIG_MX53 || defined CONFIG_MX6DL || defined CONFIG_MX6SL)
+#define USB_H3REGS_BASE		(OTG_BASE_ADDR + 0x600)
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x800)
+#else
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x600)
+#endif
+
+#define USBOTG_REG32(offset)	(USB_OTGREGS_BASE + (offset))
+#define USBOTG_REG16(offset)	(USB_OTGREGS_BASE + (offset))
+#define USBOTHER_REG(offset)	(USB_OTHERREGS_BASE + (offset))
+
+#define USB_ID               (OTG_BASE_ADDR + 0x0000)
+#define USB_HWGENERAL        (OTG_BASE_ADDR + 0x0004)
+#define USB_HWHOST           (OTG_BASE_ADDR + 0x0008)
+#define USB_HWDEVICE         (OTG_BASE_ADDR + 0x000C)
+#define USB_HWTXBUF          (OTG_BASE_ADDR + 0x0010)
+#define USB_HWRXBUF          (OTG_BASE_ADDR + 0x0014)
+#define USB_SBUSCFG          (OTG_BASE_ADDR + 0x0090)
+
+#define USB_CAPLENGTH        (OTG_BASE_ADDR + 0x0100) /* 8 bit */
+#define USB_HCIVERSION       (OTG_BASE_ADDR + 0x0102) /* 16 bit */
+#define USB_HCSPARAMS        (OTG_BASE_ADDR + 0x0104)
+#define USB_HCCPARAMS        (OTG_BASE_ADDR + 0x0108)
+#define USB_DCIVERSION       (OTG_BASE_ADDR + 0x0120) /* 16 bit */
+#define USB_DCCPARAMS        (OTG_BASE_ADDR + 0x0124)
+#define USB_USBCMD           (OTG_BASE_ADDR + 0x0140)
+#define USB_USBSTS           (OTG_BASE_ADDR + 0x0144)
+#define USB_USBINTR          (OTG_BASE_ADDR + 0x0148)
+#define USB_FRINDEX          (OTG_BASE_ADDR + 0x014C)
+#define USB_DEVICEADDR       (OTG_BASE_ADDR + 0x0154)
+#define USB_ENDPOINTLISTADDR (OTG_BASE_ADDR + 0x0158)
+#define USB_BURSTSIZE        (OTG_BASE_ADDR + 0x0160)
+#define USB_TXFILLTUNING     (OTG_BASE_ADDR + 0x0164)
+#define USB_ULPI_VIEWPORT    (OTG_BASE_ADDR + 0x0170)
+#define USB_ENDPTNAK         (OTG_BASE_ADDR + 0x0178)
+#define USB_ENDPTNAKEN       (OTG_BASE_ADDR + 0x017C)
+#define USB_PORTSC1          (OTG_BASE_ADDR + 0x0184)
+#define USB_OTGSC            (OTG_BASE_ADDR + 0x01A4)
+#define USB_USBMODE          (OTG_BASE_ADDR + 0x01A8)
+#define USB_ENDPTSETUPSTAT   (OTG_BASE_ADDR + 0x01AC)
+#define USB_ENDPTPRIME       (OTG_BASE_ADDR + 0x01B0)
+#define USB_ENDPTFLUSH       (OTG_BASE_ADDR + 0x01B4)
+#define USB_ENDPTSTAT        (OTG_BASE_ADDR + 0x01B8)
+#define USB_ENDPTCOMPLETE    (OTG_BASE_ADDR + 0x01BC)
+#define USB_ENDPTCTRL(n)     (OTG_BASE_ADDR + 0x01C0 + (4 * (n)))
+
+/*
+ * other regs (not part of ARC core)
+ */
+/* USB Control register */
+#define USBCTRL			USBOTHER_REG(0x00)
+
+/* USB OTG mirror register */
+#define USB_OTG_MIRROR		USBOTHER_REG(0x04)
+
+/* OTG UTMI PHY Function Control register */
+#define USB_PHY_CTR_FUNC	USBOTHER_REG(0x08)
+
+/* OTG UTMI PHY Function Control register */
+#define USB_PHY_CTR_FUNC2	USBOTHER_REG(0x0c)
+
+#define USB_CTRL_1		USBOTHER_REG(0x10)
+#define USBCTRL_HOST2		USBOTHER_REG(0x14)	/* USB Cotrol Register 1*/
+#define USBCTRL_HOST3		USBOTHER_REG(0x18)	/* USB Cotrol Register 1*/
+#define USBH1_PHY_CTRL0		USBOTHER_REG(0x1c)	/* USB Cotrol Register 1*/
+#define USBH1_PHY_CTRL1		USBOTHER_REG(0x20)	/* USB Cotrol Register 1*/
+
+/* USB Clock on/off Control Register */
+#define USB_CLKONOFF_CTRL       USBOTHER_REG(0x24)
+
+/* mx6x other regs */
+/* USB OTG Control register */
+#define USB_OTG_CTRL			USBOTHER_REG(0x00)
+
+/* USB H1 Control register */
+#define USB_H1_CTRL			USBOTHER_REG(0x04)
+
+/* USB H2 Control register */
+#define USB_H2_CTRL			USBOTHER_REG(0x08)
+
+/* USB H3 Control register */
+#define USB_H3_CTRL			USBOTHER_REG(0x0c)
+
+/* USB Host2 HSIC Control Register */
+#define USB_UH2_HSIC_CTRL		USBOTHER_REG(0x10)
+
+/* USB Host3 HSIC Control Register */
+#define USB_UH3_HSIC_CTRL		USBOTHER_REG(0x14)
+
+/* OTG UTMI PHY Control 0 Register */
+#define USB_OTG_PHY_CTRL_0		USBOTHER_REG(0x18)
+
+/* OTG UTMI PHY Control 1 Register */
+#define USB_H1_PHY_CTRL_0		USBOTHER_REG(0x1c)
+
+/* USB Host2 HSIC DLL Configuration Register 1 */
+#define USB_UH2_HSIC_DLL_CFG1		USBOTHER_REG(0x20)
+
+/* USB Host2 HSIC DLL Configuration Register 2 */
+#define USB_UH2_HSIC_DLL_CFG2		USBOTHER_REG(0x24)
+
+/* USB Host2 HSIC DLL Configuration Register 3 */
+#define USB_UH2_HSIC_DLL_CFG3		USBOTHER_REG(0x28)
+
+/* USB Host3 HSIC DLL Configuration Register 1 */
+#define USB_UH3_HSIC_DLL_CFG1		USBOTHER_REG(0x30)
+
+/* USB Host3 HSIC DLL Configuration Register 2 */
+#define USB_UH3_HSIC_DLL_CFG2		USBOTHER_REG(0x34)
+
+/* USB Host3 HSIC DLL Configuration Register 3 */
+#define USB_UH3_HSIC_DLL_CFG3		USBOTHER_REG(0x38)
+
+
+#define USB_PHY1_CTRL        (OTG_BASE_ADDR + 0x80C)
+#define USBCMD_RESET   2
+#define USBCMD_ATTACH  1
+
+#define USBMODE_DEVICE 2
+#define USBMODE_HOST   3
+
+struct ep_queue_head {
+	volatile unsigned int config;
+	volatile unsigned int current; /* read-only */
+
+	volatile unsigned int next_queue_item;
+	volatile unsigned int info;
+	volatile unsigned int page0;
+	volatile unsigned int page1;
+	volatile unsigned int page2;
+	volatile unsigned int page3;
+	volatile unsigned int page4;
+	volatile unsigned int reserved_0;
+
+	volatile unsigned char setup_data[8];
+	volatile unsigned int reserved[4];
+};
+
+#define CONFIG_MAX_PKT(n)     ((n) << 16)
+#define CONFIG_ZLT            (1 << 29)    /* stop on zero-len xfer */
+#define CONFIG_IOS            (1 << 15)    /* IRQ on setup */
+
+struct ep_queue_item {
+	volatile unsigned int next_item_ptr;
+	volatile unsigned int info;
+	volatile unsigned int page0;
+	volatile unsigned int page1;
+	volatile unsigned int page2;
+	volatile unsigned int page3;
+	volatile unsigned int page4;
+	unsigned int item_unaligned_addr;
+	unsigned int page_vir;
+	unsigned int page_unaligned;
+	struct ep_queue_item *next_item_vir;
+	volatile unsigned int reserved[5];
+};
+
+#define TERMINATE 1
+
+#define INFO_BYTES(n)         ((n) << 16)
+#define INFO_IOC              (1 << 15)
+#define INFO_ACTIVE           (1 << 7)
+#define INFO_HALTED           (1 << 6)
+#define INFO_BUFFER_ERROR     (1 << 5)
+#define INFO_TX_ERROR         (1 << 3)
+
+/* Device Controller Capability Parameter register */
+#define DCCPARAMS_DC				0x00000080
+#define DCCPARAMS_DEN_MASK			0x0000001f
+
+/* Frame Index Register Bit Masks */
+#define	USB_FRINDEX_MASKS			(0x3fff)
+/* USB CMD  Register Bit Masks */
+#define  USB_CMD_RUN_STOP                     (0x00000001)
+#define  USB_CMD_CTRL_RESET                   (0x00000002)
+#define  USB_CMD_PERIODIC_SCHEDULE_EN         (0x00000010)
+#define  USB_CMD_ASYNC_SCHEDULE_EN            (0x00000020)
+#define  USB_CMD_INT_AA_DOORBELL              (0x00000040)
+#define  USB_CMD_ASP                          (0x00000300)
+#define  USB_CMD_ASYNC_SCH_PARK_EN            (0x00000800)
+#define  USB_CMD_SUTW                         (0x00002000)
+#define  USB_CMD_ATDTW                        (0x00004000)
+#define  USB_CMD_ITC                          (0x00FF0000)
+
+/* bit 15,3,2 are frame list size */
+#define  USB_CMD_FRAME_SIZE_1024              (0x00000000)
+#define  USB_CMD_FRAME_SIZE_512               (0x00000004)
+#define  USB_CMD_FRAME_SIZE_256               (0x00000008)
+#define  USB_CMD_FRAME_SIZE_128               (0x0000000C)
+#define  USB_CMD_FRAME_SIZE_64                (0x00008000)
+#define  USB_CMD_FRAME_SIZE_32                (0x00008004)
+#define  USB_CMD_FRAME_SIZE_16                (0x00008008)
+#define  USB_CMD_FRAME_SIZE_8                 (0x0000800C)
+
+/* bit 9-8 are async schedule park mode count */
+#define  USB_CMD_ASP_00                       (0x00000000)
+#define  USB_CMD_ASP_01                       (0x00000100)
+#define  USB_CMD_ASP_10                       (0x00000200)
+#define  USB_CMD_ASP_11                       (0x00000300)
+#define  USB_CMD_ASP_BIT_POS                  (8)
+
+/* bit 23-16 are interrupt threshold control */
+#define  USB_CMD_ITC_NO_THRESHOLD             (0x00000000)
+#define  USB_CMD_ITC_1_MICRO_FRM              (0x00010000)
+#define  USB_CMD_ITC_2_MICRO_FRM              (0x00020000)
+#define  USB_CMD_ITC_4_MICRO_FRM              (0x00040000)
+#define  USB_CMD_ITC_8_MICRO_FRM              (0x00080000)
+#define  USB_CMD_ITC_16_MICRO_FRM             (0x00100000)
+#define  USB_CMD_ITC_32_MICRO_FRM             (0x00200000)
+#define  USB_CMD_ITC_64_MICRO_FRM             (0x00400000)
+#define  USB_CMD_ITC_BIT_POS                  (16)
+
+/* USB STS Register Bit Masks */
+#define  USB_STS_INT                          (0x00000001)
+#define  USB_STS_ERR                          (0x00000002)
+#define  USB_STS_PORT_CHANGE                  (0x00000004)
+#define  USB_STS_FRM_LST_ROLL                 (0x00000008)
+#define  USB_STS_SYS_ERR                      (0x00000010)
+#define  USB_STS_IAA                          (0x00000020)
+#define  USB_STS_RESET                        (0x00000040)
+#define  USB_STS_SOF                          (0x00000080)
+#define  USB_STS_SUSPEND                      (0x00000100)
+#define  USB_STS_HC_HALTED                    (0x00001000)
+#define  USB_STS_RCL                          (0x00002000)
+#define  USB_STS_PERIODIC_SCHEDULE            (0x00004000)
+#define  USB_STS_ASYNC_SCHEDULE               (0x00008000)
+
+/* USB INTR Register Bit Masks */
+#define  USB_INTR_INT_EN                      (0x00000001)
+#define  USB_INTR_ERR_INT_EN                  (0x00000002)
+#define  USB_INTR_PTC_DETECT_EN               (0x00000004)
+#define  USB_INTR_FRM_LST_ROLL_EN             (0x00000008)
+#define  USB_INTR_SYS_ERR_EN                  (0x00000010)
+#define  USB_INTR_ASYN_ADV_EN                 (0x00000020)
+#define  USB_INTR_RESET_EN                    (0x00000040)
+#define  USB_INTR_SOF_EN                      (0x00000080)
+#define  USB_INTR_DEVICE_SUSPEND              (0x00000100)
+
+/* Device Address bit masks */
+#define  USB_DEVICE_ADDRESS_MASK              (0xFE000000)
+#define  USB_DEVICE_ADDRESS_BIT_POS           (25)
+
+/* endpoint list address bit masks */
+#define USB_EP_LIST_ADDRESS_MASK              (0xfffff800)
+
+/* PORTSCX  Register Bit Masks */
+#define  PORTSCX_CURRENT_CONNECT_STATUS       (0x00000001)
+#define  PORTSCX_CONNECT_STATUS_CHANGE        (0x00000002)
+#define  PORTSCX_PORT_ENABLE                  (0x00000004)
+#define  PORTSCX_PORT_EN_DIS_CHANGE           (0x00000008)
+#define  PORTSCX_OVER_CURRENT_ACT             (0x00000010)
+#define  PORTSCX_OVER_CURRENT_CHG             (0x00000020)
+#define  PORTSCX_PORT_FORCE_RESUME            (0x00000040)
+#define  PORTSCX_PORT_SUSPEND                 (0x00000080)
+#define  PORTSCX_PORT_RESET                   (0x00000100)
+#define  PORTSCX_LINE_STATUS_BITS             (0x00000C00)
+#define  PORTSCX_PORT_POWER                   (0x00001000)
+#define  PORTSCX_PORT_INDICTOR_CTRL           (0x0000C000)
+#define  PORTSCX_PORT_TEST_CTRL               (0x000F0000)
+#define  PORTSCX_WAKE_ON_CONNECT_EN           (0x00100000)
+#define  PORTSCX_WAKE_ON_CONNECT_DIS          (0x00200000)
+#define  PORTSCX_WAKE_ON_OVER_CURRENT         (0x00400000)
+#define  PORTSCX_PHY_LOW_POWER_SPD            (0x00800000)
+#define  PORTSCX_PORT_FORCE_FULL_SPEED        (0x01000000)
+#define  PORTSCX_PORT_SPEED_MASK              (0x0C000000)
+#define  PORTSCX_PORT_WIDTH                   (0x10000000)
+#define  PORTSCX_PHY_TYPE_SEL                 (0xC0000000)
+
+/* bit 11-10 are line status */
+#define  PORTSCX_LINE_STATUS_SE0              (0x00000000)
+#define  PORTSCX_LINE_STATUS_JSTATE           (0x00000400)
+#define  PORTSCX_LINE_STATUS_KSTATE           (0x00000800)
+#define  PORTSCX_LINE_STATUS_UNDEF            (0x00000C00)
+#define  PORTSCX_LINE_STATUS_BIT_POS          (10)
+
+/* bit 15-14 are port indicator control */
+#define  PORTSCX_PIC_OFF                      (0x00000000)
+#define  PORTSCX_PIC_AMBER                    (0x00004000)
+#define  PORTSCX_PIC_GREEN                    (0x00008000)
+#define  PORTSCX_PIC_UNDEF                    (0x0000C000)
+#define  PORTSCX_PIC_BIT_POS                  (14)
+
+/* bit 19-16 are port test control */
+#define  PORTSCX_PTC_DISABLE                  (0x00000000)
+#define  PORTSCX_PTC_JSTATE                   (0x00010000)
+#define  PORTSCX_PTC_KSTATE                   (0x00020000)
+#define  PORTSCX_PTC_SEQNAK                   (0x00030000)
+#define  PORTSCX_PTC_PACKET                   (0x00040000)
+#define  PORTSCX_PTC_FORCE_EN                 (0x00050000)
+#define  PORTSCX_PTC_BIT_POS                  (16)
+
+/* bit 27-26 are port speed */
+#define  PORTSCX_PORT_SPEED_FULL              (0x00000000)
+#define  PORTSCX_PORT_SPEED_LOW               (0x04000000)
+#define  PORTSCX_PORT_SPEED_HIGH              (0x08000000)
+#define  PORTSCX_PORT_SPEED_UNDEF             (0x0C000000)
+#define  PORTSCX_SPEED_BIT_POS                (26)
+
+/* OTGSC Register Bit Masks */
+#define  OTGSC_B_SESSION_VALID_IRQ_EN           (1 << 27)
+#define  OTGSC_B_SESSION_VALID_IRQ_STS          (1 << 19)
+#define  OTGSC_B_SESSION_VALID                  (1 << 11)
+
+/* bit 28 is parallel transceiver width for UTMI interface */
+#define  PORTSCX_PTW                          (0x10000000)
+#define  PORTSCX_PTW_8BIT                     (0x00000000)
+#define  PORTSCX_PTW_16BIT                    (0x10000000)
+
+/* bit 31-30 are port transceiver select */
+#define  PORTSCX_PTS_UTMI                     (0x00000000)
+#define  PORTSCX_PTS_ULPI                     (0x80000000)
+#define  PORTSCX_PTS_FSLS                     (0xC0000000)
+#define  PORTSCX_PTS_BIT_POS                  (30)
+
+/* USB MODE Register Bit Masks */
+#define  USB_MODE_CTRL_MODE_IDLE              (0x00000000)
+#define  USB_MODE_CTRL_MODE_DEVICE            (0x00000002)
+#define  USB_MODE_CTRL_MODE_HOST              (0x00000003)
+#define  USB_MODE_CTRL_MODE_MASK              0x00000003
+#define  USB_MODE_CTRL_MODE_RSV               (0x00000001)
+#define  USB_MODE_ES                          0x00000004 /* (big) Endian Sel */
+#define  USB_MODE_SETUP_LOCK_OFF              (0x00000008)
+#define  USB_MODE_STREAM_DISABLE              (0x00000010)
+/* Endpoint Flush Register */
+#define EPFLUSH_TX_OFFSET		      (0x00010000)
+#define EPFLUSH_RX_OFFSET		      (0x00000000)
+
+/* Endpoint Setup Status bit masks */
+#define  EP_SETUP_STATUS_MASK                 (0x0000003F)
+#define  EP_SETUP_STATUS_EP0		      (0x00000001)
+
+/* ENDPOINTCTRLx  Register Bit Masks */
+#define  EPCTRL_TX_ENABLE                     (0x00800000)
+#define  EPCTRL_TX_DATA_TOGGLE_RST            (0x00400000)	/* Not EP0 */
+#define  EPCTRL_TX_DATA_TOGGLE_INH            (0x00200000)	/* Not EP0 */
+#define  EPCTRL_TX_TYPE                       (0x000C0000)
+#define  EPCTRL_TX_DATA_SOURCE                (0x00020000)	/* Not EP0 */
+#define  EPCTRL_TX_EP_STALL                   (0x00010000)
+#define  EPCTRL_RX_ENABLE                     (0x00000080)
+#define  EPCTRL_RX_DATA_TOGGLE_RST            (0x00000040)	/* Not EP0 */
+#define  EPCTRL_RX_DATA_TOGGLE_INH            (0x00000020)	/* Not EP0 */
+#define  EPCTRL_RX_TYPE                       (0x0000000C)
+#define  EPCTRL_RX_DATA_SINK                  (0x00000002)	/* Not EP0 */
+#define  EPCTRL_RX_EP_STALL                   (0x00000001)
+
+/* bit 19-18 and 3-2 are endpoint type */
+#define  EPCTRL_EP_TYPE_CONTROL               (0)
+#define  EPCTRL_EP_TYPE_ISO                   (1)
+#define  EPCTRL_EP_TYPE_BULK                  (2)
+#define  EPCTRL_EP_TYPE_INTERRUPT             (3)
+#define  EPCTRL_TX_EP_TYPE_SHIFT              (18)
+#define  EPCTRL_RX_EP_TYPE_SHIFT              (2)
+
+/* SNOOPn Register Bit Masks */
+#define  SNOOP_ADDRESS_MASK                   (0xFFFFF000)
+#define  SNOOP_SIZE_ZERO                      (0x00)	/* snooping disable */
+#define  SNOOP_SIZE_4KB                       (0x0B)	/* 4KB snoop size */
+#define  SNOOP_SIZE_8KB                       (0x0C)
+#define  SNOOP_SIZE_16KB                      (0x0D)
+#define  SNOOP_SIZE_32KB                      (0x0E)
+#define  SNOOP_SIZE_64KB                      (0x0F)
+#define  SNOOP_SIZE_128KB                     (0x10)
+#define  SNOOP_SIZE_256KB                     (0x11)
+#define  SNOOP_SIZE_512KB                     (0x12)
+#define  SNOOP_SIZE_1MB                       (0x13)
+#define  SNOOP_SIZE_2MB                       (0x14)
+#define  SNOOP_SIZE_4MB                       (0x15)
+#define  SNOOP_SIZE_8MB                       (0x16)
+#define  SNOOP_SIZE_16MB                      (0x17)
+#define  SNOOP_SIZE_32MB                      (0x18)
+#define  SNOOP_SIZE_64MB                      (0x19)
+#define  SNOOP_SIZE_128MB                     (0x1A)
+#define  SNOOP_SIZE_256MB                     (0x1B)
+#define  SNOOP_SIZE_512MB                     (0x1C)
+#define  SNOOP_SIZE_1GB                       (0x1D)
+#define  SNOOP_SIZE_2GB                       (0x1E)	/* 2GB snoop size */
+
+/* pri_ctrl Register Bit Masks */
+#define  PRI_CTRL_PRI_LVL1                    (0x0000000C)
+#define  PRI_CTRL_PRI_LVL0                    (0x00000003)
+
+/* si_ctrl Register Bit Masks */
+#define  SI_CTRL_ERR_DISABLE                  (0x00000010)
+#define  SI_CTRL_IDRC_DISABLE                 (0x00000008)
+#define  SI_CTRL_RD_SAFE_EN                   (0x00000004)
+#define  SI_CTRL_RD_PREFETCH_DISABLE          (0x00000002)
+#define  SI_CTRL_RD_PREFEFETCH_VAL            (0x00000001)
+
+/* control Register Bit Masks */
+#define  USB_CTRL_IOENB                       (0x00000004)
+#define  USB_CTRL_ULPI_INT0EN                 (0x00000001)
+#define  USB_CTRL_OTG_WUIR                   (0x80000000)
+#define  USB_CTRL_OTG_WUIE                   (0x08000000)
+#define  USB_CTRL_OTG_VWUE			(0x00001000)
+#define  USB_CTRL_OTG_IWUE			(0x00100000)
+
+
+
+#define INTR_UE		      (1 << 0)
+#define INTR_UEE	      (1 << 1)
+#define INTR_PCE	      (1 << 2)
+#define INTR_SEE	      (1 << 4)
+#define INTR_URE	      (1 << 6)
+#define INTR_SRE	      (1 << 7)
+#define INTR_SLE	      (1 << 8)
+
+
+/* bits used in all the endpoint status registers */
+#define EPT_TX(n) (1 << ((n) + 16))
+#define EPT_RX(n) (1 << (n))
+
+
+#define CTRL_TXE              (1 << 23)
+#define CTRL_TXR              (1 << 22)
+#define CTRL_TXI              (1 << 21)
+#define CTRL_TXD              (1 << 17)
+#define CTRL_TXS              (1 << 16)
+#define CTRL_RXE              (1 << 7)
+#define CTRL_RXR              (1 << 6)
+#define CTRL_RXI              (1 << 5)
+#define CTRL_RXD              (1 << 1)
+#define CTRL_RXS              (1 << 0)
+
+#define CTRL_TXT_CTRL         (0 << 18)
+#define CTRL_TXT_ISOCH        (1 << 18)
+#define CTRL_TXT_BULK         (2 << 18)
+#define CTRL_TXT_INT          (3 << 18)
+
+#define CTRL_RXT_CTRL         (0 << 2)
+#define CTRL_RXT_ISOCH        (1 << 2)
+#define CTRL_RXT_BULK         (2 << 2)
+#define CTRL_RXT_INT          (3 << 2)
+
+#define USB_RECV 0
+#define USB_SEND 1
+#define USB_MAX_CTRL_PAYLOAD 64
+
+/* UDC device defines */
+#define EP0_MAX_PACKET_SIZE     USB_MAX_CTRL_PAYLOAD
+#define UDC_OUT_ENDPOINT        0x02
+#define UDC_OUT_PACKET_SIZE     USB_MAX_CTRL_PAYLOAD
+#define UDC_IN_ENDPOINT         0x03
+#define UDC_IN_PACKET_SIZE      USB_MAX_CTRL_PAYLOAD
+#define UDC_INT_ENDPOINT        0x01
+#define UDC_INT_PACKET_SIZE     USB_MAX_CTRL_PAYLOAD
+#define UDC_BULK_PACKET_SIZE    USB_MAX_CTRL_PAYLOAD
+
+/* mx6q's register bit begins*/
+
+/* OTG CTRL - H3 CTRL */
+#define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
+/* bit 18 - bit 30 is reserved at mx6q */
+#define UCTRL_WKUP_VBUS_EN	(1 << 17)	/* OTG wake-up on VBUS change enable */
+#define UCTRL_WKUP_ID_EN	(1 << 16)	/* OTG wake-up on ID change enable */
+#define UCTRL_WKUP_SW		(1 << 15)	/* OTG Software Wake-up */
+#define UCTRL_WKUP_SW_EN	(1 << 14)	/* OTG Software Wake-up enable */
+#define UCTRL_UTMI_ON_CLOCK	(1 << 13)	/* Force OTG UTMI PHY clock output
+										     on even if suspend mode */
+#define UCTRL_SUSPENDM		(1 << 12)	/* Force OTG UTMI PHY Suspend */
+#define UCTRL_RESET		(1 << 11)	/* Force OTG UTMI PHY Reset */
+#define UCTRL_OWIE		(1 << 10)	/* OTG wakeup intr request received */
+#define UCTRL_PM		(1 << 9)	/* OTG Power Mask */
+#define UCTRL_OVER_CUR_POL	(1 << 8)	/* OTG Polarity of Overcurrent */
+#define UCTRL_OVER_CUR_DIS	(1 << 7)	/* Disable OTG Overcurrent Detection */
+/* bit 0 - bit 6 is reserved at mx6q */
+
+/* Host2/3 HSIC Ctrl */
+#define CLK_VLD		(1 << 31)	/* Indicating whether HSIC clock is valid */
+#define HSIC_EN		(1 << 12)	/* HSIC enable */
+#define HSIC_CLK_ON		(1 << 11)	/* Force HSIC module 480M clock on,
+						 * even when in Host is in suspend mode
+						 */
+/* OTG/HOST1 Phy Ctrl */
+#define PHY_UTMI_CLK_VLD	(1 << 31)/* Indicating whether OTG UTMI PHY Clock Valid*/
+
+int  udc_init(void);
+
+void udc_enable(struct usb_device_instance *device);
+void udc_disable(void);
+
+void udc_connect(void);
+void udc_disconnect(void);
+
+void udc_startup_events(struct usb_device_instance *device);
+void udc_setup_ep(struct usb_device_instance *device,
+	unsigned int ep, struct usb_endpoint_instance *endpoint);
+int udc_endpoint_write(struct usb_endpoint_instance *epi);
+void udc_irq(void);
+void usb_shutdown(void);
+void mxc_udc_rxqueue_update(u8 ep, u32 len);
+int is_usb_disconnected(void);
+void reset_usb_phy1(void);
+void set_usboh3_clk(void);
+void set_usb_phy1_clk(void);
+void enable_usb_phy1_clk(unsigned char enable);
+void enable_usboh3_clk(unsigned char enable);
+void udc_pins_setting(void);
+
+/*destroy functions*/
+void udc_destroy_ep(struct usb_device_instance *device,
+		    struct usb_endpoint_instance *epi);
+int udc_destroy(void);
+
+
+#ifdef CONFIG_FASTBOOT
+
+#define EP0_OUT_INDEX    0
+#define EP0_IN_INDEX    16
+#define EP1_OUT_INDEX    1
+#define EP1_IN_INDEX    17
+#define EP2_OUT_INDEX    2
+#define EP2_IN_INDEX    18
+#define EP3_OUT_INDEX    3
+#define EP3_IN_INDEX    19
+#define EP4_OUT_INDEX    4
+#define EP4_IN_INDEX    20
+#define EP5_OUT_INDEX    5
+#define EP5_IN_INDEX    21
+#define EP6_OUT_INDEX    6
+#define EP6_IN_INDEX    22
+#define EP7_OUT_INDEX    7
+#define EP7_IN_INDEX    23
+#define EP8_OUT_INDEX    8
+#define EP8_IN_INDEX    24
+#define EP9_OUT_INDEX    9
+#define EP9_IN_INDEX    25
+#define EP10_OUT_INDEX  10
+#define EP10_IN_INDEX   26
+#define EP11_OUT_INDEX  11
+#define EP11_IN_INDEX   27
+#define EP12_OUT_INDEX  12
+#define EP12_IN_INDEX   28
+#define EP13_OUT_INDEX  13
+#define EP13_IN_INDEX   29
+#define EP14_OUT_INDEX  14
+#define EP14_IN_INDEX   30
+#define EP15_OUT_INDEX  15
+#define EP15_IN_INDEX   31
+
+#define MAX_PAKET_LEN 512
+typedef void (*EP_HANDLER_P)(u32 index, u8 *buf);
+
+int  udc_irq_handler(void);
+void udc_hal_data_init(void);
+void udc_wait_connect(void);
+void udc_run(void);
+int  udc_recv_data(u32 index, u8 *recvbuf, u32 recvlen, EP_HANDLER_P cb);
+int  udc_send_data(u32 index, u8 *buf, u32 sendlen, EP_HANDLER_P cb);
+void udc_qh_dtd_init(u32 index);
+void udc_dtd_setup(u32 index, u8 ep_type);
+void udc_qh_setup(u32 index, u8 ep_type, u32 max_pkt_len, u32 zlt, u8 mult);
+u8  *udc_get_descriptor(u8 type, u8 *plen);
+void udc_set_addr(u8 addr);
+void udc_set_configure(u8 config);
+
+#endif  /* CONFIG_FASTBOOT */
+
+#endif
diff --git a/include/xilinx.h b/include/xilinx.h
index 00a585e..0d8be36 100644
--- a/include/xilinx.h
+++ b/include/xilinx.h
@@ -30,6 +30,7 @@ typedef enum {			/* typedef Xilinx_Family */
 	Xilinx_VirtexE,		/* Virtex-E Family */
 	Xilinx_Virtex2,		/* Virtex2 Family */
 	Xilinx_Spartan3,	/* Spartan-III Family */
+	Xilinx_Spartan6,	/* Spartan-6 Family */
 	xilinx_zynq,		/* Zynq Family */
 	max_xilinx_type		/* insert all new types before this */
 } Xilinx_Family;		/* end, typedef Xilinx_Family */
diff --git a/tools/Makefile b/tools/Makefile
index 097cc1d..5ceb926 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -154,18 +154,14 @@ LOGO-$(CONFIG_VIDEO_LOGO) += $(LOGO_DATA_H)
 
 # Generic logo
 ifeq ($(LOGO_BMP),)
-LOGO_BMP= $(srctree)/$(src)/logos/denx.bmp
-
-# Use board logo and fallback to vendor
-ifneq ($(wildcard $(srctree)/$(src)/logos/$(BOARD).bmp),)
-LOGO_BMP= $(srctree)/$(src)/logos/$(BOARD).bmp
-else
-ifneq ($(wildcard $(srctree)/$(src)/logos/$(VENDOR).bmp),)
-LOGO_BMP= $(srctree)/$(src)/logos/$(VENDOR).bmp
+LOGO_BMP= $(srctree)/$(src)/logos/logo.bmp
 endif
+ifeq ($(VENDOR),atmel)
+LOGO_BMP= $(srctree)/$(src)/logos/atmel.bmp
+endif
+ifeq ($(VENDOR),esd)
+LOGO_BMP= $(srctree)/$(src)/logos/esd.bmp
 endif
-
-endif # !LOGO_BMP
 
 #
 # Use native tools and options
@@ -183,10 +179,10 @@ HOST_EXTRACFLAGS += -include $(srctree)/include/libfdt_env.h \
 
 __build:	$(LOGO-y)
 
-$(LOGO_H):	$(obj)/bmp_logo $(LOGO_BMP)
+$(LOGO_H):	$(obj)/bmp_logo
 	$(obj)/bmp_logo --gen-info $(LOGO_BMP) > $@
 
-$(LOGO_DATA_H):	$(obj)/bmp_logo $(LOGO_BMP)
+$(LOGO_DATA_H):	$(obj)/bmp_logo
 	$(obj)/bmp_logo --gen-data $(LOGO_BMP) > $@
 
 # Let clean descend into subdirs
diff --git a/tools/imximage.c b/tools/imximage.c
index 18dc051..c615d57 100644
--- a/tools/imximage.c
+++ b/tools/imximage.c
@@ -6,6 +6,8 @@
  * Marvell Semiconductor <www.marvell.com>
  * Written-by: Prafulla Wadaskar <prafulla@marvell.com>
  *
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
@@ -24,6 +26,9 @@ static table_entry_t imximage_cmds[] = {
 	{CMD_DATA,              "DATA",                 "Reg Write Data", },
 	{CMD_CSF,               "CSF",           "Command Sequence File", },
 	{CMD_IMAGE_VERSION,     "IMAGE_VERSION",        "image version",  },
+#ifdef CONFIG_USE_PLUGIN
+	{CMD_PLUGIN,            "PLUGIN",               "file plugin_addr",  },
+#endif
 	{-1,                    "",                     "",	          },
 };
 
@@ -38,6 +43,7 @@ static table_entry_t imximage_boot_offset[] = {
 	{FLASH_OFFSET_SATA,	"sata",		"SATA Disk",	},
 	{FLASH_OFFSET_SD,	"sd",		"SD Card",	},
 	{FLASH_OFFSET_SPI,	"spi",		"SPI Flash",	},
+	{FLASH_OFFSET_QSPI, "qspi",     "QSPI Flash",   },
 	{-1,			"",		"Invalid",	},
 };
 
@@ -52,6 +58,7 @@ static table_entry_t imximage_boot_loadsize[] = {
 	{FLASH_LOADSIZE_SATA,		"sata",		"SATA Disk",	},
 	{FLASH_LOADSIZE_SD,		"sd",		"SD Card",	},
 	{FLASH_LOADSIZE_SPI,		"spi",		"SPI Flash",	},
+	{FLASH_LOADSIZE_QSPI,		"qspi",		"QSPI Flash",	},
 	{-1,				"",		"Invalid",	},
 };
 
@@ -75,6 +82,8 @@ static uint32_t imximage_ivt_offset = UNDEFINED;
 static uint32_t imximage_csf_size = UNDEFINED;
 /* Initial Load Region Size */
 static uint32_t imximage_init_loadsize;
+static uint32_t imximage_iram_free_start;
+static uint32_t imximage_plugin_size;
 
 static set_dcd_val_t set_dcd_val;
 static set_dcd_rst_t set_dcd_rst;
@@ -112,7 +121,11 @@ static uint32_t detect_imximage_version(struct imx_header *imx_hdr)
 
 	/* Try to detect V2 */
 	if ((fhdr_v2->header.tag == IVT_HEADER_TAG) &&
-		(hdr_v2->dcd_table.header.tag == DCD_HEADER_TAG))
+		(hdr_v2->data.dcd_table.header.tag == DCD_HEADER_TAG))
+		return IMXIMAGE_V2;
+
+	if ((fhdr_v2->header.tag == IVT_HEADER_TAG) &&
+		hdr_v2->boot_data.plugin)
 		return IMXIMAGE_V2;
 
 	return IMXIMAGE_VER_INVALID;
@@ -157,7 +170,7 @@ static void set_dcd_val_v1(struct imx_header *imxhdr, char *name, int lineno,
 static void set_dcd_val_v2(struct imx_header *imxhdr, char *name, int lineno,
 					int fld, uint32_t value, uint32_t off)
 {
-	dcd_v2_t *dcd_v2 = &imxhdr->header.hdr_v2.dcd_table;
+	dcd_v2_t *dcd_v2 = &imxhdr->header.hdr_v2.data.dcd_table;
 
 	switch (fld) {
 	case CFG_REG_ADDRESS:
@@ -192,16 +205,18 @@ static void set_dcd_rst_v1(struct imx_header *imxhdr, uint32_t dcd_len,
 static void set_dcd_rst_v2(struct imx_header *imxhdr, uint32_t dcd_len,
 						char *name, int lineno)
 {
-	dcd_v2_t *dcd_v2 = &imxhdr->header.hdr_v2.dcd_table;
-
-	dcd_v2->header.tag = DCD_HEADER_TAG;
-	dcd_v2->header.length = cpu_to_be16(
-			dcd_len * sizeof(dcd_addr_data_t) + 8);
-	dcd_v2->header.version = DCD_VERSION;
-	dcd_v2->write_dcd_command.tag = DCD_COMMAND_TAG;
-	dcd_v2->write_dcd_command.length = cpu_to_be16(
-			dcd_len * sizeof(dcd_addr_data_t) + 4);
-	dcd_v2->write_dcd_command.param = DCD_COMMAND_PARAM;
+	if (!imxhdr->header.hdr_v2.boot_data.plugin) {
+		dcd_v2_t *dcd_v2 = &imxhdr->header.hdr_v2.data.dcd_table;
+
+		dcd_v2->header.tag = DCD_HEADER_TAG;
+		dcd_v2->header.length = cpu_to_be16(
+				dcd_len * sizeof(dcd_addr_data_t) + 8);
+		dcd_v2->header.version = DCD_VERSION;
+		dcd_v2->write_dcd_command.tag = DCD_COMMAND_TAG;
+		dcd_v2->write_dcd_command.length = cpu_to_be16(
+				dcd_len * sizeof(dcd_addr_data_t) + 4);
+		dcd_v2->write_dcd_command.param = DCD_COMMAND_PARAM;
+	}
 }
 
 static void set_imx_hdr_v1(struct imx_header *imxhdr, uint32_t dcd_len,
@@ -243,20 +258,87 @@ static void set_imx_hdr_v2(struct imx_header *imxhdr, uint32_t dcd_len,
 	fhdr_v2->header.length = cpu_to_be16(sizeof(flash_header_v2_t));
 	fhdr_v2->header.version = IVT_VERSION; /* 0x40 */
 
-	fhdr_v2->entry = entry_point;
-	fhdr_v2->reserved1 = fhdr_v2->reserved2 = 0;
-	hdr_base = entry_point - imximage_init_loadsize +
-		flash_offset;
-	fhdr_v2->self = hdr_base;
-	fhdr_v2->dcd_ptr = hdr_base + offsetof(imx_header_v2_t, dcd_table);
-	fhdr_v2->boot_data_ptr = hdr_base
-			+ offsetof(imx_header_v2_t, boot_data);
-	hdr_v2->boot_data.start = entry_point - imximage_init_loadsize;
+	if (!hdr_v2->boot_data.plugin) {
+		fhdr_v2->entry = entry_point;
+		fhdr_v2->reserved1 = fhdr_v2->reserved2 = 0;
+		hdr_base = entry_point - imximage_init_loadsize +
+			flash_offset;
+		fhdr_v2->self = hdr_base;
+		fhdr_v2->dcd_ptr = hdr_base + offsetof(imx_header_v2_t, data);
+		fhdr_v2->boot_data_ptr = hdr_base
+				+ offsetof(imx_header_v2_t, boot_data);
+		hdr_v2->boot_data.start = entry_point - imximage_init_loadsize;
+
+		fhdr_v2->csf = 0;
+
+		header_size_ptr = &hdr_v2->boot_data.size;
+		csf_ptr = &fhdr_v2->csf;
+	} else {
+		imx_header_v2_t *next_hdr_v2;
+		flash_header_v2_t *next_fhdr_v2;
+
+		if(imximage_csf_size != 0) {
+			fprintf(stderr, "Error: Header v2: SECURE_BOOT"
+					"is only supported in DCD mode!");
+			exit(EXIT_FAILURE);
+		}
+
+		fhdr_v2->entry = imximage_iram_free_start +
+			flash_offset + sizeof(flash_header_v2_t) +
+			sizeof(boot_data_t);
+
+		fhdr_v2->reserved1 = fhdr_v2->reserved2 = 0;
+		fhdr_v2->self = imximage_iram_free_start + flash_offset;
+
+		fhdr_v2->dcd_ptr = 0;
+
+		fhdr_v2->boot_data_ptr = fhdr_v2->self +
+				offsetof(imx_header_v2_t, boot_data);
+
+		hdr_v2->boot_data.start = imximage_iram_free_start;
+		/*
+		 * The actural size of plugin image is "imximage_plugin_size +
+		 * sizeof(flash_header_v2_t) + sizeof(boot_data_t)", plus the
+		 * flash_offset space.The ROM code only need to copy this size
+		 * to run the plugin code. However, later when copy the whole
+		 * U-Boot image to DDR, the ROM code use memcpy to copy the
+		 * first part of the image, and use the storage read function
+		 * to get the remaining part. This requires the dividing point
+		 * must be multiple of storage sector size. Here we set the
+		 * first section to be 16KB for this purpose.
+		 */
+		hdr_v2->boot_data.size = MAX_PLUGIN_CODE_SIZE;
+
+		/* Security feature are not supported */
+		fhdr_v2->csf = 0;
+
+		next_hdr_v2 = (imx_header_v2_t *)((char*)hdr_v2 +
+				imximage_plugin_size);
+
+		next_fhdr_v2 = &next_hdr_v2->fhdr;
+
+		next_fhdr_v2->header.tag = IVT_HEADER_TAG; /* 0xD1 */
+		next_fhdr_v2->header.length =
+			cpu_to_be16(sizeof(flash_header_v2_t));
+		next_fhdr_v2->header.version = IVT_VERSION; /* 0x40 */
+
+		next_fhdr_v2->entry = entry_point;
+		hdr_base = entry_point - sizeof(struct imx_header);
+		next_fhdr_v2->reserved1 = next_fhdr_v2->reserved2 = 0;
+		next_fhdr_v2->self = hdr_base + imximage_plugin_size;
 
-	fhdr_v2->csf = 0;
+		next_fhdr_v2->dcd_ptr = 0;
+		next_fhdr_v2->boot_data_ptr = next_fhdr_v2->self +
+				offsetof(imx_header_v2_t, boot_data);
 
-	header_size_ptr = &hdr_v2->boot_data.size;
-	csf_ptr = &fhdr_v2->csf;
+		next_hdr_v2->boot_data.start = hdr_base - flash_offset;
+
+		header_size_ptr = &next_hdr_v2->boot_data.size;
+
+		next_hdr_v2->boot_data.plugin = 0;
+
+		next_fhdr_v2->csf = 0;
+	}
 }
 
 static void set_hdr_func(void)
@@ -312,16 +394,19 @@ static void print_hdr_v2(struct imx_header *imx_hdr)
 {
 	imx_header_v2_t *hdr_v2 = &imx_hdr->header.hdr_v2;
 	flash_header_v2_t *fhdr_v2 = &hdr_v2->fhdr;
-	dcd_v2_t *dcd_v2 = &hdr_v2->dcd_table;
-	uint32_t size, version;
+	dcd_v2_t *dcd_v2 = &hdr_v2->data.dcd_table;
+	uint32_t size, version, plugin;
 
-	size = be16_to_cpu(dcd_v2->header.length) - 8;
-	if (size > (MAX_HW_CFG_SIZE_V2 * sizeof(dcd_addr_data_t))) {
+	plugin = hdr_v2->boot_data.plugin;
+	if (!plugin) {
+		size = be16_to_cpu(dcd_v2->header.length) - 8;
+		if (size > (MAX_HW_CFG_SIZE_V2 * sizeof(dcd_addr_data_t))) {
 		fprintf(stderr,
 			"Error: Image corrupt DCD size %d exceed maximum %d\n",
 			(uint32_t)(size / sizeof(dcd_addr_data_t)),
 			MAX_HW_CFG_SIZE_V2);
 		exit(EXIT_FAILURE);
+		}
 	}
 
 	version = detect_imximage_version(imx_hdr);
@@ -329,19 +414,83 @@ static void print_hdr_v2(struct imx_header *imx_hdr)
 	printf("Image Type:   Freescale IMX Boot Image\n");
 	printf("Image Ver:    %x", version);
 	printf("%s\n", get_table_entry_name(imximage_versions, NULL, version));
-	printf("Data Size:    ");
-	genimg_print_size(hdr_v2->boot_data.size);
-	printf("Load Address: %08x\n", (uint32_t)fhdr_v2->boot_data_ptr);
-	printf("Entry Point:  %08x\n", (uint32_t)fhdr_v2->entry);
-	if (fhdr_v2->csf && (imximage_ivt_offset != UNDEFINED) &&
-	    (imximage_csf_size != UNDEFINED)) {
-		printf("HAB Blocks:   %08x %08x %08x\n",
-		       (uint32_t)fhdr_v2->self, 0,
-		       hdr_v2->boot_data.size - imximage_ivt_offset -
-		       imximage_csf_size);
+	printf("Mode:         %s\n", plugin ? "PLUGIN" : "DCD");
+	if (!plugin) {
+		printf("Data Size:    ");
+		genimg_print_size(hdr_v2->boot_data.size);
+		printf("Load Address: %08x\n", (uint32_t)fhdr_v2->boot_data_ptr);
+		printf("Entry Point:  %08x\n", (uint32_t)fhdr_v2->entry);
+		if (fhdr_v2->csf && (imximage_ivt_offset != UNDEFINED) &&
+		    (imximage_csf_size != UNDEFINED)) {
+			printf("HAB Blocks:   %08x %08x %08x\n",
+			       (uint32_t)fhdr_v2->self, 0,
+			       hdr_v2->boot_data.size - imximage_ivt_offset -
+			       imximage_csf_size);
+		}
+	} else {
+		imx_header_v2_t *next_hdr_v2;
+		flash_header_v2_t *next_fhdr_v2;
+
+		/*First Header*/
+		printf("Plugin Data Size:     ");
+		genimg_print_size(hdr_v2->boot_data.size);
+		printf("Plugin Code Size:     ");
+		genimg_print_size(imximage_plugin_size);
+		printf("Plugin Load Address:  %08x\n", hdr_v2->boot_data.start);
+		printf("Plugin Entry Point:   %08x\n",
+				(uint32_t)fhdr_v2->entry);
+
+		/*Second Header*/
+		next_hdr_v2 = (imx_header_v2_t *)((char*)hdr_v2 +
+				imximage_plugin_size);
+		next_fhdr_v2 = &next_hdr_v2->fhdr;
+		printf("U-Boot Data Size:     ");
+		genimg_print_size(next_hdr_v2->boot_data.size);
+		printf("U-Boot Load Address:  %08x\n", next_hdr_v2->boot_data.start);
+		printf("U-Boot Entry Point:   %08x\n",
+				(uint32_t)next_fhdr_v2->entry);
 	}
 }
 
+#ifdef CONFIG_USE_PLUGIN
+static void copy_plugin_code(struct imx_header *imxhdr, char *plugin_file)
+{
+	int ifd = -1;
+	struct stat sbuf;
+	char *plugin_buf = imxhdr->header.hdr_v2.data.plugin_code;
+	char *ptr;
+
+	ifd = open(plugin_file, O_RDONLY|O_BINARY);
+	if (fstat(ifd, &sbuf) < 0) {
+		fprintf(stderr, "Can't stat %s: %s\n",
+			plugin_file,
+			strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	ptr = mmap(0, sbuf.st_size, PROT_READ, MAP_SHARED, ifd, 0);
+	if (ptr == MAP_FAILED) {
+		fprintf(stderr, "Can't read %s: %s\n",
+			plugin_file,
+			strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	if (sbuf.st_size > MAX_PLUGIN_CODE_SIZE) {
+		printf("plugin binary size too large\n");
+		exit(EXIT_FAILURE);
+	}
+
+	memcpy(plugin_buf, ptr, sbuf.st_size);
+	imximage_plugin_size = sbuf.st_size;
+
+	(void) munmap((void *)ptr, sbuf.st_size);
+	(void) close(ifd);
+
+	imxhdr->header.hdr_v2.boot_data.plugin = 1;
+}
+#endif
+
 static void parse_cfg_cmd(struct imx_header *imxhdr, int32_t cmd, char *token,
 				char *name, int lineno, int fld, int dcd_len)
 {
@@ -411,6 +560,11 @@ static void parse_cfg_cmd(struct imx_header *imxhdr, int32_t cmd, char *token,
 		if (unlikely(cmd_ver_first != 1))
 			cmd_ver_first = 0;
 		break;
+#ifdef CONFIG_USE_PLUGIN
+	case CMD_PLUGIN:
+		copy_plugin_code(imxhdr, token);
+		break;
+#endif
 	}
 }
 
@@ -434,20 +588,31 @@ static void parse_cfg_fld(struct imx_header *imxhdr, int32_t *cmd,
 		break;
 	case CFG_REG_ADDRESS:
 	case CFG_REG_VALUE:
-		if (*cmd != CMD_DATA)
-			return;
-
-		value = get_cfg_value(token, name, lineno);
-		(*set_dcd_val)(imxhdr, name, lineno, fld, value, *dcd_len);
-
-		if (fld == CFG_REG_VALUE) {
-			(*dcd_len)++;
-			if (*dcd_len > max_dcd_entries) {
-				fprintf(stderr, "Error: %s[%d] -"
-					"DCD table exceeds maximum size(%d)\n",
-					name, lineno, max_dcd_entries);
-				exit(EXIT_FAILURE);
+		switch (*cmd) {
+		case CMD_DATA:
+			value = get_cfg_value(token, name, lineno);
+			(*set_dcd_val)(imxhdr, name, lineno, fld, value,
+					*dcd_len);
+
+			if (fld == CFG_REG_VALUE) {
+				(*dcd_len)++;
+				if (*dcd_len > max_dcd_entries) {
+					fprintf(stderr, "Error: %s[%d] -"
+						"DCD table exceeds maximum\
+						size(%d)\n",
+						name, lineno, max_dcd_entries);
+					exit(EXIT_FAILURE);
+				}
 			}
+			break;
+#ifdef CONFIG_USE_PLUGIN
+		case CMD_PLUGIN:
+			value = get_cfg_value(token, name, lineno);
+			imximage_iram_free_start = value;
+			break;
+#endif
+		default:
+			return;
 		}
 		break;
 	default:
@@ -568,6 +733,13 @@ static void imximage_set_header(void *ptr, struct stat *sbuf, int ifd,
 	/* Parse dcd configuration file */
 	dcd_len = parse_cfg_file(imxhdr, params->imagename);
 
+	if (imximage_version == IMXIMAGE_V2) {
+		if (imximage_init_loadsize < imximage_ivt_offset +
+			sizeof(imx_header_v2_t))
+				imximage_init_loadsize = imximage_ivt_offset +
+					sizeof(imx_header_v2_t);
+	}
+
 	/* Set the imx header */
 	(*set_imx_hdr)(imxhdr, dcd_len, params->ep, imximage_ivt_offset);
 
@@ -580,7 +752,7 @@ static void imximage_set_header(void *ptr, struct stat *sbuf, int ifd,
 	 *
 	 * The remaining fraction of a block bytes would not be loaded!
 	 */
-	*header_size_ptr = ROUND(sbuf->st_size, 4096);
+	*header_size_ptr = ROUND((sbuf->st_size + imximage_ivt_offset), 4096);
 
 	if (csf_ptr && imximage_csf_size) {
 		*csf_ptr = params->ep - imximage_init_loadsize +
diff --git a/tools/imximage.h b/tools/imximage.h
index 01f861e..e97df0d 100644
--- a/tools/imximage.h
+++ b/tools/imximage.h
@@ -2,13 +2,17 @@
  * (C) Copyright 2009
  * Stefano Babic, DENX Software Engineering, sbabic@denx.de.
  *
+ * Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
  * SPDX-License-Identifier:	GPL-2.0+
  */
 
 #ifndef _IMXIMAGE_H_
 #define _IMXIMAGE_H_
 
-#define MAX_HW_CFG_SIZE_V2 121 /* Max number of registers imx can set for v2 */
+#include <config.h>
+#define MAX_HW_CFG_SIZE_V2 220 /* Max number of registers imx can set for v2 */
+#define MAX_PLUGIN_CODE_SIZE (16*1024)
 #define MAX_HW_CFG_SIZE_V1 60  /* Max number of registers imx can set for v1 */
 #define APP_CODE_BARKER	0xB1
 #define DCD_BARKER	0xB17219E9
@@ -29,6 +33,7 @@
 #define FLASH_OFFSET_ONENAND	0x100
 #define FLASH_OFFSET_NOR	0x1000
 #define FLASH_OFFSET_SATA	FLASH_OFFSET_STANDARD
+#define FLASH_OFFSET_QSPI   0x1000
 
 /* Initial Load Region Size */
 #define FLASH_LOADSIZE_UNDEFINED	0xFFFFFFFF
@@ -39,6 +44,7 @@
 #define FLASH_LOADSIZE_ONENAND		0x400
 #define FLASH_LOADSIZE_NOR		0x0 /* entire image */
 #define FLASH_LOADSIZE_SATA		FLASH_LOADSIZE_STANDARD
+#define FLASH_LOADSIZE_QSPI		0x0 /* entire image */
 
 #define IVT_HEADER_TAG 0xD1
 #define IVT_VERSION 0x40
@@ -54,6 +60,7 @@ enum imximage_cmd {
 	CMD_BOOT_OFFSET,
 	CMD_DATA,
 	CMD_CSF,
+	CMD_PLUGIN,
 };
 
 enum imximage_fld_types {
@@ -149,7 +156,12 @@ typedef struct {
 typedef struct {
 	flash_header_v2_t fhdr;
 	boot_data_t boot_data;
-	dcd_v2_t dcd_table;
+	union {
+		dcd_v2_t dcd_table;
+#ifdef CONFIG_USE_PLUGIN
+		char plugin_code[MAX_PLUGIN_CODE_SIZE];
+#endif
+	} data;
 } imx_header_v2_t;
 
 /* The header must be aligned to 4k on MX53 for NAND boot */
diff --git a/tools/logos/logo.bmp b/tools/logos/logo.bmp
new file mode 100644
index 0000000..0f27840
Binary files /dev/null and b/tools/logos/logo.bmp differ
