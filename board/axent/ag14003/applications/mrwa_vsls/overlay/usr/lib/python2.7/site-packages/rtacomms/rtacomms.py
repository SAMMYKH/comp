import binascii, struct, sys, math, random, socket, time
import rtasignset, rtadisplay, rtastatus, rtalog, crc16, logging

class EndSession(Exception):
    pass

# Protocol-related packet handlers.
def handle_start_session(p, session):
    session.ns = 0
    session.nr = 0
    
    # Generate and send password seed.
    password_seed = int(math.floor(random.random()*256)) & 0xff
    session.logger.info('Password seed: %d' % password_seed)
    session.send_packet(0x03, chr(password_seed))
    
    # Generate password.
    password = int((password_seed + session.psoff) % 256) & 0xffff
    i = 16
    while i:
        bit5 = (password & 0x20) >> 5
        bit7 = (password & 0x80) >> 7
        bit8 = (password & 0x100) >> 8
        xorres = (bit5 ^ bit7 ^ bit8)
        password = (password * 2) & 0xFFFF
        password = (password + xorres) & 0xFFFF
        i -= 1
    password = (password + session.poff) & 0xFFFF
    session.password = binascii.b2a_hex(struct.pack('>H', password)).upper()
    session.logger.info('Password set to \'%s\'' % session.password)

def handle_password(p, session):
    session.ns = 0
    session.nr = 0
    
    password_in = binascii.b2a_hex(p.data).upper()
    if password_in == session.password:
        session.logger.info('Valid password received')
        session.app_ack(p.mi)
        session.active = True
    else:
        session.logger.warning(
            'Invalid password received: \'%s\'' % password_in)
        session.reject(p.mi, '\x10')
        session.active = False

def handle_heartbeat_poll(p, session):
    handle_offline_heartbeat_poll(p, session)

def handle_offline_heartbeat_poll(p, session):
    status_reply = rtastatus.generate_sign_status(p, session)
    session.send_packet(0x06, status_reply)

def handle_end_session(p, session):
    session.logger.info('Session ended')
    
    session.active = False
    
    session.app_ack(p.mi)
    
    raise EndSession()

def handle_reset(p, session):
    reset_level = ord(p.data[0])
    
    if reset_level not in [0, 1, 2, 3, 255]:
        session.reject(p.mi, '\x02')
    
    # Do reset level 0.
    if reset_level == 0:
        session.logger.warning('Reset L0')
        session.server.group.reset_l0(True)
    elif reset_level == 1:
        session.logger.warning('Reset L1')
        session.server.group.reset_l1(True)
    elif reset_level == 2:
        session.logger.warning('Reset L2')
        session.server.group.reset_l2(True)
    elif reset_level == 3:
        session.logger.warning('Reset L3')
        session.server.group.reset_l3(True)
    elif reset_level == 255:
        session.logger.warning('Reset L255')
        session.server.group.reset_l255(True)
    
    session.app_ack(p.mi)

# Packet handling functions.
handlers = {
    0x02: handle_start_session,
    0x04: handle_password,
    0x05: handle_heartbeat_poll,
    0x07: handle_end_session,
    0x08: handle_reset,
    0x09: rtastatus.update_time,
    #0x0a: rtasignset.sign_set_text_frame,
    #0x0b: rtasignset.sign_set_graphics_frame,
    #0x0c: rtasignset.sign_set_message,
    0x0e: rtadisplay.sign_display_frame,
    #0x0f: rtadisplay.sign_display_message,
    0x10: rtadisplay.enable_plan,
    0x11: rtadisplay.disable_plan,
    0x12: rtadisplay.request_enabled_plans,
    0x14: rtadisplay.sign_set_dimming_level,
    #0x15: rtadisplay.power_on_off,
    0x16: rtadisplay.disable_enable_sign,
    0x17: rtadisplay.sign_request_frame_message_plan_stored,
    0x21: rtasignset.sign_set_plan,
    0x22: rtalog.retrieve_log_type,
    0x24: rtalog.reset_log_type,
    0x25: rtastatus.sign_extended_status_request,
    0x27: rtastatus.sign_pixel_status_request,
    0x29: rtadisplay.disable_enable_uca,
    0x2A: rtadisplay.set_uca_address,
    0x2B: rtadisplay.request_uca_address,
    0x2D: rtadisplay.request_enabled_plans_checksum
    }

# RTA protocol RX packet class.
class RXPacket(object):
    def __init__(self, data):
        self.data = data[:-4] + binascii.a2b_hex(data[-4:])
        offset = crc16.crc16(self.data)
        if offset:
            raise crc16.CRCError('Offset = %d' % offset)
        self.control = self.data[0]
        
        if self.data[0] == '\x15':
            self.nr = int(struct.unpack(">B",str(binascii.a2b_hex(self.data[1:3])))[0])
            self.addr = int(struct.unpack(">B",str(binascii.a2b_hex(self.data[3:5])))[0])
        else:
            self.ns = int(struct.unpack(">B",str(binascii.a2b_hex(self.data[1:3])))[0])
            self.nr =int(struct.unpack(">B",str(binascii.a2b_hex(self.data[3:5])))[0])
            self.addr = int(struct.unpack(">B",str(binascii.a2b_hex(self.data[5:7])))[0])
            self.mi = binascii.a2b_hex(self.data[8:10])
            self.data = binascii.a2b_hex(self.data[10:-2])
    
    def __str__(self):
        if self.control == '\x15':
            return 'nak, nr: %d, addr: %d' % (self.nr, self.addr)
        else:
            return 'ns: %d, nr: %d, addr: %d, mi: %x, data:%s' \
                % (self.ns, self.nr, self.addr, ord(self.mi), repr(self.data))

class Session(object):
    def __init__(self, con, json_server, poff, psoff, addr, rx_led=None, tx_led=None):
        self.con = con
        self.server = json_server
        self.buffer = ''
        self.packet_buffer = []
        self.ns = 0
        self.nr = 0
        self.addr = addr
        self.poff = poff
        self.psoff = psoff
        self.password = ''
        self.active = False
        self.rx_led = rx_led
        self.tx_led = tx_led
        self.logger = logging.getLogger('rta')
    
    # Standard N(S) and N(R) update, called by most packets.
    def update_sequence(self, new_ns):
        self.nr += 1
        if self.nr == 256:
            self.nr = 1
        
        self.ns = new_ns
    
    # Sends an application-layer rejection message to the master.
    def reject(self, mi_code, error_code):
        self.send_packet(0x00, '%c%c' % (mi_code, error_code))
    
    # Sends an application-layer acknowledge message to the master.
    def app_ack(self, mi_code):
        self.send_packet(0x01, '%c' % (mi_code))
    
    # Sends a protocol NAK to the master.
    def nak(self):
        overhead = binascii.b2a_hex(
            struct.pack('>BB', self.nr, self.addr)).upper()
        data = '\x15' + overhead
        crc = crc16.crc16(data)
        crc = binascii.b2a_hex(struct.pack('>H', crc)).upper()
        data = data + crc + '\x03'
        
        self.logger.info('TX: Protocol NAK NR=%d' % self.nr)
        if type(self.con) is socket.socket:
                new_data = self.con.send(data)
        else:
            new_data = self.con.write(data)
        
        if self.tx_led is not None:
            try:
                with open(self.tx_led, 'w') as led_file:
                    led_file.write('1')
            except:
                pass
    
    # Sends a protocol ACK to the master.
    def ack(self):
        overhead = binascii.b2a_hex(
            struct.pack('>BB', self.nr, self.addr)).upper()
        data = '\x06' + overhead
        crc = crc16.crc16(data)
        crc = binascii.b2a_hex(struct.pack('>H', crc)).upper()
        data = data + crc + '\x03'
        
        self.logger.info('TX: Protocol ACK NR=%d' % self.nr)
        if type(self.con) is socket.socket:
                new_data = self.con.send(data)
        else:
            new_data = self.con.write(data)
        
        if self.tx_led is not None:
            try:
                with open(self.tx_led, 'w') as led_file:
                    led_file.write('1')
            except:
                pass
    
    def send_packet(self, mi, data):
        overhead = binascii.b2a_hex(
            struct.pack('>BBB', self.ns, self.nr, self.addr)).upper()
        mi = binascii.b2a_hex(struct.pack('>B', mi)).upper()
        data = binascii.b2a_hex(data).upper()
        data = '\x01' + overhead + '\x02' + mi + data
        crc = crc16.crc16(data)
        crc = binascii.b2a_hex(struct.pack('>H', crc)).upper()
        data = data + crc + '\x03'
        
        self.logger.info('TX: %s' % repr(data))
        if type(self.con) is socket.socket:
                new_data = self.con.send(data)
        else:
            new_data = self.con.write(data)
        
        if self.tx_led is not None:
            try:
                with open(self.tx_led, 'w') as led_file:
                    led_file.write('1')
            except:
                pass
    
    def process(self):
        while len(self.buffer) > 0:
            start = self.buffer.find('\x01')
            if start < 0:
                start = self.buffer.find('\x15')
            end = self.buffer.find('\x03')
            if (start >= 0) and (end >= 0) and (start < end):
                incoming_packet_data = self.buffer[start:end]
                self.buffer = self.buffer[end+2:]
            elif end >= 0:
                self.buffer = self.buffer[end+2:]
                continue
            else:
                return
            
            try:
                new_packet = RXPacket(incoming_packet_data)
            except crc16.CRCError as e:
                # Handle incorrect CRC by sending a NAK.
                self.logger.warning('CRC error: %s' % e)
                self.logger.warning('Bad packet was: %s' % repr(incoming_packet_data))
                self.nak()
                break
            else:
                self.logger.info('RX: %s' % repr(incoming_packet_data))
                self.packet_buffer.append(new_packet)
                
                if self.rx_led is not None:
                    try:
                        with open(self.rx_led, 'w') as led_file:
                            led_file.write('1')
                    except:
                        pass
    
    def handle(self):
        try:
            if type(self.con) is socket.socket:
                new_data = self.con.recv(1024)
            else:
                new_data = self.con.read(1024)
        except:
            new_data = ''
        
        # Decode new data into packets.
        if len(new_data):
            self.buffer += new_data
            self.process()
        else:
            time.sleep(0.1)
            return False
        
        # Handle new packets in the order they were received.
        for p in self.packet_buffer:
            # We received a NAK. Don't handle it for now.
            if p.control == '\x15':
                continue
            
            # Incorrect address, reject.
            if p.addr != self.addr:
                self.logger.warning('Incorrect address received: ' \
                    + '%d rather than %d' % (p.addr, self.addr))
                self.reject(p.mi, '\x0a')
                continue
            
            # Check if session is active (and whether it matters).
            if self.active is False:
                if p.mi == '\x02' or p.mi == '\x04':
                    # Start session or password message.
                    pass
                elif p.mi == '\x05':
                    # Offline heartbeat poll.
                    self.logger.info('Received offline heartbeat_poll message')
                    self.ack()
                    handle_offline_heartbeat_poll(p, self)
                    
                    continue
                else:
                    # We're offline, reject the message.
                    self.logger.warning('Message received while sign offline')
                    self.ack()
                    self.reject(p.mi, '\x01')
                    continue
            
            # Check N(S) and N(R), and send protocol ACK if OK.
            if p.mi in ['\x02', '\x04']:
                self.ack()
            elif p.ns == self.nr:
                self.update_sequence(p.ns)
                self.ack()
            else:
                self.logger.warning('Sequence number error: %s' % str(p))
                self.nak()
                continue
            
            if ord(p.mi) in handlers:
                self.logger.info(
                    'Running handler \'%s\'' % handlers[ord(p.mi)].__name__)
                
                try:
                    handlers[ord(p.mi)](p, self)
                except EndSession:
                    continue
                except Exception as e:
                    import traceback
                    self.logger.error('%s: %s' % (e, str(p)))
                    self.logger.error(traceback.format_exc())
                    continue
            else:
                self.logger.warning('Unrecognised MI code for packet: %s' \
                    % str(p))
                self.reject(p.mi, '\x06')
        
        self.packet_buffer = []
        
        return True
