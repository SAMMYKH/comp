import struct, crc16, sys, binascii, sqlite3

config_db = '/usr/share/db/config.db'

def sign_display_frame(p, session):
    frame_id = ord(p.data[0])
    
    if session.server.group.status()['enabled'] is False:
        session.reject(p.mi, '\x10')
        return
    
    # If frame_id is zero, reinstate current plan.
    if frame_id == 0:
        session.server.schedule.enable_scheduler()
    else:
        # Display specified frame.
        try:
            session.server.group.display_frame(frame_id)
        except Exception as e:
            if 'InvalidContentException' in e.message[1] or 'KeyError' in e.message[1]:
                session.logger.warning('Specified content does not exist')
                session.reject(p.mi, '\x0d')
                return
            else:
                import traceback
                session.logger.error('Unrecognised exception')
                session.logger.error(traceback.format_exc())
                session.reject(p.mi, '\x02')
                return
    
    session.app_ack(p.mi)

def enable_plan(p, session):
    plan_id = ord(p.data[0])
    
    if session.server.group.status()['enabled'] is False:
        session.reject(p.mi, '\x01')
        return
    
    # Enable specified plan.
    try:
        session.server.group.enable_plan(plan_id)
    except Exception as e:
        if 'InvalidContentException' in e.message[1]:
            session.logger.warning('Specified plan does not exist')
            session.reject(p.mi, '\x0d')
            return
        else:
            import traceback
            session.logger.error('Unrecognised exception')
            session.logger.error(traceback.format_exc())
            session.reject(p.mi, '\x02')
            return
    
    session.app_ack(p.mi)

def disable_plan(p, session):
    plan_id = ord(p.data[0])
    
    # Disable specified plan.
    try:
        session.server.group.disable_plan(plan_id)
    except Exception as e:
        if 'InvalidContentException' in e.message[1]:
            session.logger.warning('Specified plan does not exist')
            session.reject(p.mi, '\x0d')
            return
        elif 'PlanActiveException' in e.message[1]:
            session.logger.error('Disable actived plan')
            session.reject(p.mi, '\x0a')
            return
        else:
            import traceback
            session.logger.error('Unrecognised exception')
            session.logger.error(traceback.format_exc())
            session.reject(p.mi, '\x02')
            return
    
    session.app_ack(p.mi)

def request_enabled_plans(p, session):
    # Get enabled plans and return them.
    try:
        enabled_plans = session.server.group.get_enabled_plans()
    except Exception as e:
        import traceback
        session.logger.error('Unrecognised exception')
        session.logger.error(traceback.format_exc())
        session.reject(p.mi, '\x02')
        return
    
    response_data = ''
    response_data += ('%x' % len(enabled_plans)).zfill(2)
    
    for e in enabled_plans:
        response_data += ('%x' % e).zfill(2)
    
    session.send_packet(0x13, response_data.decode('hex'))

def request_enabled_plans_checksum(p, session):
    # Get enabled plans and return them.
    try:
        enabled_plans_checksum = session.server.group.get_enabled_plans_checksum()
    except Exception as e:
        import traceback
        session.logger.error('Unrecognised exception')
        session.logger.error(traceback.format_exc())
        session.reject(p.mi, '\x02')
        return

    response_data = ''
    response_data += ('%x' % len(enabled_plans_checksum)).zfill(2)

    for e in enabled_plans_checksum:
        response_data += ('%x' % e[0]).zfill(2)
        response_data += ('%x' % e[1]).zfill(4)

    session.send_packet(0x2E, response_data.decode('hex'))

def sign_set_dimming_level(p, session):
    sign_list = []
    num_entries = ord(p.data[0])
    
    for i in range(num_entries):

        sign_id = ord(p.data[(i*3)+1])
        mode = ord(p.data[(i*3)+2])
        brightness = ord(p.data[(i*3)+3])

        if check_valid_sign(sign_id) is False:
            session.reject(p.mi, '\x08')
            return        

        if mode != 1 and mode != 0:
            session.reject(p.mi, '\x02')
            return

        if brightness < 1 or brightness > 16:
            session.reject(p.mi, '\x09')
            return

        sign_list.append([sign_id, brightness, mode])
    
    for sign in sign_list:
        try:
            session.server.signs.brightness(
                sign_id=int(sign[0]),
                brightness=int(sign[1])-1,
                auto=(True if int(sign[2]) == 1 else False))
        except:
            import traceback
            session.logger.error('Unrecognised exception')
            session.logger.error(traceback.format_exc())
            session.reject(p.mi, '\x0D')
            return

    session.app_ack(p.mi)
    
def disable_enable_sign(p, session):
    sign_list = []
    num_entries = ord(p.data[0])
    
    for i in range(num_entries):

        sign_id = ord(p.data[(i*2)+1])
        enable = ord(p.data[(i*2)+2])
    
        if check_valid_sign(sign_id) is False:
            session.reject(p.mi, '\x08')
            return 

        if enable != 1 and enable != 0:
            session.reject(p.mi, '\x02')
            return

        sign_list.append([sign_id, enable])
    
    for sign in sign_list:
        try:
            if sign[1] == 1:
                session.server.group.enable(sign[0])
            elif sign[1] == 0:
                session.server.group.disable(sign[0])
        except:
            import traceback
            session.logger.error('Unrecognised exception')
            session.logger.error(traceback.format_exc())
            session.reject(p.mi, '\x0D')
            return

    session.app_ack(p.mi)

def sign_request_frame_message_plan_stored(p, session):
    # First, figure out what we're being asked for.
    request_type = ord(p.data[0])
    requested_id = ord(p.data[1])
    
    if request_type == 0:
        # Frame request.
        try:
            result = session.server.group.get_frame_list()
        except:
            import traceback
            traceback.print_exc()
            session.reject(p.mi, '\x13')
            return
        
        response_data = ''
        response_data += ('%x' % (int(len(result))*2)).zfill(2)
        for i in result:
            response_data += ('%x' % int(i)).zfill(2)
            response_data += ('%x' % (int(i) + 1)).zfill(2)

        response_data = response_data.decode('hex')
        session.send_packet(0x20, response_data)

    elif request_type == 1:
        # Plan request.
        try:
            result = session.server.group.get_plan(requested_id)
        except:
            session.reject(p.mi, '\x0D')
            return
        
        # Assemble plan response.
        response_data = ''
        response_data += ('%x' % requested_id).zfill(2)
        response_data += ('%x' % int(result['revision'])).zfill(2)
        response_data += ('%x' % int(result['type'])).zfill(2)
        if int(result['type']) == 0:
            response_data += ('%x' % int(result['days'])).zfill(2)
        elif int(result['type']) == 1:
            response_data += ('%x' % int(result['year'])).zfill(4)
            response_data += ('%x' % int(result['month'])).zfill(2)
            response_data += ('%x' % int(result['days'])).zfill(8)
        elif int(result['type']) == 2:
            response_data += ('%x' % int(result['year'])).zfill(4)
            response_data += str(result['days'])

        for e in result['entries']:
            response_data += ('%x' % int(1)).zfill(2)
            response_data += ('%x' % int(e['frameID'])).zfill(2)
            response_data += ('%x' % int(e['startH'])).zfill(2)
            response_data += ('%x' % int(e['startM'])).zfill(2)
            response_data += ('%x' % int(e['endH'])).zfill(2)
            response_data += ('%x' % int(e['endM'])).zfill(2)
        
        response_data = response_data.decode('hex')
        
        # Add last entries.
        if len(result['entries']) < 6:
            response_data += '\x00'
        session.send_packet(0x21, response_data)
    else:
        session.reject(p.mi, '\x02')
        return

def disable_enable_uca(p, session):
    enable = ord(p.data[0])
    try:
        session.server.signs.disable_enable_uca(enable)
    except:
        session.reject(p.mi, '\x02')
        return
    session.app_ack(p.mi)

def set_uca_address(p, session):
    protocol_type = ord(p.data[0])
    ip_addr = struct.unpack(">L", p.data[1:5])[0]
    port = struct.unpack(">H", p.data[5:7])[0]

    try:
        result = session.server.signs.set_uca_addr(ip_addr, port)
    except:
        session.reject(p.mi, '\x02')
        return

    response_data = ''
    response_data += ('%x' % (ip_addr)).zfill(8)
    response_data += ('%x' % (port)).zfill(4)

    response_data = response_data.decode('hex')
    session.send_packet(0x2C, response_data)

def request_uca_address(p, session):
    try:
        result = session.server.signs.get_uca_addr()
    except:
        import traceback
        traceback.print_exc()
        session.reject(p.mi, '\x02')
        return

    response_data = ''
    response_data += ('%x' % (int(result[0]))).zfill(8)
    response_data += ('%x' % (int(result[1]))).zfill(4)

    response_data = response_data.decode('hex')
    session.send_packet(0x2C, response_data)

def check_valid_sign(sign_id):
    if int(sign_id) == 0:
        return True

    with sqlite3.connect(config_db) as db:
        result = db.execute('select sign_id from signs where \
                             sign_id=?', (int(sign_id),)).fetchone()

    if result is not None:
        return True

    return False
