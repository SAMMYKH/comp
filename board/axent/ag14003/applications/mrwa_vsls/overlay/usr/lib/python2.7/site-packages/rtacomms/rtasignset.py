import struct, crc16, sys
import rtastatus

def sign_set_text_frame(p, session):
    frame_id = ord(p.data[0])
    rev = ord(p.data[1])
    font = ord(p.data[2])
    colour = ord(p.data[3])
    flash = ord(p.data[4])
    length = ord(p.data[5])
    text = str(p.data[6:-2])
    crc = str(p.data[-2:]).encode('hex')
    
    offset = crc16.crc16(p.mi + p.data)
    if offset:
        session.logger.warning('Text frame CRC error: offset = %d' % offset)
        session.reject(p.mi, '\x04')
        return
    
    if frame_id == 0:
        session.logger.warning('Text frame ID 0 is invalid')
        session.reject(p.mi, '\x02')
        return
    
    if len(text) != length:
        session.logger.warning('Specified text length does not match data')
        session.reject(p.mi, '\x16')
        return
    
    try:
        session.server.vms.set_text_frame(
            frame_id, rev, font, colour,
            flash, length, text)
    except Exception as e:
        if 'FontException' in e.message[1]:
            session.logger.warning('Invalid font')
            session.reject(p.mi, '\x0b')
            return
        elif 'ColourException' in e.message[1]:
            session.logger.warning('Invalid colour')
            session.reject(p.mi, '\x0c')
            return
        elif 'ConspicuityException' in e.message[1]:
            session.logger.warning('Invalid flash pattern')
            session.reject(p.mi, '\x11')
            return
        else:
            session.logger.error('Unrecognised exception')
            session.reject(p.mi, '\x02')
    
    session.logger.info('Successfully set sign text frame id %d' % frame_id)
    status_reply = rtastatus.generate_sign_status(p, session)
    session.send_packet(0x06, status_reply)

def sign_set_graphics_frame(p, session):
    frame_id = ord(p.data[0])
    rev = ord(p.data[1])
    height = ord(p.data[2])
    width = ord(p.data[3])
    colour = ord(p.data[4])
    flash = ord(p.data[5])
    length = struct.unpack(">H", p.data[6:8])[0]
    data = str(p.data[8:-2])
    crc = str(p.data[-2:]).encode('hex')
    
    offset = crc16.crc16(p.mi + p.data)
    if offset:
        session.logger.warning(
            'Graphics frame CRC error: offset = %d' % offset)
        session.reject(p.mi, '\x04')
        return
    
    if frame_id == 0:
        session.logger.warning('Graphics frame ID 0 is invalid')
        session.reject(p.mi, '\x02')
        return
    
    if len(data) != length:
        session.logger.warning('Specified data length does not match data')
        session.reject(p.mi, '\x16')
        return
    
    try:
        session.server.vms.set_graphics_frame(
            frame_id, rev, (width, height), colour,
            flash, data.encode('hex'))
    except Exception as e:
        try:
            error_message = e.message[1]
        except:
            import traceback
            session.logger.error('Unrecognised exception')
            session.logger.error(traceback.format_exc())
            session.reject(p.mi, '\x02')
        else:
            if 'SizeException' in e.message[1]:
                session.logger.warning('Frame size incorrect')
                session.reject(p.mi, '\x16')
                return
            elif 'ColourException' in e.message[1]:
                session.logger.warning('Invalid colour')
                session.reject(p.mi, '\x0c')
                return
            elif 'ConspicuityException' in e.message[1]:
                session.logger.warning('Invalid flash pattern')
                session.reject(p.mi, '\x11')
                return
            else:
                import traceback
                session.logger.error('Unrecognised exception')
                session.logger.error(traceback.format_exc())
                session.reject(p.mi, '\x02')
    
    session.logger.info(
        'Successfully set sign graphics frame id %d' % frame_id)
    status_reply = rtastatus.generate_sign_status(p, session)
    session.send_packet(0x06, status_reply)

def sign_set_message(p, session):
    message_id = ord(p.data[0])
    rev = ord(p.data[1])
    transition = ord(p.data[2])
    frames = []
    offsets = [(3, 4), (5, 6), (7, 8), (9, 10), (11, 12), (13, 14)]
    for f in xrange((len(p.data) - 3) / 2):
        frames.append((ord(p.data[offsets[f][0]]), ord(p.data[offsets[f][1]])))
    
    if message_id == 0:
        session.logger.warning('Message ID 0 is invalid')
        session.reject(p.mi, '\x02')
        return
    
    if frames[0][0] == 0:
        session.logger.warning('No frames defined in message')
        session.reject(p.mi, '\x03')
    
    # Include all frames until one has an ID of 0.
    frame_list = []
    for f in frames:
        if f[0] != 0:
            frame_list.append(f)
        else:
            break
    
    # Now call the function to create and store the message.
    try:
        session.server.vms.set_message(message_id, rev, transition, frame_list)
    except Exception as e:
        if 'InvalidContentException' in e.message[1]:
            session.logger.warning('Specified content does not exist')
            session.reject(p.mi, '\x13')
            return
        else:
            import traceback
            session.logger.error('Unrecognised exception')
            session.logger.error(traceback.format_exc())
            session.reject(p.mi, '\x02')
            return
    
    session.logger.info('Successfully set sign message id %d' % message_id)
    status_reply = rtastatus.generate_sign_status(p, session)
    session.send_packet(0x06, status_reply)

def sign_set_plan(p, session):
    plan_id = ord(p.data[0])
    rev = ord(p.data[1])
    type = ord(p.data[2])
    
    if plan_id == 0:
        session.logger.warning('Plan ID 0 is invalid')
        session.reject(p.mi, '\x0D')
        return

    if type == 0:
        sch_len = 1
    elif type == 1:
        sch_len = 7
    elif type == 2:
        sch_len = 50
    else:
        session.logger.warning('Schedule type is invalid')
        session.reject(p.mi, '\x02')
        return
    
    sch_data = str(p.data[3:(3 + sch_len)])
    plan_data = p.data[(3 + sch_len):]
    num_plans = len(plan_data) / 6
    plans = []

    if num_plans == 0:
        session.logger.warning('No Frames')
        session.reject(p.mi, '\x03')
        return
    elif num_plans > 6:
        session.logger.warning('Too many Frames')
        session.reject(p.mi, '\x03')
        return

    for i in xrange(num_plans):
        new_plan = tuple(ord(c) for c in \
            plan_data[(i * 6): (i * 6) + 6])

        if new_plan[0] == 0:
            break
        
        if (new_plan[0] != 1) or \
            (session.server.vsls.check_valid_frames(new_plan[1]) == False) :
            session.logger.warning('Unknown Frames')
            session.reject(p.mi, '\x0D')
            return

        plans.append(new_plan)
    
    # Call the function which creates the plan.
    try:
        session.server.group.set_plan(plan_id, rev, type,
                                      sch_data.encode('hex'), plans)
    except Exception as e:
        if 'InvalidContentException' in e.message[1]:
            session.logger.warning('Specified content does not exist')
            session.reject(p.mi, '\x13')
            return
        elif 'InvalidPlanException' in e.message[1]:
            session.logger.warning('Invalid date parameter')
            session.reject(p.mi, '\x02')
            return
        elif 'OverlapException' in e.message[1]:
            session.logger.warning('Overlapped schedule')
            session.reject(p.mi, '\x02')
            return
        else:
            import traceback
            session.logger.error('Unrecognised exception')
            session.logger.error(traceback.format_exc())
            session.reject(p.mi, '\x02')
            return
    
    session.logger.info('Successfully set sign plan id %d' % plan_id)
    status_reply = rtastatus.generate_sign_status(p, session)
    session.send_packet(0x06, status_reply)

