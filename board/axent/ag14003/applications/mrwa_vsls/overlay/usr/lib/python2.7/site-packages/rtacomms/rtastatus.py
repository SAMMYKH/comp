import time, struct, sys, hashlib, os.path, sqlite3, crc16, binascii

config_db = '/usr/share/db/config.db'

def generate_sign_status(p, session):
    group_status = session.server.group.status()
    
    status_data = ''
    
    # Controller on/offline status.
    status_data += ('%x' % (1 if session.active else 0)).zfill(2)
    
    # Application error code.
    status_data += ('%x' % group_status['applicationError']).zfill(2)
    
    # Current date/time
    now = time.localtime(time.time())
    d = ('%x' % now.tm_mday).zfill(2)
    m = ('%x' % now.tm_mon).zfill(2)
    y = ('%x' % now.tm_year).zfill(4)
    h = ('%x' % now.tm_hour).zfill(2)
    mi = ('%x' % now.tm_min).zfill(2)
    s = ('%x' % now.tm_sec).zfill(2)
    status_data += d + m + y + h + mi + s

    # Calculate the SHA hash (or something) of the RTA database.
    with open('/usr/share/db/rta.db', 'rb') as data:
        m = hashlib.sha1()
        m.update(data.read())
    status_data += ('%x' % (int(m.hexdigest(), 16) & 0xffff)).zfill(4)

    # Get controller error code.
    try:
        fault = session.server.group.get_current_fault(0)
    except:
        fault = 0xff
    
    status_data += ('%x' % fault).zfill(2)

    # Get number of signs attached (ie. number of VMS displays).
    sign_list = session.server.signs.get_signs()
    status_data += ('%x' % len(sign_list)).zfill(2)

    current_frame = 0
    current_frame_rev = 0

    current_plan = 0
    current_plan_rev = 0

    if session.server.schedule.check_enabled():
        try:
            cur_schedule = session.server.schedule.get_current()
        except:
            pass
        else:
            with sqlite3.connect('/usr/share/db/rta.db') as rta_db:
                if cur_schedule is not None:
                    current_plan = int(cur_schedule[3])
                    current_frame = int(cur_schedule[2])
                    current_plan_rev = rta_db.execute(
                        'select revision from plan where uniqueID=?',
                        (current_plan,)).fetchone()
                    if current_plan_rev is not None \
                    and current_plan_rev[0] is not None:
                        current_plan_rev = int(current_plan_rev[0])

    # Add as much data as needed for each VMS display entry.
    for sign in sign_list:
        # Sign ID.
        status_data += ('%x' % sign['sign_id']).zfill(2)

        # Sign error code.
        try:
            fault = session.server.group.get_current_fault(1)
        except:
            fault = 0xff
        status_data += ('%x' % fault).zfill(2)

        # Flag whether sign is running.
        status_data += ('%x' % (1 if sign['enabled'] == 'yes' else 0)).zfill(2)

        # Get displaying frame ID and revision.
        status_data += ('%x' % current_frame).zfill(2)
        status_data += ('%x' % current_frame_rev).zfill(2)

        # Get displaying plan ID and revision.
        status_data += ('%x' % current_plan).zfill(2)
        status_data += ('%x' % current_plan_rev).zfill(2)
    
    return status_data.decode('hex')

def update_time(p, session):
    new_time = struct.unpack('>BBHBBB', p.data[0:14])
    d = str(new_time[0]).zfill(2)
    m = str(new_time[1]).zfill(2)
    y = str(new_time[2]).zfill(4)
    h = str(new_time[3]).zfill(2)
    mi = str(new_time[4]).zfill(2)
    s = str(new_time[5]).zfill(2)
    new_time = '%s-%s-%s %s:%s:%s' % (y, m, d, h, mi, s)
    
    try:
        session.server.settings.set_system_time(new_time, False)
    except Exception as e:
        print >> sys.stderr, 'Unable to set time: %s' % new_time, e
        session.reject(p.mi, '\x02')
    else:
        session.app_ack(p.mi)

def sign_extended_status_request(p, session):
    try:
        group_status = session.server.group.status()
        hostname = 'AXNTSLS'
        status_data = ''

        # Controller on/offline status.
        status_data += ('%x' % (1 if session.active else 0)).zfill(2)

        # Application error code.
        status_data += ('%x' % group_status['applicationError']).zfill(2)

        # Manufacturer info.
        for i in hostname:
            status_data += ('%x' % ord(i)).zfill(2)

        #version
        version = session.server.signs.get_version()
        status_data += ('%x' % version).zfill(6)

        # Current date/time
        now = time.localtime(time.time())
        d = ('%x' % now.tm_mday).zfill(2)
        m = ('%x' % now.tm_mon).zfill(2)
        y = ('%x' % now.tm_year).zfill(4)
        h = ('%x' % now.tm_hour).zfill(2)
        mi = ('%x' % now.tm_min).zfill(2)
        s = ('%x' % now.tm_sec).zfill(2)
        status_data += d + m + y + h + mi + s

        # Get controller error code.
        try:
            fault = session.server.group.get_current_fault(0)
        except:
            fault = 0xff
    
        status_data += ('%x' % fault).zfill(2)

        #Get UCA Disable/Enable
        enable = session.server.signs.get_disable_enable_uca()
        status_data += ('%x' % enable).zfill(2)

        #Get UCA Address and Port
        addr = session.server.signs.get_uca_addr()
        status_data += ('%x' % addr[0]).zfill(8)
        status_data += ('%x' % addr[1]).zfill(4)

        # Get number of signs attached (ie. number of VMS displays).
        sign_list = session.server.signs.get_signs()
        status_data += ('%x' % len(sign_list)).zfill(2)

        #Get sign status
        sign_status = session.server.signs.get_status()
        for sign in sign_status:
            # Sign ID.
            status_data += ('%x' % int(sign['sign_id'])).zfill(2)
            # Solar current
            status_data += ('%x' % int(round(float(sign['solar_current'])*10))).zfill(2)
            # battery current
            status_data += ('%x' % int(round(float(sign['battery_current'])*10))).zfill(2)
            # battery voltage ID.
            status_data += ('%x' % int(round(float(sign['battery_voltage'])*10))).zfill(2)
            # Sign error code.
            try:
                fault = session.server.group.get_current_fault(1)
            except:
                fault = 0xff

            status_data += ('%x' % fault).zfill(2)

            # Dimming mode. TODO: Fill this in properly.
            status_data += ('%x' % (1 if sign['brightness_mode'] == 'manual' else 0)).zfill(2)
            # Brightness level. TODO: Fill this in properly.
            status_data += ('%x' % int(sign['brightness'])).zfill(2)
    except:
        import traceback
        session.logger.error('Unrecognised exception')
        session.logger.error(traceback.format_exc())
        session.reject(p.mi, '\x02')
        return

    status_data = status_data.decode('hex')
    session.send_packet(0x26, status_data)

def sign_pixel_status_request(p, session):
    num_mod = 2
    sign_list = session.server.signs.get_signs()
    sign_status = session.server.signs.get_status()

    if sign_list is None or sign_status is None:
        session.reject(p.mi, '\x02')
        return

    response_data = ''
    response_data += ('%x' % len(sign_list)).zfill(2)

    for status in sign_status:
        response_data += ('%x' % int(status['sign_id'])).zfill(2)
        response_data += ('%x' % num_mod).zfill(2)

        if int(status['annulus_driver']) != 0:
            annulus_status = 3
        elif max((int(status['annulus_open']) + int(status['annulus_short'])),
                 int(status['annulus_visible'])) == 1:
            annulus_status = 1
        elif max((int(status['annulus_open']) + int(status['annulus_short'])),
                 int(status['annulus_visible'])) > 1:
            annulus_status = 2
        else:
            annulus_status = 0

        if int(status['matrix_driver']) != 0:
            matrix_status = 3
        elif max((int(status['matrix_open']) + int(status['matrix_short'])),
                 int(status['matrix_visible'])) == 1:
            matrix_status = 1
        elif max((int(status['matrix_open']) + int(status['matrix_short'])),
                 int(status['matrix_visible'])) > 1:
            matrix_status = 2
        else:
            matrix_status = 0

        response_data += ('%x' % (annulus_status << 2 | matrix_status)).zfill(2)    

    response_data = response_data.decode('hex')
    session.send_packet(0x28, response_data)
